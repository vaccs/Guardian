#include "parser.h"

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[1209][56] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[1][7] = 7,
	[1][8] = 8,
	[1][9] = 9,
	[1][10] = 10,
	[1][11] = 11,
	[1][12] = 12,
	[1][13] = 13,
	[1][14] = 14,
	[4][2] = 40,
	[4][3] = 41,
	[4][4] = 42,
	[4][5] = 44,
	[4][6] = 45,
	[4][7] = 47,
	[4][8] = 48,
	[4][9] = 49,
	[4][10] = 50,
	[4][11] = 51,
	[4][12] = 52,
	[4][14] = 53,
	[4][37] = 43,
	[4][38] = 46,
	[5][2] = 2,
	[5][3] = 3,
	[5][4] = 4,
	[5][5] = 5,
	[5][6] = 6,
	[5][7] = 7,
	[5][8] = 8,
	[5][9] = 9,
	[5][10] = 10,
	[5][11] = 73,
	[5][12] = 12,
	[6][2] = 2,
	[6][3] = 3,
	[6][4] = 4,
	[6][5] = 5,
	[6][6] = 6,
	[6][7] = 7,
	[6][8] = 8,
	[6][9] = 9,
	[6][10] = 10,
	[6][11] = 73,
	[6][12] = 12,
	[8][2] = 76,
	[8][3] = 77,
	[8][4] = 78,
	[8][5] = 79,
	[8][6] = 80,
	[8][7] = 82,
	[8][8] = 83,
	[8][9] = 85,
	[8][10] = 86,
	[8][11] = 87,
	[8][12] = 88,
	[8][14] = 89,
	[8][38] = 81,
	[8][39] = 84,
	[9][2] = 2,
	[9][3] = 3,
	[9][4] = 4,
	[9][5] = 5,
	[9][6] = 6,
	[9][7] = 7,
	[9][8] = 8,
	[9][9] = 9,
	[9][10] = 10,
	[9][11] = 73,
	[9][12] = 12,
	[11][40] = 110,
	[11][41] = 111,
	[12][2] = 2,
	[12][3] = 3,
	[12][4] = 4,
	[12][5] = 5,
	[12][6] = 6,
	[12][7] = 7,
	[12][8] = 8,
	[12][9] = 9,
	[12][10] = 10,
	[12][11] = 73,
	[12][12] = 12,
	[13][42] = 113,
	[13][43] = 114,
	[13][44] = 115,
	[13][45] = 116,
	[13][46] = 117,
	[13][47] = 118,
	[13][48] = 119,
	[14][4] = 120,
	[14][11] = 122,
	[14][14] = 128,
	[14][38] = 121,
	[14][40] = 123,
	[14][49] = 124,
	[14][50] = 125,
	[14][51] = 126,
	[14][52] = 127,
	[15][6] = 131,
	[15][9] = 132,
	[16][15] = 133,
	[17][2] = 2,
	[17][3] = 3,
	[17][4] = 4,
	[17][5] = 5,
	[17][6] = 6,
	[17][7] = 7,
	[17][8] = 8,
	[17][9] = 9,
	[17][10] = 10,
	[17][11] = 11,
	[17][12] = 12,
	[17][13] = 13,
	[17][14] = 14,
	[19][29] = 141,
	[19][30] = 142,
	[20][16] = 143,
	[21][21] = 144,
	[22][36] = 145,
	[23][2] = 2,
	[23][3] = 3,
	[23][4] = 4,
	[23][5] = 5,
	[23][6] = 6,
	[23][7] = 7,
	[23][8] = 8,
	[23][9] = 9,
	[23][10] = 10,
	[23][11] = 11,
	[23][12] = 12,
	[23][13] = 13,
	[23][14] = 14,
	[24][35] = 154,
	[25][17] = 155,
	[26][33] = 156,
	[27][31] = 157,
	[28][18] = 158,
	[28][32] = 159,
	[29][13] = 162,
	[29][19] = 160,
	[29][22] = 161,
	[30][34] = 163,
	[31][4] = 164,
	[31][8] = 165,
	[31][20] = 166,
	[33][25] = 167,
	[33][26] = 168,
	[33][27] = 169,
	[33][28] = 170,
	[34][23] = 171,
	[34][24] = 172,
	[35][2] = 2,
	[35][3] = 3,
	[35][4] = 4,
	[35][5] = 5,
	[35][6] = 6,
	[35][7] = 7,
	[35][8] = 8,
	[35][9] = 9,
	[35][10] = 10,
	[35][11] = 11,
	[35][12] = 12,
	[35][13] = 13,
	[35][14] = 14,
	[36][2] = 2,
	[36][3] = 3,
	[36][4] = 4,
	[36][5] = 5,
	[36][6] = 6,
	[36][7] = 7,
	[36][8] = 8,
	[36][9] = 9,
	[36][10] = 10,
	[36][11] = 11,
	[36][12] = 12,
	[36][13] = 13,
	[36][14] = 14,
	[38][2] = 2,
	[38][3] = 3,
	[38][4] = 4,
	[38][5] = 5,
	[38][6] = 6,
	[38][7] = 7,
	[38][8] = 8,
	[38][9] = 9,
	[38][10] = 10,
	[38][11] = 11,
	[38][12] = 12,
	[38][13] = 13,
	[38][14] = 14,
	[39][2] = 2,
	[39][3] = 3,
	[39][4] = 4,
	[39][5] = 5,
	[39][6] = 6,
	[39][7] = 7,
	[39][8] = 8,
	[39][9] = 9,
	[39][10] = 10,
	[39][11] = 11,
	[39][12] = 12,
	[39][13] = 13,
	[39][14] = 14,
	[42][2] = 40,
	[42][3] = 41,
	[42][4] = 42,
	[42][5] = 44,
	[42][6] = 45,
	[42][7] = 47,
	[42][8] = 48,
	[42][9] = 49,
	[42][10] = 50,
	[42][11] = 51,
	[42][12] = 52,
	[42][14] = 53,
	[42][37] = 201,
	[42][38] = 202,
	[44][2] = 40,
	[44][3] = 41,
	[44][4] = 42,
	[44][5] = 44,
	[44][6] = 45,
	[44][7] = 47,
	[44][8] = 48,
	[44][9] = 49,
	[44][10] = 50,
	[44][11] = 51,
	[44][12] = 52,
	[45][2] = 40,
	[45][3] = 41,
	[45][4] = 42,
	[45][5] = 44,
	[45][6] = 45,
	[45][7] = 47,
	[45][8] = 48,
	[45][9] = 49,
	[45][10] = 50,
	[45][11] = 51,
	[45][12] = 52,
	[46][2] = 40,
	[46][3] = 41,
	[46][4] = 42,
	[46][5] = 44,
	[46][6] = 45,
	[46][7] = 47,
	[46][8] = 48,
	[46][9] = 49,
	[46][10] = 50,
	[46][11] = 51,
	[46][12] = 52,
	[46][14] = 53,
	[48][2] = 76,
	[48][3] = 77,
	[48][4] = 78,
	[48][5] = 79,
	[48][6] = 80,
	[48][7] = 82,
	[48][8] = 83,
	[48][9] = 85,
	[48][10] = 86,
	[48][11] = 87,
	[48][12] = 88,
	[48][14] = 89,
	[48][38] = 208,
	[48][39] = 209,
	[49][2] = 40,
	[49][3] = 41,
	[49][4] = 42,
	[49][5] = 44,
	[49][6] = 45,
	[49][7] = 47,
	[49][8] = 48,
	[49][9] = 49,
	[49][10] = 50,
	[49][11] = 51,
	[49][12] = 52,
	[52][2] = 40,
	[52][3] = 41,
	[52][4] = 42,
	[52][5] = 44,
	[52][6] = 45,
	[52][7] = 47,
	[52][8] = 48,
	[52][9] = 49,
	[52][10] = 50,
	[52][11] = 51,
	[52][12] = 52,
	[53][4] = 120,
	[53][11] = 122,
	[53][14] = 128,
	[53][38] = 213,
	[53][40] = 214,
	[53][49] = 124,
	[53][50] = 125,
	[53][51] = 126,
	[53][52] = 127,
	[54][6] = 216,
	[54][9] = 217,
	[55][15] = 218,
	[57][29] = 219,
	[57][30] = 220,
	[58][16] = 221,
	[59][21] = 222,
	[60][37] = 223,
	[60][38] = 224,
	[61][35] = 225,
	[62][17] = 226,
	[63][33] = 227,
	[64][31] = 228,
	[65][18] = 229,
	[65][32] = 230,
	[66][13] = 233,
	[66][19] = 231,
	[66][22] = 232,
	[67][34] = 234,
	[68][4] = 235,
	[68][8] = 236,
	[68][20] = 237,
	[70][25] = 238,
	[70][26] = 239,
	[70][27] = 240,
	[70][28] = 241,
	[71][23] = 242,
	[71][24] = 243,
	[78][2] = 40,
	[78][3] = 41,
	[78][4] = 42,
	[78][5] = 44,
	[78][6] = 45,
	[78][7] = 47,
	[78][8] = 48,
	[78][9] = 49,
	[78][10] = 50,
	[78][11] = 51,
	[78][12] = 52,
	[78][14] = 53,
	[78][37] = 244,
	[78][38] = 245,
	[79][2] = 76,
	[79][3] = 77,
	[79][4] = 78,
	[79][5] = 79,
	[79][6] = 80,
	[79][7] = 82,
	[79][8] = 83,
	[79][9] = 85,
	[79][10] = 86,
	[79][11] = 87,
	[79][12] = 88,
	[80][2] = 76,
	[80][3] = 77,
	[80][4] = 78,
	[80][5] = 79,
	[80][6] = 80,
	[80][7] = 82,
	[80][8] = 83,
	[80][9] = 85,
	[80][10] = 86,
	[80][11] = 87,
	[80][12] = 88,
	[81][2] = 76,
	[81][3] = 77,
	[81][4] = 78,
	[81][5] = 79,
	[81][6] = 80,
	[81][7] = 82,
	[81][8] = 83,
	[81][9] = 85,
	[81][10] = 86,
	[81][11] = 87,
	[81][12] = 88,
	[81][14] = 89,
	[83][2] = 76,
	[83][3] = 77,
	[83][4] = 78,
	[83][5] = 79,
	[83][6] = 80,
	[83][7] = 82,
	[83][8] = 83,
	[83][9] = 85,
	[83][10] = 86,
	[83][11] = 87,
	[83][12] = 88,
	[83][14] = 89,
	[83][38] = 251,
	[83][39] = 252,
	[85][2] = 76,
	[85][3] = 77,
	[85][4] = 78,
	[85][5] = 79,
	[85][6] = 80,
	[85][7] = 82,
	[85][8] = 83,
	[85][9] = 85,
	[85][10] = 86,
	[85][11] = 87,
	[85][12] = 88,
	[88][2] = 76,
	[88][3] = 77,
	[88][4] = 78,
	[88][5] = 79,
	[88][6] = 80,
	[88][7] = 82,
	[88][8] = 83,
	[88][9] = 85,
	[88][10] = 86,
	[88][11] = 87,
	[88][12] = 88,
	[89][4] = 120,
	[89][11] = 122,
	[89][14] = 128,
	[89][38] = 256,
	[89][40] = 257,
	[89][49] = 124,
	[89][50] = 125,
	[89][51] = 126,
	[89][52] = 127,
	[90][6] = 259,
	[90][9] = 260,
	[91][15] = 261,
	[93][29] = 262,
	[93][30] = 263,
	[94][16] = 264,
	[95][21] = 265,
	[96][38] = 266,
	[96][39] = 267,
	[97][35] = 268,
	[98][17] = 269,
	[99][33] = 270,
	[100][31] = 271,
	[101][18] = 272,
	[101][32] = 273,
	[102][13] = 276,
	[102][19] = 274,
	[102][22] = 275,
	[103][34] = 277,
	[104][4] = 278,
	[104][8] = 279,
	[104][20] = 280,
	[106][25] = 281,
	[106][26] = 282,
	[106][27] = 283,
	[106][28] = 284,
	[107][23] = 285,
	[107][24] = 286,
	[110][2] = 287,
	[110][3] = 288,
	[110][4] = 289,
	[110][7] = 290,
	[110][8] = 291,
	[110][11] = 292,
	[110][22] = 293,
	[111][2] = 2,
	[111][3] = 3,
	[111][4] = 4,
	[111][5] = 5,
	[111][6] = 6,
	[111][7] = 7,
	[111][8] = 8,
	[111][9] = 9,
	[111][10] = 10,
	[111][11] = 73,
	[111][12] = 12,
	[111][14] = 14,
	[113][7] = 299,
	[114][40] = 300,
	[115][40] = 301,
	[116][40] = 302,
	[117][40] = 303,
	[118][40] = 304,
	[119][40] = 305,
	[120][4] = 306,
	[120][11] = 309,
	[120][14] = 314,
	[120][37] = 307,
	[120][38] = 308,
	[120][49] = 310,
	[120][50] = 311,
	[120][51] = 312,
	[120][52] = 313,
	[121][4] = 120,
	[121][11] = 317,
	[121][14] = 128,
	[121][49] = 124,
	[121][50] = 125,
	[121][51] = 126,
	[121][52] = 127,
	[123][2] = 2,
	[123][3] = 3,
	[123][4] = 4,
	[123][5] = 5,
	[123][6] = 6,
	[123][7] = 7,
	[123][8] = 8,
	[123][9] = 9,
	[123][10] = 10,
	[123][11] = 73,
	[123][12] = 12,
	[123][14] = 14,
	[128][4] = 323,
	[128][11] = 325,
	[128][14] = 331,
	[128][38] = 324,
	[128][40] = 326,
	[128][49] = 327,
	[128][50] = 328,
	[128][51] = 329,
	[128][52] = 330,
	[129][54] = 334,
	[130][11] = 335,
	[131][2] = 2,
	[131][3] = 3,
	[131][4] = 4,
	[131][5] = 5,
	[131][6] = 6,
	[131][7] = 7,
	[131][8] = 8,
	[131][9] = 9,
	[131][10] = 10,
	[131][11] = 73,
	[131][12] = 12,
	[132][2] = 2,
	[132][3] = 3,
	[132][4] = 4,
	[132][5] = 5,
	[132][6] = 6,
	[132][7] = 7,
	[132][8] = 8,
	[132][9] = 9,
	[132][10] = 10,
	[132][11] = 73,
	[132][12] = 12,
	[133][2] = 2,
	[133][3] = 3,
	[133][4] = 4,
	[133][5] = 5,
	[133][6] = 6,
	[133][7] = 7,
	[133][8] = 8,
	[133][9] = 9,
	[133][10] = 10,
	[133][11] = 73,
	[133][12] = 12,
	[135][2] = 2,
	[135][3] = 3,
	[135][4] = 4,
	[135][5] = 5,
	[135][6] = 6,
	[135][7] = 7,
	[135][8] = 8,
	[135][9] = 9,
	[135][10] = 10,
	[135][11] = 11,
	[135][12] = 12,
	[135][13] = 13,
	[135][14] = 14,
	[136][2] = 2,
	[136][3] = 3,
	[136][4] = 4,
	[136][5] = 5,
	[136][6] = 6,
	[136][7] = 7,
	[136][8] = 8,
	[136][9] = 9,
	[136][10] = 10,
	[136][11] = 11,
	[136][12] = 12,
	[136][13] = 13,
	[136][14] = 14,
	[137][2] = 2,
	[137][3] = 3,
	[137][4] = 4,
	[137][5] = 5,
	[137][6] = 6,
	[137][7] = 7,
	[137][8] = 8,
	[137][9] = 9,
	[137][10] = 10,
	[137][11] = 11,
	[137][12] = 12,
	[137][13] = 13,
	[137][14] = 14,
	[138][2] = 2,
	[138][3] = 3,
	[138][4] = 4,
	[138][5] = 5,
	[138][6] = 6,
	[138][7] = 7,
	[138][8] = 8,
	[138][9] = 9,
	[138][10] = 10,
	[138][11] = 11,
	[138][12] = 12,
	[138][13] = 13,
	[138][14] = 14,
	[139][2] = 2,
	[139][3] = 3,
	[139][4] = 4,
	[139][5] = 5,
	[139][6] = 6,
	[139][7] = 7,
	[139][8] = 8,
	[139][9] = 9,
	[139][10] = 10,
	[139][11] = 11,
	[139][12] = 12,
	[139][13] = 13,
	[139][14] = 14,
	[140][2] = 2,
	[140][3] = 3,
	[140][4] = 4,
	[140][5] = 5,
	[140][6] = 6,
	[140][7] = 7,
	[140][8] = 8,
	[140][9] = 9,
	[140][10] = 10,
	[140][11] = 11,
	[140][12] = 12,
	[140][13] = 13,
	[140][14] = 14,
	[141][2] = 2,
	[141][3] = 3,
	[141][4] = 4,
	[141][5] = 5,
	[141][6] = 6,
	[141][7] = 7,
	[141][8] = 8,
	[141][9] = 9,
	[141][10] = 10,
	[141][11] = 73,
	[141][12] = 12,
	[142][2] = 2,
	[142][3] = 3,
	[142][4] = 4,
	[142][5] = 5,
	[142][6] = 6,
	[142][7] = 7,
	[142][8] = 8,
	[142][9] = 9,
	[142][10] = 10,
	[142][11] = 73,
	[142][12] = 12,
	[143][2] = 2,
	[143][3] = 3,
	[143][4] = 4,
	[143][5] = 5,
	[143][6] = 6,
	[143][7] = 7,
	[143][8] = 8,
	[143][9] = 9,
	[143][10] = 10,
	[143][11] = 73,
	[143][12] = 12,
	[144][2] = 2,
	[144][3] = 3,
	[144][4] = 4,
	[144][5] = 5,
	[144][6] = 6,
	[144][7] = 7,
	[144][8] = 8,
	[144][9] = 9,
	[144][10] = 10,
	[144][11] = 73,
	[144][12] = 12,
	[148][2] = 2,
	[148][3] = 3,
	[148][4] = 4,
	[148][5] = 5,
	[148][6] = 6,
	[148][7] = 7,
	[148][8] = 8,
	[148][9] = 9,
	[148][10] = 10,
	[148][11] = 11,
	[148][12] = 12,
	[148][13] = 13,
	[148][14] = 14,
	[149][2] = 2,
	[149][3] = 3,
	[149][4] = 4,
	[149][5] = 5,
	[149][6] = 6,
	[149][7] = 7,
	[149][8] = 8,
	[149][9] = 9,
	[149][10] = 10,
	[149][11] = 11,
	[149][12] = 12,
	[149][13] = 13,
	[149][14] = 14,
	[150][2] = 2,
	[150][3] = 3,
	[150][4] = 4,
	[150][5] = 5,
	[150][6] = 6,
	[150][7] = 7,
	[150][8] = 8,
	[150][9] = 9,
	[150][10] = 10,
	[150][11] = 11,
	[150][12] = 12,
	[150][13] = 13,
	[150][14] = 14,
	[151][2] = 2,
	[151][3] = 3,
	[151][4] = 4,
	[151][5] = 5,
	[151][6] = 6,
	[151][7] = 7,
	[151][8] = 8,
	[151][9] = 9,
	[151][10] = 10,
	[151][11] = 11,
	[151][12] = 12,
	[151][13] = 13,
	[151][14] = 14,
	[152][2] = 2,
	[152][3] = 3,
	[152][4] = 4,
	[152][5] = 5,
	[152][6] = 6,
	[152][7] = 7,
	[152][8] = 8,
	[152][9] = 9,
	[152][10] = 10,
	[152][11] = 11,
	[152][12] = 12,
	[152][13] = 13,
	[152][14] = 14,
	[153][2] = 2,
	[153][3] = 3,
	[153][4] = 4,
	[153][5] = 5,
	[153][6] = 6,
	[153][7] = 7,
	[153][8] = 8,
	[153][9] = 9,
	[153][10] = 10,
	[153][11] = 11,
	[153][12] = 12,
	[153][13] = 13,
	[153][14] = 14,
	[154][2] = 2,
	[154][3] = 3,
	[154][4] = 4,
	[154][5] = 5,
	[154][6] = 6,
	[154][7] = 7,
	[154][8] = 8,
	[154][9] = 9,
	[154][10] = 10,
	[154][11] = 73,
	[154][12] = 12,
	[154][14] = 14,
	[155][2] = 2,
	[155][3] = 3,
	[155][4] = 4,
	[155][5] = 5,
	[155][6] = 6,
	[155][7] = 7,
	[155][8] = 8,
	[155][9] = 9,
	[155][10] = 10,
	[155][11] = 73,
	[155][12] = 12,
	[156][11] = 358,
	[157][2] = 2,
	[157][3] = 3,
	[157][4] = 4,
	[157][5] = 5,
	[157][6] = 6,
	[157][7] = 7,
	[157][8] = 8,
	[157][9] = 9,
	[157][10] = 10,
	[157][11] = 73,
	[157][12] = 12,
	[158][2] = 360,
	[158][3] = 361,
	[158][4] = 362,
	[158][5] = 363,
	[158][6] = 364,
	[158][7] = 365,
	[158][8] = 366,
	[158][9] = 367,
	[158][10] = 368,
	[158][11] = 369,
	[158][12] = 370,
	[158][14] = 371,
	[159][2] = 2,
	[159][3] = 3,
	[159][4] = 4,
	[159][5] = 5,
	[159][6] = 6,
	[159][7] = 7,
	[159][8] = 8,
	[159][9] = 9,
	[159][10] = 10,
	[159][11] = 73,
	[159][12] = 12,
	[160][2] = 2,
	[160][3] = 3,
	[160][4] = 4,
	[160][5] = 5,
	[160][6] = 6,
	[160][7] = 7,
	[160][8] = 8,
	[160][9] = 9,
	[160][10] = 10,
	[160][11] = 73,
	[160][12] = 12,
	[161][2] = 2,
	[161][3] = 3,
	[161][4] = 4,
	[161][5] = 5,
	[161][6] = 6,
	[161][7] = 7,
	[161][8] = 8,
	[161][9] = 9,
	[161][10] = 10,
	[161][11] = 73,
	[161][12] = 12,
	[162][2] = 2,
	[162][3] = 3,
	[162][4] = 4,
	[162][5] = 5,
	[162][6] = 6,
	[162][7] = 7,
	[162][8] = 8,
	[162][9] = 9,
	[162][10] = 10,
	[162][11] = 73,
	[162][12] = 12,
	[163][2] = 2,
	[163][3] = 3,
	[163][4] = 4,
	[163][5] = 5,
	[163][6] = 6,
	[163][7] = 7,
	[163][8] = 8,
	[163][9] = 9,
	[163][10] = 10,
	[163][11] = 73,
	[163][12] = 12,
	[163][14] = 14,
	[164][2] = 40,
	[164][3] = 41,
	[164][4] = 42,
	[164][5] = 44,
	[164][6] = 45,
	[164][7] = 47,
	[164][8] = 48,
	[164][9] = 49,
	[164][10] = 50,
	[164][11] = 51,
	[164][12] = 52,
	[164][14] = 53,
	[164][37] = 397,
	[164][38] = 398,
	[165][2] = 400,
	[165][3] = 401,
	[165][4] = 402,
	[165][5] = 403,
	[165][6] = 404,
	[165][7] = 405,
	[165][8] = 406,
	[165][9] = 407,
	[165][10] = 408,
	[165][11] = 409,
	[165][12] = 410,
	[165][14] = 411,
	[166][11] = 431,
	[167][2] = 2,
	[167][3] = 3,
	[167][4] = 4,
	[167][5] = 5,
	[167][6] = 6,
	[167][7] = 7,
	[167][8] = 8,
	[167][9] = 9,
	[167][10] = 10,
	[167][11] = 73,
	[167][12] = 12,
	[168][2] = 2,
	[168][3] = 3,
	[168][4] = 4,
	[168][5] = 5,
	[168][6] = 6,
	[168][7] = 7,
	[168][8] = 8,
	[168][9] = 9,
	[168][10] = 10,
	[168][11] = 73,
	[168][12] = 12,
	[169][2] = 2,
	[169][3] = 3,
	[169][4] = 4,
	[169][5] = 5,
	[169][6] = 6,
	[169][7] = 7,
	[169][8] = 8,
	[169][9] = 9,
	[169][10] = 10,
	[169][11] = 73,
	[169][12] = 12,
	[170][2] = 2,
	[170][3] = 3,
	[170][4] = 4,
	[170][5] = 5,
	[170][6] = 6,
	[170][7] = 7,
	[170][8] = 8,
	[170][9] = 9,
	[170][10] = 10,
	[170][11] = 73,
	[170][12] = 12,
	[171][2] = 2,
	[171][3] = 3,
	[171][4] = 4,
	[171][5] = 5,
	[171][6] = 6,
	[171][7] = 7,
	[171][8] = 8,
	[171][9] = 9,
	[171][10] = 10,
	[171][11] = 73,
	[171][12] = 12,
	[172][2] = 2,
	[172][3] = 3,
	[172][4] = 4,
	[172][5] = 5,
	[172][6] = 6,
	[172][7] = 7,
	[172][8] = 8,
	[172][9] = 9,
	[172][10] = 10,
	[172][11] = 73,
	[172][12] = 12,
	[174][2] = 2,
	[174][3] = 3,
	[174][4] = 4,
	[174][5] = 5,
	[174][6] = 6,
	[174][7] = 7,
	[174][8] = 8,
	[174][9] = 9,
	[174][10] = 10,
	[174][11] = 11,
	[174][12] = 12,
	[174][13] = 13,
	[174][14] = 14,
	[175][2] = 2,
	[175][3] = 3,
	[175][4] = 4,
	[175][5] = 5,
	[175][6] = 6,
	[175][7] = 7,
	[175][8] = 8,
	[175][9] = 9,
	[175][10] = 10,
	[175][11] = 11,
	[175][12] = 12,
	[175][13] = 13,
	[175][14] = 14,
	[176][2] = 2,
	[176][3] = 3,
	[176][4] = 4,
	[176][5] = 5,
	[176][6] = 6,
	[176][7] = 7,
	[176][8] = 8,
	[176][9] = 9,
	[176][10] = 10,
	[176][11] = 11,
	[176][12] = 12,
	[176][13] = 13,
	[176][14] = 14,
	[177][2] = 2,
	[177][3] = 3,
	[177][4] = 4,
	[177][5] = 5,
	[177][6] = 6,
	[177][7] = 7,
	[177][8] = 8,
	[177][9] = 9,
	[177][10] = 10,
	[177][11] = 11,
	[177][12] = 12,
	[177][13] = 13,
	[177][14] = 14,
	[178][2] = 2,
	[178][3] = 3,
	[178][4] = 4,
	[178][5] = 5,
	[178][6] = 6,
	[178][7] = 7,
	[178][8] = 8,
	[178][9] = 9,
	[178][10] = 10,
	[178][11] = 11,
	[178][12] = 12,
	[178][13] = 13,
	[178][14] = 14,
	[179][2] = 2,
	[179][3] = 3,
	[179][4] = 4,
	[179][5] = 5,
	[179][6] = 6,
	[179][7] = 7,
	[179][8] = 8,
	[179][9] = 9,
	[179][10] = 10,
	[179][11] = 11,
	[179][12] = 12,
	[179][13] = 13,
	[179][14] = 14,
	[181][2] = 2,
	[181][3] = 3,
	[181][4] = 4,
	[181][5] = 5,
	[181][6] = 6,
	[181][7] = 7,
	[181][8] = 8,
	[181][9] = 9,
	[181][10] = 10,
	[181][11] = 11,
	[181][12] = 12,
	[181][13] = 13,
	[181][14] = 14,
	[182][2] = 2,
	[182][3] = 3,
	[182][4] = 4,
	[182][5] = 5,
	[182][6] = 6,
	[182][7] = 7,
	[182][8] = 8,
	[182][9] = 9,
	[182][10] = 10,
	[182][11] = 11,
	[182][12] = 12,
	[182][13] = 13,
	[182][14] = 14,
	[183][2] = 2,
	[183][3] = 3,
	[183][4] = 4,
	[183][5] = 5,
	[183][6] = 6,
	[183][7] = 7,
	[183][8] = 8,
	[183][9] = 9,
	[183][10] = 10,
	[183][11] = 11,
	[183][12] = 12,
	[183][13] = 13,
	[183][14] = 14,
	[184][2] = 2,
	[184][3] = 3,
	[184][4] = 4,
	[184][5] = 5,
	[184][6] = 6,
	[184][7] = 7,
	[184][8] = 8,
	[184][9] = 9,
	[184][10] = 10,
	[184][11] = 11,
	[184][12] = 12,
	[184][13] = 13,
	[184][14] = 14,
	[185][2] = 2,
	[185][3] = 3,
	[185][4] = 4,
	[185][5] = 5,
	[185][6] = 6,
	[185][7] = 7,
	[185][8] = 8,
	[185][9] = 9,
	[185][10] = 10,
	[185][11] = 11,
	[185][12] = 12,
	[185][13] = 13,
	[185][14] = 14,
	[186][2] = 2,
	[186][3] = 3,
	[186][4] = 4,
	[186][5] = 5,
	[186][6] = 6,
	[186][7] = 7,
	[186][8] = 8,
	[186][9] = 9,
	[186][10] = 10,
	[186][11] = 11,
	[186][12] = 12,
	[186][13] = 13,
	[186][14] = 14,
	[188][2] = 2,
	[188][3] = 3,
	[188][4] = 4,
	[188][5] = 5,
	[188][6] = 6,
	[188][7] = 7,
	[188][8] = 8,
	[188][9] = 9,
	[188][10] = 10,
	[188][11] = 11,
	[188][12] = 12,
	[188][13] = 13,
	[188][14] = 14,
	[189][2] = 2,
	[189][3] = 3,
	[189][4] = 4,
	[189][5] = 5,
	[189][6] = 6,
	[189][7] = 7,
	[189][8] = 8,
	[189][9] = 9,
	[189][10] = 10,
	[189][11] = 11,
	[189][12] = 12,
	[189][13] = 13,
	[189][14] = 14,
	[190][2] = 2,
	[190][3] = 3,
	[190][4] = 4,
	[190][5] = 5,
	[190][6] = 6,
	[190][7] = 7,
	[190][8] = 8,
	[190][9] = 9,
	[190][10] = 10,
	[190][11] = 11,
	[190][12] = 12,
	[190][13] = 13,
	[190][14] = 14,
	[191][2] = 2,
	[191][3] = 3,
	[191][4] = 4,
	[191][5] = 5,
	[191][6] = 6,
	[191][7] = 7,
	[191][8] = 8,
	[191][9] = 9,
	[191][10] = 10,
	[191][11] = 11,
	[191][12] = 12,
	[191][13] = 13,
	[191][14] = 14,
	[192][2] = 2,
	[192][3] = 3,
	[192][4] = 4,
	[192][5] = 5,
	[192][6] = 6,
	[192][7] = 7,
	[192][8] = 8,
	[192][9] = 9,
	[192][10] = 10,
	[192][11] = 11,
	[192][12] = 12,
	[192][13] = 13,
	[192][14] = 14,
	[193][2] = 2,
	[193][3] = 3,
	[193][4] = 4,
	[193][5] = 5,
	[193][6] = 6,
	[193][7] = 7,
	[193][8] = 8,
	[193][9] = 9,
	[193][10] = 10,
	[193][11] = 11,
	[193][12] = 12,
	[193][13] = 13,
	[193][14] = 14,
	[195][2] = 2,
	[195][3] = 3,
	[195][4] = 4,
	[195][5] = 5,
	[195][6] = 6,
	[195][7] = 7,
	[195][8] = 8,
	[195][9] = 9,
	[195][10] = 10,
	[195][11] = 11,
	[195][12] = 12,
	[195][13] = 13,
	[195][14] = 14,
	[196][2] = 2,
	[196][3] = 3,
	[196][4] = 4,
	[196][5] = 5,
	[196][6] = 6,
	[196][7] = 7,
	[196][8] = 8,
	[196][9] = 9,
	[196][10] = 10,
	[196][11] = 11,
	[196][12] = 12,
	[196][13] = 13,
	[196][14] = 14,
	[197][2] = 2,
	[197][3] = 3,
	[197][4] = 4,
	[197][5] = 5,
	[197][6] = 6,
	[197][7] = 7,
	[197][8] = 8,
	[197][9] = 9,
	[197][10] = 10,
	[197][11] = 11,
	[197][12] = 12,
	[197][13] = 13,
	[197][14] = 14,
	[198][2] = 2,
	[198][3] = 3,
	[198][4] = 4,
	[198][5] = 5,
	[198][6] = 6,
	[198][7] = 7,
	[198][8] = 8,
	[198][9] = 9,
	[198][10] = 10,
	[198][11] = 11,
	[198][12] = 12,
	[198][13] = 13,
	[198][14] = 14,
	[199][2] = 2,
	[199][3] = 3,
	[199][4] = 4,
	[199][5] = 5,
	[199][6] = 6,
	[199][7] = 7,
	[199][8] = 8,
	[199][9] = 9,
	[199][10] = 10,
	[199][11] = 11,
	[199][12] = 12,
	[199][13] = 13,
	[199][14] = 14,
	[200][2] = 2,
	[200][3] = 3,
	[200][4] = 4,
	[200][5] = 5,
	[200][6] = 6,
	[200][7] = 7,
	[200][8] = 8,
	[200][9] = 9,
	[200][10] = 10,
	[200][11] = 11,
	[200][12] = 12,
	[200][13] = 13,
	[200][14] = 14,
	[202][2] = 40,
	[202][3] = 41,
	[202][4] = 42,
	[202][5] = 44,
	[202][6] = 45,
	[202][7] = 47,
	[202][8] = 48,
	[202][9] = 49,
	[202][10] = 50,
	[202][11] = 51,
	[202][12] = 52,
	[202][14] = 53,
	[203][37] = 464,
	[203][38] = 465,
	[207][37] = 466,
	[207][38] = 467,
	[208][2] = 76,
	[208][3] = 77,
	[208][4] = 78,
	[208][5] = 79,
	[208][6] = 80,
	[208][7] = 82,
	[208][8] = 83,
	[208][9] = 85,
	[208][10] = 86,
	[208][11] = 87,
	[208][12] = 88,
	[208][14] = 89,
	[210][38] = 470,
	[210][39] = 471,
	[213][4] = 120,
	[213][11] = 317,
	[213][14] = 128,
	[213][49] = 124,
	[213][50] = 125,
	[213][51] = 126,
	[213][52] = 127,
	[214][2] = 40,
	[214][3] = 41,
	[214][4] = 42,
	[214][5] = 44,
	[214][6] = 45,
	[214][7] = 47,
	[214][8] = 48,
	[214][9] = 49,
	[214][10] = 50,
	[214][11] = 51,
	[214][12] = 52,
	[214][14] = 53,
	[215][11] = 476,
	[216][2] = 40,
	[216][3] = 41,
	[216][4] = 42,
	[216][5] = 44,
	[216][6] = 45,
	[216][7] = 47,
	[216][8] = 48,
	[216][9] = 49,
	[216][10] = 50,
	[216][11] = 51,
	[216][12] = 52,
	[217][2] = 40,
	[217][3] = 41,
	[217][4] = 42,
	[217][5] = 44,
	[217][6] = 45,
	[217][7] = 47,
	[217][8] = 48,
	[217][9] = 49,
	[217][10] = 50,
	[217][11] = 51,
	[217][12] = 52,
	[218][2] = 40,
	[218][3] = 41,
	[218][4] = 42,
	[218][5] = 44,
	[218][6] = 45,
	[218][7] = 47,
	[218][8] = 48,
	[218][9] = 49,
	[218][10] = 50,
	[218][11] = 51,
	[218][12] = 52,
	[219][2] = 40,
	[219][3] = 41,
	[219][4] = 42,
	[219][5] = 44,
	[219][6] = 45,
	[219][7] = 47,
	[219][8] = 48,
	[219][9] = 49,
	[219][10] = 50,
	[219][11] = 51,
	[219][12] = 52,
	[220][2] = 40,
	[220][3] = 41,
	[220][4] = 42,
	[220][5] = 44,
	[220][6] = 45,
	[220][7] = 47,
	[220][8] = 48,
	[220][9] = 49,
	[220][10] = 50,
	[220][11] = 51,
	[220][12] = 52,
	[221][2] = 40,
	[221][3] = 41,
	[221][4] = 42,
	[221][5] = 44,
	[221][6] = 45,
	[221][7] = 47,
	[221][8] = 48,
	[221][9] = 49,
	[221][10] = 50,
	[221][11] = 51,
	[221][12] = 52,
	[222][2] = 40,
	[222][3] = 41,
	[222][4] = 42,
	[222][5] = 44,
	[222][6] = 45,
	[222][7] = 47,
	[222][8] = 48,
	[222][9] = 49,
	[222][10] = 50,
	[222][11] = 51,
	[222][12] = 52,
	[224][2] = 40,
	[224][3] = 41,
	[224][4] = 42,
	[224][5] = 44,
	[224][6] = 45,
	[224][7] = 47,
	[224][8] = 48,
	[224][9] = 49,
	[224][10] = 50,
	[224][11] = 51,
	[224][12] = 52,
	[224][14] = 53,
	[225][2] = 40,
	[225][3] = 41,
	[225][4] = 42,
	[225][5] = 44,
	[225][6] = 45,
	[225][7] = 47,
	[225][8] = 48,
	[225][9] = 49,
	[225][10] = 50,
	[225][11] = 51,
	[225][12] = 52,
	[225][14] = 53,
	[226][2] = 40,
	[226][3] = 41,
	[226][4] = 42,
	[226][5] = 44,
	[226][6] = 45,
	[226][7] = 47,
	[226][8] = 48,
	[226][9] = 49,
	[226][10] = 50,
	[226][11] = 51,
	[226][12] = 52,
	[227][11] = 488,
	[228][2] = 40,
	[228][3] = 41,
	[228][4] = 42,
	[228][5] = 44,
	[228][6] = 45,
	[228][7] = 47,
	[228][8] = 48,
	[228][9] = 49,
	[228][10] = 50,
	[228][11] = 51,
	[228][12] = 52,
	[229][2] = 360,
	[229][3] = 361,
	[229][4] = 362,
	[229][5] = 363,
	[229][6] = 364,
	[229][7] = 365,
	[229][8] = 366,
	[229][9] = 367,
	[229][10] = 368,
	[229][11] = 369,
	[229][12] = 370,
	[229][14] = 371,
	[230][2] = 40,
	[230][3] = 41,
	[230][4] = 42,
	[230][5] = 44,
	[230][6] = 45,
	[230][7] = 47,
	[230][8] = 48,
	[230][9] = 49,
	[230][10] = 50,
	[230][11] = 51,
	[230][12] = 52,
	[231][2] = 40,
	[231][3] = 41,
	[231][4] = 42,
	[231][5] = 44,
	[231][6] = 45,
	[231][7] = 47,
	[231][8] = 48,
	[231][9] = 49,
	[231][10] = 50,
	[231][11] = 51,
	[231][12] = 52,
	[232][2] = 40,
	[232][3] = 41,
	[232][4] = 42,
	[232][5] = 44,
	[232][6] = 45,
	[232][7] = 47,
	[232][8] = 48,
	[232][9] = 49,
	[232][10] = 50,
	[232][11] = 51,
	[232][12] = 52,
	[233][2] = 40,
	[233][3] = 41,
	[233][4] = 42,
	[233][5] = 44,
	[233][6] = 45,
	[233][7] = 47,
	[233][8] = 48,
	[233][9] = 49,
	[233][10] = 50,
	[233][11] = 51,
	[233][12] = 52,
	[234][2] = 40,
	[234][3] = 41,
	[234][4] = 42,
	[234][5] = 44,
	[234][6] = 45,
	[234][7] = 47,
	[234][8] = 48,
	[234][9] = 49,
	[234][10] = 50,
	[234][11] = 51,
	[234][12] = 52,
	[234][14] = 53,
	[235][2] = 40,
	[235][3] = 41,
	[235][4] = 42,
	[235][5] = 44,
	[235][6] = 45,
	[235][7] = 47,
	[235][8] = 48,
	[235][9] = 49,
	[235][10] = 50,
	[235][11] = 51,
	[235][12] = 52,
	[235][14] = 53,
	[235][37] = 497,
	[235][38] = 498,
	[236][2] = 400,
	[236][3] = 401,
	[236][4] = 402,
	[236][5] = 403,
	[236][6] = 404,
	[236][7] = 405,
	[236][8] = 406,
	[236][9] = 407,
	[236][10] = 408,
	[236][11] = 409,
	[236][12] = 410,
	[236][14] = 411,
	[237][11] = 501,
	[238][2] = 40,
	[238][3] = 41,
	[238][4] = 42,
	[238][5] = 44,
	[238][6] = 45,
	[238][7] = 47,
	[238][8] = 48,
	[238][9] = 49,
	[238][10] = 50,
	[238][11] = 51,
	[238][12] = 52,
	[239][2] = 40,
	[239][3] = 41,
	[239][4] = 42,
	[239][5] = 44,
	[239][6] = 45,
	[239][7] = 47,
	[239][8] = 48,
	[239][9] = 49,
	[239][10] = 50,
	[239][11] = 51,
	[239][12] = 52,
	[240][2] = 40,
	[240][3] = 41,
	[240][4] = 42,
	[240][5] = 44,
	[240][6] = 45,
	[240][7] = 47,
	[240][8] = 48,
	[240][9] = 49,
	[240][10] = 50,
	[240][11] = 51,
	[240][12] = 52,
	[241][2] = 40,
	[241][3] = 41,
	[241][4] = 42,
	[241][5] = 44,
	[241][6] = 45,
	[241][7] = 47,
	[241][8] = 48,
	[241][9] = 49,
	[241][10] = 50,
	[241][11] = 51,
	[241][12] = 52,
	[242][2] = 40,
	[242][3] = 41,
	[242][4] = 42,
	[242][5] = 44,
	[242][6] = 45,
	[242][7] = 47,
	[242][8] = 48,
	[242][9] = 49,
	[242][10] = 50,
	[242][11] = 51,
	[242][12] = 52,
	[243][2] = 40,
	[243][3] = 41,
	[243][4] = 42,
	[243][5] = 44,
	[243][6] = 45,
	[243][7] = 47,
	[243][8] = 48,
	[243][9] = 49,
	[243][10] = 50,
	[243][11] = 51,
	[243][12] = 52,
	[245][2] = 40,
	[245][3] = 41,
	[245][4] = 42,
	[245][5] = 44,
	[245][6] = 45,
	[245][7] = 47,
	[245][8] = 48,
	[245][9] = 49,
	[245][10] = 50,
	[245][11] = 51,
	[245][12] = 52,
	[245][14] = 53,
	[246][37] = 510,
	[246][38] = 511,
	[250][38] = 512,
	[250][39] = 513,
	[251][2] = 76,
	[251][3] = 77,
	[251][4] = 78,
	[251][5] = 79,
	[251][6] = 80,
	[251][7] = 82,
	[251][8] = 83,
	[251][9] = 85,
	[251][10] = 86,
	[251][11] = 87,
	[251][12] = 88,
	[251][14] = 89,
	[253][38] = 516,
	[253][39] = 517,
	[256][4] = 120,
	[256][11] = 317,
	[256][14] = 128,
	[256][49] = 124,
	[256][50] = 125,
	[256][51] = 126,
	[256][52] = 127,
	[257][2] = 76,
	[257][3] = 77,
	[257][4] = 78,
	[257][5] = 79,
	[257][6] = 80,
	[257][7] = 82,
	[257][8] = 83,
	[257][9] = 85,
	[257][10] = 86,
	[257][11] = 87,
	[257][12] = 88,
	[257][14] = 89,
	[258][11] = 522,
	[259][2] = 76,
	[259][3] = 77,
	[259][4] = 78,
	[259][5] = 79,
	[259][6] = 80,
	[259][7] = 82,
	[259][8] = 83,
	[259][9] = 85,
	[259][10] = 86,
	[259][11] = 87,
	[259][12] = 88,
	[260][2] = 76,
	[260][3] = 77,
	[260][4] = 78,
	[260][5] = 79,
	[260][6] = 80,
	[260][7] = 82,
	[260][8] = 83,
	[260][9] = 85,
	[260][10] = 86,
	[260][11] = 87,
	[260][12] = 88,
	[261][2] = 76,
	[261][3] = 77,
	[261][4] = 78,
	[261][5] = 79,
	[261][6] = 80,
	[261][7] = 82,
	[261][8] = 83,
	[261][9] = 85,
	[261][10] = 86,
	[261][11] = 87,
	[261][12] = 88,
	[262][2] = 76,
	[262][3] = 77,
	[262][4] = 78,
	[262][5] = 79,
	[262][6] = 80,
	[262][7] = 82,
	[262][8] = 83,
	[262][9] = 85,
	[262][10] = 86,
	[262][11] = 87,
	[262][12] = 88,
	[263][2] = 76,
	[263][3] = 77,
	[263][4] = 78,
	[263][5] = 79,
	[263][6] = 80,
	[263][7] = 82,
	[263][8] = 83,
	[263][9] = 85,
	[263][10] = 86,
	[263][11] = 87,
	[263][12] = 88,
	[264][2] = 76,
	[264][3] = 77,
	[264][4] = 78,
	[264][5] = 79,
	[264][6] = 80,
	[264][7] = 82,
	[264][8] = 83,
	[264][9] = 85,
	[264][10] = 86,
	[264][11] = 87,
	[264][12] = 88,
	[265][2] = 76,
	[265][3] = 77,
	[265][4] = 78,
	[265][5] = 79,
	[265][6] = 80,
	[265][7] = 82,
	[265][8] = 83,
	[265][9] = 85,
	[265][10] = 86,
	[265][11] = 87,
	[265][12] = 88,
	[266][2] = 76,
	[266][3] = 77,
	[266][4] = 78,
	[266][5] = 79,
	[266][6] = 80,
	[266][7] = 82,
	[266][8] = 83,
	[266][9] = 85,
	[266][10] = 86,
	[266][11] = 87,
	[266][12] = 88,
	[266][14] = 89,
	[268][2] = 76,
	[268][3] = 77,
	[268][4] = 78,
	[268][5] = 79,
	[268][6] = 80,
	[268][7] = 82,
	[268][8] = 83,
	[268][9] = 85,
	[268][10] = 86,
	[268][11] = 87,
	[268][12] = 88,
	[268][14] = 89,
	[269][2] = 76,
	[269][3] = 77,
	[269][4] = 78,
	[269][5] = 79,
	[269][6] = 80,
	[269][7] = 82,
	[269][8] = 83,
	[269][9] = 85,
	[269][10] = 86,
	[269][11] = 87,
	[269][12] = 88,
	[270][11] = 534,
	[271][2] = 76,
	[271][3] = 77,
	[271][4] = 78,
	[271][5] = 79,
	[271][6] = 80,
	[271][7] = 82,
	[271][8] = 83,
	[271][9] = 85,
	[271][10] = 86,
	[271][11] = 87,
	[271][12] = 88,
	[272][2] = 360,
	[272][3] = 361,
	[272][4] = 362,
	[272][5] = 363,
	[272][6] = 364,
	[272][7] = 365,
	[272][8] = 366,
	[272][9] = 367,
	[272][10] = 368,
	[272][11] = 369,
	[272][12] = 370,
	[272][14] = 371,
	[273][2] = 76,
	[273][3] = 77,
	[273][4] = 78,
	[273][5] = 79,
	[273][6] = 80,
	[273][7] = 82,
	[273][8] = 83,
	[273][9] = 85,
	[273][10] = 86,
	[273][11] = 87,
	[273][12] = 88,
	[274][2] = 76,
	[274][3] = 77,
	[274][4] = 78,
	[274][5] = 79,
	[274][6] = 80,
	[274][7] = 82,
	[274][8] = 83,
	[274][9] = 85,
	[274][10] = 86,
	[274][11] = 87,
	[274][12] = 88,
	[275][2] = 76,
	[275][3] = 77,
	[275][4] = 78,
	[275][5] = 79,
	[275][6] = 80,
	[275][7] = 82,
	[275][8] = 83,
	[275][9] = 85,
	[275][10] = 86,
	[275][11] = 87,
	[275][12] = 88,
	[276][2] = 76,
	[276][3] = 77,
	[276][4] = 78,
	[276][5] = 79,
	[276][6] = 80,
	[276][7] = 82,
	[276][8] = 83,
	[276][9] = 85,
	[276][10] = 86,
	[276][11] = 87,
	[276][12] = 88,
	[277][2] = 76,
	[277][3] = 77,
	[277][4] = 78,
	[277][5] = 79,
	[277][6] = 80,
	[277][7] = 82,
	[277][8] = 83,
	[277][9] = 85,
	[277][10] = 86,
	[277][11] = 87,
	[277][12] = 88,
	[277][14] = 89,
	[278][2] = 40,
	[278][3] = 41,
	[278][4] = 42,
	[278][5] = 44,
	[278][6] = 45,
	[278][7] = 47,
	[278][8] = 48,
	[278][9] = 49,
	[278][10] = 50,
	[278][11] = 51,
	[278][12] = 52,
	[278][14] = 53,
	[278][37] = 543,
	[278][38] = 544,
	[279][2] = 400,
	[279][3] = 401,
	[279][4] = 402,
	[279][5] = 403,
	[279][6] = 404,
	[279][7] = 405,
	[279][8] = 406,
	[279][9] = 407,
	[279][10] = 408,
	[279][11] = 409,
	[279][12] = 410,
	[279][14] = 411,
	[280][11] = 547,
	[281][2] = 76,
	[281][3] = 77,
	[281][4] = 78,
	[281][5] = 79,
	[281][6] = 80,
	[281][7] = 82,
	[281][8] = 83,
	[281][9] = 85,
	[281][10] = 86,
	[281][11] = 87,
	[281][12] = 88,
	[282][2] = 76,
	[282][3] = 77,
	[282][4] = 78,
	[282][5] = 79,
	[282][6] = 80,
	[282][7] = 82,
	[282][8] = 83,
	[282][9] = 85,
	[282][10] = 86,
	[282][11] = 87,
	[282][12] = 88,
	[283][2] = 76,
	[283][3] = 77,
	[283][4] = 78,
	[283][5] = 79,
	[283][6] = 80,
	[283][7] = 82,
	[283][8] = 83,
	[283][9] = 85,
	[283][10] = 86,
	[283][11] = 87,
	[283][12] = 88,
	[284][2] = 76,
	[284][3] = 77,
	[284][4] = 78,
	[284][5] = 79,
	[284][6] = 80,
	[284][7] = 82,
	[284][8] = 83,
	[284][9] = 85,
	[284][10] = 86,
	[284][11] = 87,
	[284][12] = 88,
	[285][2] = 76,
	[285][3] = 77,
	[285][4] = 78,
	[285][5] = 79,
	[285][6] = 80,
	[285][7] = 82,
	[285][8] = 83,
	[285][9] = 85,
	[285][10] = 86,
	[285][11] = 87,
	[285][12] = 88,
	[286][2] = 76,
	[286][3] = 77,
	[286][4] = 78,
	[286][5] = 79,
	[286][6] = 80,
	[286][7] = 82,
	[286][8] = 83,
	[286][9] = 85,
	[286][10] = 86,
	[286][11] = 87,
	[286][12] = 88,
	[287][55] = 554,
	[288][55] = 555,
	[289][2] = 556,
	[289][3] = 557,
	[289][4] = 558,
	[289][7] = 559,
	[289][8] = 560,
	[289][11] = 561,
	[289][22] = 562,
	[290][55] = 567,
	[291][2] = 568,
	[291][3] = 569,
	[291][4] = 570,
	[291][5] = 571,
	[292][55] = 578,
	[293][2] = 579,
	[293][3] = 580,
	[293][4] = 581,
	[293][7] = 582,
	[293][8] = 583,
	[294][36] = 588,
	[295][9] = 589,
	[295][18] = 590,
	[295][19] = 591,
	[296][17] = 592,
	[297][2] = 287,
	[297][3] = 288,
	[297][4] = 289,
	[297][7] = 290,
	[297][8] = 291,
	[297][11] = 292,
	[297][22] = 293,
	[298][36] = 594,
	[299][36] = 595,
	[300][2] = 596,
	[300][3] = 597,
	[300][4] = 598,
	[300][7] = 599,
	[300][8] = 600,
	[301][2] = 287,
	[301][3] = 288,
	[301][4] = 289,
	[301][7] = 290,
	[301][8] = 291,
	[301][11] = 292,
	[301][22] = 293,
	[302][2] = 2,
	[302][3] = 3,
	[302][4] = 4,
	[302][5] = 5,
	[302][6] = 6,
	[302][7] = 7,
	[302][8] = 8,
	[302][9] = 9,
	[302][10] = 10,
	[302][11] = 73,
	[302][12] = 12,
	[302][14] = 14,
	[303][2] = 2,
	[303][3] = 3,
	[303][4] = 4,
	[303][5] = 5,
	[303][6] = 6,
	[303][7] = 7,
	[303][8] = 8,
	[303][9] = 9,
	[303][10] = 10,
	[303][11] = 73,
	[303][12] = 12,
	[303][14] = 14,
	[304][2] = 2,
	[304][3] = 3,
	[304][4] = 4,
	[304][5] = 5,
	[304][6] = 6,
	[304][7] = 7,
	[304][8] = 8,
	[304][9] = 9,
	[304][10] = 10,
	[304][11] = 73,
	[304][12] = 12,
	[304][14] = 14,
	[305][2] = 2,
	[305][3] = 3,
	[305][4] = 4,
	[305][5] = 5,
	[305][6] = 6,
	[305][7] = 7,
	[305][8] = 8,
	[305][9] = 9,
	[305][10] = 10,
	[305][11] = 73,
	[305][12] = 12,
	[305][14] = 14,
	[306][4] = 306,
	[306][11] = 309,
	[306][14] = 314,
	[306][37] = 611,
	[306][38] = 612,
	[306][49] = 310,
	[306][50] = 311,
	[306][51] = 312,
	[306][52] = 313,
	[308][4] = 306,
	[308][11] = 309,
	[308][14] = 314,
	[308][49] = 310,
	[308][50] = 311,
	[308][51] = 312,
	[308][52] = 313,
	[314][4] = 323,
	[314][11] = 325,
	[314][14] = 331,
	[314][38] = 616,
	[314][40] = 617,
	[314][49] = 327,
	[314][50] = 328,
	[314][51] = 329,
	[314][52] = 330,
	[315][54] = 619,
	[316][37] = 620,
	[316][38] = 621,
	[319][38] = 622,
	[319][40] = 623,
	[320][11] = 624,
	[323][4] = 306,
	[323][11] = 309,
	[323][14] = 314,
	[323][37] = 625,
	[323][38] = 626,
	[323][49] = 310,
	[323][50] = 311,
	[323][51] = 312,
	[323][52] = 313,
	[324][4] = 323,
	[324][11] = 325,
	[324][14] = 331,
	[324][49] = 327,
	[324][50] = 328,
	[324][51] = 329,
	[324][52] = 330,
	[326][4] = 120,
	[326][11] = 122,
	[326][14] = 128,
	[326][49] = 124,
	[326][50] = 125,
	[326][51] = 126,
	[326][52] = 127,
	[331][4] = 323,
	[331][11] = 325,
	[331][14] = 331,
	[331][38] = 632,
	[331][40] = 633,
	[331][49] = 327,
	[331][50] = 328,
	[331][51] = 329,
	[331][52] = 330,
	[332][54] = 635,
	[333][38] = 636,
	[333][40] = 637,
	[335][38] = 638,
	[335][40] = 639,
	[336][13] = 162,
	[336][19] = 160,
	[336][22] = 161,
	[337][13] = 162,
	[337][19] = 160,
	[337][22] = 161,
	[338][29] = 141,
	[338][30] = 142,
	[345][25] = 167,
	[345][26] = 168,
	[345][27] = 169,
	[345][28] = 170,
	[346][25] = 167,
	[346][26] = 168,
	[346][27] = 169,
	[346][28] = 170,
	[347][15] = 133,
	[356][35] = 640,
	[357][16] = 143,
	[359][17] = 155,
	[362][2] = 40,
	[362][3] = 41,
	[362][4] = 42,
	[362][5] = 44,
	[362][6] = 45,
	[362][7] = 47,
	[362][8] = 48,
	[362][9] = 49,
	[362][10] = 50,
	[362][11] = 51,
	[362][12] = 52,
	[362][14] = 53,
	[362][37] = 641,
	[362][38] = 642,
	[363][2] = 360,
	[363][3] = 361,
	[363][4] = 362,
	[363][5] = 363,
	[363][6] = 364,
	[363][7] = 365,
	[363][8] = 366,
	[363][9] = 367,
	[363][10] = 368,
	[363][11] = 369,
	[363][12] = 370,
	[364][2] = 360,
	[364][3] = 361,
	[364][4] = 362,
	[364][5] = 363,
	[364][6] = 364,
	[364][7] = 365,
	[364][8] = 366,
	[364][9] = 367,
	[364][10] = 368,
	[364][11] = 369,
	[364][12] = 370,
	[366][2] = 76,
	[366][3] = 77,
	[366][4] = 78,
	[366][5] = 79,
	[366][6] = 80,
	[366][7] = 82,
	[366][8] = 83,
	[366][9] = 85,
	[366][10] = 86,
	[366][11] = 87,
	[366][12] = 88,
	[366][14] = 89,
	[366][38] = 646,
	[366][39] = 647,
	[367][2] = 360,
	[367][3] = 361,
	[367][4] = 362,
	[367][5] = 363,
	[367][6] = 364,
	[367][7] = 365,
	[367][8] = 366,
	[367][9] = 367,
	[367][10] = 368,
	[367][11] = 369,
	[367][12] = 370,
	[370][2] = 360,
	[370][3] = 361,
	[370][4] = 362,
	[370][5] = 363,
	[370][6] = 364,
	[370][7] = 365,
	[370][8] = 366,
	[370][9] = 367,
	[370][10] = 368,
	[370][11] = 369,
	[370][12] = 370,
	[371][4] = 120,
	[371][11] = 122,
	[371][14] = 128,
	[371][38] = 651,
	[371][40] = 652,
	[371][49] = 124,
	[371][50] = 125,
	[371][51] = 126,
	[371][52] = 127,
	[372][6] = 654,
	[372][9] = 655,
	[373][15] = 656,
	[375][29] = 657,
	[375][30] = 658,
	[376][16] = 659,
	[377][21] = 660,
	[378][40] = 661,
	[379][35] = 662,
	[380][17] = 663,
	[381][33] = 664,
	[382][31] = 665,
	[383][18] = 666,
	[383][32] = 667,
	[384][13] = 670,
	[384][19] = 668,
	[384][22] = 669,
	[385][34] = 671,
	[386][4] = 672,
	[386][8] = 673,
	[386][20] = 674,
	[388][25] = 675,
	[388][26] = 676,
	[388][27] = 677,
	[388][28] = 678,
	[389][23] = 679,
	[389][24] = 680,
	[391][31] = 157,
	[392][21] = 144,
	[393][21] = 144,
	[394][21] = 144,
	[396][34] = 681,
	[398][2] = 40,
	[398][3] = 41,
	[398][4] = 42,
	[398][5] = 44,
	[398][6] = 45,
	[398][7] = 47,
	[398][8] = 48,
	[398][9] = 49,
	[398][10] = 50,
	[398][11] = 51,
	[398][12] = 52,
	[398][14] = 53,
	[399][37] = 684,
	[399][38] = 685,
	[402][2] = 40,
	[402][3] = 41,
	[402][4] = 42,
	[402][5] = 44,
	[402][6] = 45,
	[402][7] = 47,
	[402][8] = 48,
	[402][9] = 49,
	[402][10] = 50,
	[402][11] = 51,
	[402][12] = 52,
	[402][14] = 53,
	[402][37] = 686,
	[402][38] = 687,
	[403][2] = 400,
	[403][3] = 401,
	[403][4] = 402,
	[403][5] = 403,
	[403][6] = 404,
	[403][7] = 405,
	[403][8] = 406,
	[403][9] = 407,
	[403][10] = 408,
	[403][11] = 409,
	[403][12] = 410,
	[404][2] = 400,
	[404][3] = 401,
	[404][4] = 402,
	[404][5] = 403,
	[404][6] = 404,
	[404][7] = 405,
	[404][8] = 406,
	[404][9] = 407,
	[404][10] = 408,
	[404][11] = 409,
	[404][12] = 410,
	[406][2] = 76,
	[406][3] = 77,
	[406][4] = 78,
	[406][5] = 79,
	[406][6] = 80,
	[406][7] = 82,
	[406][8] = 83,
	[406][9] = 85,
	[406][10] = 86,
	[406][11] = 87,
	[406][12] = 88,
	[406][14] = 89,
	[406][38] = 691,
	[406][39] = 692,
	[407][2] = 400,
	[407][3] = 401,
	[407][4] = 402,
	[407][5] = 403,
	[407][6] = 404,
	[407][7] = 405,
	[407][8] = 406,
	[407][9] = 407,
	[407][10] = 408,
	[407][11] = 409,
	[407][12] = 410,
	[410][2] = 400,
	[410][3] = 401,
	[410][4] = 402,
	[410][5] = 403,
	[410][6] = 404,
	[410][7] = 405,
	[410][8] = 406,
	[410][9] = 407,
	[410][10] = 408,
	[410][11] = 409,
	[410][12] = 410,
	[411][4] = 120,
	[411][11] = 122,
	[411][14] = 128,
	[411][38] = 696,
	[411][40] = 697,
	[411][49] = 124,
	[411][50] = 125,
	[411][51] = 126,
	[411][52] = 127,
	[412][6] = 699,
	[412][9] = 700,
	[413][15] = 701,
	[415][29] = 702,
	[415][30] = 703,
	[416][16] = 704,
	[417][21] = 705,
	[418][39] = 706,
	[419][35] = 707,
	[420][17] = 708,
	[421][33] = 709,
	[422][31] = 710,
	[423][18] = 711,
	[423][32] = 712,
	[424][13] = 715,
	[424][19] = 713,
	[424][22] = 714,
	[425][34] = 716,
	[426][4] = 717,
	[426][8] = 718,
	[426][20] = 719,
	[428][25] = 720,
	[428][26] = 721,
	[428][27] = 722,
	[428][28] = 723,
	[429][23] = 724,
	[429][24] = 725,
	[432][23] = 171,
	[432][24] = 172,
	[433][23] = 171,
	[433][24] = 172,
	[434][23] = 171,
	[434][24] = 172,
	[435][23] = 171,
	[435][24] = 172,
	[436][6] = 131,
	[436][9] = 132,
	[437][6] = 131,
	[437][9] = 132,
	[463][37] = 726,
	[463][38] = 727,
	[465][2] = 40,
	[465][3] = 41,
	[465][4] = 42,
	[465][5] = 44,
	[465][6] = 45,
	[465][7] = 47,
	[465][8] = 48,
	[465][9] = 49,
	[465][10] = 50,
	[465][11] = 51,
	[465][12] = 52,
	[465][14] = 53,
	[467][2] = 40,
	[467][3] = 41,
	[467][4] = 42,
	[467][5] = 44,
	[467][6] = 45,
	[467][7] = 47,
	[467][8] = 48,
	[467][9] = 49,
	[467][10] = 50,
	[467][11] = 51,
	[467][12] = 52,
	[467][14] = 53,
	[469][38] = 730,
	[469][39] = 731,
	[470][2] = 76,
	[470][3] = 77,
	[470][4] = 78,
	[470][5] = 79,
	[470][6] = 80,
	[470][7] = 82,
	[470][8] = 83,
	[470][9] = 85,
	[470][10] = 86,
	[470][11] = 87,
	[470][12] = 88,
	[470][14] = 89,
	[473][38] = 733,
	[473][40] = 734,
	[476][38] = 735,
	[476][40] = 736,
	[477][13] = 233,
	[477][19] = 231,
	[477][22] = 232,
	[478][13] = 233,
	[478][19] = 231,
	[478][22] = 232,
	[479][29] = 219,
	[479][30] = 220,
	[480][25] = 238,
	[480][26] = 239,
	[480][27] = 240,
	[480][28] = 241,
	[481][25] = 238,
	[481][26] = 239,
	[481][27] = 240,
	[481][28] = 241,
	[482][15] = 218,
	[486][35] = 737,
	[487][16] = 221,
	[489][17] = 226,
	[490][40] = 738,
	[491][31] = 228,
	[492][21] = 222,
	[493][21] = 222,
	[494][21] = 222,
	[496][34] = 739,
	[498][2] = 40,
	[498][3] = 41,
	[498][4] = 42,
	[498][5] = 44,
	[498][6] = 45,
	[498][7] = 47,
	[498][8] = 48,
	[498][9] = 49,
	[498][10] = 50,
	[498][11] = 51,
	[498][12] = 52,
	[498][14] = 53,
	[499][37] = 742,
	[499][38] = 743,
	[500][39] = 744,
	[502][23] = 242,
	[502][24] = 243,
	[503][23] = 242,
	[503][24] = 243,
	[504][23] = 242,
	[504][24] = 243,
	[505][23] = 242,
	[505][24] = 243,
	[506][6] = 216,
	[506][9] = 217,
	[507][6] = 216,
	[507][9] = 217,
	[509][37] = 745,
	[509][38] = 746,
	[511][2] = 40,
	[511][3] = 41,
	[511][4] = 42,
	[511][5] = 44,
	[511][6] = 45,
	[511][7] = 47,
	[511][8] = 48,
	[511][9] = 49,
	[511][10] = 50,
	[511][11] = 51,
	[511][12] = 52,
	[511][14] = 53,
	[512][2] = 76,
	[512][3] = 77,
	[512][4] = 78,
	[512][5] = 79,
	[512][6] = 80,
	[512][7] = 82,
	[512][8] = 83,
	[512][9] = 85,
	[512][10] = 86,
	[512][11] = 87,
	[512][12] = 88,
	[512][14] = 89,
	[515][38] = 749,
	[515][39] = 750,
	[516][2] = 76,
	[516][3] = 77,
	[516][4] = 78,
	[516][5] = 79,
	[516][6] = 80,
	[516][7] = 82,
	[516][8] = 83,
	[516][9] = 85,
	[516][10] = 86,
	[516][11] = 87,
	[516][12] = 88,
	[516][14] = 89,
	[519][38] = 752,
	[519][40] = 753,
	[522][38] = 754,
	[522][40] = 755,
	[523][13] = 276,
	[523][19] = 274,
	[523][22] = 275,
	[524][13] = 276,
	[524][19] = 274,
	[524][22] = 275,
	[525][29] = 262,
	[525][30] = 263,
	[526][25] = 281,
	[526][26] = 282,
	[526][27] = 283,
	[526][28] = 284,
	[527][25] = 281,
	[527][26] = 282,
	[527][27] = 283,
	[527][28] = 284,
	[528][15] = 261,
	[532][35] = 756,
	[533][16] = 264,
	[535][17] = 269,
	[536][40] = 757,
	[537][31] = 271,
	[538][21] = 265,
	[539][21] = 265,
	[540][21] = 265,
	[542][34] = 758,
	[544][2] = 40,
	[544][3] = 41,
	[544][4] = 42,
	[544][5] = 44,
	[544][6] = 45,
	[544][7] = 47,
	[544][8] = 48,
	[544][9] = 49,
	[544][10] = 50,
	[544][11] = 51,
	[544][12] = 52,
	[544][14] = 53,
	[545][37] = 761,
	[545][38] = 762,
	[546][39] = 763,
	[548][23] = 285,
	[548][24] = 286,
	[549][23] = 285,
	[549][24] = 286,
	[550][23] = 285,
	[550][24] = 286,
	[551][23] = 285,
	[551][24] = 286,
	[552][6] = 259,
	[552][9] = 260,
	[553][6] = 259,
	[553][9] = 260,
	[554][55] = 764,
	[555][55] = 766,
	[556][55] = 768,
	[557][55] = 769,
	[558][2] = 556,
	[558][3] = 557,
	[558][4] = 558,
	[558][7] = 559,
	[558][8] = 560,
	[558][11] = 561,
	[558][22] = 562,
	[559][55] = 771,
	[560][2] = 568,
	[560][3] = 569,
	[560][4] = 570,
	[560][5] = 571,
	[561][55] = 773,
	[562][2] = 579,
	[562][3] = 580,
	[562][4] = 581,
	[562][7] = 582,
	[562][8] = 583,
	[563][37] = 775,
	[564][9] = 776,
	[564][18] = 777,
	[564][19] = 778,
	[565][17] = 779,
	[566][2] = 556,
	[566][3] = 557,
	[566][4] = 558,
	[566][7] = 559,
	[566][8] = 560,
	[566][11] = 561,
	[566][22] = 562,
	[567][55] = 781,
	[570][2] = 783,
	[570][3] = 784,
	[570][4] = 785,
	[570][5] = 786,
	[571][2] = 568,
	[571][3] = 569,
	[571][4] = 570,
	[572][39] = 794,
	[574][16] = 795,
	[575][6] = 796,
	[576][15] = 797,
	[577][2] = 568,
	[577][3] = 569,
	[577][4] = 570,
	[577][5] = 571,
	[577][17] = 799,
	[577][38] = 798,
	[578][55] = 801,
	[581][2] = 803,
	[581][3] = 804,
	[581][4] = 805,
	[581][7] = 806,
	[581][8] = 807,
	[583][2] = 568,
	[583][3] = 569,
	[583][4] = 570,
	[583][5] = 571,
	[584][22] = 813,
	[585][9] = 814,
	[585][18] = 815,
	[585][19] = 816,
	[586][17] = 817,
	[587][2] = 579,
	[587][3] = 580,
	[587][4] = 581,
	[587][7] = 582,
	[587][8] = 583,
	[592][2] = 287,
	[592][3] = 288,
	[592][4] = 289,
	[592][7] = 290,
	[592][8] = 291,
	[592][11] = 292,
	[592][22] = 293,
	[593][2] = 287,
	[593][3] = 288,
	[593][4] = 289,
	[593][7] = 290,
	[593][8] = 291,
	[593][11] = 292,
	[593][22] = 293,
	[598][2] = 803,
	[598][3] = 804,
	[598][4] = 805,
	[598][7] = 806,
	[598][8] = 807,
	[600][2] = 568,
	[600][3] = 569,
	[600][4] = 570,
	[600][5] = 571,
	[601][36] = 825,
	[602][9] = 826,
	[602][18] = 827,
	[602][19] = 828,
	[603][17] = 829,
	[604][2] = 596,
	[604][3] = 597,
	[604][4] = 598,
	[604][7] = 599,
	[604][8] = 600,
	[605][36] = 831,
	[607][36] = 145,
	[612][4] = 306,
	[612][11] = 309,
	[612][14] = 314,
	[612][49] = 310,
	[612][50] = 311,
	[612][51] = 312,
	[612][52] = 313,
	[613][37] = 835,
	[613][38] = 836,
	[615][37] = 837,
	[615][38] = 838,
	[616][4] = 323,
	[616][11] = 325,
	[616][14] = 331,
	[616][49] = 327,
	[616][50] = 328,
	[616][51] = 329,
	[616][52] = 330,
	[617][4] = 306,
	[617][11] = 309,
	[617][14] = 314,
	[617][49] = 310,
	[617][50] = 311,
	[617][51] = 312,
	[617][52] = 313,
	[618][38] = 843,
	[618][40] = 844,
	[621][4] = 306,
	[621][11] = 309,
	[621][14] = 314,
	[621][49] = 310,
	[621][50] = 311,
	[621][51] = 312,
	[621][52] = 313,
	[622][4] = 120,
	[622][11] = 317,
	[622][14] = 128,
	[622][49] = 124,
	[622][50] = 125,
	[622][51] = 126,
	[622][52] = 127,
	[623][2] = 2,
	[623][3] = 3,
	[623][4] = 4,
	[623][5] = 5,
	[623][6] = 6,
	[623][7] = 7,
	[623][8] = 8,
	[623][9] = 9,
	[623][10] = 10,
	[623][11] = 73,
	[623][12] = 12,
	[623][14] = 14,
	[626][4] = 306,
	[626][11] = 309,
	[626][14] = 314,
	[626][49] = 310,
	[626][50] = 311,
	[626][51] = 312,
	[626][52] = 313,
	[627][37] = 850,
	[627][38] = 851,
	[629][38] = 852,
	[629][40] = 853,
	[632][4] = 323,
	[632][11] = 325,
	[632][14] = 331,
	[632][49] = 327,
	[632][50] = 328,
	[632][51] = 329,
	[632][52] = 330,
	[633][4] = 323,
	[633][11] = 325,
	[633][14] = 331,
	[633][49] = 327,
	[633][50] = 328,
	[633][51] = 329,
	[633][52] = 330,
	[634][38] = 858,
	[634][40] = 859,
	[636][4] = 323,
	[636][11] = 325,
	[636][14] = 331,
	[636][49] = 327,
	[636][50] = 328,
	[636][51] = 329,
	[636][52] = 330,
	[637][4] = 120,
	[637][11] = 122,
	[637][14] = 128,
	[637][49] = 124,
	[637][50] = 125,
	[637][51] = 126,
	[637][52] = 127,
	[638][4] = 120,
	[638][11] = 317,
	[638][14] = 128,
	[638][49] = 124,
	[638][50] = 125,
	[638][51] = 126,
	[638][52] = 127,
	[639][2] = 2,
	[639][3] = 3,
	[639][4] = 4,
	[639][5] = 5,
	[639][6] = 6,
	[639][7] = 7,
	[639][8] = 8,
	[639][9] = 9,
	[639][10] = 10,
	[639][11] = 73,
	[639][12] = 12,
	[639][14] = 14,
	[640][2] = 2,
	[640][3] = 3,
	[640][4] = 4,
	[640][5] = 5,
	[640][6] = 6,
	[640][7] = 7,
	[640][8] = 8,
	[640][9] = 9,
	[640][10] = 10,
	[640][11] = 73,
	[640][12] = 12,
	[640][14] = 14,
	[642][2] = 40,
	[642][3] = 41,
	[642][4] = 42,
	[642][5] = 44,
	[642][6] = 45,
	[642][7] = 47,
	[642][8] = 48,
	[642][9] = 49,
	[642][10] = 50,
	[642][11] = 51,
	[642][12] = 52,
	[642][14] = 53,
	[643][37] = 867,
	[643][38] = 868,
	[646][2] = 76,
	[646][3] = 77,
	[646][4] = 78,
	[646][5] = 79,
	[646][6] = 80,
	[646][7] = 82,
	[646][8] = 83,
	[646][9] = 85,
	[646][10] = 86,
	[646][11] = 87,
	[646][12] = 88,
	[646][14] = 89,
	[648][38] = 871,
	[648][39] = 872,
	[651][4] = 120,
	[651][11] = 317,
	[651][14] = 128,
	[651][49] = 124,
	[651][50] = 125,
	[651][51] = 126,
	[651][52] = 127,
	[652][2] = 360,
	[652][3] = 361,
	[652][4] = 362,
	[652][5] = 363,
	[652][6] = 364,
	[652][7] = 365,
	[652][8] = 366,
	[652][9] = 367,
	[652][10] = 368,
	[652][11] = 369,
	[652][12] = 370,
	[652][14] = 371,
	[653][11] = 877,
	[654][2] = 360,
	[654][3] = 361,
	[654][4] = 362,
	[654][5] = 363,
	[654][6] = 364,
	[654][7] = 365,
	[654][8] = 366,
	[654][9] = 367,
	[654][10] = 368,
	[654][11] = 369,
	[654][12] = 370,
	[655][2] = 360,
	[655][3] = 361,
	[655][4] = 362,
	[655][5] = 363,
	[655][6] = 364,
	[655][7] = 365,
	[655][8] = 366,
	[655][9] = 367,
	[655][10] = 368,
	[655][11] = 369,
	[655][12] = 370,
	[656][2] = 360,
	[656][3] = 361,
	[656][4] = 362,
	[656][5] = 363,
	[656][6] = 364,
	[656][7] = 365,
	[656][8] = 366,
	[656][9] = 367,
	[656][10] = 368,
	[656][11] = 369,
	[656][12] = 370,
	[657][2] = 360,
	[657][3] = 361,
	[657][4] = 362,
	[657][5] = 363,
	[657][6] = 364,
	[657][7] = 365,
	[657][8] = 366,
	[657][9] = 367,
	[657][10] = 368,
	[657][11] = 369,
	[657][12] = 370,
	[658][2] = 360,
	[658][3] = 361,
	[658][4] = 362,
	[658][5] = 363,
	[658][6] = 364,
	[658][7] = 365,
	[658][8] = 366,
	[658][9] = 367,
	[658][10] = 368,
	[658][11] = 369,
	[658][12] = 370,
	[659][2] = 360,
	[659][3] = 361,
	[659][4] = 362,
	[659][5] = 363,
	[659][6] = 364,
	[659][7] = 365,
	[659][8] = 366,
	[659][9] = 367,
	[659][10] = 368,
	[659][11] = 369,
	[659][12] = 370,
	[660][2] = 360,
	[660][3] = 361,
	[660][4] = 362,
	[660][5] = 363,
	[660][6] = 364,
	[660][7] = 365,
	[660][8] = 366,
	[660][9] = 367,
	[660][10] = 368,
	[660][11] = 369,
	[660][12] = 370,
	[661][2] = 2,
	[661][3] = 3,
	[661][4] = 4,
	[661][5] = 5,
	[661][6] = 6,
	[661][7] = 7,
	[661][8] = 8,
	[661][9] = 9,
	[661][10] = 10,
	[661][11] = 73,
	[661][12] = 12,
	[662][2] = 360,
	[662][3] = 361,
	[662][4] = 362,
	[662][5] = 363,
	[662][6] = 364,
	[662][7] = 365,
	[662][8] = 366,
	[662][9] = 367,
	[662][10] = 368,
	[662][11] = 369,
	[662][12] = 370,
	[662][14] = 371,
	[663][2] = 360,
	[663][3] = 361,
	[663][4] = 362,
	[663][5] = 363,
	[663][6] = 364,
	[663][7] = 365,
	[663][8] = 366,
	[663][9] = 367,
	[663][10] = 368,
	[663][11] = 369,
	[663][12] = 370,
	[664][11] = 889,
	[665][2] = 360,
	[665][3] = 361,
	[665][4] = 362,
	[665][5] = 363,
	[665][6] = 364,
	[665][7] = 365,
	[665][8] = 366,
	[665][9] = 367,
	[665][10] = 368,
	[665][11] = 369,
	[665][12] = 370,
	[666][2] = 360,
	[666][3] = 361,
	[666][4] = 362,
	[666][5] = 363,
	[666][6] = 364,
	[666][7] = 365,
	[666][8] = 366,
	[666][9] = 367,
	[666][10] = 368,
	[666][11] = 369,
	[666][12] = 370,
	[666][14] = 371,
	[667][2] = 360,
	[667][3] = 361,
	[667][4] = 362,
	[667][5] = 363,
	[667][6] = 364,
	[667][7] = 365,
	[667][8] = 366,
	[667][9] = 367,
	[667][10] = 368,
	[667][11] = 369,
	[667][12] = 370,
	[668][2] = 360,
	[668][3] = 361,
	[668][4] = 362,
	[668][5] = 363,
	[668][6] = 364,
	[668][7] = 365,
	[668][8] = 366,
	[668][9] = 367,
	[668][10] = 368,
	[668][11] = 369,
	[668][12] = 370,
	[669][2] = 360,
	[669][3] = 361,
	[669][4] = 362,
	[669][5] = 363,
	[669][6] = 364,
	[669][7] = 365,
	[669][8] = 366,
	[669][9] = 367,
	[669][10] = 368,
	[669][11] = 369,
	[669][12] = 370,
	[670][2] = 360,
	[670][3] = 361,
	[670][4] = 362,
	[670][5] = 363,
	[670][6] = 364,
	[670][7] = 365,
	[670][8] = 366,
	[670][9] = 367,
	[670][10] = 368,
	[670][11] = 369,
	[670][12] = 370,
	[671][2] = 360,
	[671][3] = 361,
	[671][4] = 362,
	[671][5] = 363,
	[671][6] = 364,
	[671][7] = 365,
	[671][8] = 366,
	[671][9] = 367,
	[671][10] = 368,
	[671][11] = 369,
	[671][12] = 370,
	[671][14] = 371,
	[672][2] = 40,
	[672][3] = 41,
	[672][4] = 42,
	[672][5] = 44,
	[672][6] = 45,
	[672][7] = 47,
	[672][8] = 48,
	[672][9] = 49,
	[672][10] = 50,
	[672][11] = 51,
	[672][12] = 52,
	[672][14] = 53,
	[672][37] = 898,
	[672][38] = 899,
	[673][2] = 400,
	[673][3] = 401,
	[673][4] = 402,
	[673][5] = 403,
	[673][6] = 404,
	[673][7] = 405,
	[673][8] = 406,
	[673][9] = 407,
	[673][10] = 408,
	[673][11] = 409,
	[673][12] = 410,
	[673][14] = 411,
	[674][11] = 902,
	[675][2] = 360,
	[675][3] = 361,
	[675][4] = 362,
	[675][5] = 363,
	[675][6] = 364,
	[675][7] = 365,
	[675][8] = 366,
	[675][9] = 367,
	[675][10] = 368,
	[675][11] = 369,
	[675][12] = 370,
	[676][2] = 360,
	[676][3] = 361,
	[676][4] = 362,
	[676][5] = 363,
	[676][6] = 364,
	[676][7] = 365,
	[676][8] = 366,
	[676][9] = 367,
	[676][10] = 368,
	[676][11] = 369,
	[676][12] = 370,
	[677][2] = 360,
	[677][3] = 361,
	[677][4] = 362,
	[677][5] = 363,
	[677][6] = 364,
	[677][7] = 365,
	[677][8] = 366,
	[677][9] = 367,
	[677][10] = 368,
	[677][11] = 369,
	[677][12] = 370,
	[678][2] = 360,
	[678][3] = 361,
	[678][4] = 362,
	[678][5] = 363,
	[678][6] = 364,
	[678][7] = 365,
	[678][8] = 366,
	[678][9] = 367,
	[678][10] = 368,
	[678][11] = 369,
	[678][12] = 370,
	[679][2] = 360,
	[679][3] = 361,
	[679][4] = 362,
	[679][5] = 363,
	[679][6] = 364,
	[679][7] = 365,
	[679][8] = 366,
	[679][9] = 367,
	[679][10] = 368,
	[679][11] = 369,
	[679][12] = 370,
	[680][2] = 360,
	[680][3] = 361,
	[680][4] = 362,
	[680][5] = 363,
	[680][6] = 364,
	[680][7] = 365,
	[680][8] = 366,
	[680][9] = 367,
	[680][10] = 368,
	[680][11] = 369,
	[680][12] = 370,
	[681][2] = 2,
	[681][3] = 3,
	[681][4] = 4,
	[681][5] = 5,
	[681][6] = 6,
	[681][7] = 7,
	[681][8] = 8,
	[681][9] = 9,
	[681][10] = 10,
	[681][11] = 73,
	[681][12] = 12,
	[681][14] = 14,
	[683][37] = 910,
	[683][38] = 911,
	[685][2] = 40,
	[685][3] = 41,
	[685][4] = 42,
	[685][5] = 44,
	[685][6] = 45,
	[685][7] = 47,
	[685][8] = 48,
	[685][9] = 49,
	[685][10] = 50,
	[685][11] = 51,
	[685][12] = 52,
	[685][14] = 53,
	[687][2] = 40,
	[687][3] = 41,
	[687][4] = 42,
	[687][5] = 44,
	[687][6] = 45,
	[687][7] = 47,
	[687][8] = 48,
	[687][9] = 49,
	[687][10] = 50,
	[687][11] = 51,
	[687][12] = 52,
	[687][14] = 53,
	[688][37] = 915,
	[688][38] = 916,
	[691][2] = 76,
	[691][3] = 77,
	[691][4] = 78,
	[691][5] = 79,
	[691][6] = 80,
	[691][7] = 82,
	[691][8] = 83,
	[691][9] = 85,
	[691][10] = 86,
	[691][11] = 87,
	[691][12] = 88,
	[691][14] = 89,
	[693][38] = 919,
	[693][39] = 920,
	[696][4] = 120,
	[696][11] = 317,
	[696][14] = 128,
	[696][49] = 124,
	[696][50] = 125,
	[696][51] = 126,
	[696][52] = 127,
	[697][2] = 400,
	[697][3] = 401,
	[697][4] = 402,
	[697][5] = 403,
	[697][6] = 404,
	[697][7] = 405,
	[697][8] = 406,
	[697][9] = 407,
	[697][10] = 408,
	[697][11] = 409,
	[697][12] = 410,
	[697][14] = 411,
	[698][11] = 925,
	[699][2] = 400,
	[699][3] = 401,
	[699][4] = 402,
	[699][5] = 403,
	[699][6] = 404,
	[699][7] = 405,
	[699][8] = 406,
	[699][9] = 407,
	[699][10] = 408,
	[699][11] = 409,
	[699][12] = 410,
	[700][2] = 400,
	[700][3] = 401,
	[700][4] = 402,
	[700][5] = 403,
	[700][6] = 404,
	[700][7] = 405,
	[700][8] = 406,
	[700][9] = 407,
	[700][10] = 408,
	[700][11] = 409,
	[700][12] = 410,
	[701][2] = 400,
	[701][3] = 401,
	[701][4] = 402,
	[701][5] = 403,
	[701][6] = 404,
	[701][7] = 405,
	[701][8] = 406,
	[701][9] = 407,
	[701][10] = 408,
	[701][11] = 409,
	[701][12] = 410,
	[702][2] = 400,
	[702][3] = 401,
	[702][4] = 402,
	[702][5] = 403,
	[702][6] = 404,
	[702][7] = 405,
	[702][8] = 406,
	[702][9] = 407,
	[702][10] = 408,
	[702][11] = 409,
	[702][12] = 410,
	[703][2] = 400,
	[703][3] = 401,
	[703][4] = 402,
	[703][5] = 403,
	[703][6] = 404,
	[703][7] = 405,
	[703][8] = 406,
	[703][9] = 407,
	[703][10] = 408,
	[703][11] = 409,
	[703][12] = 410,
	[704][2] = 400,
	[704][3] = 401,
	[704][4] = 402,
	[704][5] = 403,
	[704][6] = 404,
	[704][7] = 405,
	[704][8] = 406,
	[704][9] = 407,
	[704][10] = 408,
	[704][11] = 409,
	[704][12] = 410,
	[705][2] = 400,
	[705][3] = 401,
	[705][4] = 402,
	[705][5] = 403,
	[705][6] = 404,
	[705][7] = 405,
	[705][8] = 406,
	[705][9] = 407,
	[705][10] = 408,
	[705][11] = 409,
	[705][12] = 410,
	[707][2] = 400,
	[707][3] = 401,
	[707][4] = 402,
	[707][5] = 403,
	[707][6] = 404,
	[707][7] = 405,
	[707][8] = 406,
	[707][9] = 407,
	[707][10] = 408,
	[707][11] = 409,
	[707][12] = 410,
	[707][14] = 411,
	[708][2] = 400,
	[708][3] = 401,
	[708][4] = 402,
	[708][5] = 403,
	[708][6] = 404,
	[708][7] = 405,
	[708][8] = 406,
	[708][9] = 407,
	[708][10] = 408,
	[708][11] = 409,
	[708][12] = 410,
	[709][11] = 936,
	[710][2] = 400,
	[710][3] = 401,
	[710][4] = 402,
	[710][5] = 403,
	[710][6] = 404,
	[710][7] = 405,
	[710][8] = 406,
	[710][9] = 407,
	[710][10] = 408,
	[710][11] = 409,
	[710][12] = 410,
	[711][2] = 360,
	[711][3] = 361,
	[711][4] = 362,
	[711][5] = 363,
	[711][6] = 364,
	[711][7] = 365,
	[711][8] = 366,
	[711][9] = 367,
	[711][10] = 368,
	[711][11] = 369,
	[711][12] = 370,
	[711][14] = 371,
	[712][2] = 400,
	[712][3] = 401,
	[712][4] = 402,
	[712][5] = 403,
	[712][6] = 404,
	[712][7] = 405,
	[712][8] = 406,
	[712][9] = 407,
	[712][10] = 408,
	[712][11] = 409,
	[712][12] = 410,
	[713][2] = 400,
	[713][3] = 401,
	[713][4] = 402,
	[713][5] = 403,
	[713][6] = 404,
	[713][7] = 405,
	[713][8] = 406,
	[713][9] = 407,
	[713][10] = 408,
	[713][11] = 409,
	[713][12] = 410,
	[714][2] = 400,
	[714][3] = 401,
	[714][4] = 402,
	[714][5] = 403,
	[714][6] = 404,
	[714][7] = 405,
	[714][8] = 406,
	[714][9] = 407,
	[714][10] = 408,
	[714][11] = 409,
	[714][12] = 410,
	[715][2] = 400,
	[715][3] = 401,
	[715][4] = 402,
	[715][5] = 403,
	[715][6] = 404,
	[715][7] = 405,
	[715][8] = 406,
	[715][9] = 407,
	[715][10] = 408,
	[715][11] = 409,
	[715][12] = 410,
	[716][2] = 400,
	[716][3] = 401,
	[716][4] = 402,
	[716][5] = 403,
	[716][6] = 404,
	[716][7] = 405,
	[716][8] = 406,
	[716][9] = 407,
	[716][10] = 408,
	[716][11] = 409,
	[716][12] = 410,
	[716][14] = 411,
	[717][2] = 40,
	[717][3] = 41,
	[717][4] = 42,
	[717][5] = 44,
	[717][6] = 45,
	[717][7] = 47,
	[717][8] = 48,
	[717][9] = 49,
	[717][10] = 50,
	[717][11] = 51,
	[717][12] = 52,
	[717][14] = 53,
	[717][37] = 945,
	[717][38] = 946,
	[718][2] = 400,
	[718][3] = 401,
	[718][4] = 402,
	[718][5] = 403,
	[718][6] = 404,
	[718][7] = 405,
	[718][8] = 406,
	[718][9] = 407,
	[718][10] = 408,
	[718][11] = 409,
	[718][12] = 410,
	[718][14] = 411,
	[719][11] = 949,
	[720][2] = 400,
	[720][3] = 401,
	[720][4] = 402,
	[720][5] = 403,
	[720][6] = 404,
	[720][7] = 405,
	[720][8] = 406,
	[720][9] = 407,
	[720][10] = 408,
	[720][11] = 409,
	[720][12] = 410,
	[721][2] = 400,
	[721][3] = 401,
	[721][4] = 402,
	[721][5] = 403,
	[721][6] = 404,
	[721][7] = 405,
	[721][8] = 406,
	[721][9] = 407,
	[721][10] = 408,
	[721][11] = 409,
	[721][12] = 410,
	[722][2] = 400,
	[722][3] = 401,
	[722][4] = 402,
	[722][5] = 403,
	[722][6] = 404,
	[722][7] = 405,
	[722][8] = 406,
	[722][9] = 407,
	[722][10] = 408,
	[722][11] = 409,
	[722][12] = 410,
	[723][2] = 400,
	[723][3] = 401,
	[723][4] = 402,
	[723][5] = 403,
	[723][6] = 404,
	[723][7] = 405,
	[723][8] = 406,
	[723][9] = 407,
	[723][10] = 408,
	[723][11] = 409,
	[723][12] = 410,
	[724][2] = 400,
	[724][3] = 401,
	[724][4] = 402,
	[724][5] = 403,
	[724][6] = 404,
	[724][7] = 405,
	[724][8] = 406,
	[724][9] = 407,
	[724][10] = 408,
	[724][11] = 409,
	[724][12] = 410,
	[725][2] = 400,
	[725][3] = 401,
	[725][4] = 402,
	[725][5] = 403,
	[725][6] = 404,
	[725][7] = 405,
	[725][8] = 406,
	[725][9] = 407,
	[725][10] = 408,
	[725][11] = 409,
	[725][12] = 410,
	[727][2] = 40,
	[727][3] = 41,
	[727][4] = 42,
	[727][5] = 44,
	[727][6] = 45,
	[727][7] = 47,
	[727][8] = 48,
	[727][9] = 49,
	[727][10] = 50,
	[727][11] = 51,
	[727][12] = 52,
	[727][14] = 53,
	[730][2] = 76,
	[730][3] = 77,
	[730][4] = 78,
	[730][5] = 79,
	[730][6] = 80,
	[730][7] = 82,
	[730][8] = 83,
	[730][9] = 85,
	[730][10] = 86,
	[730][11] = 87,
	[730][12] = 88,
	[730][14] = 89,
	[733][4] = 120,
	[733][11] = 317,
	[733][14] = 128,
	[733][49] = 124,
	[733][50] = 125,
	[733][51] = 126,
	[733][52] = 127,
	[734][2] = 40,
	[734][3] = 41,
	[734][4] = 42,
	[734][5] = 44,
	[734][6] = 45,
	[734][7] = 47,
	[734][8] = 48,
	[734][9] = 49,
	[734][10] = 50,
	[734][11] = 51,
	[734][12] = 52,
	[734][14] = 53,
	[735][4] = 120,
	[735][11] = 317,
	[735][14] = 128,
	[735][49] = 124,
	[735][50] = 125,
	[735][51] = 126,
	[735][52] = 127,
	[736][2] = 40,
	[736][3] = 41,
	[736][4] = 42,
	[736][5] = 44,
	[736][6] = 45,
	[736][7] = 47,
	[736][8] = 48,
	[736][9] = 49,
	[736][10] = 50,
	[736][11] = 51,
	[736][12] = 52,
	[736][14] = 53,
	[737][2] = 40,
	[737][3] = 41,
	[737][4] = 42,
	[737][5] = 44,
	[737][6] = 45,
	[737][7] = 47,
	[737][8] = 48,
	[737][9] = 49,
	[737][10] = 50,
	[737][11] = 51,
	[737][12] = 52,
	[737][14] = 53,
	[738][2] = 40,
	[738][3] = 41,
	[738][4] = 42,
	[738][5] = 44,
	[738][6] = 45,
	[738][7] = 47,
	[738][8] = 48,
	[738][9] = 49,
	[738][10] = 50,
	[738][11] = 51,
	[738][12] = 52,
	[739][2] = 40,
	[739][3] = 41,
	[739][4] = 42,
	[739][5] = 44,
	[739][6] = 45,
	[739][7] = 47,
	[739][8] = 48,
	[739][9] = 49,
	[739][10] = 50,
	[739][11] = 51,
	[739][12] = 52,
	[739][14] = 53,
	[741][37] = 965,
	[741][38] = 966,
	[743][2] = 40,
	[743][3] = 41,
	[743][4] = 42,
	[743][5] = 44,
	[743][6] = 45,
	[743][7] = 47,
	[743][8] = 48,
	[743][9] = 49,
	[743][10] = 50,
	[743][11] = 51,
	[743][12] = 52,
	[743][14] = 53,
	[746][2] = 40,
	[746][3] = 41,
	[746][4] = 42,
	[746][5] = 44,
	[746][6] = 45,
	[746][7] = 47,
	[746][8] = 48,
	[746][9] = 49,
	[746][10] = 50,
	[746][11] = 51,
	[746][12] = 52,
	[746][14] = 53,
	[749][2] = 76,
	[749][3] = 77,
	[749][4] = 78,
	[749][5] = 79,
	[749][6] = 80,
	[749][7] = 82,
	[749][8] = 83,
	[749][9] = 85,
	[749][10] = 86,
	[749][11] = 87,
	[749][12] = 88,
	[749][14] = 89,
	[752][4] = 120,
	[752][11] = 317,
	[752][14] = 128,
	[752][49] = 124,
	[752][50] = 125,
	[752][51] = 126,
	[752][52] = 127,
	[753][2] = 76,
	[753][3] = 77,
	[753][4] = 78,
	[753][5] = 79,
	[753][6] = 80,
	[753][7] = 82,
	[753][8] = 83,
	[753][9] = 85,
	[753][10] = 86,
	[753][11] = 87,
	[753][12] = 88,
	[753][14] = 89,
	[754][4] = 120,
	[754][11] = 317,
	[754][14] = 128,
	[754][49] = 124,
	[754][50] = 125,
	[754][51] = 126,
	[754][52] = 127,
	[755][2] = 76,
	[755][3] = 77,
	[755][4] = 78,
	[755][5] = 79,
	[755][6] = 80,
	[755][7] = 82,
	[755][8] = 83,
	[755][9] = 85,
	[755][10] = 86,
	[755][11] = 87,
	[755][12] = 88,
	[755][14] = 89,
	[756][2] = 76,
	[756][3] = 77,
	[756][4] = 78,
	[756][5] = 79,
	[756][6] = 80,
	[756][7] = 82,
	[756][8] = 83,
	[756][9] = 85,
	[756][10] = 86,
	[756][11] = 87,
	[756][12] = 88,
	[756][14] = 89,
	[757][2] = 76,
	[757][3] = 77,
	[757][4] = 78,
	[757][5] = 79,
	[757][6] = 80,
	[757][7] = 82,
	[757][8] = 83,
	[757][9] = 85,
	[757][10] = 86,
	[757][11] = 87,
	[757][12] = 88,
	[758][2] = 76,
	[758][3] = 77,
	[758][4] = 78,
	[758][5] = 79,
	[758][6] = 80,
	[758][7] = 82,
	[758][8] = 83,
	[758][9] = 85,
	[758][10] = 86,
	[758][11] = 87,
	[758][12] = 88,
	[758][14] = 89,
	[760][37] = 977,
	[760][38] = 978,
	[762][2] = 40,
	[762][3] = 41,
	[762][4] = 42,
	[762][5] = 44,
	[762][6] = 45,
	[762][7] = 47,
	[762][8] = 48,
	[762][9] = 49,
	[762][10] = 50,
	[762][11] = 51,
	[762][12] = 52,
	[762][14] = 53,
	[764][55] = 764,
	[766][55] = 766,
	[768][55] = 982,
	[769][55] = 984,
	[770][37] = 986,
	[771][55] = 987,
	[772][39] = 989,
	[773][55] = 990,
	[774][22] = 992,
	[775][55] = 993,
	[779][2] = 556,
	[779][3] = 557,
	[779][4] = 558,
	[779][7] = 559,
	[779][8] = 560,
	[779][11] = 561,
	[779][22] = 562,
	[780][2] = 556,
	[780][3] = 557,
	[780][4] = 558,
	[780][7] = 559,
	[780][8] = 560,
	[780][11] = 561,
	[780][22] = 562,
	[781][55] = 781,
	[785][2] = 783,
	[785][3] = 784,
	[785][4] = 785,
	[785][5] = 786,
	[786][2] = 783,
	[786][3] = 784,
	[786][4] = 785,
	[787][37] = 1001,
	[789][16] = 1002,
	[790][6] = 1003,
	[791][15] = 1004,
	[792][2] = 783,
	[792][3] = 784,
	[792][4] = 785,
	[792][5] = 786,
	[792][17] = 1006,
	[792][38] = 1005,
	[794][55] = 1008,
	[795][2] = 568,
	[795][3] = 569,
	[795][4] = 570,
	[795][5] = 571,
	[796][2] = 1011,
	[796][3] = 1012,
	[796][4] = 1013,
	[796][5] = 1014,
	[797][2] = 568,
	[797][3] = 569,
	[797][4] = 570,
	[797][5] = 571,
	[798][2] = 568,
	[798][3] = 569,
	[798][4] = 570,
	[798][5] = 571,
	[799][2] = 568,
	[799][3] = 569,
	[799][4] = 570,
	[799][5] = 571,
	[800][2] = 568,
	[800][3] = 569,
	[800][4] = 570,
	[800][5] = 571,
	[800][17] = 1024,
	[800][38] = 1023,
	[801][55] = 801,
	[805][2] = 803,
	[805][3] = 804,
	[805][4] = 805,
	[805][7] = 806,
	[805][8] = 807,
	[807][2] = 568,
	[807][3] = 569,
	[807][4] = 570,
	[807][5] = 571,
	[808][37] = 1030,
	[809][9] = 1031,
	[809][18] = 1032,
	[809][19] = 1033,
	[810][17] = 1034,
	[811][2] = 803,
	[811][3] = 804,
	[811][4] = 805,
	[811][7] = 806,
	[811][8] = 807,
	[812][39] = 1036,
	[813][55] = 1037,
	[817][2] = 579,
	[817][3] = 580,
	[817][4] = 581,
	[817][7] = 582,
	[817][8] = 583,
	[818][2] = 579,
	[818][3] = 580,
	[818][4] = 581,
	[818][7] = 582,
	[818][8] = 583,
	[820][17] = 1042,
	[822][2] = 287,
	[822][3] = 288,
	[822][4] = 289,
	[822][7] = 290,
	[822][8] = 291,
	[822][11] = 292,
	[822][22] = 293,
	[823][37] = 1044,
	[824][39] = 1045,
	[829][2] = 596,
	[829][3] = 597,
	[829][4] = 598,
	[829][7] = 599,
	[829][8] = 600,
	[830][2] = 596,
	[830][3] = 597,
	[830][4] = 598,
	[830][7] = 599,
	[830][8] = 600,
	[834][37] = 1050,
	[834][38] = 1051,
	[836][4] = 306,
	[836][11] = 309,
	[836][14] = 314,
	[836][49] = 310,
	[836][50] = 311,
	[836][51] = 312,
	[836][52] = 313,
	[838][4] = 306,
	[838][11] = 309,
	[838][14] = 314,
	[838][49] = 310,
	[838][50] = 311,
	[838][51] = 312,
	[838][52] = 313,
	[840][38] = 1054,
	[840][40] = 1055,
	[843][4] = 323,
	[843][11] = 325,
	[843][14] = 331,
	[843][49] = 327,
	[843][50] = 328,
	[843][51] = 329,
	[843][52] = 330,
	[844][4] = 306,
	[844][11] = 309,
	[844][14] = 314,
	[844][49] = 310,
	[844][50] = 311,
	[844][51] = 312,
	[844][52] = 313,
	[849][37] = 1058,
	[849][38] = 1059,
	[851][4] = 306,
	[851][11] = 309,
	[851][14] = 314,
	[851][49] = 310,
	[851][50] = 311,
	[851][51] = 312,
	[851][52] = 313,
	[852][4] = 323,
	[852][11] = 325,
	[852][14] = 331,
	[852][49] = 327,
	[852][50] = 328,
	[852][51] = 329,
	[852][52] = 330,
	[853][4] = 120,
	[853][11] = 122,
	[853][14] = 128,
	[853][49] = 124,
	[853][50] = 125,
	[853][51] = 126,
	[853][52] = 127,
	[855][38] = 1063,
	[855][40] = 1064,
	[858][4] = 323,
	[858][11] = 325,
	[858][14] = 331,
	[858][49] = 327,
	[858][50] = 328,
	[858][51] = 329,
	[858][52] = 330,
	[859][4] = 323,
	[859][11] = 325,
	[859][14] = 331,
	[859][49] = 327,
	[859][50] = 328,
	[859][51] = 329,
	[859][52] = 330,
	[866][37] = 1067,
	[866][38] = 1068,
	[868][2] = 40,
	[868][3] = 41,
	[868][4] = 42,
	[868][5] = 44,
	[868][6] = 45,
	[868][7] = 47,
	[868][8] = 48,
	[868][9] = 49,
	[868][10] = 50,
	[868][11] = 51,
	[868][12] = 52,
	[868][14] = 53,
	[870][38] = 1070,
	[870][39] = 1071,
	[871][2] = 76,
	[871][3] = 77,
	[871][4] = 78,
	[871][5] = 79,
	[871][6] = 80,
	[871][7] = 82,
	[871][8] = 83,
	[871][9] = 85,
	[871][10] = 86,
	[871][11] = 87,
	[871][12] = 88,
	[871][14] = 89,
	[874][38] = 1073,
	[874][40] = 1074,
	[877][38] = 1075,
	[877][40] = 1076,
	[878][13] = 670,
	[878][19] = 668,
	[878][22] = 669,
	[879][13] = 670,
	[879][19] = 668,
	[879][22] = 669,
	[880][29] = 657,
	[880][30] = 658,
	[881][25] = 675,
	[881][26] = 676,
	[881][27] = 677,
	[881][28] = 678,
	[882][25] = 675,
	[882][26] = 676,
	[882][27] = 677,
	[882][28] = 678,
	[883][15] = 656,
	[887][35] = 1077,
	[888][16] = 659,
	[890][17] = 663,
	[891][40] = 1078,
	[892][31] = 665,
	[893][21] = 660,
	[894][21] = 660,
	[895][21] = 660,
	[897][34] = 1079,
	[899][2] = 40,
	[899][3] = 41,
	[899][4] = 42,
	[899][5] = 44,
	[899][6] = 45,
	[899][7] = 47,
	[899][8] = 48,
	[899][9] = 49,
	[899][10] = 50,
	[899][11] = 51,
	[899][12] = 52,
	[899][14] = 53,
	[900][37] = 1082,
	[900][38] = 1083,
	[901][39] = 1084,
	[903][23] = 679,
	[903][24] = 680,
	[904][23] = 679,
	[904][24] = 680,
	[905][23] = 679,
	[905][24] = 680,
	[906][23] = 679,
	[906][24] = 680,
	[907][6] = 654,
	[907][9] = 655,
	[908][6] = 654,
	[908][9] = 655,
	[911][2] = 40,
	[911][3] = 41,
	[911][4] = 42,
	[911][5] = 44,
	[911][6] = 45,
	[911][7] = 47,
	[911][8] = 48,
	[911][9] = 49,
	[911][10] = 50,
	[911][11] = 51,
	[911][12] = 52,
	[911][14] = 53,
	[914][37] = 1086,
	[914][38] = 1087,
	[916][2] = 40,
	[916][3] = 41,
	[916][4] = 42,
	[916][5] = 44,
	[916][6] = 45,
	[916][7] = 47,
	[916][8] = 48,
	[916][9] = 49,
	[916][10] = 50,
	[916][11] = 51,
	[916][12] = 52,
	[916][14] = 53,
	[918][38] = 1089,
	[918][39] = 1090,
	[919][2] = 76,
	[919][3] = 77,
	[919][4] = 78,
	[919][5] = 79,
	[919][6] = 80,
	[919][7] = 82,
	[919][8] = 83,
	[919][9] = 85,
	[919][10] = 86,
	[919][11] = 87,
	[919][12] = 88,
	[919][14] = 89,
	[922][38] = 1092,
	[922][40] = 1093,
	[925][38] = 1094,
	[925][40] = 1095,
	[926][13] = 715,
	[926][19] = 713,
	[926][22] = 714,
	[927][13] = 715,
	[927][19] = 713,
	[927][22] = 714,
	[928][29] = 702,
	[928][30] = 703,
	[929][25] = 720,
	[929][26] = 721,
	[929][27] = 722,
	[929][28] = 723,
	[930][25] = 720,
	[930][26] = 721,
	[930][27] = 722,
	[930][28] = 723,
	[931][15] = 701,
	[934][35] = 1096,
	[935][16] = 704,
	[937][17] = 708,
	[938][40] = 1097,
	[939][31] = 710,
	[940][21] = 705,
	[941][21] = 705,
	[942][21] = 705,
	[944][34] = 1098,
	[946][2] = 40,
	[946][3] = 41,
	[946][4] = 42,
	[946][5] = 44,
	[946][6] = 45,
	[946][7] = 47,
	[946][8] = 48,
	[946][9] = 49,
	[946][10] = 50,
	[946][11] = 51,
	[946][12] = 52,
	[946][14] = 53,
	[947][37] = 1101,
	[947][38] = 1102,
	[948][39] = 1103,
	[950][23] = 724,
	[950][24] = 725,
	[951][23] = 724,
	[951][24] = 725,
	[952][23] = 724,
	[952][24] = 725,
	[953][23] = 724,
	[953][24] = 725,
	[954][6] = 699,
	[954][9] = 700,
	[955][6] = 699,
	[955][9] = 700,
	[966][2] = 40,
	[966][3] = 41,
	[966][4] = 42,
	[966][5] = 44,
	[966][6] = 45,
	[966][7] = 47,
	[966][8] = 48,
	[966][9] = 49,
	[966][10] = 50,
	[966][11] = 51,
	[966][12] = 52,
	[966][14] = 53,
	[978][2] = 40,
	[978][3] = 41,
	[978][4] = 42,
	[978][5] = 44,
	[978][6] = 45,
	[978][7] = 47,
	[978][8] = 48,
	[978][9] = 49,
	[978][10] = 50,
	[978][11] = 51,
	[978][12] = 52,
	[978][14] = 53,
	[982][55] = 982,
	[984][55] = 984,
	[986][55] = 1108,
	[987][55] = 987,
	[989][55] = 1110,
	[990][55] = 990,
	[992][55] = 1112,
	[993][55] = 764,
	[995][17] = 1114,
	[997][2] = 556,
	[997][3] = 557,
	[997][4] = 558,
	[997][7] = 559,
	[997][8] = 560,
	[997][11] = 561,
	[997][22] = 562,
	[999][37] = 1116,
	[1002][2] = 783,
	[1002][3] = 784,
	[1002][4] = 785,
	[1002][5] = 786,
	[1003][2] = 1119,
	[1003][3] = 1120,
	[1003][4] = 1121,
	[1003][5] = 1122,
	[1004][2] = 783,
	[1004][3] = 784,
	[1004][4] = 785,
	[1004][5] = 786,
	[1005][2] = 783,
	[1005][3] = 784,
	[1005][4] = 785,
	[1005][5] = 786,
	[1006][2] = 783,
	[1006][3] = 784,
	[1006][4] = 785,
	[1006][5] = 786,
	[1007][2] = 783,
	[1007][3] = 784,
	[1007][4] = 785,
	[1007][5] = 786,
	[1007][17] = 1132,
	[1007][38] = 1131,
	[1008][55] = 1135,
	[1010][16] = 1137,
	[1013][2] = 783,
	[1013][3] = 784,
	[1013][4] = 785,
	[1013][5] = 786,
	[1014][2] = 1011,
	[1014][3] = 1012,
	[1014][4] = 1013,
	[1018][15] = 1140,
	[1020][2] = 568,
	[1020][3] = 569,
	[1020][4] = 570,
	[1020][5] = 571,
	[1020][17] = 1024,
	[1020][38] = 1023,
	[1022][2] = 568,
	[1022][3] = 569,
	[1022][4] = 570,
	[1022][5] = 571,
	[1022][17] = 1024,
	[1022][38] = 1023,
	[1023][2] = 568,
	[1023][3] = 569,
	[1023][4] = 570,
	[1023][5] = 571,
	[1024][2] = 568,
	[1024][3] = 569,
	[1024][4] = 570,
	[1024][5] = 571,
	[1026][2] = 568,
	[1026][3] = 569,
	[1026][4] = 570,
	[1026][5] = 571,
	[1026][17] = 1024,
	[1026][38] = 1023,
	[1028][37] = 1146,
	[1029][39] = 1147,
	[1034][2] = 803,
	[1034][3] = 804,
	[1034][4] = 805,
	[1034][7] = 806,
	[1034][8] = 807,
	[1035][2] = 803,
	[1035][3] = 804,
	[1035][4] = 805,
	[1035][7] = 806,
	[1035][8] = 807,
	[1037][55] = 1152,
	[1039][17] = 1154,
	[1041][2] = 579,
	[1041][3] = 580,
	[1041][4] = 581,
	[1041][7] = 582,
	[1041][8] = 583,
	[1042][2] = 287,
	[1042][3] = 288,
	[1042][4] = 289,
	[1042][7] = 290,
	[1042][8] = 291,
	[1042][11] = 292,
	[1042][22] = 293,
	[1047][17] = 1157,
	[1049][2] = 596,
	[1049][3] = 597,
	[1049][4] = 598,
	[1049][7] = 599,
	[1049][8] = 600,
	[1051][4] = 306,
	[1051][11] = 309,
	[1051][14] = 314,
	[1051][49] = 310,
	[1051][50] = 311,
	[1051][51] = 312,
	[1051][52] = 313,
	[1054][4] = 323,
	[1054][11] = 325,
	[1054][14] = 331,
	[1054][49] = 327,
	[1054][50] = 328,
	[1054][51] = 329,
	[1054][52] = 330,
	[1055][4] = 306,
	[1055][11] = 309,
	[1055][14] = 314,
	[1055][49] = 310,
	[1055][50] = 311,
	[1055][51] = 312,
	[1055][52] = 313,
	[1059][4] = 306,
	[1059][11] = 309,
	[1059][14] = 314,
	[1059][49] = 310,
	[1059][50] = 311,
	[1059][51] = 312,
	[1059][52] = 313,
	[1063][4] = 323,
	[1063][11] = 325,
	[1063][14] = 331,
	[1063][49] = 327,
	[1063][50] = 328,
	[1063][51] = 329,
	[1063][52] = 330,
	[1064][4] = 323,
	[1064][11] = 325,
	[1064][14] = 331,
	[1064][49] = 327,
	[1064][50] = 328,
	[1064][51] = 329,
	[1064][52] = 330,
	[1068][2] = 40,
	[1068][3] = 41,
	[1068][4] = 42,
	[1068][5] = 44,
	[1068][6] = 45,
	[1068][7] = 47,
	[1068][8] = 48,
	[1068][9] = 49,
	[1068][10] = 50,
	[1068][11] = 51,
	[1068][12] = 52,
	[1068][14] = 53,
	[1070][2] = 76,
	[1070][3] = 77,
	[1070][4] = 78,
	[1070][5] = 79,
	[1070][6] = 80,
	[1070][7] = 82,
	[1070][8] = 83,
	[1070][9] = 85,
	[1070][10] = 86,
	[1070][11] = 87,
	[1070][12] = 88,
	[1070][14] = 89,
	[1073][4] = 120,
	[1073][11] = 317,
	[1073][14] = 128,
	[1073][49] = 124,
	[1073][50] = 125,
	[1073][51] = 126,
	[1073][52] = 127,
	[1074][2] = 360,
	[1074][3] = 361,
	[1074][4] = 362,
	[1074][5] = 363,
	[1074][6] = 364,
	[1074][7] = 365,
	[1074][8] = 366,
	[1074][9] = 367,
	[1074][10] = 368,
	[1074][11] = 369,
	[1074][12] = 370,
	[1074][14] = 371,
	[1075][4] = 120,
	[1075][11] = 317,
	[1075][14] = 128,
	[1075][49] = 124,
	[1075][50] = 125,
	[1075][51] = 126,
	[1075][52] = 127,
	[1076][2] = 360,
	[1076][3] = 361,
	[1076][4] = 362,
	[1076][5] = 363,
	[1076][6] = 364,
	[1076][7] = 365,
	[1076][8] = 366,
	[1076][9] = 367,
	[1076][10] = 368,
	[1076][11] = 369,
	[1076][12] = 370,
	[1076][14] = 371,
	[1077][2] = 360,
	[1077][3] = 361,
	[1077][4] = 362,
	[1077][5] = 363,
	[1077][6] = 364,
	[1077][7] = 365,
	[1077][8] = 366,
	[1077][9] = 367,
	[1077][10] = 368,
	[1077][11] = 369,
	[1077][12] = 370,
	[1077][14] = 371,
	[1078][2] = 360,
	[1078][3] = 361,
	[1078][4] = 362,
	[1078][5] = 363,
	[1078][6] = 364,
	[1078][7] = 365,
	[1078][8] = 366,
	[1078][9] = 367,
	[1078][10] = 368,
	[1078][11] = 369,
	[1078][12] = 370,
	[1079][2] = 360,
	[1079][3] = 361,
	[1079][4] = 362,
	[1079][5] = 363,
	[1079][6] = 364,
	[1079][7] = 365,
	[1079][8] = 366,
	[1079][9] = 367,
	[1079][10] = 368,
	[1079][11] = 369,
	[1079][12] = 370,
	[1079][14] = 371,
	[1081][37] = 1174,
	[1081][38] = 1175,
	[1083][2] = 40,
	[1083][3] = 41,
	[1083][4] = 42,
	[1083][5] = 44,
	[1083][6] = 45,
	[1083][7] = 47,
	[1083][8] = 48,
	[1083][9] = 49,
	[1083][10] = 50,
	[1083][11] = 51,
	[1083][12] = 52,
	[1083][14] = 53,
	[1087][2] = 40,
	[1087][3] = 41,
	[1087][4] = 42,
	[1087][5] = 44,
	[1087][6] = 45,
	[1087][7] = 47,
	[1087][8] = 48,
	[1087][9] = 49,
	[1087][10] = 50,
	[1087][11] = 51,
	[1087][12] = 52,
	[1087][14] = 53,
	[1089][2] = 76,
	[1089][3] = 77,
	[1089][4] = 78,
	[1089][5] = 79,
	[1089][6] = 80,
	[1089][7] = 82,
	[1089][8] = 83,
	[1089][9] = 85,
	[1089][10] = 86,
	[1089][11] = 87,
	[1089][12] = 88,
	[1089][14] = 89,
	[1092][4] = 120,
	[1092][11] = 317,
	[1092][14] = 128,
	[1092][49] = 124,
	[1092][50] = 125,
	[1092][51] = 126,
	[1092][52] = 127,
	[1093][2] = 400,
	[1093][3] = 401,
	[1093][4] = 402,
	[1093][5] = 403,
	[1093][6] = 404,
	[1093][7] = 405,
	[1093][8] = 406,
	[1093][9] = 407,
	[1093][10] = 408,
	[1093][11] = 409,
	[1093][12] = 410,
	[1093][14] = 411,
	[1094][4] = 120,
	[1094][11] = 317,
	[1094][14] = 128,
	[1094][49] = 124,
	[1094][50] = 125,
	[1094][51] = 126,
	[1094][52] = 127,
	[1095][2] = 400,
	[1095][3] = 401,
	[1095][4] = 402,
	[1095][5] = 403,
	[1095][6] = 404,
	[1095][7] = 405,
	[1095][8] = 406,
	[1095][9] = 407,
	[1095][10] = 408,
	[1095][11] = 409,
	[1095][12] = 410,
	[1095][14] = 411,
	[1096][2] = 400,
	[1096][3] = 401,
	[1096][4] = 402,
	[1096][5] = 403,
	[1096][6] = 404,
	[1096][7] = 405,
	[1096][8] = 406,
	[1096][9] = 407,
	[1096][10] = 408,
	[1096][11] = 409,
	[1096][12] = 410,
	[1096][14] = 411,
	[1097][2] = 400,
	[1097][3] = 401,
	[1097][4] = 402,
	[1097][5] = 403,
	[1097][6] = 404,
	[1097][7] = 405,
	[1097][8] = 406,
	[1097][9] = 407,
	[1097][10] = 408,
	[1097][11] = 409,
	[1097][12] = 410,
	[1098][2] = 400,
	[1098][3] = 401,
	[1098][4] = 402,
	[1098][5] = 403,
	[1098][6] = 404,
	[1098][7] = 405,
	[1098][8] = 406,
	[1098][9] = 407,
	[1098][10] = 408,
	[1098][11] = 409,
	[1098][12] = 410,
	[1098][14] = 411,
	[1100][37] = 1186,
	[1100][38] = 1187,
	[1102][2] = 40,
	[1102][3] = 41,
	[1102][4] = 42,
	[1102][5] = 44,
	[1102][6] = 45,
	[1102][7] = 47,
	[1102][8] = 48,
	[1102][9] = 49,
	[1102][10] = 50,
	[1102][11] = 51,
	[1102][12] = 52,
	[1102][14] = 53,
	[1108][55] = 982,
	[1110][55] = 1190,
	[1112][55] = 1192,
	[1114][2] = 556,
	[1114][3] = 557,
	[1114][4] = 558,
	[1114][7] = 559,
	[1114][8] = 560,
	[1114][11] = 561,
	[1114][22] = 562,
	[1118][16] = 1195,
	[1121][2] = 783,
	[1121][3] = 784,
	[1121][4] = 785,
	[1121][5] = 786,
	[1122][2] = 1119,
	[1122][3] = 1120,
	[1122][4] = 1121,
	[1126][15] = 1198,
	[1128][2] = 783,
	[1128][3] = 784,
	[1128][4] = 785,
	[1128][5] = 786,
	[1128][17] = 1132,
	[1128][38] = 1131,
	[1130][2] = 783,
	[1130][3] = 784,
	[1130][4] = 785,
	[1130][5] = 786,
	[1130][17] = 1132,
	[1130][38] = 1131,
	[1131][2] = 783,
	[1131][3] = 784,
	[1131][4] = 785,
	[1131][5] = 786,
	[1132][2] = 783,
	[1132][3] = 784,
	[1132][4] = 785,
	[1132][5] = 786,
	[1134][2] = 783,
	[1134][3] = 784,
	[1134][4] = 785,
	[1134][5] = 786,
	[1134][17] = 1132,
	[1134][38] = 1131,
	[1135][55] = 1135,
	[1137][2] = 568,
	[1137][3] = 569,
	[1137][4] = 570,
	[1137][5] = 571,
	[1138][37] = 1206,
	[1140][2] = 568,
	[1140][3] = 569,
	[1140][4] = 570,
	[1140][5] = 571,
	[1149][17] = 1208,
	[1151][2] = 803,
	[1151][3] = 804,
	[1151][4] = 805,
	[1151][7] = 806,
	[1151][8] = 807,
	[1152][55] = 1152,
	[1154][2] = 579,
	[1154][3] = 580,
	[1154][4] = 581,
	[1154][7] = 582,
	[1154][8] = 583,
	[1157][2] = 596,
	[1157][3] = 597,
	[1157][4] = 598,
	[1157][7] = 599,
	[1157][8] = 600,
	[1175][2] = 40,
	[1175][3] = 41,
	[1175][4] = 42,
	[1175][5] = 44,
	[1175][6] = 45,
	[1175][7] = 47,
	[1175][8] = 48,
	[1175][9] = 49,
	[1175][10] = 50,
	[1175][11] = 51,
	[1175][12] = 52,
	[1175][14] = 53,
	[1187][2] = 40,
	[1187][3] = 41,
	[1187][4] = 42,
	[1187][5] = 44,
	[1187][6] = 45,
	[1187][7] = 47,
	[1187][8] = 48,
	[1187][9] = 49,
	[1187][10] = 50,
	[1187][11] = 51,
	[1187][12] = 52,
	[1187][14] = 53,
	[1190][55] = 1190,
	[1192][55] = 1192,
	[1195][2] = 783,
	[1195][3] = 784,
	[1195][4] = 785,
	[1195][5] = 786,
	[1196][37] = 1218,
	[1198][2] = 783,
	[1198][3] = 784,
	[1198][4] = 785,
	[1198][5] = 786,
	[1208][2] = 803,
	[1208][3] = 804,
	[1208][4] = 805,
	[1208][7] = 806,
	[1208][8] = 807,
};


const unsigned zebu_reduces[1221][55] = {
	[2][4] = 1,
	[2][6] = 1,
	[2][8] = 1,
	[2][9] = 1,
	[2][13] = 1,
	[2][15] = 1,
	[2][16] = 1,
	[2][17] = 1,
	[2][18] = 1,
	[2][19] = 1,
	[2][20] = 1,
	[2][21] = 1,
	[2][22] = 1,
	[2][23] = 1,
	[2][24] = 1,
	[2][25] = 1,
	[2][26] = 1,
	[2][27] = 1,
	[2][28] = 1,
	[2][29] = 1,
	[2][30] = 1,
	[2][31] = 1,
	[2][32] = 1,
	[2][33] = 1,
	[2][34] = 1,
	[2][35] = 1,
	[2][36] = 1,
	[3][4] = 2,
	[3][6] = 2,
	[3][8] = 2,
	[3][9] = 2,
	[3][13] = 2,
	[3][15] = 2,
	[3][16] = 2,
	[3][17] = 2,
	[3][18] = 2,
	[3][19] = 2,
	[3][20] = 2,
	[3][21] = 2,
	[3][22] = 2,
	[3][23] = 2,
	[3][24] = 2,
	[3][25] = 2,
	[3][26] = 2,
	[3][27] = 2,
	[3][28] = 2,
	[3][29] = 2,
	[3][30] = 2,
	[3][31] = 2,
	[3][32] = 2,
	[3][33] = 2,
	[3][34] = 2,
	[3][35] = 2,
	[3][36] = 2,
	[7][4] = 3,
	[7][6] = 3,
	[7][8] = 3,
	[7][9] = 3,
	[7][13] = 3,
	[7][15] = 3,
	[7][16] = 3,
	[7][17] = 3,
	[7][18] = 3,
	[7][19] = 3,
	[7][20] = 3,
	[7][21] = 3,
	[7][22] = 3,
	[7][23] = 3,
	[7][24] = 3,
	[7][25] = 3,
	[7][26] = 3,
	[7][27] = 3,
	[7][28] = 3,
	[7][29] = 3,
	[7][30] = 3,
	[7][31] = 3,
	[7][32] = 3,
	[7][33] = 3,
	[7][34] = 3,
	[7][35] = 3,
	[7][36] = 3,
	[10][4] = 4,
	[10][6] = 4,
	[10][8] = 4,
	[10][9] = 4,
	[10][13] = 4,
	[10][15] = 4,
	[10][16] = 4,
	[10][17] = 4,
	[10][18] = 4,
	[10][19] = 4,
	[10][20] = 4,
	[10][21] = 4,
	[10][22] = 4,
	[10][23] = 4,
	[10][24] = 4,
	[10][25] = 4,
	[10][26] = 4,
	[10][27] = 4,
	[10][28] = 4,
	[10][29] = 4,
	[10][30] = 4,
	[10][31] = 4,
	[10][32] = 4,
	[10][33] = 4,
	[10][34] = 4,
	[10][35] = 4,
	[10][36] = 4,
	[11][4] = 5,
	[11][6] = 5,
	[11][8] = 5,
	[11][9] = 5,
	[11][13] = 5,
	[11][15] = 5,
	[11][16] = 5,
	[11][17] = 5,
	[11][18] = 5,
	[11][19] = 5,
	[11][20] = 5,
	[11][21] = 5,
	[11][22] = 5,
	[11][23] = 5,
	[11][24] = 5,
	[11][25] = 5,
	[11][26] = 5,
	[11][27] = 5,
	[11][28] = 5,
	[11][29] = 5,
	[11][30] = 5,
	[11][31] = 5,
	[11][32] = 5,
	[11][33] = 5,
	[11][34] = 5,
	[11][35] = 5,
	[11][36] = 5,
	[15][15] = 6,
	[15][16] = 6,
	[15][17] = 6,
	[15][18] = 6,
	[15][23] = 6,
	[15][24] = 6,
	[15][25] = 6,
	[15][26] = 6,
	[15][27] = 6,
	[15][28] = 6,
	[15][29] = 6,
	[15][30] = 6,
	[15][31] = 6,
	[15][32] = 6,
	[15][33] = 6,
	[15][34] = 6,
	[15][35] = 6,
	[15][36] = 6,
	[16][16] = 7,
	[16][17] = 7,
	[16][18] = 7,
	[16][31] = 7,
	[16][32] = 7,
	[16][33] = 7,
	[16][34] = 7,
	[16][35] = 7,
	[16][36] = 7,
	[17][53] = 8,
	[18][33] = 9,
	[18][34] = 9,
	[18][35] = 9,
	[18][36] = 9,
	[19][15] = 10,
	[19][16] = 10,
	[19][17] = 10,
	[19][18] = 10,
	[19][31] = 10,
	[19][32] = 10,
	[19][33] = 10,
	[19][34] = 10,
	[19][35] = 10,
	[19][36] = 10,
	[20][17] = 11,
	[20][18] = 11,
	[20][31] = 11,
	[20][32] = 11,
	[20][33] = 11,
	[20][34] = 11,
	[20][35] = 11,
	[20][36] = 11,
	[21][6] = 12,
	[21][9] = 12,
	[21][13] = 12,
	[21][15] = 12,
	[21][16] = 12,
	[21][17] = 12,
	[21][18] = 12,
	[21][19] = 12,
	[21][22] = 12,
	[21][23] = 12,
	[21][24] = 12,
	[21][25] = 12,
	[21][26] = 12,
	[21][27] = 12,
	[21][28] = 12,
	[21][29] = 12,
	[21][30] = 12,
	[21][31] = 12,
	[21][32] = 12,
	[21][33] = 12,
	[21][34] = 12,
	[21][35] = 12,
	[21][36] = 12,
	[23][53] = 13,
	[24][36] = 14,
	[25][18] = 15,
	[25][31] = 15,
	[25][32] = 15,
	[25][33] = 15,
	[25][34] = 15,
	[25][35] = 15,
	[25][36] = 15,
	[26][34] = 16,
	[26][35] = 16,
	[26][36] = 16,
	[27][18] = 17,
	[27][32] = 17,
	[27][33] = 17,
	[27][34] = 17,
	[27][35] = 17,
	[27][36] = 17,
	[28][33] = 18,
	[28][34] = 18,
	[28][35] = 18,
	[28][36] = 18,
	[29][6] = 19,
	[29][9] = 19,
	[29][15] = 19,
	[29][16] = 19,
	[29][17] = 19,
	[29][18] = 19,
	[29][23] = 19,
	[29][24] = 19,
	[29][25] = 19,
	[29][26] = 19,
	[29][27] = 19,
	[29][28] = 19,
	[29][29] = 19,
	[29][30] = 19,
	[29][31] = 19,
	[29][32] = 19,
	[29][33] = 19,
	[29][34] = 19,
	[29][35] = 19,
	[29][36] = 19,
	[30][35] = 20,
	[30][36] = 20,
	[31][6] = 21,
	[31][9] = 21,
	[31][13] = 21,
	[31][15] = 21,
	[31][16] = 21,
	[31][17] = 21,
	[31][18] = 21,
	[31][19] = 21,
	[31][21] = 21,
	[31][22] = 21,
	[31][23] = 21,
	[31][24] = 21,
	[31][25] = 21,
	[31][26] = 21,
	[31][27] = 21,
	[31][28] = 21,
	[31][29] = 21,
	[31][30] = 21,
	[31][31] = 21,
	[31][32] = 21,
	[31][33] = 21,
	[31][34] = 21,
	[31][35] = 21,
	[31][36] = 21,
	[32][4] = 22,
	[32][6] = 22,
	[32][8] = 22,
	[32][9] = 22,
	[32][13] = 22,
	[32][15] = 22,
	[32][16] = 22,
	[32][17] = 22,
	[32][18] = 22,
	[32][19] = 22,
	[32][20] = 22,
	[32][21] = 22,
	[32][22] = 22,
	[32][23] = 22,
	[32][24] = 22,
	[32][25] = 22,
	[32][26] = 22,
	[32][27] = 22,
	[32][28] = 22,
	[32][29] = 22,
	[32][30] = 22,
	[32][31] = 22,
	[32][32] = 22,
	[32][33] = 22,
	[32][34] = 22,
	[32][35] = 22,
	[32][36] = 22,
	[33][15] = 23,
	[33][16] = 23,
	[33][17] = 23,
	[33][18] = 23,
	[33][29] = 23,
	[33][30] = 23,
	[33][31] = 23,
	[33][32] = 23,
	[33][33] = 23,
	[33][34] = 23,
	[33][35] = 23,
	[33][36] = 23,
	[34][15] = 24,
	[34][16] = 24,
	[34][17] = 24,
	[34][18] = 24,
	[34][25] = 24,
	[34][26] = 24,
	[34][27] = 24,
	[34][28] = 24,
	[34][29] = 24,
	[34][30] = 24,
	[34][31] = 24,
	[34][32] = 24,
	[34][33] = 24,
	[34][34] = 24,
	[34][35] = 24,
	[34][36] = 24,
	[35][53] = 25,
	[36][53] = 26,
	[37][6] = 27,
	[37][9] = 27,
	[37][13] = 27,
	[37][15] = 27,
	[37][16] = 27,
	[37][17] = 27,
	[37][18] = 27,
	[37][19] = 27,
	[37][21] = 27,
	[37][22] = 27,
	[37][23] = 27,
	[37][24] = 27,
	[37][25] = 27,
	[37][26] = 27,
	[37][27] = 27,
	[37][28] = 27,
	[37][29] = 27,
	[37][30] = 27,
	[37][31] = 27,
	[37][32] = 27,
	[37][33] = 27,
	[37][34] = 27,
	[37][35] = 27,
	[37][36] = 27,
	[38][53] = 28,
	[39][53] = 29,
	[40][4] = 1,
	[40][6] = 1,
	[40][8] = 1,
	[40][9] = 1,
	[40][13] = 1,
	[40][15] = 1,
	[40][16] = 1,
	[40][17] = 1,
	[40][18] = 1,
	[40][19] = 1,
	[40][20] = 1,
	[40][21] = 1,
	[40][22] = 1,
	[40][23] = 1,
	[40][24] = 1,
	[40][25] = 1,
	[40][26] = 1,
	[40][27] = 1,
	[40][28] = 1,
	[40][29] = 1,
	[40][30] = 1,
	[40][31] = 1,
	[40][32] = 1,
	[40][33] = 1,
	[40][34] = 1,
	[40][35] = 1,
	[40][37] = 1,
	[40][38] = 1,
	[41][4] = 2,
	[41][6] = 2,
	[41][8] = 2,
	[41][9] = 2,
	[41][13] = 2,
	[41][15] = 2,
	[41][16] = 2,
	[41][17] = 2,
	[41][18] = 2,
	[41][19] = 2,
	[41][20] = 2,
	[41][21] = 2,
	[41][22] = 2,
	[41][23] = 2,
	[41][24] = 2,
	[41][25] = 2,
	[41][26] = 2,
	[41][27] = 2,
	[41][28] = 2,
	[41][29] = 2,
	[41][30] = 2,
	[41][31] = 2,
	[41][32] = 2,
	[41][33] = 2,
	[41][34] = 2,
	[41][35] = 2,
	[41][37] = 2,
	[41][38] = 2,
	[43][4] = 30,
	[43][6] = 30,
	[43][8] = 30,
	[43][9] = 30,
	[43][13] = 30,
	[43][15] = 30,
	[43][16] = 30,
	[43][17] = 30,
	[43][18] = 30,
	[43][19] = 30,
	[43][20] = 30,
	[43][21] = 30,
	[43][22] = 30,
	[43][23] = 30,
	[43][24] = 30,
	[43][25] = 30,
	[43][26] = 30,
	[43][27] = 30,
	[43][28] = 30,
	[43][29] = 30,
	[43][30] = 30,
	[43][31] = 30,
	[43][32] = 30,
	[43][33] = 30,
	[43][34] = 30,
	[43][35] = 30,
	[43][36] = 30,
	[47][4] = 3,
	[47][6] = 3,
	[47][8] = 3,
	[47][9] = 3,
	[47][13] = 3,
	[47][15] = 3,
	[47][16] = 3,
	[47][17] = 3,
	[47][18] = 3,
	[47][19] = 3,
	[47][20] = 3,
	[47][21] = 3,
	[47][22] = 3,
	[47][23] = 3,
	[47][24] = 3,
	[47][25] = 3,
	[47][26] = 3,
	[47][27] = 3,
	[47][28] = 3,
	[47][29] = 3,
	[47][30] = 3,
	[47][31] = 3,
	[47][32] = 3,
	[47][33] = 3,
	[47][34] = 3,
	[47][35] = 3,
	[47][37] = 3,
	[47][38] = 3,
	[50][4] = 4,
	[50][6] = 4,
	[50][8] = 4,
	[50][9] = 4,
	[50][13] = 4,
	[50][15] = 4,
	[50][16] = 4,
	[50][17] = 4,
	[50][18] = 4,
	[50][19] = 4,
	[50][20] = 4,
	[50][21] = 4,
	[50][22] = 4,
	[50][23] = 4,
	[50][24] = 4,
	[50][25] = 4,
	[50][26] = 4,
	[50][27] = 4,
	[50][28] = 4,
	[50][29] = 4,
	[50][30] = 4,
	[50][31] = 4,
	[50][32] = 4,
	[50][33] = 4,
	[50][34] = 4,
	[50][35] = 4,
	[50][37] = 4,
	[50][38] = 4,
	[51][4] = 5,
	[51][6] = 5,
	[51][8] = 5,
	[51][9] = 5,
	[51][13] = 5,
	[51][15] = 5,
	[51][16] = 5,
	[51][17] = 5,
	[51][18] = 5,
	[51][19] = 5,
	[51][20] = 5,
	[51][21] = 5,
	[51][22] = 5,
	[51][23] = 5,
	[51][24] = 5,
	[51][25] = 5,
	[51][26] = 5,
	[51][27] = 5,
	[51][28] = 5,
	[51][29] = 5,
	[51][30] = 5,
	[51][31] = 5,
	[51][32] = 5,
	[51][33] = 5,
	[51][34] = 5,
	[51][35] = 5,
	[51][37] = 5,
	[51][38] = 5,
	[54][15] = 6,
	[54][16] = 6,
	[54][17] = 6,
	[54][18] = 6,
	[54][23] = 6,
	[54][24] = 6,
	[54][25] = 6,
	[54][26] = 6,
	[54][27] = 6,
	[54][28] = 6,
	[54][29] = 6,
	[54][30] = 6,
	[54][31] = 6,
	[54][32] = 6,
	[54][33] = 6,
	[54][34] = 6,
	[54][35] = 6,
	[54][37] = 6,
	[54][38] = 6,
	[55][16] = 7,
	[55][17] = 7,
	[55][18] = 7,
	[55][31] = 7,
	[55][32] = 7,
	[55][33] = 7,
	[55][34] = 7,
	[55][35] = 7,
	[55][37] = 7,
	[55][38] = 7,
	[56][33] = 9,
	[56][34] = 9,
	[56][35] = 9,
	[56][37] = 9,
	[56][38] = 9,
	[57][15] = 10,
	[57][16] = 10,
	[57][17] = 10,
	[57][18] = 10,
	[57][31] = 10,
	[57][32] = 10,
	[57][33] = 10,
	[57][34] = 10,
	[57][35] = 10,
	[57][37] = 10,
	[57][38] = 10,
	[58][17] = 11,
	[58][18] = 11,
	[58][31] = 11,
	[58][32] = 11,
	[58][33] = 11,
	[58][34] = 11,
	[58][35] = 11,
	[58][37] = 11,
	[58][38] = 11,
	[59][6] = 12,
	[59][9] = 12,
	[59][13] = 12,
	[59][15] = 12,
	[59][16] = 12,
	[59][17] = 12,
	[59][18] = 12,
	[59][19] = 12,
	[59][22] = 12,
	[59][23] = 12,
	[59][24] = 12,
	[59][25] = 12,
	[59][26] = 12,
	[59][27] = 12,
	[59][28] = 12,
	[59][29] = 12,
	[59][30] = 12,
	[59][31] = 12,
	[59][32] = 12,
	[59][33] = 12,
	[59][34] = 12,
	[59][35] = 12,
	[59][37] = 12,
	[59][38] = 12,
	[61][37] = 14,
	[61][38] = 14,
	[62][18] = 15,
	[62][31] = 15,
	[62][32] = 15,
	[62][33] = 15,
	[62][34] = 15,
	[62][35] = 15,
	[62][37] = 15,
	[62][38] = 15,
	[63][34] = 16,
	[63][35] = 16,
	[63][37] = 16,
	[63][38] = 16,
	[64][18] = 17,
	[64][32] = 17,
	[64][33] = 17,
	[64][34] = 17,
	[64][35] = 17,
	[64][37] = 17,
	[64][38] = 17,
	[65][33] = 18,
	[65][34] = 18,
	[65][35] = 18,
	[65][37] = 18,
	[65][38] = 18,
	[66][6] = 19,
	[66][9] = 19,
	[66][15] = 19,
	[66][16] = 19,
	[66][17] = 19,
	[66][18] = 19,
	[66][23] = 19,
	[66][24] = 19,
	[66][25] = 19,
	[66][26] = 19,
	[66][27] = 19,
	[66][28] = 19,
	[66][29] = 19,
	[66][30] = 19,
	[66][31] = 19,
	[66][32] = 19,
	[66][33] = 19,
	[66][34] = 19,
	[66][35] = 19,
	[66][37] = 19,
	[66][38] = 19,
	[67][35] = 20,
	[67][37] = 20,
	[67][38] = 20,
	[68][6] = 21,
	[68][9] = 21,
	[68][13] = 21,
	[68][15] = 21,
	[68][16] = 21,
	[68][17] = 21,
	[68][18] = 21,
	[68][19] = 21,
	[68][21] = 21,
	[68][22] = 21,
	[68][23] = 21,
	[68][24] = 21,
	[68][25] = 21,
	[68][26] = 21,
	[68][27] = 21,
	[68][28] = 21,
	[68][29] = 21,
	[68][30] = 21,
	[68][31] = 21,
	[68][32] = 21,
	[68][33] = 21,
	[68][34] = 21,
	[68][35] = 21,
	[68][37] = 21,
	[68][38] = 21,
	[69][4] = 22,
	[69][6] = 22,
	[69][8] = 22,
	[69][9] = 22,
	[69][13] = 22,
	[69][15] = 22,
	[69][16] = 22,
	[69][17] = 22,
	[69][18] = 22,
	[69][19] = 22,
	[69][20] = 22,
	[69][21] = 22,
	[69][22] = 22,
	[69][23] = 22,
	[69][24] = 22,
	[69][25] = 22,
	[69][26] = 22,
	[69][27] = 22,
	[69][28] = 22,
	[69][29] = 22,
	[69][30] = 22,
	[69][31] = 22,
	[69][32] = 22,
	[69][33] = 22,
	[69][34] = 22,
	[69][35] = 22,
	[69][37] = 22,
	[69][38] = 22,
	[70][15] = 23,
	[70][16] = 23,
	[70][17] = 23,
	[70][18] = 23,
	[70][29] = 23,
	[70][30] = 23,
	[70][31] = 23,
	[70][32] = 23,
	[70][33] = 23,
	[70][34] = 23,
	[70][35] = 23,
	[70][37] = 23,
	[70][38] = 23,
	[71][15] = 24,
	[71][16] = 24,
	[71][17] = 24,
	[71][18] = 24,
	[71][25] = 24,
	[71][26] = 24,
	[71][27] = 24,
	[71][28] = 24,
	[71][29] = 24,
	[71][30] = 24,
	[71][31] = 24,
	[71][32] = 24,
	[71][33] = 24,
	[71][34] = 24,
	[71][35] = 24,
	[71][37] = 24,
	[71][38] = 24,
	[72][6] = 27,
	[72][9] = 27,
	[72][13] = 27,
	[72][15] = 27,
	[72][16] = 27,
	[72][17] = 27,
	[72][18] = 27,
	[72][19] = 27,
	[72][21] = 27,
	[72][22] = 27,
	[72][23] = 27,
	[72][24] = 27,
	[72][25] = 27,
	[72][26] = 27,
	[72][27] = 27,
	[72][28] = 27,
	[72][29] = 27,
	[72][30] = 27,
	[72][31] = 27,
	[72][32] = 27,
	[72][33] = 27,
	[72][34] = 27,
	[72][35] = 27,
	[72][37] = 27,
	[72][38] = 27,
	[73][4] = 5,
	[73][6] = 5,
	[73][8] = 5,
	[73][9] = 5,
	[73][13] = 5,
	[73][15] = 5,
	[73][16] = 5,
	[73][17] = 5,
	[73][18] = 5,
	[73][19] = 5,
	[73][20] = 5,
	[73][21] = 5,
	[73][22] = 5,
	[73][23] = 5,
	[73][24] = 5,
	[73][25] = 5,
	[73][26] = 5,
	[73][27] = 5,
	[73][28] = 5,
	[73][29] = 5,
	[73][30] = 5,
	[73][31] = 5,
	[73][32] = 5,
	[73][33] = 5,
	[73][34] = 5,
	[73][35] = 5,
	[73][36] = 5,
	[74][6] = 31,
	[74][9] = 31,
	[74][13] = 31,
	[74][15] = 31,
	[74][16] = 31,
	[74][17] = 31,
	[74][18] = 31,
	[74][19] = 31,
	[74][21] = 31,
	[74][22] = 31,
	[74][23] = 31,
	[74][24] = 31,
	[74][25] = 31,
	[74][26] = 31,
	[74][27] = 31,
	[74][28] = 31,
	[74][29] = 31,
	[74][30] = 31,
	[74][31] = 31,
	[74][32] = 31,
	[74][33] = 31,
	[74][34] = 31,
	[74][35] = 31,
	[74][36] = 31,
	[75][6] = 32,
	[75][9] = 32,
	[75][13] = 32,
	[75][15] = 32,
	[75][16] = 32,
	[75][17] = 32,
	[75][18] = 32,
	[75][19] = 32,
	[75][21] = 32,
	[75][22] = 32,
	[75][23] = 32,
	[75][24] = 32,
	[75][25] = 32,
	[75][26] = 32,
	[75][27] = 32,
	[75][28] = 32,
	[75][29] = 32,
	[75][30] = 32,
	[75][31] = 32,
	[75][32] = 32,
	[75][33] = 32,
	[75][34] = 32,
	[75][35] = 32,
	[75][36] = 32,
	[76][4] = 1,
	[76][6] = 1,
	[76][8] = 1,
	[76][9] = 1,
	[76][13] = 1,
	[76][15] = 1,
	[76][16] = 1,
	[76][17] = 1,
	[76][18] = 1,
	[76][19] = 1,
	[76][20] = 1,
	[76][21] = 1,
	[76][22] = 1,
	[76][23] = 1,
	[76][24] = 1,
	[76][25] = 1,
	[76][26] = 1,
	[76][27] = 1,
	[76][28] = 1,
	[76][29] = 1,
	[76][30] = 1,
	[76][31] = 1,
	[76][32] = 1,
	[76][33] = 1,
	[76][34] = 1,
	[76][35] = 1,
	[76][38] = 1,
	[76][39] = 1,
	[77][4] = 2,
	[77][6] = 2,
	[77][8] = 2,
	[77][9] = 2,
	[77][13] = 2,
	[77][15] = 2,
	[77][16] = 2,
	[77][17] = 2,
	[77][18] = 2,
	[77][19] = 2,
	[77][20] = 2,
	[77][21] = 2,
	[77][22] = 2,
	[77][23] = 2,
	[77][24] = 2,
	[77][25] = 2,
	[77][26] = 2,
	[77][27] = 2,
	[77][28] = 2,
	[77][29] = 2,
	[77][30] = 2,
	[77][31] = 2,
	[77][32] = 2,
	[77][33] = 2,
	[77][34] = 2,
	[77][35] = 2,
	[77][38] = 2,
	[77][39] = 2,
	[82][4] = 3,
	[82][6] = 3,
	[82][8] = 3,
	[82][9] = 3,
	[82][13] = 3,
	[82][15] = 3,
	[82][16] = 3,
	[82][17] = 3,
	[82][18] = 3,
	[82][19] = 3,
	[82][20] = 3,
	[82][21] = 3,
	[82][22] = 3,
	[82][23] = 3,
	[82][24] = 3,
	[82][25] = 3,
	[82][26] = 3,
	[82][27] = 3,
	[82][28] = 3,
	[82][29] = 3,
	[82][30] = 3,
	[82][31] = 3,
	[82][32] = 3,
	[82][33] = 3,
	[82][34] = 3,
	[82][35] = 3,
	[82][38] = 3,
	[82][39] = 3,
	[84][4] = 33,
	[84][6] = 33,
	[84][8] = 33,
	[84][9] = 33,
	[84][13] = 33,
	[84][15] = 33,
	[84][16] = 33,
	[84][17] = 33,
	[84][18] = 33,
	[84][19] = 33,
	[84][20] = 33,
	[84][21] = 33,
	[84][22] = 33,
	[84][23] = 33,
	[84][24] = 33,
	[84][25] = 33,
	[84][26] = 33,
	[84][27] = 33,
	[84][28] = 33,
	[84][29] = 33,
	[84][30] = 33,
	[84][31] = 33,
	[84][32] = 33,
	[84][33] = 33,
	[84][34] = 33,
	[84][35] = 33,
	[84][36] = 33,
	[86][4] = 4,
	[86][6] = 4,
	[86][8] = 4,
	[86][9] = 4,
	[86][13] = 4,
	[86][15] = 4,
	[86][16] = 4,
	[86][17] = 4,
	[86][18] = 4,
	[86][19] = 4,
	[86][20] = 4,
	[86][21] = 4,
	[86][22] = 4,
	[86][23] = 4,
	[86][24] = 4,
	[86][25] = 4,
	[86][26] = 4,
	[86][27] = 4,
	[86][28] = 4,
	[86][29] = 4,
	[86][30] = 4,
	[86][31] = 4,
	[86][32] = 4,
	[86][33] = 4,
	[86][34] = 4,
	[86][35] = 4,
	[86][38] = 4,
	[86][39] = 4,
	[87][4] = 5,
	[87][6] = 5,
	[87][8] = 5,
	[87][9] = 5,
	[87][13] = 5,
	[87][15] = 5,
	[87][16] = 5,
	[87][17] = 5,
	[87][18] = 5,
	[87][19] = 5,
	[87][20] = 5,
	[87][21] = 5,
	[87][22] = 5,
	[87][23] = 5,
	[87][24] = 5,
	[87][25] = 5,
	[87][26] = 5,
	[87][27] = 5,
	[87][28] = 5,
	[87][29] = 5,
	[87][30] = 5,
	[87][31] = 5,
	[87][32] = 5,
	[87][33] = 5,
	[87][34] = 5,
	[87][35] = 5,
	[87][38] = 5,
	[87][39] = 5,
	[90][15] = 6,
	[90][16] = 6,
	[90][17] = 6,
	[90][18] = 6,
	[90][23] = 6,
	[90][24] = 6,
	[90][25] = 6,
	[90][26] = 6,
	[90][27] = 6,
	[90][28] = 6,
	[90][29] = 6,
	[90][30] = 6,
	[90][31] = 6,
	[90][32] = 6,
	[90][33] = 6,
	[90][34] = 6,
	[90][35] = 6,
	[90][38] = 6,
	[90][39] = 6,
	[91][16] = 7,
	[91][17] = 7,
	[91][18] = 7,
	[91][31] = 7,
	[91][32] = 7,
	[91][33] = 7,
	[91][34] = 7,
	[91][35] = 7,
	[91][38] = 7,
	[91][39] = 7,
	[92][33] = 9,
	[92][34] = 9,
	[92][35] = 9,
	[92][38] = 9,
	[92][39] = 9,
	[93][15] = 10,
	[93][16] = 10,
	[93][17] = 10,
	[93][18] = 10,
	[93][31] = 10,
	[93][32] = 10,
	[93][33] = 10,
	[93][34] = 10,
	[93][35] = 10,
	[93][38] = 10,
	[93][39] = 10,
	[94][17] = 11,
	[94][18] = 11,
	[94][31] = 11,
	[94][32] = 11,
	[94][33] = 11,
	[94][34] = 11,
	[94][35] = 11,
	[94][38] = 11,
	[94][39] = 11,
	[95][6] = 12,
	[95][9] = 12,
	[95][13] = 12,
	[95][15] = 12,
	[95][16] = 12,
	[95][17] = 12,
	[95][18] = 12,
	[95][19] = 12,
	[95][22] = 12,
	[95][23] = 12,
	[95][24] = 12,
	[95][25] = 12,
	[95][26] = 12,
	[95][27] = 12,
	[95][28] = 12,
	[95][29] = 12,
	[95][30] = 12,
	[95][31] = 12,
	[95][32] = 12,
	[95][33] = 12,
	[95][34] = 12,
	[95][35] = 12,
	[95][38] = 12,
	[95][39] = 12,
	[97][38] = 14,
	[97][39] = 14,
	[98][18] = 15,
	[98][31] = 15,
	[98][32] = 15,
	[98][33] = 15,
	[98][34] = 15,
	[98][35] = 15,
	[98][38] = 15,
	[98][39] = 15,
	[99][34] = 16,
	[99][35] = 16,
	[99][38] = 16,
	[99][39] = 16,
	[100][18] = 17,
	[100][32] = 17,
	[100][33] = 17,
	[100][34] = 17,
	[100][35] = 17,
	[100][38] = 17,
	[100][39] = 17,
	[101][33] = 18,
	[101][34] = 18,
	[101][35] = 18,
	[101][38] = 18,
	[101][39] = 18,
	[102][6] = 19,
	[102][9] = 19,
	[102][15] = 19,
	[102][16] = 19,
	[102][17] = 19,
	[102][18] = 19,
	[102][23] = 19,
	[102][24] = 19,
	[102][25] = 19,
	[102][26] = 19,
	[102][27] = 19,
	[102][28] = 19,
	[102][29] = 19,
	[102][30] = 19,
	[102][31] = 19,
	[102][32] = 19,
	[102][33] = 19,
	[102][34] = 19,
	[102][35] = 19,
	[102][38] = 19,
	[102][39] = 19,
	[103][35] = 20,
	[103][38] = 20,
	[103][39] = 20,
	[104][6] = 21,
	[104][9] = 21,
	[104][13] = 21,
	[104][15] = 21,
	[104][16] = 21,
	[104][17] = 21,
	[104][18] = 21,
	[104][19] = 21,
	[104][21] = 21,
	[104][22] = 21,
	[104][23] = 21,
	[104][24] = 21,
	[104][25] = 21,
	[104][26] = 21,
	[104][27] = 21,
	[104][28] = 21,
	[104][29] = 21,
	[104][30] = 21,
	[104][31] = 21,
	[104][32] = 21,
	[104][33] = 21,
	[104][34] = 21,
	[104][35] = 21,
	[104][38] = 21,
	[104][39] = 21,
	[105][4] = 22,
	[105][6] = 22,
	[105][8] = 22,
	[105][9] = 22,
	[105][13] = 22,
	[105][15] = 22,
	[105][16] = 22,
	[105][17] = 22,
	[105][18] = 22,
	[105][19] = 22,
	[105][20] = 22,
	[105][21] = 22,
	[105][22] = 22,
	[105][23] = 22,
	[105][24] = 22,
	[105][25] = 22,
	[105][26] = 22,
	[105][27] = 22,
	[105][28] = 22,
	[105][29] = 22,
	[105][30] = 22,
	[105][31] = 22,
	[105][32] = 22,
	[105][33] = 22,
	[105][34] = 22,
	[105][35] = 22,
	[105][38] = 22,
	[105][39] = 22,
	[106][15] = 23,
	[106][16] = 23,
	[106][17] = 23,
	[106][18] = 23,
	[106][29] = 23,
	[106][30] = 23,
	[106][31] = 23,
	[106][32] = 23,
	[106][33] = 23,
	[106][34] = 23,
	[106][35] = 23,
	[106][38] = 23,
	[106][39] = 23,
	[107][15] = 24,
	[107][16] = 24,
	[107][17] = 24,
	[107][18] = 24,
	[107][25] = 24,
	[107][26] = 24,
	[107][27] = 24,
	[107][28] = 24,
	[107][29] = 24,
	[107][30] = 24,
	[107][31] = 24,
	[107][32] = 24,
	[107][33] = 24,
	[107][34] = 24,
	[107][35] = 24,
	[107][38] = 24,
	[107][39] = 24,
	[108][6] = 27,
	[108][9] = 27,
	[108][13] = 27,
	[108][15] = 27,
	[108][16] = 27,
	[108][17] = 27,
	[108][18] = 27,
	[108][19] = 27,
	[108][21] = 27,
	[108][22] = 27,
	[108][23] = 27,
	[108][24] = 27,
	[108][25] = 27,
	[108][26] = 27,
	[108][27] = 27,
	[108][28] = 27,
	[108][29] = 27,
	[108][30] = 27,
	[108][31] = 27,
	[108][32] = 27,
	[108][33] = 27,
	[108][34] = 27,
	[108][35] = 27,
	[108][38] = 27,
	[108][39] = 27,
	[109][6] = 34,
	[109][9] = 34,
	[109][13] = 34,
	[109][15] = 34,
	[109][16] = 34,
	[109][17] = 34,
	[109][18] = 34,
	[109][19] = 34,
	[109][21] = 34,
	[109][22] = 34,
	[109][23] = 34,
	[109][24] = 34,
	[109][25] = 34,
	[109][26] = 34,
	[109][27] = 34,
	[109][28] = 34,
	[109][29] = 34,
	[109][30] = 34,
	[109][31] = 34,
	[109][32] = 34,
	[109][33] = 34,
	[109][34] = 34,
	[109][35] = 34,
	[109][36] = 34,
	[112][6] = 35,
	[112][9] = 35,
	[112][13] = 35,
	[112][15] = 35,
	[112][16] = 35,
	[112][17] = 35,
	[112][18] = 35,
	[112][19] = 35,
	[112][21] = 35,
	[112][22] = 35,
	[112][23] = 35,
	[112][24] = 35,
	[112][25] = 35,
	[112][26] = 35,
	[112][27] = 35,
	[112][28] = 35,
	[112][29] = 35,
	[112][30] = 35,
	[112][31] = 35,
	[112][32] = 35,
	[112][33] = 35,
	[112][34] = 35,
	[112][35] = 35,
	[112][36] = 35,
	[122][11] = 36,
	[122][54] = 36,
	[124][11] = 37,
	[124][54] = 37,
	[125][11] = 38,
	[125][54] = 38,
	[126][11] = 39,
	[126][54] = 39,
	[127][11] = 40,
	[127][54] = 40,
	[129][11] = 41,
	[134][53] = 42,
	[135][53] = 43,
	[136][53] = 44,
	[137][53] = 45,
	[138][53] = 46,
	[139][53] = 47,
	[140][53] = 48,
	[145][2] = 49,
	[145][3] = 49,
	[145][4] = 49,
	[145][5] = 49,
	[145][6] = 49,
	[145][7] = 49,
	[145][8] = 49,
	[145][9] = 49,
	[145][10] = 49,
	[145][11] = 49,
	[145][12] = 49,
	[145][13] = 49,
	[145][14] = 49,
	[145][53] = 49,
	[146][2] = 50,
	[146][3] = 50,
	[146][4] = 50,
	[146][5] = 50,
	[146][6] = 50,
	[146][7] = 50,
	[146][8] = 50,
	[146][9] = 50,
	[146][10] = 50,
	[146][11] = 50,
	[146][12] = 50,
	[146][13] = 50,
	[146][14] = 50,
	[146][53] = 50,
	[147][53] = 51,
	[148][53] = 52,
	[149][53] = 53,
	[150][53] = 54,
	[151][53] = 55,
	[152][53] = 56,
	[153][53] = 57,
	[173][53] = 58,
	[174][53] = 59,
	[175][53] = 60,
	[176][53] = 61,
	[177][53] = 62,
	[178][53] = 63,
	[179][53] = 64,
	[180][53] = 65,
	[181][53] = 66,
	[182][53] = 67,
	[183][53] = 68,
	[184][53] = 69,
	[185][53] = 70,
	[186][53] = 71,
	[187][53] = 72,
	[188][53] = 73,
	[189][53] = 74,
	[190][53] = 75,
	[191][53] = 76,
	[192][53] = 77,
	[193][53] = 78,
	[194][53] = 79,
	[195][53] = 80,
	[196][53] = 81,
	[197][53] = 82,
	[198][53] = 83,
	[199][53] = 84,
	[200][53] = 85,
	[201][4] = 30,
	[201][6] = 30,
	[201][8] = 30,
	[201][9] = 30,
	[201][13] = 30,
	[201][15] = 30,
	[201][16] = 30,
	[201][17] = 30,
	[201][18] = 30,
	[201][19] = 30,
	[201][20] = 30,
	[201][21] = 30,
	[201][22] = 30,
	[201][23] = 30,
	[201][24] = 30,
	[201][25] = 30,
	[201][26] = 30,
	[201][27] = 30,
	[201][28] = 30,
	[201][29] = 30,
	[201][30] = 30,
	[201][31] = 30,
	[201][32] = 30,
	[201][33] = 30,
	[201][34] = 30,
	[201][35] = 30,
	[201][37] = 30,
	[201][38] = 30,
	[204][6] = 31,
	[204][9] = 31,
	[204][13] = 31,
	[204][15] = 31,
	[204][16] = 31,
	[204][17] = 31,
	[204][18] = 31,
	[204][19] = 31,
	[204][21] = 31,
	[204][22] = 31,
	[204][23] = 31,
	[204][24] = 31,
	[204][25] = 31,
	[204][26] = 31,
	[204][27] = 31,
	[204][28] = 31,
	[204][29] = 31,
	[204][30] = 31,
	[204][31] = 31,
	[204][32] = 31,
	[204][33] = 31,
	[204][34] = 31,
	[204][35] = 31,
	[204][37] = 31,
	[204][38] = 31,
	[205][6] = 32,
	[205][9] = 32,
	[205][13] = 32,
	[205][15] = 32,
	[205][16] = 32,
	[205][17] = 32,
	[205][18] = 32,
	[205][19] = 32,
	[205][21] = 32,
	[205][22] = 32,
	[205][23] = 32,
	[205][24] = 32,
	[205][25] = 32,
	[205][26] = 32,
	[205][27] = 32,
	[205][28] = 32,
	[205][29] = 32,
	[205][30] = 32,
	[205][31] = 32,
	[205][32] = 32,
	[205][33] = 32,
	[205][34] = 32,
	[205][35] = 32,
	[205][37] = 32,
	[205][38] = 32,
	[206][4] = 86,
	[206][6] = 86,
	[206][8] = 86,
	[206][9] = 86,
	[206][13] = 86,
	[206][15] = 86,
	[206][16] = 86,
	[206][17] = 86,
	[206][18] = 86,
	[206][19] = 86,
	[206][20] = 86,
	[206][21] = 86,
	[206][22] = 86,
	[206][23] = 86,
	[206][24] = 86,
	[206][25] = 86,
	[206][26] = 86,
	[206][27] = 86,
	[206][28] = 86,
	[206][29] = 86,
	[206][30] = 86,
	[206][31] = 86,
	[206][32] = 86,
	[206][33] = 86,
	[206][34] = 86,
	[206][35] = 86,
	[206][36] = 86,
	[209][4] = 33,
	[209][6] = 33,
	[209][8] = 33,
	[209][9] = 33,
	[209][13] = 33,
	[209][15] = 33,
	[209][16] = 33,
	[209][17] = 33,
	[209][18] = 33,
	[209][19] = 33,
	[209][20] = 33,
	[209][21] = 33,
	[209][22] = 33,
	[209][23] = 33,
	[209][24] = 33,
	[209][25] = 33,
	[209][26] = 33,
	[209][27] = 33,
	[209][28] = 33,
	[209][29] = 33,
	[209][30] = 33,
	[209][31] = 33,
	[209][32] = 33,
	[209][33] = 33,
	[209][34] = 33,
	[209][35] = 33,
	[209][37] = 33,
	[209][38] = 33,
	[211][6] = 34,
	[211][9] = 34,
	[211][13] = 34,
	[211][15] = 34,
	[211][16] = 34,
	[211][17] = 34,
	[211][18] = 34,
	[211][19] = 34,
	[211][21] = 34,
	[211][22] = 34,
	[211][23] = 34,
	[211][24] = 34,
	[211][25] = 34,
	[211][26] = 34,
	[211][27] = 34,
	[211][28] = 34,
	[211][29] = 34,
	[211][30] = 34,
	[211][31] = 34,
	[211][32] = 34,
	[211][33] = 34,
	[211][34] = 34,
	[211][35] = 34,
	[211][37] = 34,
	[211][38] = 34,
	[212][6] = 35,
	[212][9] = 35,
	[212][13] = 35,
	[212][15] = 35,
	[212][16] = 35,
	[212][17] = 35,
	[212][18] = 35,
	[212][19] = 35,
	[212][21] = 35,
	[212][22] = 35,
	[212][23] = 35,
	[212][24] = 35,
	[212][25] = 35,
	[212][26] = 35,
	[212][27] = 35,
	[212][28] = 35,
	[212][29] = 35,
	[212][30] = 35,
	[212][31] = 35,
	[212][32] = 35,
	[212][33] = 35,
	[212][34] = 35,
	[212][35] = 35,
	[212][37] = 35,
	[212][38] = 35,
	[223][4] = 87,
	[223][6] = 87,
	[223][8] = 87,
	[223][9] = 87,
	[223][13] = 87,
	[223][15] = 87,
	[223][16] = 87,
	[223][17] = 87,
	[223][18] = 87,
	[223][19] = 87,
	[223][20] = 87,
	[223][21] = 87,
	[223][22] = 87,
	[223][23] = 87,
	[223][24] = 87,
	[223][25] = 87,
	[223][26] = 87,
	[223][27] = 87,
	[223][28] = 87,
	[223][29] = 87,
	[223][30] = 87,
	[223][31] = 87,
	[223][32] = 87,
	[223][33] = 87,
	[223][34] = 87,
	[223][35] = 87,
	[223][36] = 87,
	[244][4] = 30,
	[244][6] = 30,
	[244][8] = 30,
	[244][9] = 30,
	[244][13] = 30,
	[244][15] = 30,
	[244][16] = 30,
	[244][17] = 30,
	[244][18] = 30,
	[244][19] = 30,
	[244][20] = 30,
	[244][21] = 30,
	[244][22] = 30,
	[244][23] = 30,
	[244][24] = 30,
	[244][25] = 30,
	[244][26] = 30,
	[244][27] = 30,
	[244][28] = 30,
	[244][29] = 30,
	[244][30] = 30,
	[244][31] = 30,
	[244][32] = 30,
	[244][33] = 30,
	[244][34] = 30,
	[244][35] = 30,
	[244][38] = 30,
	[244][39] = 30,
	[247][6] = 31,
	[247][9] = 31,
	[247][13] = 31,
	[247][15] = 31,
	[247][16] = 31,
	[247][17] = 31,
	[247][18] = 31,
	[247][19] = 31,
	[247][21] = 31,
	[247][22] = 31,
	[247][23] = 31,
	[247][24] = 31,
	[247][25] = 31,
	[247][26] = 31,
	[247][27] = 31,
	[247][28] = 31,
	[247][29] = 31,
	[247][30] = 31,
	[247][31] = 31,
	[247][32] = 31,
	[247][33] = 31,
	[247][34] = 31,
	[247][35] = 31,
	[247][38] = 31,
	[247][39] = 31,
	[248][6] = 32,
	[248][9] = 32,
	[248][13] = 32,
	[248][15] = 32,
	[248][16] = 32,
	[248][17] = 32,
	[248][18] = 32,
	[248][19] = 32,
	[248][21] = 32,
	[248][22] = 32,
	[248][23] = 32,
	[248][24] = 32,
	[248][25] = 32,
	[248][26] = 32,
	[248][27] = 32,
	[248][28] = 32,
	[248][29] = 32,
	[248][30] = 32,
	[248][31] = 32,
	[248][32] = 32,
	[248][33] = 32,
	[248][34] = 32,
	[248][35] = 32,
	[248][38] = 32,
	[248][39] = 32,
	[249][4] = 88,
	[249][6] = 88,
	[249][8] = 88,
	[249][9] = 88,
	[249][13] = 88,
	[249][15] = 88,
	[249][16] = 88,
	[249][17] = 88,
	[249][18] = 88,
	[249][19] = 88,
	[249][20] = 88,
	[249][21] = 88,
	[249][22] = 88,
	[249][23] = 88,
	[249][24] = 88,
	[249][25] = 88,
	[249][26] = 88,
	[249][27] = 88,
	[249][28] = 88,
	[249][29] = 88,
	[249][30] = 88,
	[249][31] = 88,
	[249][32] = 88,
	[249][33] = 88,
	[249][34] = 88,
	[249][35] = 88,
	[249][36] = 88,
	[252][4] = 33,
	[252][6] = 33,
	[252][8] = 33,
	[252][9] = 33,
	[252][13] = 33,
	[252][15] = 33,
	[252][16] = 33,
	[252][17] = 33,
	[252][18] = 33,
	[252][19] = 33,
	[252][20] = 33,
	[252][21] = 33,
	[252][22] = 33,
	[252][23] = 33,
	[252][24] = 33,
	[252][25] = 33,
	[252][26] = 33,
	[252][27] = 33,
	[252][28] = 33,
	[252][29] = 33,
	[252][30] = 33,
	[252][31] = 33,
	[252][32] = 33,
	[252][33] = 33,
	[252][34] = 33,
	[252][35] = 33,
	[252][38] = 33,
	[252][39] = 33,
	[254][6] = 34,
	[254][9] = 34,
	[254][13] = 34,
	[254][15] = 34,
	[254][16] = 34,
	[254][17] = 34,
	[254][18] = 34,
	[254][19] = 34,
	[254][21] = 34,
	[254][22] = 34,
	[254][23] = 34,
	[254][24] = 34,
	[254][25] = 34,
	[254][26] = 34,
	[254][27] = 34,
	[254][28] = 34,
	[254][29] = 34,
	[254][30] = 34,
	[254][31] = 34,
	[254][32] = 34,
	[254][33] = 34,
	[254][34] = 34,
	[254][35] = 34,
	[254][38] = 34,
	[254][39] = 34,
	[255][6] = 35,
	[255][9] = 35,
	[255][13] = 35,
	[255][15] = 35,
	[255][16] = 35,
	[255][17] = 35,
	[255][18] = 35,
	[255][19] = 35,
	[255][21] = 35,
	[255][22] = 35,
	[255][23] = 35,
	[255][24] = 35,
	[255][25] = 35,
	[255][26] = 35,
	[255][27] = 35,
	[255][28] = 35,
	[255][29] = 35,
	[255][30] = 35,
	[255][31] = 35,
	[255][32] = 35,
	[255][33] = 35,
	[255][34] = 35,
	[255][35] = 35,
	[255][38] = 35,
	[255][39] = 35,
	[267][4] = 89,
	[267][6] = 89,
	[267][8] = 89,
	[267][9] = 89,
	[267][13] = 89,
	[267][15] = 89,
	[267][16] = 89,
	[267][17] = 89,
	[267][18] = 89,
	[267][19] = 89,
	[267][20] = 89,
	[267][21] = 89,
	[267][22] = 89,
	[267][23] = 89,
	[267][24] = 89,
	[267][25] = 89,
	[267][26] = 89,
	[267][27] = 89,
	[267][28] = 89,
	[267][29] = 89,
	[267][30] = 89,
	[267][31] = 89,
	[267][32] = 89,
	[267][33] = 89,
	[267][34] = 89,
	[267][35] = 89,
	[267][36] = 89,
	[287][2] = 90,
	[287][3] = 90,
	[287][4] = 90,
	[287][7] = 90,
	[287][8] = 90,
	[287][9] = 90,
	[287][11] = 90,
	[287][17] = 90,
	[287][18] = 90,
	[287][19] = 90,
	[287][22] = 90,
	[287][36] = 90,
	[288][2] = 91,
	[288][3] = 91,
	[288][4] = 91,
	[288][7] = 91,
	[288][8] = 91,
	[288][9] = 91,
	[288][11] = 91,
	[288][17] = 91,
	[288][18] = 91,
	[288][19] = 91,
	[288][22] = 91,
	[288][36] = 91,
	[290][2] = 92,
	[290][3] = 92,
	[290][4] = 92,
	[290][7] = 92,
	[290][8] = 92,
	[290][9] = 92,
	[290][11] = 92,
	[290][17] = 92,
	[290][18] = 92,
	[290][19] = 92,
	[290][22] = 92,
	[290][36] = 92,
	[292][2] = 93,
	[292][3] = 93,
	[292][4] = 93,
	[292][7] = 93,
	[292][8] = 93,
	[292][9] = 93,
	[292][11] = 93,
	[292][17] = 93,
	[292][18] = 93,
	[292][19] = 93,
	[292][22] = 93,
	[292][36] = 93,
	[295][2] = 94,
	[295][3] = 94,
	[295][4] = 94,
	[295][7] = 94,
	[295][8] = 94,
	[295][11] = 94,
	[295][17] = 94,
	[295][22] = 94,
	[295][36] = 94,
	[296][36] = 95,
	[297][17] = 96,
	[297][36] = 96,
	[307][11] = 97,
	[307][54] = 97,
	[309][37] = 36,
	[309][38] = 36,
	[309][54] = 36,
	[310][37] = 37,
	[310][38] = 37,
	[310][54] = 37,
	[311][37] = 38,
	[311][38] = 38,
	[311][54] = 38,
	[312][37] = 39,
	[312][38] = 39,
	[312][54] = 39,
	[313][37] = 40,
	[313][38] = 40,
	[313][54] = 40,
	[315][37] = 41,
	[315][38] = 41,
	[317][11] = 36,
	[317][38] = 98,
	[317][40] = 98,
	[317][54] = 36,
	[318][33] = 99,
	[318][34] = 99,
	[318][35] = 99,
	[318][36] = 99,
	[321][33] = 100,
	[321][34] = 100,
	[321][35] = 100,
	[321][36] = 100,
	[322][33] = 101,
	[322][34] = 101,
	[322][35] = 101,
	[322][36] = 101,
	[325][38] = 36,
	[325][40] = 36,
	[325][54] = 36,
	[327][38] = 37,
	[327][40] = 37,
	[327][54] = 37,
	[328][38] = 38,
	[328][40] = 38,
	[328][54] = 38,
	[329][38] = 39,
	[329][40] = 39,
	[329][54] = 39,
	[330][38] = 40,
	[330][40] = 40,
	[330][54] = 40,
	[332][38] = 41,
	[332][40] = 41,
	[334][11] = 102,
	[334][54] = 102,
	[336][6] = 103,
	[336][9] = 103,
	[336][15] = 103,
	[336][16] = 103,
	[336][17] = 103,
	[336][18] = 103,
	[336][23] = 103,
	[336][24] = 103,
	[336][25] = 103,
	[336][26] = 103,
	[336][27] = 103,
	[336][28] = 103,
	[336][29] = 103,
	[336][30] = 103,
	[336][31] = 103,
	[336][32] = 103,
	[336][33] = 103,
	[336][34] = 103,
	[336][35] = 103,
	[336][36] = 103,
	[337][6] = 104,
	[337][9] = 104,
	[337][15] = 104,
	[337][16] = 104,
	[337][17] = 104,
	[337][18] = 104,
	[337][23] = 104,
	[337][24] = 104,
	[337][25] = 104,
	[337][26] = 104,
	[337][27] = 104,
	[337][28] = 104,
	[337][29] = 104,
	[337][30] = 104,
	[337][31] = 104,
	[337][32] = 104,
	[337][33] = 104,
	[337][34] = 104,
	[337][35] = 104,
	[337][36] = 104,
	[338][15] = 105,
	[338][16] = 105,
	[338][17] = 105,
	[338][18] = 105,
	[338][31] = 105,
	[338][32] = 105,
	[338][33] = 105,
	[338][34] = 105,
	[338][35] = 105,
	[338][36] = 105,
	[339][53] = 106,
	[340][53] = 107,
	[341][53] = 108,
	[342][53] = 109,
	[343][53] = 110,
	[344][53] = 111,
	[345][15] = 112,
	[345][16] = 112,
	[345][17] = 112,
	[345][18] = 112,
	[345][29] = 112,
	[345][30] = 112,
	[345][31] = 112,
	[345][32] = 112,
	[345][33] = 112,
	[345][34] = 112,
	[345][35] = 112,
	[345][36] = 112,
	[346][15] = 113,
	[346][16] = 113,
	[346][17] = 113,
	[346][18] = 113,
	[346][29] = 113,
	[346][30] = 113,
	[346][31] = 113,
	[346][32] = 113,
	[346][33] = 113,
	[346][34] = 113,
	[346][35] = 113,
	[346][36] = 113,
	[347][16] = 114,
	[347][17] = 114,
	[347][18] = 114,
	[347][31] = 114,
	[347][32] = 114,
	[347][33] = 114,
	[347][34] = 114,
	[347][35] = 114,
	[347][36] = 114,
	[348][6] = 115,
	[348][9] = 115,
	[348][13] = 115,
	[348][15] = 115,
	[348][16] = 115,
	[348][17] = 115,
	[348][18] = 115,
	[348][19] = 115,
	[348][21] = 115,
	[348][22] = 115,
	[348][23] = 115,
	[348][24] = 115,
	[348][25] = 115,
	[348][26] = 115,
	[348][27] = 115,
	[348][28] = 115,
	[348][29] = 115,
	[348][30] = 115,
	[348][31] = 115,
	[348][32] = 115,
	[348][33] = 115,
	[348][34] = 115,
	[348][35] = 115,
	[348][36] = 115,
	[349][53] = 116,
	[350][53] = 117,
	[351][53] = 118,
	[352][53] = 119,
	[353][53] = 120,
	[354][53] = 121,
	[355][36] = 122,
	[356][36] = 123,
	[357][17] = 124,
	[357][18] = 124,
	[357][31] = 124,
	[357][32] = 124,
	[357][33] = 124,
	[357][34] = 124,
	[357][35] = 124,
	[357][36] = 124,
	[358][34] = 125,
	[358][35] = 125,
	[358][36] = 125,
	[359][18] = 126,
	[359][31] = 126,
	[359][32] = 126,
	[359][33] = 126,
	[359][34] = 126,
	[359][35] = 126,
	[359][36] = 126,
	[360][4] = 1,
	[360][6] = 1,
	[360][8] = 1,
	[360][9] = 1,
	[360][13] = 1,
	[360][15] = 1,
	[360][16] = 1,
	[360][17] = 1,
	[360][18] = 1,
	[360][19] = 1,
	[360][20] = 1,
	[360][21] = 1,
	[360][22] = 1,
	[360][23] = 1,
	[360][24] = 1,
	[360][25] = 1,
	[360][26] = 1,
	[360][27] = 1,
	[360][28] = 1,
	[360][29] = 1,
	[360][30] = 1,
	[360][31] = 1,
	[360][32] = 1,
	[360][33] = 1,
	[360][34] = 1,
	[360][35] = 1,
	[360][40] = 1,
	[361][4] = 2,
	[361][6] = 2,
	[361][8] = 2,
	[361][9] = 2,
	[361][13] = 2,
	[361][15] = 2,
	[361][16] = 2,
	[361][17] = 2,
	[361][18] = 2,
	[361][19] = 2,
	[361][20] = 2,
	[361][21] = 2,
	[361][22] = 2,
	[361][23] = 2,
	[361][24] = 2,
	[361][25] = 2,
	[361][26] = 2,
	[361][27] = 2,
	[361][28] = 2,
	[361][29] = 2,
	[361][30] = 2,
	[361][31] = 2,
	[361][32] = 2,
	[361][33] = 2,
	[361][34] = 2,
	[361][35] = 2,
	[361][40] = 2,
	[365][4] = 3,
	[365][6] = 3,
	[365][8] = 3,
	[365][9] = 3,
	[365][13] = 3,
	[365][15] = 3,
	[365][16] = 3,
	[365][17] = 3,
	[365][18] = 3,
	[365][19] = 3,
	[365][20] = 3,
	[365][21] = 3,
	[365][22] = 3,
	[365][23] = 3,
	[365][24] = 3,
	[365][25] = 3,
	[365][26] = 3,
	[365][27] = 3,
	[365][28] = 3,
	[365][29] = 3,
	[365][30] = 3,
	[365][31] = 3,
	[365][32] = 3,
	[365][33] = 3,
	[365][34] = 3,
	[365][35] = 3,
	[365][40] = 3,
	[368][4] = 4,
	[368][6] = 4,
	[368][8] = 4,
	[368][9] = 4,
	[368][13] = 4,
	[368][15] = 4,
	[368][16] = 4,
	[368][17] = 4,
	[368][18] = 4,
	[368][19] = 4,
	[368][20] = 4,
	[368][21] = 4,
	[368][22] = 4,
	[368][23] = 4,
	[368][24] = 4,
	[368][25] = 4,
	[368][26] = 4,
	[368][27] = 4,
	[368][28] = 4,
	[368][29] = 4,
	[368][30] = 4,
	[368][31] = 4,
	[368][32] = 4,
	[368][33] = 4,
	[368][34] = 4,
	[368][35] = 4,
	[368][40] = 4,
	[369][4] = 5,
	[369][6] = 5,
	[369][8] = 5,
	[369][9] = 5,
	[369][13] = 5,
	[369][15] = 5,
	[369][16] = 5,
	[369][17] = 5,
	[369][18] = 5,
	[369][19] = 5,
	[369][20] = 5,
	[369][21] = 5,
	[369][22] = 5,
	[369][23] = 5,
	[369][24] = 5,
	[369][25] = 5,
	[369][26] = 5,
	[369][27] = 5,
	[369][28] = 5,
	[369][29] = 5,
	[369][30] = 5,
	[369][31] = 5,
	[369][32] = 5,
	[369][33] = 5,
	[369][34] = 5,
	[369][35] = 5,
	[369][40] = 5,
	[372][15] = 6,
	[372][16] = 6,
	[372][17] = 6,
	[372][18] = 6,
	[372][23] = 6,
	[372][24] = 6,
	[372][25] = 6,
	[372][26] = 6,
	[372][27] = 6,
	[372][28] = 6,
	[372][29] = 6,
	[372][30] = 6,
	[372][31] = 6,
	[372][32] = 6,
	[372][33] = 6,
	[372][34] = 6,
	[372][35] = 6,
	[372][40] = 6,
	[373][16] = 7,
	[373][17] = 7,
	[373][18] = 7,
	[373][31] = 7,
	[373][32] = 7,
	[373][33] = 7,
	[373][34] = 7,
	[373][35] = 7,
	[373][40] = 7,
	[374][33] = 9,
	[374][34] = 9,
	[374][35] = 9,
	[374][40] = 9,
	[375][15] = 10,
	[375][16] = 10,
	[375][17] = 10,
	[375][18] = 10,
	[375][31] = 10,
	[375][32] = 10,
	[375][33] = 10,
	[375][34] = 10,
	[375][35] = 10,
	[375][40] = 10,
	[376][17] = 11,
	[376][18] = 11,
	[376][31] = 11,
	[376][32] = 11,
	[376][33] = 11,
	[376][34] = 11,
	[376][35] = 11,
	[376][40] = 11,
	[377][6] = 12,
	[377][9] = 12,
	[377][13] = 12,
	[377][15] = 12,
	[377][16] = 12,
	[377][17] = 12,
	[377][18] = 12,
	[377][19] = 12,
	[377][22] = 12,
	[377][23] = 12,
	[377][24] = 12,
	[377][25] = 12,
	[377][26] = 12,
	[377][27] = 12,
	[377][28] = 12,
	[377][29] = 12,
	[377][30] = 12,
	[377][31] = 12,
	[377][32] = 12,
	[377][33] = 12,
	[377][34] = 12,
	[377][35] = 12,
	[377][40] = 12,
	[379][40] = 14,
	[380][18] = 15,
	[380][31] = 15,
	[380][32] = 15,
	[380][33] = 15,
	[380][34] = 15,
	[380][35] = 15,
	[380][40] = 15,
	[381][34] = 16,
	[381][35] = 16,
	[381][40] = 16,
	[382][18] = 17,
	[382][32] = 17,
	[382][33] = 17,
	[382][34] = 17,
	[382][35] = 17,
	[382][40] = 17,
	[383][33] = 18,
	[383][34] = 18,
	[383][35] = 18,
	[383][40] = 18,
	[384][6] = 19,
	[384][9] = 19,
	[384][15] = 19,
	[384][16] = 19,
	[384][17] = 19,
	[384][18] = 19,
	[384][23] = 19,
	[384][24] = 19,
	[384][25] = 19,
	[384][26] = 19,
	[384][27] = 19,
	[384][28] = 19,
	[384][29] = 19,
	[384][30] = 19,
	[384][31] = 19,
	[384][32] = 19,
	[384][33] = 19,
	[384][34] = 19,
	[384][35] = 19,
	[384][40] = 19,
	[385][35] = 20,
	[385][40] = 20,
	[386][6] = 21,
	[386][9] = 21,
	[386][13] = 21,
	[386][15] = 21,
	[386][16] = 21,
	[386][17] = 21,
	[386][18] = 21,
	[386][19] = 21,
	[386][21] = 21,
	[386][22] = 21,
	[386][23] = 21,
	[386][24] = 21,
	[386][25] = 21,
	[386][26] = 21,
	[386][27] = 21,
	[386][28] = 21,
	[386][29] = 21,
	[386][30] = 21,
	[386][31] = 21,
	[386][32] = 21,
	[386][33] = 21,
	[386][34] = 21,
	[386][35] = 21,
	[386][40] = 21,
	[387][4] = 22,
	[387][6] = 22,
	[387][8] = 22,
	[387][9] = 22,
	[387][13] = 22,
	[387][15] = 22,
	[387][16] = 22,
	[387][17] = 22,
	[387][18] = 22,
	[387][19] = 22,
	[387][20] = 22,
	[387][21] = 22,
	[387][22] = 22,
	[387][23] = 22,
	[387][24] = 22,
	[387][25] = 22,
	[387][26] = 22,
	[387][27] = 22,
	[387][28] = 22,
	[387][29] = 22,
	[387][30] = 22,
	[387][31] = 22,
	[387][32] = 22,
	[387][33] = 22,
	[387][34] = 22,
	[387][35] = 22,
	[387][40] = 22,
	[388][15] = 23,
	[388][16] = 23,
	[388][17] = 23,
	[388][18] = 23,
	[388][29] = 23,
	[388][30] = 23,
	[388][31] = 23,
	[388][32] = 23,
	[388][33] = 23,
	[388][34] = 23,
	[388][35] = 23,
	[388][40] = 23,
	[389][15] = 24,
	[389][16] = 24,
	[389][17] = 24,
	[389][18] = 24,
	[389][25] = 24,
	[389][26] = 24,
	[389][27] = 24,
	[389][28] = 24,
	[389][29] = 24,
	[389][30] = 24,
	[389][31] = 24,
	[389][32] = 24,
	[389][33] = 24,
	[389][34] = 24,
	[389][35] = 24,
	[389][40] = 24,
	[390][6] = 27,
	[390][9] = 27,
	[390][13] = 27,
	[390][15] = 27,
	[390][16] = 27,
	[390][17] = 27,
	[390][18] = 27,
	[390][19] = 27,
	[390][21] = 27,
	[390][22] = 27,
	[390][23] = 27,
	[390][24] = 27,
	[390][25] = 27,
	[390][26] = 27,
	[390][27] = 27,
	[390][28] = 27,
	[390][29] = 27,
	[390][30] = 27,
	[390][31] = 27,
	[390][32] = 27,
	[390][33] = 27,
	[390][34] = 27,
	[390][35] = 27,
	[390][40] = 27,
	[391][18] = 127,
	[391][32] = 127,
	[391][33] = 127,
	[391][34] = 127,
	[391][35] = 127,
	[391][36] = 127,
	[392][6] = 128,
	[392][9] = 128,
	[392][13] = 128,
	[392][15] = 128,
	[392][16] = 128,
	[392][17] = 128,
	[392][18] = 128,
	[392][19] = 128,
	[392][22] = 128,
	[392][23] = 128,
	[392][24] = 128,
	[392][25] = 128,
	[392][26] = 128,
	[392][27] = 128,
	[392][28] = 128,
	[392][29] = 128,
	[392][30] = 128,
	[392][31] = 128,
	[392][32] = 128,
	[392][33] = 128,
	[392][34] = 128,
	[392][35] = 128,
	[392][36] = 128,
	[393][6] = 129,
	[393][9] = 129,
	[393][13] = 129,
	[393][15] = 129,
	[393][16] = 129,
	[393][17] = 129,
	[393][18] = 129,
	[393][19] = 129,
	[393][22] = 129,
	[393][23] = 129,
	[393][24] = 129,
	[393][25] = 129,
	[393][26] = 129,
	[393][27] = 129,
	[393][28] = 129,
	[393][29] = 129,
	[393][30] = 129,
	[393][31] = 129,
	[393][32] = 129,
	[393][33] = 129,
	[393][34] = 129,
	[393][35] = 129,
	[393][36] = 129,
	[394][6] = 130,
	[394][9] = 130,
	[394][13] = 130,
	[394][15] = 130,
	[394][16] = 130,
	[394][17] = 130,
	[394][18] = 130,
	[394][19] = 130,
	[394][22] = 130,
	[394][23] = 130,
	[394][24] = 130,
	[394][25] = 130,
	[394][26] = 130,
	[394][27] = 130,
	[394][28] = 130,
	[394][29] = 130,
	[394][30] = 130,
	[394][31] = 130,
	[394][32] = 130,
	[394][33] = 130,
	[394][34] = 130,
	[394][35] = 130,
	[394][36] = 130,
	[395][35] = 131,
	[395][36] = 131,
	[396][35] = 132,
	[396][36] = 132,
	[397][4] = 133,
	[397][6] = 133,
	[397][8] = 133,
	[397][9] = 133,
	[397][13] = 133,
	[397][15] = 133,
	[397][16] = 133,
	[397][17] = 133,
	[397][18] = 133,
	[397][19] = 133,
	[397][20] = 133,
	[397][21] = 133,
	[397][22] = 133,
	[397][23] = 133,
	[397][24] = 133,
	[397][25] = 133,
	[397][26] = 133,
	[397][27] = 133,
	[397][28] = 133,
	[397][29] = 133,
	[397][30] = 133,
	[397][31] = 133,
	[397][32] = 133,
	[397][33] = 133,
	[397][34] = 133,
	[397][35] = 133,
	[397][36] = 133,
	[400][4] = 1,
	[400][6] = 1,
	[400][8] = 1,
	[400][9] = 1,
	[400][13] = 1,
	[400][15] = 1,
	[400][16] = 1,
	[400][17] = 1,
	[400][18] = 1,
	[400][19] = 1,
	[400][20] = 1,
	[400][21] = 1,
	[400][22] = 1,
	[400][23] = 1,
	[400][24] = 1,
	[400][25] = 1,
	[400][26] = 1,
	[400][27] = 1,
	[400][28] = 1,
	[400][29] = 1,
	[400][30] = 1,
	[400][31] = 1,
	[400][32] = 1,
	[400][33] = 1,
	[400][34] = 1,
	[400][35] = 1,
	[400][39] = 1,
	[401][4] = 2,
	[401][6] = 2,
	[401][8] = 2,
	[401][9] = 2,
	[401][13] = 2,
	[401][15] = 2,
	[401][16] = 2,
	[401][17] = 2,
	[401][18] = 2,
	[401][19] = 2,
	[401][20] = 2,
	[401][21] = 2,
	[401][22] = 2,
	[401][23] = 2,
	[401][24] = 2,
	[401][25] = 2,
	[401][26] = 2,
	[401][27] = 2,
	[401][28] = 2,
	[401][29] = 2,
	[401][30] = 2,
	[401][31] = 2,
	[401][32] = 2,
	[401][33] = 2,
	[401][34] = 2,
	[401][35] = 2,
	[401][39] = 2,
	[405][4] = 3,
	[405][6] = 3,
	[405][8] = 3,
	[405][9] = 3,
	[405][13] = 3,
	[405][15] = 3,
	[405][16] = 3,
	[405][17] = 3,
	[405][18] = 3,
	[405][19] = 3,
	[405][20] = 3,
	[405][21] = 3,
	[405][22] = 3,
	[405][23] = 3,
	[405][24] = 3,
	[405][25] = 3,
	[405][26] = 3,
	[405][27] = 3,
	[405][28] = 3,
	[405][29] = 3,
	[405][30] = 3,
	[405][31] = 3,
	[405][32] = 3,
	[405][33] = 3,
	[405][34] = 3,
	[405][35] = 3,
	[405][39] = 3,
	[408][4] = 4,
	[408][6] = 4,
	[408][8] = 4,
	[408][9] = 4,
	[408][13] = 4,
	[408][15] = 4,
	[408][16] = 4,
	[408][17] = 4,
	[408][18] = 4,
	[408][19] = 4,
	[408][20] = 4,
	[408][21] = 4,
	[408][22] = 4,
	[408][23] = 4,
	[408][24] = 4,
	[408][25] = 4,
	[408][26] = 4,
	[408][27] = 4,
	[408][28] = 4,
	[408][29] = 4,
	[408][30] = 4,
	[408][31] = 4,
	[408][32] = 4,
	[408][33] = 4,
	[408][34] = 4,
	[408][35] = 4,
	[408][39] = 4,
	[409][4] = 5,
	[409][6] = 5,
	[409][8] = 5,
	[409][9] = 5,
	[409][13] = 5,
	[409][15] = 5,
	[409][16] = 5,
	[409][17] = 5,
	[409][18] = 5,
	[409][19] = 5,
	[409][20] = 5,
	[409][21] = 5,
	[409][22] = 5,
	[409][23] = 5,
	[409][24] = 5,
	[409][25] = 5,
	[409][26] = 5,
	[409][27] = 5,
	[409][28] = 5,
	[409][29] = 5,
	[409][30] = 5,
	[409][31] = 5,
	[409][32] = 5,
	[409][33] = 5,
	[409][34] = 5,
	[409][35] = 5,
	[409][39] = 5,
	[412][15] = 6,
	[412][16] = 6,
	[412][17] = 6,
	[412][18] = 6,
	[412][23] = 6,
	[412][24] = 6,
	[412][25] = 6,
	[412][26] = 6,
	[412][27] = 6,
	[412][28] = 6,
	[412][29] = 6,
	[412][30] = 6,
	[412][31] = 6,
	[412][32] = 6,
	[412][33] = 6,
	[412][34] = 6,
	[412][35] = 6,
	[412][39] = 6,
	[413][16] = 7,
	[413][17] = 7,
	[413][18] = 7,
	[413][31] = 7,
	[413][32] = 7,
	[413][33] = 7,
	[413][34] = 7,
	[413][35] = 7,
	[413][39] = 7,
	[414][33] = 9,
	[414][34] = 9,
	[414][35] = 9,
	[414][39] = 9,
	[415][15] = 10,
	[415][16] = 10,
	[415][17] = 10,
	[415][18] = 10,
	[415][31] = 10,
	[415][32] = 10,
	[415][33] = 10,
	[415][34] = 10,
	[415][35] = 10,
	[415][39] = 10,
	[416][17] = 11,
	[416][18] = 11,
	[416][31] = 11,
	[416][32] = 11,
	[416][33] = 11,
	[416][34] = 11,
	[416][35] = 11,
	[416][39] = 11,
	[417][6] = 12,
	[417][9] = 12,
	[417][13] = 12,
	[417][15] = 12,
	[417][16] = 12,
	[417][17] = 12,
	[417][18] = 12,
	[417][19] = 12,
	[417][22] = 12,
	[417][23] = 12,
	[417][24] = 12,
	[417][25] = 12,
	[417][26] = 12,
	[417][27] = 12,
	[417][28] = 12,
	[417][29] = 12,
	[417][30] = 12,
	[417][31] = 12,
	[417][32] = 12,
	[417][33] = 12,
	[417][34] = 12,
	[417][35] = 12,
	[417][39] = 12,
	[419][39] = 14,
	[420][18] = 15,
	[420][31] = 15,
	[420][32] = 15,
	[420][33] = 15,
	[420][34] = 15,
	[420][35] = 15,
	[420][39] = 15,
	[421][34] = 16,
	[421][35] = 16,
	[421][39] = 16,
	[422][18] = 17,
	[422][32] = 17,
	[422][33] = 17,
	[422][34] = 17,
	[422][35] = 17,
	[422][39] = 17,
	[423][33] = 18,
	[423][34] = 18,
	[423][35] = 18,
	[423][39] = 18,
	[424][6] = 19,
	[424][9] = 19,
	[424][15] = 19,
	[424][16] = 19,
	[424][17] = 19,
	[424][18] = 19,
	[424][23] = 19,
	[424][24] = 19,
	[424][25] = 19,
	[424][26] = 19,
	[424][27] = 19,
	[424][28] = 19,
	[424][29] = 19,
	[424][30] = 19,
	[424][31] = 19,
	[424][32] = 19,
	[424][33] = 19,
	[424][34] = 19,
	[424][35] = 19,
	[424][39] = 19,
	[425][35] = 20,
	[425][39] = 20,
	[426][6] = 21,
	[426][9] = 21,
	[426][13] = 21,
	[426][15] = 21,
	[426][16] = 21,
	[426][17] = 21,
	[426][18] = 21,
	[426][19] = 21,
	[426][21] = 21,
	[426][22] = 21,
	[426][23] = 21,
	[426][24] = 21,
	[426][25] = 21,
	[426][26] = 21,
	[426][27] = 21,
	[426][28] = 21,
	[426][29] = 21,
	[426][30] = 21,
	[426][31] = 21,
	[426][32] = 21,
	[426][33] = 21,
	[426][34] = 21,
	[426][35] = 21,
	[426][39] = 21,
	[427][4] = 22,
	[427][6] = 22,
	[427][8] = 22,
	[427][9] = 22,
	[427][13] = 22,
	[427][15] = 22,
	[427][16] = 22,
	[427][17] = 22,
	[427][18] = 22,
	[427][19] = 22,
	[427][20] = 22,
	[427][21] = 22,
	[427][22] = 22,
	[427][23] = 22,
	[427][24] = 22,
	[427][25] = 22,
	[427][26] = 22,
	[427][27] = 22,
	[427][28] = 22,
	[427][29] = 22,
	[427][30] = 22,
	[427][31] = 22,
	[427][32] = 22,
	[427][33] = 22,
	[427][34] = 22,
	[427][35] = 22,
	[427][39] = 22,
	[428][15] = 23,
	[428][16] = 23,
	[428][17] = 23,
	[428][18] = 23,
	[428][29] = 23,
	[428][30] = 23,
	[428][31] = 23,
	[428][32] = 23,
	[428][33] = 23,
	[428][34] = 23,
	[428][35] = 23,
	[428][39] = 23,
	[429][15] = 24,
	[429][16] = 24,
	[429][17] = 24,
	[429][18] = 24,
	[429][25] = 24,
	[429][26] = 24,
	[429][27] = 24,
	[429][28] = 24,
	[429][29] = 24,
	[429][30] = 24,
	[429][31] = 24,
	[429][32] = 24,
	[429][33] = 24,
	[429][34] = 24,
	[429][35] = 24,
	[429][39] = 24,
	[430][6] = 27,
	[430][9] = 27,
	[430][13] = 27,
	[430][15] = 27,
	[430][16] = 27,
	[430][17] = 27,
	[430][18] = 27,
	[430][19] = 27,
	[430][21] = 27,
	[430][22] = 27,
	[430][23] = 27,
	[430][24] = 27,
	[430][25] = 27,
	[430][26] = 27,
	[430][27] = 27,
	[430][28] = 27,
	[430][29] = 27,
	[430][30] = 27,
	[430][31] = 27,
	[430][32] = 27,
	[430][33] = 27,
	[430][34] = 27,
	[430][35] = 27,
	[430][39] = 27,
	[431][4] = 134,
	[431][6] = 134,
	[431][8] = 134,
	[431][9] = 134,
	[431][13] = 134,
	[431][15] = 134,
	[431][16] = 134,
	[431][17] = 134,
	[431][18] = 134,
	[431][19] = 134,
	[431][20] = 134,
	[431][21] = 134,
	[431][22] = 134,
	[431][23] = 134,
	[431][24] = 134,
	[431][25] = 134,
	[431][26] = 134,
	[431][27] = 134,
	[431][28] = 134,
	[431][29] = 134,
	[431][30] = 134,
	[431][31] = 134,
	[431][32] = 134,
	[431][33] = 134,
	[431][34] = 134,
	[431][35] = 134,
	[431][36] = 134,
	[432][15] = 135,
	[432][16] = 135,
	[432][17] = 135,
	[432][18] = 135,
	[432][25] = 135,
	[432][26] = 135,
	[432][27] = 135,
	[432][28] = 135,
	[432][29] = 135,
	[432][30] = 135,
	[432][31] = 135,
	[432][32] = 135,
	[432][33] = 135,
	[432][34] = 135,
	[432][35] = 135,
	[432][36] = 135,
	[433][15] = 136,
	[433][16] = 136,
	[433][17] = 136,
	[433][18] = 136,
	[433][25] = 136,
	[433][26] = 136,
	[433][27] = 136,
	[433][28] = 136,
	[433][29] = 136,
	[433][30] = 136,
	[433][31] = 136,
	[433][32] = 136,
	[433][33] = 136,
	[433][34] = 136,
	[433][35] = 136,
	[433][36] = 136,
	[434][15] = 137,
	[434][16] = 137,
	[434][17] = 137,
	[434][18] = 137,
	[434][25] = 137,
	[434][26] = 137,
	[434][27] = 137,
	[434][28] = 137,
	[434][29] = 137,
	[434][30] = 137,
	[434][31] = 137,
	[434][32] = 137,
	[434][33] = 137,
	[434][34] = 137,
	[434][35] = 137,
	[434][36] = 137,
	[435][15] = 138,
	[435][16] = 138,
	[435][17] = 138,
	[435][18] = 138,
	[435][25] = 138,
	[435][26] = 138,
	[435][27] = 138,
	[435][28] = 138,
	[435][29] = 138,
	[435][30] = 138,
	[435][31] = 138,
	[435][32] = 138,
	[435][33] = 138,
	[435][34] = 138,
	[435][35] = 138,
	[435][36] = 138,
	[436][15] = 139,
	[436][16] = 139,
	[436][17] = 139,
	[436][18] = 139,
	[436][23] = 139,
	[436][24] = 139,
	[436][25] = 139,
	[436][26] = 139,
	[436][27] = 139,
	[436][28] = 139,
	[436][29] = 139,
	[436][30] = 139,
	[436][31] = 139,
	[436][32] = 139,
	[436][33] = 139,
	[436][34] = 139,
	[436][35] = 139,
	[436][36] = 139,
	[437][15] = 140,
	[437][16] = 140,
	[437][17] = 140,
	[437][18] = 140,
	[437][23] = 140,
	[437][24] = 140,
	[437][25] = 140,
	[437][26] = 140,
	[437][27] = 140,
	[437][28] = 140,
	[437][29] = 140,
	[437][30] = 140,
	[437][31] = 140,
	[437][32] = 140,
	[437][33] = 140,
	[437][34] = 140,
	[437][35] = 140,
	[437][36] = 140,
	[438][53] = 141,
	[439][53] = 142,
	[440][53] = 143,
	[441][53] = 144,
	[442][53] = 145,
	[443][53] = 146,
	[444][53] = 147,
	[445][53] = 148,
	[446][53] = 149,
	[447][53] = 150,
	[448][53] = 151,
	[449][53] = 152,
	[450][53] = 153,
	[451][53] = 154,
	[452][53] = 155,
	[453][53] = 156,
	[454][53] = 157,
	[455][53] = 158,
	[456][53] = 159,
	[457][53] = 160,
	[458][53] = 161,
	[459][53] = 162,
	[460][53] = 163,
	[461][53] = 164,
	[462][4] = 86,
	[462][6] = 86,
	[462][8] = 86,
	[462][9] = 86,
	[462][13] = 86,
	[462][15] = 86,
	[462][16] = 86,
	[462][17] = 86,
	[462][18] = 86,
	[462][19] = 86,
	[462][20] = 86,
	[462][21] = 86,
	[462][22] = 86,
	[462][23] = 86,
	[462][24] = 86,
	[462][25] = 86,
	[462][26] = 86,
	[462][27] = 86,
	[462][28] = 86,
	[462][29] = 86,
	[462][30] = 86,
	[462][31] = 86,
	[462][32] = 86,
	[462][33] = 86,
	[462][34] = 86,
	[462][35] = 86,
	[462][37] = 86,
	[462][38] = 86,
	[464][4] = 87,
	[464][6] = 87,
	[464][8] = 87,
	[464][9] = 87,
	[464][13] = 87,
	[464][15] = 87,
	[464][16] = 87,
	[464][17] = 87,
	[464][18] = 87,
	[464][19] = 87,
	[464][20] = 87,
	[464][21] = 87,
	[464][22] = 87,
	[464][23] = 87,
	[464][24] = 87,
	[464][25] = 87,
	[464][26] = 87,
	[464][27] = 87,
	[464][28] = 87,
	[464][29] = 87,
	[464][30] = 87,
	[464][31] = 87,
	[464][32] = 87,
	[464][33] = 87,
	[464][34] = 87,
	[464][35] = 87,
	[464][37] = 87,
	[464][38] = 87,
	[466][4] = 165,
	[466][6] = 165,
	[466][8] = 165,
	[466][9] = 165,
	[466][13] = 165,
	[466][15] = 165,
	[466][16] = 165,
	[466][17] = 165,
	[466][18] = 165,
	[466][19] = 165,
	[466][20] = 165,
	[466][21] = 165,
	[466][22] = 165,
	[466][23] = 165,
	[466][24] = 165,
	[466][25] = 165,
	[466][26] = 165,
	[466][27] = 165,
	[466][28] = 165,
	[466][29] = 165,
	[466][30] = 165,
	[466][31] = 165,
	[466][32] = 165,
	[466][33] = 165,
	[466][34] = 165,
	[466][35] = 165,
	[466][36] = 165,
	[468][4] = 88,
	[468][6] = 88,
	[468][8] = 88,
	[468][9] = 88,
	[468][13] = 88,
	[468][15] = 88,
	[468][16] = 88,
	[468][17] = 88,
	[468][18] = 88,
	[468][19] = 88,
	[468][20] = 88,
	[468][21] = 88,
	[468][22] = 88,
	[468][23] = 88,
	[468][24] = 88,
	[468][25] = 88,
	[468][26] = 88,
	[468][27] = 88,
	[468][28] = 88,
	[468][29] = 88,
	[468][30] = 88,
	[468][31] = 88,
	[468][32] = 88,
	[468][33] = 88,
	[468][34] = 88,
	[468][35] = 88,
	[468][37] = 88,
	[468][38] = 88,
	[471][4] = 89,
	[471][6] = 89,
	[471][8] = 89,
	[471][9] = 89,
	[471][13] = 89,
	[471][15] = 89,
	[471][16] = 89,
	[471][17] = 89,
	[471][18] = 89,
	[471][19] = 89,
	[471][20] = 89,
	[471][21] = 89,
	[471][22] = 89,
	[471][23] = 89,
	[471][24] = 89,
	[471][25] = 89,
	[471][26] = 89,
	[471][27] = 89,
	[471][28] = 89,
	[471][29] = 89,
	[471][30] = 89,
	[471][31] = 89,
	[471][32] = 89,
	[471][33] = 89,
	[471][34] = 89,
	[471][35] = 89,
	[471][37] = 89,
	[471][38] = 89,
	[472][33] = 99,
	[472][34] = 99,
	[472][35] = 99,
	[472][37] = 99,
	[472][38] = 99,
	[474][33] = 100,
	[474][34] = 100,
	[474][35] = 100,
	[474][37] = 100,
	[474][38] = 100,
	[475][33] = 101,
	[475][34] = 101,
	[475][35] = 101,
	[475][37] = 101,
	[475][38] = 101,
	[477][6] = 103,
	[477][9] = 103,
	[477][15] = 103,
	[477][16] = 103,
	[477][17] = 103,
	[477][18] = 103,
	[477][23] = 103,
	[477][24] = 103,
	[477][25] = 103,
	[477][26] = 103,
	[477][27] = 103,
	[477][28] = 103,
	[477][29] = 103,
	[477][30] = 103,
	[477][31] = 103,
	[477][32] = 103,
	[477][33] = 103,
	[477][34] = 103,
	[477][35] = 103,
	[477][37] = 103,
	[477][38] = 103,
	[478][6] = 104,
	[478][9] = 104,
	[478][15] = 104,
	[478][16] = 104,
	[478][17] = 104,
	[478][18] = 104,
	[478][23] = 104,
	[478][24] = 104,
	[478][25] = 104,
	[478][26] = 104,
	[478][27] = 104,
	[478][28] = 104,
	[478][29] = 104,
	[478][30] = 104,
	[478][31] = 104,
	[478][32] = 104,
	[478][33] = 104,
	[478][34] = 104,
	[478][35] = 104,
	[478][37] = 104,
	[478][38] = 104,
	[479][15] = 105,
	[479][16] = 105,
	[479][17] = 105,
	[479][18] = 105,
	[479][31] = 105,
	[479][32] = 105,
	[479][33] = 105,
	[479][34] = 105,
	[479][35] = 105,
	[479][37] = 105,
	[479][38] = 105,
	[480][15] = 112,
	[480][16] = 112,
	[480][17] = 112,
	[480][18] = 112,
	[480][29] = 112,
	[480][30] = 112,
	[480][31] = 112,
	[480][32] = 112,
	[480][33] = 112,
	[480][34] = 112,
	[480][35] = 112,
	[480][37] = 112,
	[480][38] = 112,
	[481][15] = 113,
	[481][16] = 113,
	[481][17] = 113,
	[481][18] = 113,
	[481][29] = 113,
	[481][30] = 113,
	[481][31] = 113,
	[481][32] = 113,
	[481][33] = 113,
	[481][34] = 113,
	[481][35] = 113,
	[481][37] = 113,
	[481][38] = 113,
	[482][16] = 114,
	[482][17] = 114,
	[482][18] = 114,
	[482][31] = 114,
	[482][32] = 114,
	[482][33] = 114,
	[482][34] = 114,
	[482][35] = 114,
	[482][37] = 114,
	[482][38] = 114,
	[483][6] = 115,
	[483][9] = 115,
	[483][13] = 115,
	[483][15] = 115,
	[483][16] = 115,
	[483][17] = 115,
	[483][18] = 115,
	[483][19] = 115,
	[483][21] = 115,
	[483][22] = 115,
	[483][23] = 115,
	[483][24] = 115,
	[483][25] = 115,
	[483][26] = 115,
	[483][27] = 115,
	[483][28] = 115,
	[483][29] = 115,
	[483][30] = 115,
	[483][31] = 115,
	[483][32] = 115,
	[483][33] = 115,
	[483][34] = 115,
	[483][35] = 115,
	[483][37] = 115,
	[483][38] = 115,
	[484][4] = 166,
	[484][6] = 166,
	[484][8] = 166,
	[484][9] = 166,
	[484][13] = 166,
	[484][15] = 166,
	[484][16] = 166,
	[484][17] = 166,
	[484][18] = 166,
	[484][19] = 166,
	[484][20] = 166,
	[484][21] = 166,
	[484][22] = 166,
	[484][23] = 166,
	[484][24] = 166,
	[484][25] = 166,
	[484][26] = 166,
	[484][27] = 166,
	[484][28] = 166,
	[484][29] = 166,
	[484][30] = 166,
	[484][31] = 166,
	[484][32] = 166,
	[484][33] = 166,
	[484][34] = 166,
	[484][35] = 166,
	[484][36] = 166,
	[485][37] = 122,
	[485][38] = 122,
	[486][37] = 123,
	[486][38] = 123,
	[487][17] = 124,
	[487][18] = 124,
	[487][31] = 124,
	[487][32] = 124,
	[487][33] = 124,
	[487][34] = 124,
	[487][35] = 124,
	[487][37] = 124,
	[487][38] = 124,
	[488][34] = 125,
	[488][35] = 125,
	[488][37] = 125,
	[488][38] = 125,
	[489][18] = 126,
	[489][31] = 126,
	[489][32] = 126,
	[489][33] = 126,
	[489][34] = 126,
	[489][35] = 126,
	[489][37] = 126,
	[489][38] = 126,
	[491][18] = 127,
	[491][32] = 127,
	[491][33] = 127,
	[491][34] = 127,
	[491][35] = 127,
	[491][37] = 127,
	[491][38] = 127,
	[492][6] = 128,
	[492][9] = 128,
	[492][13] = 128,
	[492][15] = 128,
	[492][16] = 128,
	[492][17] = 128,
	[492][18] = 128,
	[492][19] = 128,
	[492][22] = 128,
	[492][23] = 128,
	[492][24] = 128,
	[492][25] = 128,
	[492][26] = 128,
	[492][27] = 128,
	[492][28] = 128,
	[492][29] = 128,
	[492][30] = 128,
	[492][31] = 128,
	[492][32] = 128,
	[492][33] = 128,
	[492][34] = 128,
	[492][35] = 128,
	[492][37] = 128,
	[492][38] = 128,
	[493][6] = 129,
	[493][9] = 129,
	[493][13] = 129,
	[493][15] = 129,
	[493][16] = 129,
	[493][17] = 129,
	[493][18] = 129,
	[493][19] = 129,
	[493][22] = 129,
	[493][23] = 129,
	[493][24] = 129,
	[493][25] = 129,
	[493][26] = 129,
	[493][27] = 129,
	[493][28] = 129,
	[493][29] = 129,
	[493][30] = 129,
	[493][31] = 129,
	[493][32] = 129,
	[493][33] = 129,
	[493][34] = 129,
	[493][35] = 129,
	[493][37] = 129,
	[493][38] = 129,
	[494][6] = 130,
	[494][9] = 130,
	[494][13] = 130,
	[494][15] = 130,
	[494][16] = 130,
	[494][17] = 130,
	[494][18] = 130,
	[494][19] = 130,
	[494][22] = 130,
	[494][23] = 130,
	[494][24] = 130,
	[494][25] = 130,
	[494][26] = 130,
	[494][27] = 130,
	[494][28] = 130,
	[494][29] = 130,
	[494][30] = 130,
	[494][31] = 130,
	[494][32] = 130,
	[494][33] = 130,
	[494][34] = 130,
	[494][35] = 130,
	[494][37] = 130,
	[494][38] = 130,
	[495][35] = 131,
	[495][37] = 131,
	[495][38] = 131,
	[496][35] = 132,
	[496][37] = 132,
	[496][38] = 132,
	[497][4] = 133,
	[497][6] = 133,
	[497][8] = 133,
	[497][9] = 133,
	[497][13] = 133,
	[497][15] = 133,
	[497][16] = 133,
	[497][17] = 133,
	[497][18] = 133,
	[497][19] = 133,
	[497][20] = 133,
	[497][21] = 133,
	[497][22] = 133,
	[497][23] = 133,
	[497][24] = 133,
	[497][25] = 133,
	[497][26] = 133,
	[497][27] = 133,
	[497][28] = 133,
	[497][29] = 133,
	[497][30] = 133,
	[497][31] = 133,
	[497][32] = 133,
	[497][33] = 133,
	[497][34] = 133,
	[497][35] = 133,
	[497][37] = 133,
	[497][38] = 133,
	[501][4] = 134,
	[501][6] = 134,
	[501][8] = 134,
	[501][9] = 134,
	[501][13] = 134,
	[501][15] = 134,
	[501][16] = 134,
	[501][17] = 134,
	[501][18] = 134,
	[501][19] = 134,
	[501][20] = 134,
	[501][21] = 134,
	[501][22] = 134,
	[501][23] = 134,
	[501][24] = 134,
	[501][25] = 134,
	[501][26] = 134,
	[501][27] = 134,
	[501][28] = 134,
	[501][29] = 134,
	[501][30] = 134,
	[501][31] = 134,
	[501][32] = 134,
	[501][33] = 134,
	[501][34] = 134,
	[501][35] = 134,
	[501][37] = 134,
	[501][38] = 134,
	[502][15] = 135,
	[502][16] = 135,
	[502][17] = 135,
	[502][18] = 135,
	[502][25] = 135,
	[502][26] = 135,
	[502][27] = 135,
	[502][28] = 135,
	[502][29] = 135,
	[502][30] = 135,
	[502][31] = 135,
	[502][32] = 135,
	[502][33] = 135,
	[502][34] = 135,
	[502][35] = 135,
	[502][37] = 135,
	[502][38] = 135,
	[503][15] = 136,
	[503][16] = 136,
	[503][17] = 136,
	[503][18] = 136,
	[503][25] = 136,
	[503][26] = 136,
	[503][27] = 136,
	[503][28] = 136,
	[503][29] = 136,
	[503][30] = 136,
	[503][31] = 136,
	[503][32] = 136,
	[503][33] = 136,
	[503][34] = 136,
	[503][35] = 136,
	[503][37] = 136,
	[503][38] = 136,
	[504][15] = 137,
	[504][16] = 137,
	[504][17] = 137,
	[504][18] = 137,
	[504][25] = 137,
	[504][26] = 137,
	[504][27] = 137,
	[504][28] = 137,
	[504][29] = 137,
	[504][30] = 137,
	[504][31] = 137,
	[504][32] = 137,
	[504][33] = 137,
	[504][34] = 137,
	[504][35] = 137,
	[504][37] = 137,
	[504][38] = 137,
	[505][15] = 138,
	[505][16] = 138,
	[505][17] = 138,
	[505][18] = 138,
	[505][25] = 138,
	[505][26] = 138,
	[505][27] = 138,
	[505][28] = 138,
	[505][29] = 138,
	[505][30] = 138,
	[505][31] = 138,
	[505][32] = 138,
	[505][33] = 138,
	[505][34] = 138,
	[505][35] = 138,
	[505][37] = 138,
	[505][38] = 138,
	[506][15] = 139,
	[506][16] = 139,
	[506][17] = 139,
	[506][18] = 139,
	[506][23] = 139,
	[506][24] = 139,
	[506][25] = 139,
	[506][26] = 139,
	[506][27] = 139,
	[506][28] = 139,
	[506][29] = 139,
	[506][30] = 139,
	[506][31] = 139,
	[506][32] = 139,
	[506][33] = 139,
	[506][34] = 139,
	[506][35] = 139,
	[506][37] = 139,
	[506][38] = 139,
	[507][15] = 140,
	[507][16] = 140,
	[507][17] = 140,
	[507][18] = 140,
	[507][23] = 140,
	[507][24] = 140,
	[507][25] = 140,
	[507][26] = 140,
	[507][27] = 140,
	[507][28] = 140,
	[507][29] = 140,
	[507][30] = 140,
	[507][31] = 140,
	[507][32] = 140,
	[507][33] = 140,
	[507][34] = 140,
	[507][35] = 140,
	[507][37] = 140,
	[507][38] = 140,
	[508][4] = 86,
	[508][6] = 86,
	[508][8] = 86,
	[508][9] = 86,
	[508][13] = 86,
	[508][15] = 86,
	[508][16] = 86,
	[508][17] = 86,
	[508][18] = 86,
	[508][19] = 86,
	[508][20] = 86,
	[508][21] = 86,
	[508][22] = 86,
	[508][23] = 86,
	[508][24] = 86,
	[508][25] = 86,
	[508][26] = 86,
	[508][27] = 86,
	[508][28] = 86,
	[508][29] = 86,
	[508][30] = 86,
	[508][31] = 86,
	[508][32] = 86,
	[508][33] = 86,
	[508][34] = 86,
	[508][35] = 86,
	[508][38] = 86,
	[508][39] = 86,
	[510][4] = 87,
	[510][6] = 87,
	[510][8] = 87,
	[510][9] = 87,
	[510][13] = 87,
	[510][15] = 87,
	[510][16] = 87,
	[510][17] = 87,
	[510][18] = 87,
	[510][19] = 87,
	[510][20] = 87,
	[510][21] = 87,
	[510][22] = 87,
	[510][23] = 87,
	[510][24] = 87,
	[510][25] = 87,
	[510][26] = 87,
	[510][27] = 87,
	[510][28] = 87,
	[510][29] = 87,
	[510][30] = 87,
	[510][31] = 87,
	[510][32] = 87,
	[510][33] = 87,
	[510][34] = 87,
	[510][35] = 87,
	[510][38] = 87,
	[510][39] = 87,
	[513][4] = 167,
	[513][6] = 167,
	[513][8] = 167,
	[513][9] = 167,
	[513][13] = 167,
	[513][15] = 167,
	[513][16] = 167,
	[513][17] = 167,
	[513][18] = 167,
	[513][19] = 167,
	[513][20] = 167,
	[513][21] = 167,
	[513][22] = 167,
	[513][23] = 167,
	[513][24] = 167,
	[513][25] = 167,
	[513][26] = 167,
	[513][27] = 167,
	[513][28] = 167,
	[513][29] = 167,
	[513][30] = 167,
	[513][31] = 167,
	[513][32] = 167,
	[513][33] = 167,
	[513][34] = 167,
	[513][35] = 167,
	[513][36] = 167,
	[514][4] = 88,
	[514][6] = 88,
	[514][8] = 88,
	[514][9] = 88,
	[514][13] = 88,
	[514][15] = 88,
	[514][16] = 88,
	[514][17] = 88,
	[514][18] = 88,
	[514][19] = 88,
	[514][20] = 88,
	[514][21] = 88,
	[514][22] = 88,
	[514][23] = 88,
	[514][24] = 88,
	[514][25] = 88,
	[514][26] = 88,
	[514][27] = 88,
	[514][28] = 88,
	[514][29] = 88,
	[514][30] = 88,
	[514][31] = 88,
	[514][32] = 88,
	[514][33] = 88,
	[514][34] = 88,
	[514][35] = 88,
	[514][38] = 88,
	[514][39] = 88,
	[517][4] = 89,
	[517][6] = 89,
	[517][8] = 89,
	[517][9] = 89,
	[517][13] = 89,
	[517][15] = 89,
	[517][16] = 89,
	[517][17] = 89,
	[517][18] = 89,
	[517][19] = 89,
	[517][20] = 89,
	[517][21] = 89,
	[517][22] = 89,
	[517][23] = 89,
	[517][24] = 89,
	[517][25] = 89,
	[517][26] = 89,
	[517][27] = 89,
	[517][28] = 89,
	[517][29] = 89,
	[517][30] = 89,
	[517][31] = 89,
	[517][32] = 89,
	[517][33] = 89,
	[517][34] = 89,
	[517][35] = 89,
	[517][38] = 89,
	[517][39] = 89,
	[518][33] = 99,
	[518][34] = 99,
	[518][35] = 99,
	[518][38] = 99,
	[518][39] = 99,
	[520][33] = 100,
	[520][34] = 100,
	[520][35] = 100,
	[520][38] = 100,
	[520][39] = 100,
	[521][33] = 101,
	[521][34] = 101,
	[521][35] = 101,
	[521][38] = 101,
	[521][39] = 101,
	[523][6] = 103,
	[523][9] = 103,
	[523][15] = 103,
	[523][16] = 103,
	[523][17] = 103,
	[523][18] = 103,
	[523][23] = 103,
	[523][24] = 103,
	[523][25] = 103,
	[523][26] = 103,
	[523][27] = 103,
	[523][28] = 103,
	[523][29] = 103,
	[523][30] = 103,
	[523][31] = 103,
	[523][32] = 103,
	[523][33] = 103,
	[523][34] = 103,
	[523][35] = 103,
	[523][38] = 103,
	[523][39] = 103,
	[524][6] = 104,
	[524][9] = 104,
	[524][15] = 104,
	[524][16] = 104,
	[524][17] = 104,
	[524][18] = 104,
	[524][23] = 104,
	[524][24] = 104,
	[524][25] = 104,
	[524][26] = 104,
	[524][27] = 104,
	[524][28] = 104,
	[524][29] = 104,
	[524][30] = 104,
	[524][31] = 104,
	[524][32] = 104,
	[524][33] = 104,
	[524][34] = 104,
	[524][35] = 104,
	[524][38] = 104,
	[524][39] = 104,
	[525][15] = 105,
	[525][16] = 105,
	[525][17] = 105,
	[525][18] = 105,
	[525][31] = 105,
	[525][32] = 105,
	[525][33] = 105,
	[525][34] = 105,
	[525][35] = 105,
	[525][38] = 105,
	[525][39] = 105,
	[526][15] = 112,
	[526][16] = 112,
	[526][17] = 112,
	[526][18] = 112,
	[526][29] = 112,
	[526][30] = 112,
	[526][31] = 112,
	[526][32] = 112,
	[526][33] = 112,
	[526][34] = 112,
	[526][35] = 112,
	[526][38] = 112,
	[526][39] = 112,
	[527][15] = 113,
	[527][16] = 113,
	[527][17] = 113,
	[527][18] = 113,
	[527][29] = 113,
	[527][30] = 113,
	[527][31] = 113,
	[527][32] = 113,
	[527][33] = 113,
	[527][34] = 113,
	[527][35] = 113,
	[527][38] = 113,
	[527][39] = 113,
	[528][16] = 114,
	[528][17] = 114,
	[528][18] = 114,
	[528][31] = 114,
	[528][32] = 114,
	[528][33] = 114,
	[528][34] = 114,
	[528][35] = 114,
	[528][38] = 114,
	[528][39] = 114,
	[529][6] = 115,
	[529][9] = 115,
	[529][13] = 115,
	[529][15] = 115,
	[529][16] = 115,
	[529][17] = 115,
	[529][18] = 115,
	[529][19] = 115,
	[529][21] = 115,
	[529][22] = 115,
	[529][23] = 115,
	[529][24] = 115,
	[529][25] = 115,
	[529][26] = 115,
	[529][27] = 115,
	[529][28] = 115,
	[529][29] = 115,
	[529][30] = 115,
	[529][31] = 115,
	[529][32] = 115,
	[529][33] = 115,
	[529][34] = 115,
	[529][35] = 115,
	[529][38] = 115,
	[529][39] = 115,
	[530][4] = 168,
	[530][6] = 168,
	[530][8] = 168,
	[530][9] = 168,
	[530][13] = 168,
	[530][15] = 168,
	[530][16] = 168,
	[530][17] = 168,
	[530][18] = 168,
	[530][19] = 168,
	[530][20] = 168,
	[530][21] = 168,
	[530][22] = 168,
	[530][23] = 168,
	[530][24] = 168,
	[530][25] = 168,
	[530][26] = 168,
	[530][27] = 168,
	[530][28] = 168,
	[530][29] = 168,
	[530][30] = 168,
	[530][31] = 168,
	[530][32] = 168,
	[530][33] = 168,
	[530][34] = 168,
	[530][35] = 168,
	[530][36] = 168,
	[531][38] = 122,
	[531][39] = 122,
	[532][38] = 123,
	[532][39] = 123,
	[533][17] = 124,
	[533][18] = 124,
	[533][31] = 124,
	[533][32] = 124,
	[533][33] = 124,
	[533][34] = 124,
	[533][35] = 124,
	[533][38] = 124,
	[533][39] = 124,
	[534][34] = 125,
	[534][35] = 125,
	[534][38] = 125,
	[534][39] = 125,
	[535][18] = 126,
	[535][31] = 126,
	[535][32] = 126,
	[535][33] = 126,
	[535][34] = 126,
	[535][35] = 126,
	[535][38] = 126,
	[535][39] = 126,
	[537][18] = 127,
	[537][32] = 127,
	[537][33] = 127,
	[537][34] = 127,
	[537][35] = 127,
	[537][38] = 127,
	[537][39] = 127,
	[538][6] = 128,
	[538][9] = 128,
	[538][13] = 128,
	[538][15] = 128,
	[538][16] = 128,
	[538][17] = 128,
	[538][18] = 128,
	[538][19] = 128,
	[538][22] = 128,
	[538][23] = 128,
	[538][24] = 128,
	[538][25] = 128,
	[538][26] = 128,
	[538][27] = 128,
	[538][28] = 128,
	[538][29] = 128,
	[538][30] = 128,
	[538][31] = 128,
	[538][32] = 128,
	[538][33] = 128,
	[538][34] = 128,
	[538][35] = 128,
	[538][38] = 128,
	[538][39] = 128,
	[539][6] = 129,
	[539][9] = 129,
	[539][13] = 129,
	[539][15] = 129,
	[539][16] = 129,
	[539][17] = 129,
	[539][18] = 129,
	[539][19] = 129,
	[539][22] = 129,
	[539][23] = 129,
	[539][24] = 129,
	[539][25] = 129,
	[539][26] = 129,
	[539][27] = 129,
	[539][28] = 129,
	[539][29] = 129,
	[539][30] = 129,
	[539][31] = 129,
	[539][32] = 129,
	[539][33] = 129,
	[539][34] = 129,
	[539][35] = 129,
	[539][38] = 129,
	[539][39] = 129,
	[540][6] = 130,
	[540][9] = 130,
	[540][13] = 130,
	[540][15] = 130,
	[540][16] = 130,
	[540][17] = 130,
	[540][18] = 130,
	[540][19] = 130,
	[540][22] = 130,
	[540][23] = 130,
	[540][24] = 130,
	[540][25] = 130,
	[540][26] = 130,
	[540][27] = 130,
	[540][28] = 130,
	[540][29] = 130,
	[540][30] = 130,
	[540][31] = 130,
	[540][32] = 130,
	[540][33] = 130,
	[540][34] = 130,
	[540][35] = 130,
	[540][38] = 130,
	[540][39] = 130,
	[541][35] = 131,
	[541][38] = 131,
	[541][39] = 131,
	[542][35] = 132,
	[542][38] = 132,
	[542][39] = 132,
	[543][4] = 133,
	[543][6] = 133,
	[543][8] = 133,
	[543][9] = 133,
	[543][13] = 133,
	[543][15] = 133,
	[543][16] = 133,
	[543][17] = 133,
	[543][18] = 133,
	[543][19] = 133,
	[543][20] = 133,
	[543][21] = 133,
	[543][22] = 133,
	[543][23] = 133,
	[543][24] = 133,
	[543][25] = 133,
	[543][26] = 133,
	[543][27] = 133,
	[543][28] = 133,
	[543][29] = 133,
	[543][30] = 133,
	[543][31] = 133,
	[543][32] = 133,
	[543][33] = 133,
	[543][34] = 133,
	[543][35] = 133,
	[543][38] = 133,
	[543][39] = 133,
	[547][4] = 134,
	[547][6] = 134,
	[547][8] = 134,
	[547][9] = 134,
	[547][13] = 134,
	[547][15] = 134,
	[547][16] = 134,
	[547][17] = 134,
	[547][18] = 134,
	[547][19] = 134,
	[547][20] = 134,
	[547][21] = 134,
	[547][22] = 134,
	[547][23] = 134,
	[547][24] = 134,
	[547][25] = 134,
	[547][26] = 134,
	[547][27] = 134,
	[547][28] = 134,
	[547][29] = 134,
	[547][30] = 134,
	[547][31] = 134,
	[547][32] = 134,
	[547][33] = 134,
	[547][34] = 134,
	[547][35] = 134,
	[547][38] = 134,
	[547][39] = 134,
	[548][15] = 135,
	[548][16] = 135,
	[548][17] = 135,
	[548][18] = 135,
	[548][25] = 135,
	[548][26] = 135,
	[548][27] = 135,
	[548][28] = 135,
	[548][29] = 135,
	[548][30] = 135,
	[548][31] = 135,
	[548][32] = 135,
	[548][33] = 135,
	[548][34] = 135,
	[548][35] = 135,
	[548][38] = 135,
	[548][39] = 135,
	[549][15] = 136,
	[549][16] = 136,
	[549][17] = 136,
	[549][18] = 136,
	[549][25] = 136,
	[549][26] = 136,
	[549][27] = 136,
	[549][28] = 136,
	[549][29] = 136,
	[549][30] = 136,
	[549][31] = 136,
	[549][32] = 136,
	[549][33] = 136,
	[549][34] = 136,
	[549][35] = 136,
	[549][38] = 136,
	[549][39] = 136,
	[550][15] = 137,
	[550][16] = 137,
	[550][17] = 137,
	[550][18] = 137,
	[550][25] = 137,
	[550][26] = 137,
	[550][27] = 137,
	[550][28] = 137,
	[550][29] = 137,
	[550][30] = 137,
	[550][31] = 137,
	[550][32] = 137,
	[550][33] = 137,
	[550][34] = 137,
	[550][35] = 137,
	[550][38] = 137,
	[550][39] = 137,
	[551][15] = 138,
	[551][16] = 138,
	[551][17] = 138,
	[551][18] = 138,
	[551][25] = 138,
	[551][26] = 138,
	[551][27] = 138,
	[551][28] = 138,
	[551][29] = 138,
	[551][30] = 138,
	[551][31] = 138,
	[551][32] = 138,
	[551][33] = 138,
	[551][34] = 138,
	[551][35] = 138,
	[551][38] = 138,
	[551][39] = 138,
	[552][15] = 139,
	[552][16] = 139,
	[552][17] = 139,
	[552][18] = 139,
	[552][23] = 139,
	[552][24] = 139,
	[552][25] = 139,
	[552][26] = 139,
	[552][27] = 139,
	[552][28] = 139,
	[552][29] = 139,
	[552][30] = 139,
	[552][31] = 139,
	[552][32] = 139,
	[552][33] = 139,
	[552][34] = 139,
	[552][35] = 139,
	[552][38] = 139,
	[552][39] = 139,
	[553][15] = 140,
	[553][16] = 140,
	[553][17] = 140,
	[553][18] = 140,
	[553][23] = 140,
	[553][24] = 140,
	[553][25] = 140,
	[553][26] = 140,
	[553][27] = 140,
	[553][28] = 140,
	[553][29] = 140,
	[553][30] = 140,
	[553][31] = 140,
	[553][32] = 140,
	[553][33] = 140,
	[553][34] = 140,
	[553][35] = 140,
	[553][38] = 140,
	[553][39] = 140,
	[554][2] = 169,
	[554][3] = 169,
	[554][4] = 169,
	[554][7] = 169,
	[554][8] = 169,
	[554][9] = 169,
	[554][11] = 169,
	[554][17] = 169,
	[554][18] = 169,
	[554][19] = 169,
	[554][22] = 169,
	[554][36] = 169,
	[555][2] = 170,
	[555][3] = 170,
	[555][4] = 170,
	[555][7] = 170,
	[555][8] = 170,
	[555][9] = 170,
	[555][11] = 170,
	[555][17] = 170,
	[555][18] = 170,
	[555][19] = 170,
	[555][22] = 170,
	[555][36] = 170,
	[556][2] = 90,
	[556][3] = 90,
	[556][4] = 90,
	[556][7] = 90,
	[556][8] = 90,
	[556][9] = 90,
	[556][11] = 90,
	[556][17] = 90,
	[556][18] = 90,
	[556][19] = 90,
	[556][22] = 90,
	[556][37] = 90,
	[557][2] = 91,
	[557][3] = 91,
	[557][4] = 91,
	[557][7] = 91,
	[557][8] = 91,
	[557][9] = 91,
	[557][11] = 91,
	[557][17] = 91,
	[557][18] = 91,
	[557][19] = 91,
	[557][22] = 91,
	[557][37] = 91,
	[559][2] = 92,
	[559][3] = 92,
	[559][4] = 92,
	[559][7] = 92,
	[559][8] = 92,
	[559][9] = 92,
	[559][11] = 92,
	[559][17] = 92,
	[559][18] = 92,
	[559][19] = 92,
	[559][22] = 92,
	[559][37] = 92,
	[561][2] = 93,
	[561][3] = 93,
	[561][4] = 93,
	[561][7] = 93,
	[561][8] = 93,
	[561][9] = 93,
	[561][11] = 93,
	[561][17] = 93,
	[561][18] = 93,
	[561][19] = 93,
	[561][22] = 93,
	[561][37] = 93,
	[564][2] = 94,
	[564][3] = 94,
	[564][4] = 94,
	[564][7] = 94,
	[564][8] = 94,
	[564][11] = 94,
	[564][17] = 94,
	[564][22] = 94,
	[564][37] = 94,
	[565][37] = 95,
	[566][17] = 96,
	[566][37] = 96,
	[567][2] = 171,
	[567][3] = 171,
	[567][4] = 171,
	[567][7] = 171,
	[567][8] = 171,
	[567][9] = 171,
	[567][11] = 171,
	[567][17] = 171,
	[567][18] = 171,
	[567][19] = 171,
	[567][22] = 171,
	[567][36] = 171,
	[568][2] = 172,
	[568][3] = 172,
	[568][4] = 172,
	[568][5] = 172,
	[568][6] = 172,
	[568][15] = 172,
	[568][16] = 172,
	[568][17] = 172,
	[568][38] = 172,
	[568][39] = 172,
	[569][2] = 173,
	[569][3] = 173,
	[569][4] = 173,
	[569][5] = 173,
	[569][6] = 173,
	[569][15] = 173,
	[569][16] = 173,
	[569][17] = 173,
	[569][38] = 173,
	[569][39] = 173,
	[573][2] = 174,
	[573][3] = 174,
	[573][4] = 174,
	[573][5] = 174,
	[573][6] = 174,
	[573][15] = 174,
	[573][16] = 174,
	[573][17] = 174,
	[573][38] = 174,
	[573][39] = 174,
	[574][2] = 175,
	[574][3] = 175,
	[574][4] = 175,
	[574][5] = 175,
	[574][17] = 175,
	[574][38] = 175,
	[574][39] = 175,
	[575][2] = 176,
	[575][3] = 176,
	[575][4] = 176,
	[575][5] = 176,
	[575][15] = 176,
	[575][16] = 176,
	[575][17] = 176,
	[575][38] = 176,
	[575][39] = 176,
	[576][2] = 177,
	[576][3] = 177,
	[576][4] = 177,
	[576][5] = 177,
	[576][16] = 177,
	[576][17] = 177,
	[576][38] = 177,
	[576][39] = 177,
	[577][39] = 178,
	[578][2] = 179,
	[578][3] = 179,
	[578][4] = 179,
	[578][7] = 179,
	[578][8] = 179,
	[578][9] = 179,
	[578][11] = 179,
	[578][17] = 179,
	[578][18] = 179,
	[578][19] = 179,
	[578][22] = 179,
	[578][36] = 179,
	[579][2] = 180,
	[579][3] = 180,
	[579][4] = 180,
	[579][7] = 180,
	[579][8] = 180,
	[579][9] = 180,
	[579][17] = 180,
	[579][18] = 180,
	[579][19] = 180,
	[579][22] = 180,
	[580][2] = 181,
	[580][3] = 181,
	[580][4] = 181,
	[580][7] = 181,
	[580][8] = 181,
	[580][9] = 181,
	[580][17] = 181,
	[580][18] = 181,
	[580][19] = 181,
	[580][22] = 181,
	[582][2] = 182,
	[582][3] = 182,
	[582][4] = 182,
	[582][7] = 182,
	[582][8] = 182,
	[582][9] = 182,
	[582][17] = 182,
	[582][18] = 182,
	[582][19] = 182,
	[582][22] = 182,
	[585][2] = 183,
	[585][3] = 183,
	[585][4] = 183,
	[585][7] = 183,
	[585][8] = 183,
	[585][17] = 183,
	[585][22] = 183,
	[586][22] = 184,
	[587][17] = 185,
	[587][22] = 185,
	[588][2] = 186,
	[588][3] = 186,
	[588][4] = 186,
	[588][5] = 186,
	[588][6] = 186,
	[588][7] = 186,
	[588][8] = 186,
	[588][9] = 186,
	[588][10] = 186,
	[588][11] = 186,
	[588][12] = 186,
	[588][13] = 186,
	[588][14] = 186,
	[588][53] = 186,
	[589][2] = 187,
	[589][3] = 187,
	[589][4] = 187,
	[589][7] = 187,
	[589][8] = 187,
	[589][11] = 187,
	[589][17] = 187,
	[589][22] = 187,
	[589][36] = 187,
	[590][2] = 188,
	[590][3] = 188,
	[590][4] = 188,
	[590][7] = 188,
	[590][8] = 188,
	[590][11] = 188,
	[590][17] = 188,
	[590][22] = 188,
	[590][36] = 188,
	[591][2] = 189,
	[591][3] = 189,
	[591][4] = 189,
	[591][7] = 189,
	[591][8] = 189,
	[591][11] = 189,
	[591][17] = 189,
	[591][22] = 189,
	[591][36] = 189,
	[593][17] = 190,
	[593][36] = 190,
	[594][2] = 191,
	[594][3] = 191,
	[594][4] = 191,
	[594][5] = 191,
	[594][6] = 191,
	[594][7] = 191,
	[594][8] = 191,
	[594][9] = 191,
	[594][10] = 191,
	[594][11] = 191,
	[594][12] = 191,
	[594][13] = 191,
	[594][14] = 191,
	[594][53] = 191,
	[595][2] = 192,
	[595][3] = 192,
	[595][4] = 192,
	[595][5] = 192,
	[595][6] = 192,
	[595][7] = 192,
	[595][8] = 192,
	[595][9] = 192,
	[595][10] = 192,
	[595][11] = 192,
	[595][12] = 192,
	[595][13] = 192,
	[595][14] = 192,
	[595][53] = 192,
	[596][2] = 180,
	[596][3] = 180,
	[596][4] = 180,
	[596][7] = 180,
	[596][8] = 180,
	[596][9] = 180,
	[596][17] = 180,
	[596][18] = 180,
	[596][19] = 180,
	[596][36] = 180,
	[597][2] = 181,
	[597][3] = 181,
	[597][4] = 181,
	[597][7] = 181,
	[597][8] = 181,
	[597][9] = 181,
	[597][17] = 181,
	[597][18] = 181,
	[597][19] = 181,
	[597][36] = 181,
	[599][2] = 182,
	[599][3] = 182,
	[599][4] = 182,
	[599][7] = 182,
	[599][8] = 182,
	[599][9] = 182,
	[599][17] = 182,
	[599][18] = 182,
	[599][19] = 182,
	[599][36] = 182,
	[602][2] = 183,
	[602][3] = 183,
	[602][4] = 183,
	[602][7] = 183,
	[602][8] = 183,
	[602][17] = 183,
	[602][36] = 183,
	[603][36] = 184,
	[604][17] = 185,
	[604][36] = 185,
	[606][2] = 193,
	[606][3] = 193,
	[606][4] = 193,
	[606][5] = 193,
	[606][6] = 193,
	[606][7] = 193,
	[606][8] = 193,
	[606][9] = 193,
	[606][10] = 193,
	[606][11] = 193,
	[606][12] = 193,
	[606][13] = 193,
	[606][14] = 193,
	[606][53] = 193,
	[608][2] = 194,
	[608][3] = 194,
	[608][4] = 194,
	[608][5] = 194,
	[608][6] = 194,
	[608][7] = 194,
	[608][8] = 194,
	[608][9] = 194,
	[608][10] = 194,
	[608][11] = 194,
	[608][12] = 194,
	[608][13] = 194,
	[608][14] = 194,
	[608][53] = 194,
	[609][2] = 195,
	[609][3] = 195,
	[609][4] = 195,
	[609][5] = 195,
	[609][6] = 195,
	[609][7] = 195,
	[609][8] = 195,
	[609][9] = 195,
	[609][10] = 195,
	[609][11] = 195,
	[609][12] = 195,
	[609][13] = 195,
	[609][14] = 195,
	[609][53] = 195,
	[610][2] = 196,
	[610][3] = 196,
	[610][4] = 196,
	[610][5] = 196,
	[610][6] = 196,
	[610][7] = 196,
	[610][8] = 196,
	[610][9] = 196,
	[610][10] = 196,
	[610][11] = 196,
	[610][12] = 196,
	[610][13] = 196,
	[610][14] = 196,
	[610][53] = 196,
	[611][37] = 97,
	[611][38] = 97,
	[611][54] = 97,
	[614][11] = 197,
	[614][54] = 197,
	[619][37] = 102,
	[619][38] = 102,
	[619][54] = 102,
	[620][11] = 198,
	[620][54] = 198,
	[624][38] = 199,
	[624][40] = 199,
	[625][38] = 97,
	[625][40] = 97,
	[625][54] = 97,
	[628][11] = 200,
	[630][11] = 201,
	[631][11] = 202,
	[635][38] = 102,
	[635][40] = 102,
	[635][54] = 102,
	[641][4] = 30,
	[641][6] = 30,
	[641][8] = 30,
	[641][9] = 30,
	[641][13] = 30,
	[641][15] = 30,
	[641][16] = 30,
	[641][17] = 30,
	[641][18] = 30,
	[641][19] = 30,
	[641][20] = 30,
	[641][21] = 30,
	[641][22] = 30,
	[641][23] = 30,
	[641][24] = 30,
	[641][25] = 30,
	[641][26] = 30,
	[641][27] = 30,
	[641][28] = 30,
	[641][29] = 30,
	[641][30] = 30,
	[641][31] = 30,
	[641][32] = 30,
	[641][33] = 30,
	[641][34] = 30,
	[641][35] = 30,
	[641][40] = 30,
	[644][6] = 31,
	[644][9] = 31,
	[644][13] = 31,
	[644][15] = 31,
	[644][16] = 31,
	[644][17] = 31,
	[644][18] = 31,
	[644][19] = 31,
	[644][21] = 31,
	[644][22] = 31,
	[644][23] = 31,
	[644][24] = 31,
	[644][25] = 31,
	[644][26] = 31,
	[644][27] = 31,
	[644][28] = 31,
	[644][29] = 31,
	[644][30] = 31,
	[644][31] = 31,
	[644][32] = 31,
	[644][33] = 31,
	[644][34] = 31,
	[644][35] = 31,
	[644][40] = 31,
	[645][6] = 32,
	[645][9] = 32,
	[645][13] = 32,
	[645][15] = 32,
	[645][16] = 32,
	[645][17] = 32,
	[645][18] = 32,
	[645][19] = 32,
	[645][21] = 32,
	[645][22] = 32,
	[645][23] = 32,
	[645][24] = 32,
	[645][25] = 32,
	[645][26] = 32,
	[645][27] = 32,
	[645][28] = 32,
	[645][29] = 32,
	[645][30] = 32,
	[645][31] = 32,
	[645][32] = 32,
	[645][33] = 32,
	[645][34] = 32,
	[645][35] = 32,
	[645][40] = 32,
	[647][4] = 33,
	[647][6] = 33,
	[647][8] = 33,
	[647][9] = 33,
	[647][13] = 33,
	[647][15] = 33,
	[647][16] = 33,
	[647][17] = 33,
	[647][18] = 33,
	[647][19] = 33,
	[647][20] = 33,
	[647][21] = 33,
	[647][22] = 33,
	[647][23] = 33,
	[647][24] = 33,
	[647][25] = 33,
	[647][26] = 33,
	[647][27] = 33,
	[647][28] = 33,
	[647][29] = 33,
	[647][30] = 33,
	[647][31] = 33,
	[647][32] = 33,
	[647][33] = 33,
	[647][34] = 33,
	[647][35] = 33,
	[647][40] = 33,
	[649][6] = 34,
	[649][9] = 34,
	[649][13] = 34,
	[649][15] = 34,
	[649][16] = 34,
	[649][17] = 34,
	[649][18] = 34,
	[649][19] = 34,
	[649][21] = 34,
	[649][22] = 34,
	[649][23] = 34,
	[649][24] = 34,
	[649][25] = 34,
	[649][26] = 34,
	[649][27] = 34,
	[649][28] = 34,
	[649][29] = 34,
	[649][30] = 34,
	[649][31] = 34,
	[649][32] = 34,
	[649][33] = 34,
	[649][34] = 34,
	[649][35] = 34,
	[649][40] = 34,
	[650][6] = 35,
	[650][9] = 35,
	[650][13] = 35,
	[650][15] = 35,
	[650][16] = 35,
	[650][17] = 35,
	[650][18] = 35,
	[650][19] = 35,
	[650][21] = 35,
	[650][22] = 35,
	[650][23] = 35,
	[650][24] = 35,
	[650][25] = 35,
	[650][26] = 35,
	[650][27] = 35,
	[650][28] = 35,
	[650][29] = 35,
	[650][30] = 35,
	[650][31] = 35,
	[650][32] = 35,
	[650][33] = 35,
	[650][34] = 35,
	[650][35] = 35,
	[650][40] = 35,
	[682][4] = 203,
	[682][6] = 203,
	[682][8] = 203,
	[682][9] = 203,
	[682][13] = 203,
	[682][15] = 203,
	[682][16] = 203,
	[682][17] = 203,
	[682][18] = 203,
	[682][19] = 203,
	[682][20] = 203,
	[682][21] = 203,
	[682][22] = 203,
	[682][23] = 203,
	[682][24] = 203,
	[682][25] = 203,
	[682][26] = 203,
	[682][27] = 203,
	[682][28] = 203,
	[682][29] = 203,
	[682][30] = 203,
	[682][31] = 203,
	[682][32] = 203,
	[682][33] = 203,
	[682][34] = 203,
	[682][35] = 203,
	[682][36] = 203,
	[684][4] = 204,
	[684][6] = 204,
	[684][8] = 204,
	[684][9] = 204,
	[684][13] = 204,
	[684][15] = 204,
	[684][16] = 204,
	[684][17] = 204,
	[684][18] = 204,
	[684][19] = 204,
	[684][20] = 204,
	[684][21] = 204,
	[684][22] = 204,
	[684][23] = 204,
	[684][24] = 204,
	[684][25] = 204,
	[684][26] = 204,
	[684][27] = 204,
	[684][28] = 204,
	[684][29] = 204,
	[684][30] = 204,
	[684][31] = 204,
	[684][32] = 204,
	[684][33] = 204,
	[684][34] = 204,
	[684][35] = 204,
	[684][36] = 204,
	[686][4] = 30,
	[686][6] = 30,
	[686][8] = 30,
	[686][9] = 30,
	[686][13] = 30,
	[686][15] = 30,
	[686][16] = 30,
	[686][17] = 30,
	[686][18] = 30,
	[686][19] = 30,
	[686][20] = 30,
	[686][21] = 30,
	[686][22] = 30,
	[686][23] = 30,
	[686][24] = 30,
	[686][25] = 30,
	[686][26] = 30,
	[686][27] = 30,
	[686][28] = 30,
	[686][29] = 30,
	[686][30] = 30,
	[686][31] = 30,
	[686][32] = 30,
	[686][33] = 30,
	[686][34] = 30,
	[686][35] = 30,
	[686][39] = 30,
	[689][6] = 31,
	[689][9] = 31,
	[689][13] = 31,
	[689][15] = 31,
	[689][16] = 31,
	[689][17] = 31,
	[689][18] = 31,
	[689][19] = 31,
	[689][21] = 31,
	[689][22] = 31,
	[689][23] = 31,
	[689][24] = 31,
	[689][25] = 31,
	[689][26] = 31,
	[689][27] = 31,
	[689][28] = 31,
	[689][29] = 31,
	[689][30] = 31,
	[689][31] = 31,
	[689][32] = 31,
	[689][33] = 31,
	[689][34] = 31,
	[689][35] = 31,
	[689][39] = 31,
	[690][6] = 32,
	[690][9] = 32,
	[690][13] = 32,
	[690][15] = 32,
	[690][16] = 32,
	[690][17] = 32,
	[690][18] = 32,
	[690][19] = 32,
	[690][21] = 32,
	[690][22] = 32,
	[690][23] = 32,
	[690][24] = 32,
	[690][25] = 32,
	[690][26] = 32,
	[690][27] = 32,
	[690][28] = 32,
	[690][29] = 32,
	[690][30] = 32,
	[690][31] = 32,
	[690][32] = 32,
	[690][33] = 32,
	[690][34] = 32,
	[690][35] = 32,
	[690][39] = 32,
	[692][4] = 33,
	[692][6] = 33,
	[692][8] = 33,
	[692][9] = 33,
	[692][13] = 33,
	[692][15] = 33,
	[692][16] = 33,
	[692][17] = 33,
	[692][18] = 33,
	[692][19] = 33,
	[692][20] = 33,
	[692][21] = 33,
	[692][22] = 33,
	[692][23] = 33,
	[692][24] = 33,
	[692][25] = 33,
	[692][26] = 33,
	[692][27] = 33,
	[692][28] = 33,
	[692][29] = 33,
	[692][30] = 33,
	[692][31] = 33,
	[692][32] = 33,
	[692][33] = 33,
	[692][34] = 33,
	[692][35] = 33,
	[692][39] = 33,
	[694][6] = 34,
	[694][9] = 34,
	[694][13] = 34,
	[694][15] = 34,
	[694][16] = 34,
	[694][17] = 34,
	[694][18] = 34,
	[694][19] = 34,
	[694][21] = 34,
	[694][22] = 34,
	[694][23] = 34,
	[694][24] = 34,
	[694][25] = 34,
	[694][26] = 34,
	[694][27] = 34,
	[694][28] = 34,
	[694][29] = 34,
	[694][30] = 34,
	[694][31] = 34,
	[694][32] = 34,
	[694][33] = 34,
	[694][34] = 34,
	[694][35] = 34,
	[694][39] = 34,
	[695][6] = 35,
	[695][9] = 35,
	[695][13] = 35,
	[695][15] = 35,
	[695][16] = 35,
	[695][17] = 35,
	[695][18] = 35,
	[695][19] = 35,
	[695][21] = 35,
	[695][22] = 35,
	[695][23] = 35,
	[695][24] = 35,
	[695][25] = 35,
	[695][26] = 35,
	[695][27] = 35,
	[695][28] = 35,
	[695][29] = 35,
	[695][30] = 35,
	[695][31] = 35,
	[695][32] = 35,
	[695][33] = 35,
	[695][34] = 35,
	[695][35] = 35,
	[695][39] = 35,
	[706][4] = 205,
	[706][6] = 205,
	[706][8] = 205,
	[706][9] = 205,
	[706][13] = 205,
	[706][15] = 205,
	[706][16] = 205,
	[706][17] = 205,
	[706][18] = 205,
	[706][19] = 205,
	[706][20] = 205,
	[706][21] = 205,
	[706][22] = 205,
	[706][23] = 205,
	[706][24] = 205,
	[706][25] = 205,
	[706][26] = 205,
	[706][27] = 205,
	[706][28] = 205,
	[706][29] = 205,
	[706][30] = 205,
	[706][31] = 205,
	[706][32] = 205,
	[706][33] = 205,
	[706][34] = 205,
	[706][35] = 205,
	[706][36] = 205,
	[726][4] = 165,
	[726][6] = 165,
	[726][8] = 165,
	[726][9] = 165,
	[726][13] = 165,
	[726][15] = 165,
	[726][16] = 165,
	[726][17] = 165,
	[726][18] = 165,
	[726][19] = 165,
	[726][20] = 165,
	[726][21] = 165,
	[726][22] = 165,
	[726][23] = 165,
	[726][24] = 165,
	[726][25] = 165,
	[726][26] = 165,
	[726][27] = 165,
	[726][28] = 165,
	[726][29] = 165,
	[726][30] = 165,
	[726][31] = 165,
	[726][32] = 165,
	[726][33] = 165,
	[726][34] = 165,
	[726][35] = 165,
	[726][37] = 165,
	[726][38] = 165,
	[728][4] = 166,
	[728][6] = 166,
	[728][8] = 166,
	[728][9] = 166,
	[728][13] = 166,
	[728][15] = 166,
	[728][16] = 166,
	[728][17] = 166,
	[728][18] = 166,
	[728][19] = 166,
	[728][20] = 166,
	[728][21] = 166,
	[728][22] = 166,
	[728][23] = 166,
	[728][24] = 166,
	[728][25] = 166,
	[728][26] = 166,
	[728][27] = 166,
	[728][28] = 166,
	[728][29] = 166,
	[728][30] = 166,
	[728][31] = 166,
	[728][32] = 166,
	[728][33] = 166,
	[728][34] = 166,
	[728][35] = 166,
	[728][37] = 166,
	[728][38] = 166,
	[729][4] = 206,
	[729][6] = 206,
	[729][8] = 206,
	[729][9] = 206,
	[729][13] = 206,
	[729][15] = 206,
	[729][16] = 206,
	[729][17] = 206,
	[729][18] = 206,
	[729][19] = 206,
	[729][20] = 206,
	[729][21] = 206,
	[729][22] = 206,
	[729][23] = 206,
	[729][24] = 206,
	[729][25] = 206,
	[729][26] = 206,
	[729][27] = 206,
	[729][28] = 206,
	[729][29] = 206,
	[729][30] = 206,
	[729][31] = 206,
	[729][32] = 206,
	[729][33] = 206,
	[729][34] = 206,
	[729][35] = 206,
	[729][36] = 206,
	[731][4] = 167,
	[731][6] = 167,
	[731][8] = 167,
	[731][9] = 167,
	[731][13] = 167,
	[731][15] = 167,
	[731][16] = 167,
	[731][17] = 167,
	[731][18] = 167,
	[731][19] = 167,
	[731][20] = 167,
	[731][21] = 167,
	[731][22] = 167,
	[731][23] = 167,
	[731][24] = 167,
	[731][25] = 167,
	[731][26] = 167,
	[731][27] = 167,
	[731][28] = 167,
	[731][29] = 167,
	[731][30] = 167,
	[731][31] = 167,
	[731][32] = 167,
	[731][33] = 167,
	[731][34] = 167,
	[731][35] = 167,
	[731][37] = 167,
	[731][38] = 167,
	[732][4] = 168,
	[732][6] = 168,
	[732][8] = 168,
	[732][9] = 168,
	[732][13] = 168,
	[732][15] = 168,
	[732][16] = 168,
	[732][17] = 168,
	[732][18] = 168,
	[732][19] = 168,
	[732][20] = 168,
	[732][21] = 168,
	[732][22] = 168,
	[732][23] = 168,
	[732][24] = 168,
	[732][25] = 168,
	[732][26] = 168,
	[732][27] = 168,
	[732][28] = 168,
	[732][29] = 168,
	[732][30] = 168,
	[732][31] = 168,
	[732][32] = 168,
	[732][33] = 168,
	[732][34] = 168,
	[732][35] = 168,
	[732][37] = 168,
	[732][38] = 168,
	[740][4] = 203,
	[740][6] = 203,
	[740][8] = 203,
	[740][9] = 203,
	[740][13] = 203,
	[740][15] = 203,
	[740][16] = 203,
	[740][17] = 203,
	[740][18] = 203,
	[740][19] = 203,
	[740][20] = 203,
	[740][21] = 203,
	[740][22] = 203,
	[740][23] = 203,
	[740][24] = 203,
	[740][25] = 203,
	[740][26] = 203,
	[740][27] = 203,
	[740][28] = 203,
	[740][29] = 203,
	[740][30] = 203,
	[740][31] = 203,
	[740][32] = 203,
	[740][33] = 203,
	[740][34] = 203,
	[740][35] = 203,
	[740][37] = 203,
	[740][38] = 203,
	[742][4] = 204,
	[742][6] = 204,
	[742][8] = 204,
	[742][9] = 204,
	[742][13] = 204,
	[742][15] = 204,
	[742][16] = 204,
	[742][17] = 204,
	[742][18] = 204,
	[742][19] = 204,
	[742][20] = 204,
	[742][21] = 204,
	[742][22] = 204,
	[742][23] = 204,
	[742][24] = 204,
	[742][25] = 204,
	[742][26] = 204,
	[742][27] = 204,
	[742][28] = 204,
	[742][29] = 204,
	[742][30] = 204,
	[742][31] = 204,
	[742][32] = 204,
	[742][33] = 204,
	[742][34] = 204,
	[742][35] = 204,
	[742][37] = 204,
	[742][38] = 204,
	[744][4] = 205,
	[744][6] = 205,
	[744][8] = 205,
	[744][9] = 205,
	[744][13] = 205,
	[744][15] = 205,
	[744][16] = 205,
	[744][17] = 205,
	[744][18] = 205,
	[744][19] = 205,
	[744][20] = 205,
	[744][21] = 205,
	[744][22] = 205,
	[744][23] = 205,
	[744][24] = 205,
	[744][25] = 205,
	[744][26] = 205,
	[744][27] = 205,
	[744][28] = 205,
	[744][29] = 205,
	[744][30] = 205,
	[744][31] = 205,
	[744][32] = 205,
	[744][33] = 205,
	[744][34] = 205,
	[744][35] = 205,
	[744][37] = 205,
	[744][38] = 205,
	[745][4] = 165,
	[745][6] = 165,
	[745][8] = 165,
	[745][9] = 165,
	[745][13] = 165,
	[745][15] = 165,
	[745][16] = 165,
	[745][17] = 165,
	[745][18] = 165,
	[745][19] = 165,
	[745][20] = 165,
	[745][21] = 165,
	[745][22] = 165,
	[745][23] = 165,
	[745][24] = 165,
	[745][25] = 165,
	[745][26] = 165,
	[745][27] = 165,
	[745][28] = 165,
	[745][29] = 165,
	[745][30] = 165,
	[745][31] = 165,
	[745][32] = 165,
	[745][33] = 165,
	[745][34] = 165,
	[745][35] = 165,
	[745][38] = 165,
	[745][39] = 165,
	[747][4] = 166,
	[747][6] = 166,
	[747][8] = 166,
	[747][9] = 166,
	[747][13] = 166,
	[747][15] = 166,
	[747][16] = 166,
	[747][17] = 166,
	[747][18] = 166,
	[747][19] = 166,
	[747][20] = 166,
	[747][21] = 166,
	[747][22] = 166,
	[747][23] = 166,
	[747][24] = 166,
	[747][25] = 166,
	[747][26] = 166,
	[747][27] = 166,
	[747][28] = 166,
	[747][29] = 166,
	[747][30] = 166,
	[747][31] = 166,
	[747][32] = 166,
	[747][33] = 166,
	[747][34] = 166,
	[747][35] = 166,
	[747][38] = 166,
	[747][39] = 166,
	[748][4] = 207,
	[748][6] = 207,
	[748][8] = 207,
	[748][9] = 207,
	[748][13] = 207,
	[748][15] = 207,
	[748][16] = 207,
	[748][17] = 207,
	[748][18] = 207,
	[748][19] = 207,
	[748][20] = 207,
	[748][21] = 207,
	[748][22] = 207,
	[748][23] = 207,
	[748][24] = 207,
	[748][25] = 207,
	[748][26] = 207,
	[748][27] = 207,
	[748][28] = 207,
	[748][29] = 207,
	[748][30] = 207,
	[748][31] = 207,
	[748][32] = 207,
	[748][33] = 207,
	[748][34] = 207,
	[748][35] = 207,
	[748][36] = 207,
	[750][4] = 167,
	[750][6] = 167,
	[750][8] = 167,
	[750][9] = 167,
	[750][13] = 167,
	[750][15] = 167,
	[750][16] = 167,
	[750][17] = 167,
	[750][18] = 167,
	[750][19] = 167,
	[750][20] = 167,
	[750][21] = 167,
	[750][22] = 167,
	[750][23] = 167,
	[750][24] = 167,
	[750][25] = 167,
	[750][26] = 167,
	[750][27] = 167,
	[750][28] = 167,
	[750][29] = 167,
	[750][30] = 167,
	[750][31] = 167,
	[750][32] = 167,
	[750][33] = 167,
	[750][34] = 167,
	[750][35] = 167,
	[750][38] = 167,
	[750][39] = 167,
	[751][4] = 168,
	[751][6] = 168,
	[751][8] = 168,
	[751][9] = 168,
	[751][13] = 168,
	[751][15] = 168,
	[751][16] = 168,
	[751][17] = 168,
	[751][18] = 168,
	[751][19] = 168,
	[751][20] = 168,
	[751][21] = 168,
	[751][22] = 168,
	[751][23] = 168,
	[751][24] = 168,
	[751][25] = 168,
	[751][26] = 168,
	[751][27] = 168,
	[751][28] = 168,
	[751][29] = 168,
	[751][30] = 168,
	[751][31] = 168,
	[751][32] = 168,
	[751][33] = 168,
	[751][34] = 168,
	[751][35] = 168,
	[751][38] = 168,
	[751][39] = 168,
	[759][4] = 203,
	[759][6] = 203,
	[759][8] = 203,
	[759][9] = 203,
	[759][13] = 203,
	[759][15] = 203,
	[759][16] = 203,
	[759][17] = 203,
	[759][18] = 203,
	[759][19] = 203,
	[759][20] = 203,
	[759][21] = 203,
	[759][22] = 203,
	[759][23] = 203,
	[759][24] = 203,
	[759][25] = 203,
	[759][26] = 203,
	[759][27] = 203,
	[759][28] = 203,
	[759][29] = 203,
	[759][30] = 203,
	[759][31] = 203,
	[759][32] = 203,
	[759][33] = 203,
	[759][34] = 203,
	[759][35] = 203,
	[759][38] = 203,
	[759][39] = 203,
	[761][4] = 204,
	[761][6] = 204,
	[761][8] = 204,
	[761][9] = 204,
	[761][13] = 204,
	[761][15] = 204,
	[761][16] = 204,
	[761][17] = 204,
	[761][18] = 204,
	[761][19] = 204,
	[761][20] = 204,
	[761][21] = 204,
	[761][22] = 204,
	[761][23] = 204,
	[761][24] = 204,
	[761][25] = 204,
	[761][26] = 204,
	[761][27] = 204,
	[761][28] = 204,
	[761][29] = 204,
	[761][30] = 204,
	[761][31] = 204,
	[761][32] = 204,
	[761][33] = 204,
	[761][34] = 204,
	[761][35] = 204,
	[761][38] = 204,
	[761][39] = 204,
	[763][4] = 205,
	[763][6] = 205,
	[763][8] = 205,
	[763][9] = 205,
	[763][13] = 205,
	[763][15] = 205,
	[763][16] = 205,
	[763][17] = 205,
	[763][18] = 205,
	[763][19] = 205,
	[763][20] = 205,
	[763][21] = 205,
	[763][22] = 205,
	[763][23] = 205,
	[763][24] = 205,
	[763][25] = 205,
	[763][26] = 205,
	[763][27] = 205,
	[763][28] = 205,
	[763][29] = 205,
	[763][30] = 205,
	[763][31] = 205,
	[763][32] = 205,
	[763][33] = 205,
	[763][34] = 205,
	[763][35] = 205,
	[763][38] = 205,
	[763][39] = 205,
	[764][2] = 208,
	[764][3] = 208,
	[764][4] = 208,
	[764][7] = 208,
	[764][8] = 208,
	[764][9] = 208,
	[764][11] = 208,
	[764][17] = 208,
	[764][18] = 208,
	[764][19] = 208,
	[764][22] = 208,
	[764][36] = 208,
	[765][2] = 209,
	[765][3] = 209,
	[765][4] = 209,
	[765][7] = 209,
	[765][8] = 209,
	[765][9] = 209,
	[765][11] = 209,
	[765][17] = 209,
	[765][18] = 209,
	[765][19] = 209,
	[765][22] = 209,
	[765][36] = 209,
	[766][2] = 210,
	[766][3] = 210,
	[766][4] = 210,
	[766][7] = 210,
	[766][8] = 210,
	[766][9] = 210,
	[766][11] = 210,
	[766][17] = 210,
	[766][18] = 210,
	[766][19] = 210,
	[766][22] = 210,
	[766][36] = 210,
	[767][2] = 211,
	[767][3] = 211,
	[767][4] = 211,
	[767][7] = 211,
	[767][8] = 211,
	[767][9] = 211,
	[767][11] = 211,
	[767][17] = 211,
	[767][18] = 211,
	[767][19] = 211,
	[767][22] = 211,
	[767][36] = 211,
	[768][2] = 169,
	[768][3] = 169,
	[768][4] = 169,
	[768][7] = 169,
	[768][8] = 169,
	[768][9] = 169,
	[768][11] = 169,
	[768][17] = 169,
	[768][18] = 169,
	[768][19] = 169,
	[768][22] = 169,
	[768][37] = 169,
	[769][2] = 170,
	[769][3] = 170,
	[769][4] = 170,
	[769][7] = 170,
	[769][8] = 170,
	[769][9] = 170,
	[769][11] = 170,
	[769][17] = 170,
	[769][18] = 170,
	[769][19] = 170,
	[769][22] = 170,
	[769][37] = 170,
	[771][2] = 171,
	[771][3] = 171,
	[771][4] = 171,
	[771][7] = 171,
	[771][8] = 171,
	[771][9] = 171,
	[771][11] = 171,
	[771][17] = 171,
	[771][18] = 171,
	[771][19] = 171,
	[771][22] = 171,
	[771][37] = 171,
	[773][2] = 179,
	[773][3] = 179,
	[773][4] = 179,
	[773][7] = 179,
	[773][8] = 179,
	[773][9] = 179,
	[773][11] = 179,
	[773][17] = 179,
	[773][18] = 179,
	[773][19] = 179,
	[773][22] = 179,
	[773][37] = 179,
	[775][2] = 212,
	[775][3] = 212,
	[775][4] = 212,
	[775][7] = 212,
	[775][8] = 212,
	[775][9] = 212,
	[775][11] = 212,
	[775][17] = 212,
	[775][18] = 212,
	[775][19] = 212,
	[775][22] = 212,
	[775][36] = 212,
	[776][2] = 187,
	[776][3] = 187,
	[776][4] = 187,
	[776][7] = 187,
	[776][8] = 187,
	[776][11] = 187,
	[776][17] = 187,
	[776][22] = 187,
	[776][37] = 187,
	[777][2] = 188,
	[777][3] = 188,
	[777][4] = 188,
	[777][7] = 188,
	[777][8] = 188,
	[777][11] = 188,
	[777][17] = 188,
	[777][22] = 188,
	[777][37] = 188,
	[778][2] = 189,
	[778][3] = 189,
	[778][4] = 189,
	[778][7] = 189,
	[778][8] = 189,
	[778][11] = 189,
	[778][17] = 189,
	[778][22] = 189,
	[778][37] = 189,
	[780][17] = 190,
	[780][37] = 190,
	[781][2] = 213,
	[781][3] = 213,
	[781][4] = 213,
	[781][7] = 213,
	[781][8] = 213,
	[781][9] = 213,
	[781][11] = 213,
	[781][17] = 213,
	[781][18] = 213,
	[781][19] = 213,
	[781][22] = 213,
	[781][36] = 213,
	[782][2] = 214,
	[782][3] = 214,
	[782][4] = 214,
	[782][7] = 214,
	[782][8] = 214,
	[782][9] = 214,
	[782][11] = 214,
	[782][17] = 214,
	[782][18] = 214,
	[782][19] = 214,
	[782][22] = 214,
	[782][36] = 214,
	[783][2] = 172,
	[783][3] = 172,
	[783][4] = 172,
	[783][5] = 172,
	[783][6] = 172,
	[783][15] = 172,
	[783][16] = 172,
	[783][17] = 172,
	[783][37] = 172,
	[783][38] = 172,
	[784][2] = 173,
	[784][3] = 173,
	[784][4] = 173,
	[784][5] = 173,
	[784][6] = 173,
	[784][15] = 173,
	[784][16] = 173,
	[784][17] = 173,
	[784][37] = 173,
	[784][38] = 173,
	[788][2] = 174,
	[788][3] = 174,
	[788][4] = 174,
	[788][5] = 174,
	[788][6] = 174,
	[788][15] = 174,
	[788][16] = 174,
	[788][17] = 174,
	[788][37] = 174,
	[788][38] = 174,
	[789][2] = 175,
	[789][3] = 175,
	[789][4] = 175,
	[789][5] = 175,
	[789][17] = 175,
	[789][37] = 175,
	[789][38] = 175,
	[790][2] = 176,
	[790][3] = 176,
	[790][4] = 176,
	[790][5] = 176,
	[790][15] = 176,
	[790][16] = 176,
	[790][17] = 176,
	[790][37] = 176,
	[790][38] = 176,
	[791][2] = 177,
	[791][3] = 177,
	[791][4] = 177,
	[791][5] = 177,
	[791][16] = 177,
	[791][17] = 177,
	[791][37] = 177,
	[791][38] = 177,
	[792][37] = 178,
	[793][2] = 215,
	[793][3] = 215,
	[793][4] = 215,
	[793][5] = 215,
	[793][6] = 215,
	[793][15] = 215,
	[793][16] = 215,
	[793][17] = 215,
	[793][38] = 215,
	[793][39] = 215,
	[794][2] = 216,
	[794][3] = 216,
	[794][4] = 216,
	[794][7] = 216,
	[794][8] = 216,
	[794][9] = 216,
	[794][11] = 216,
	[794][17] = 216,
	[794][18] = 216,
	[794][19] = 216,
	[794][22] = 216,
	[794][36] = 216,
	[800][39] = 217,
	[801][2] = 218,
	[801][3] = 218,
	[801][4] = 218,
	[801][7] = 218,
	[801][8] = 218,
	[801][9] = 218,
	[801][11] = 218,
	[801][17] = 218,
	[801][18] = 218,
	[801][19] = 218,
	[801][22] = 218,
	[801][36] = 218,
	[802][2] = 219,
	[802][3] = 219,
	[802][4] = 219,
	[802][7] = 219,
	[802][8] = 219,
	[802][9] = 219,
	[802][11] = 219,
	[802][17] = 219,
	[802][18] = 219,
	[802][19] = 219,
	[802][22] = 219,
	[802][36] = 219,
	[803][2] = 180,
	[803][3] = 180,
	[803][4] = 180,
	[803][7] = 180,
	[803][8] = 180,
	[803][9] = 180,
	[803][17] = 180,
	[803][18] = 180,
	[803][19] = 180,
	[803][37] = 180,
	[804][2] = 181,
	[804][3] = 181,
	[804][4] = 181,
	[804][7] = 181,
	[804][8] = 181,
	[804][9] = 181,
	[804][17] = 181,
	[804][18] = 181,
	[804][19] = 181,
	[804][37] = 181,
	[806][2] = 182,
	[806][3] = 182,
	[806][4] = 182,
	[806][7] = 182,
	[806][8] = 182,
	[806][9] = 182,
	[806][17] = 182,
	[806][18] = 182,
	[806][19] = 182,
	[806][37] = 182,
	[809][2] = 183,
	[809][3] = 183,
	[809][4] = 183,
	[809][7] = 183,
	[809][8] = 183,
	[809][17] = 183,
	[809][37] = 183,
	[810][37] = 184,
	[811][17] = 185,
	[811][37] = 185,
	[813][2] = 220,
	[813][3] = 220,
	[813][4] = 220,
	[813][7] = 220,
	[813][8] = 220,
	[813][9] = 220,
	[813][11] = 220,
	[813][17] = 220,
	[813][18] = 220,
	[813][19] = 220,
	[813][22] = 220,
	[813][36] = 220,
	[814][2] = 221,
	[814][3] = 221,
	[814][4] = 221,
	[814][7] = 221,
	[814][8] = 221,
	[814][17] = 221,
	[814][22] = 221,
	[815][2] = 222,
	[815][3] = 222,
	[815][4] = 222,
	[815][7] = 222,
	[815][8] = 222,
	[815][17] = 222,
	[815][22] = 222,
	[816][2] = 223,
	[816][3] = 223,
	[816][4] = 223,
	[816][7] = 223,
	[816][8] = 223,
	[816][17] = 223,
	[816][22] = 223,
	[818][17] = 224,
	[818][22] = 224,
	[819][36] = 225,
	[820][36] = 226,
	[821][17] = 227,
	[821][36] = 227,
	[822][17] = 228,
	[822][36] = 228,
	[825][2] = 229,
	[825][3] = 229,
	[825][4] = 229,
	[825][5] = 229,
	[825][6] = 229,
	[825][7] = 229,
	[825][8] = 229,
	[825][9] = 229,
	[825][10] = 229,
	[825][11] = 229,
	[825][12] = 229,
	[825][13] = 229,
	[825][14] = 229,
	[825][53] = 229,
	[826][2] = 221,
	[826][3] = 221,
	[826][4] = 221,
	[826][7] = 221,
	[826][8] = 221,
	[826][17] = 221,
	[826][36] = 221,
	[827][2] = 222,
	[827][3] = 222,
	[827][4] = 222,
	[827][7] = 222,
	[827][8] = 222,
	[827][17] = 222,
	[827][36] = 222,
	[828][2] = 223,
	[828][3] = 223,
	[828][4] = 223,
	[828][7] = 223,
	[828][8] = 223,
	[828][17] = 223,
	[828][36] = 223,
	[830][17] = 224,
	[830][36] = 224,
	[831][2] = 230,
	[831][3] = 230,
	[831][4] = 230,
	[831][5] = 230,
	[831][6] = 230,
	[831][7] = 230,
	[831][8] = 230,
	[831][9] = 230,
	[831][10] = 230,
	[831][11] = 230,
	[831][12] = 230,
	[831][13] = 230,
	[831][14] = 230,
	[831][53] = 230,
	[832][2] = 231,
	[832][3] = 231,
	[832][4] = 231,
	[832][5] = 231,
	[832][6] = 231,
	[832][7] = 231,
	[832][8] = 231,
	[832][9] = 231,
	[832][10] = 231,
	[832][11] = 231,
	[832][12] = 231,
	[832][13] = 231,
	[832][14] = 231,
	[832][53] = 231,
	[833][37] = 197,
	[833][38] = 197,
	[833][54] = 197,
	[835][37] = 198,
	[835][38] = 198,
	[835][54] = 198,
	[837][11] = 232,
	[837][54] = 232,
	[839][37] = 200,
	[839][38] = 200,
	[841][37] = 201,
	[841][38] = 201,
	[842][37] = 202,
	[842][38] = 202,
	[845][11] = 233,
	[845][54] = 233,
	[846][33] = 234,
	[846][34] = 234,
	[846][35] = 234,
	[846][36] = 234,
	[847][33] = 235,
	[847][34] = 235,
	[847][35] = 235,
	[847][36] = 235,
	[848][38] = 197,
	[848][40] = 197,
	[848][54] = 197,
	[850][38] = 198,
	[850][40] = 198,
	[850][54] = 198,
	[854][38] = 200,
	[854][40] = 200,
	[856][38] = 201,
	[856][40] = 201,
	[857][38] = 202,
	[857][40] = 202,
	[860][11] = 236,
	[861][11] = 237,
	[862][33] = 238,
	[862][34] = 238,
	[862][35] = 238,
	[862][36] = 238,
	[863][33] = 239,
	[863][34] = 239,
	[863][35] = 239,
	[863][36] = 239,
	[864][36] = 240,
	[865][4] = 86,
	[865][6] = 86,
	[865][8] = 86,
	[865][9] = 86,
	[865][13] = 86,
	[865][15] = 86,
	[865][16] = 86,
	[865][17] = 86,
	[865][18] = 86,
	[865][19] = 86,
	[865][20] = 86,
	[865][21] = 86,
	[865][22] = 86,
	[865][23] = 86,
	[865][24] = 86,
	[865][25] = 86,
	[865][26] = 86,
	[865][27] = 86,
	[865][28] = 86,
	[865][29] = 86,
	[865][30] = 86,
	[865][31] = 86,
	[865][32] = 86,
	[865][33] = 86,
	[865][34] = 86,
	[865][35] = 86,
	[865][40] = 86,
	[867][4] = 87,
	[867][6] = 87,
	[867][8] = 87,
	[867][9] = 87,
	[867][13] = 87,
	[867][15] = 87,
	[867][16] = 87,
	[867][17] = 87,
	[867][18] = 87,
	[867][19] = 87,
	[867][20] = 87,
	[867][21] = 87,
	[867][22] = 87,
	[867][23] = 87,
	[867][24] = 87,
	[867][25] = 87,
	[867][26] = 87,
	[867][27] = 87,
	[867][28] = 87,
	[867][29] = 87,
	[867][30] = 87,
	[867][31] = 87,
	[867][32] = 87,
	[867][33] = 87,
	[867][34] = 87,
	[867][35] = 87,
	[867][40] = 87,
	[869][4] = 88,
	[869][6] = 88,
	[869][8] = 88,
	[869][9] = 88,
	[869][13] = 88,
	[869][15] = 88,
	[869][16] = 88,
	[869][17] = 88,
	[869][18] = 88,
	[869][19] = 88,
	[869][20] = 88,
	[869][21] = 88,
	[869][22] = 88,
	[869][23] = 88,
	[869][24] = 88,
	[869][25] = 88,
	[869][26] = 88,
	[869][27] = 88,
	[869][28] = 88,
	[869][29] = 88,
	[869][30] = 88,
	[869][31] = 88,
	[869][32] = 88,
	[869][33] = 88,
	[869][34] = 88,
	[869][35] = 88,
	[869][40] = 88,
	[872][4] = 89,
	[872][6] = 89,
	[872][8] = 89,
	[872][9] = 89,
	[872][13] = 89,
	[872][15] = 89,
	[872][16] = 89,
	[872][17] = 89,
	[872][18] = 89,
	[872][19] = 89,
	[872][20] = 89,
	[872][21] = 89,
	[872][22] = 89,
	[872][23] = 89,
	[872][24] = 89,
	[872][25] = 89,
	[872][26] = 89,
	[872][27] = 89,
	[872][28] = 89,
	[872][29] = 89,
	[872][30] = 89,
	[872][31] = 89,
	[872][32] = 89,
	[872][33] = 89,
	[872][34] = 89,
	[872][35] = 89,
	[872][40] = 89,
	[873][33] = 99,
	[873][34] = 99,
	[873][35] = 99,
	[873][40] = 99,
	[875][33] = 100,
	[875][34] = 100,
	[875][35] = 100,
	[875][40] = 100,
	[876][33] = 101,
	[876][34] = 101,
	[876][35] = 101,
	[876][40] = 101,
	[878][6] = 103,
	[878][9] = 103,
	[878][15] = 103,
	[878][16] = 103,
	[878][17] = 103,
	[878][18] = 103,
	[878][23] = 103,
	[878][24] = 103,
	[878][25] = 103,
	[878][26] = 103,
	[878][27] = 103,
	[878][28] = 103,
	[878][29] = 103,
	[878][30] = 103,
	[878][31] = 103,
	[878][32] = 103,
	[878][33] = 103,
	[878][34] = 103,
	[878][35] = 103,
	[878][40] = 103,
	[879][6] = 104,
	[879][9] = 104,
	[879][15] = 104,
	[879][16] = 104,
	[879][17] = 104,
	[879][18] = 104,
	[879][23] = 104,
	[879][24] = 104,
	[879][25] = 104,
	[879][26] = 104,
	[879][27] = 104,
	[879][28] = 104,
	[879][29] = 104,
	[879][30] = 104,
	[879][31] = 104,
	[879][32] = 104,
	[879][33] = 104,
	[879][34] = 104,
	[879][35] = 104,
	[879][40] = 104,
	[880][15] = 105,
	[880][16] = 105,
	[880][17] = 105,
	[880][18] = 105,
	[880][31] = 105,
	[880][32] = 105,
	[880][33] = 105,
	[880][34] = 105,
	[880][35] = 105,
	[880][40] = 105,
	[881][15] = 112,
	[881][16] = 112,
	[881][17] = 112,
	[881][18] = 112,
	[881][29] = 112,
	[881][30] = 112,
	[881][31] = 112,
	[881][32] = 112,
	[881][33] = 112,
	[881][34] = 112,
	[881][35] = 112,
	[881][40] = 112,
	[882][15] = 113,
	[882][16] = 113,
	[882][17] = 113,
	[882][18] = 113,
	[882][29] = 113,
	[882][30] = 113,
	[882][31] = 113,
	[882][32] = 113,
	[882][33] = 113,
	[882][34] = 113,
	[882][35] = 113,
	[882][40] = 113,
	[883][16] = 114,
	[883][17] = 114,
	[883][18] = 114,
	[883][31] = 114,
	[883][32] = 114,
	[883][33] = 114,
	[883][34] = 114,
	[883][35] = 114,
	[883][40] = 114,
	[884][6] = 115,
	[884][9] = 115,
	[884][13] = 115,
	[884][15] = 115,
	[884][16] = 115,
	[884][17] = 115,
	[884][18] = 115,
	[884][19] = 115,
	[884][21] = 115,
	[884][22] = 115,
	[884][23] = 115,
	[884][24] = 115,
	[884][25] = 115,
	[884][26] = 115,
	[884][27] = 115,
	[884][28] = 115,
	[884][29] = 115,
	[884][30] = 115,
	[884][31] = 115,
	[884][32] = 115,
	[884][33] = 115,
	[884][34] = 115,
	[884][35] = 115,
	[884][40] = 115,
	[885][33] = 241,
	[885][34] = 241,
	[885][35] = 241,
	[885][36] = 241,
	[886][40] = 122,
	[887][40] = 123,
	[888][17] = 124,
	[888][18] = 124,
	[888][31] = 124,
	[888][32] = 124,
	[888][33] = 124,
	[888][34] = 124,
	[888][35] = 124,
	[888][40] = 124,
	[889][34] = 125,
	[889][35] = 125,
	[889][40] = 125,
	[890][18] = 126,
	[890][31] = 126,
	[890][32] = 126,
	[890][33] = 126,
	[890][34] = 126,
	[890][35] = 126,
	[890][40] = 126,
	[892][18] = 127,
	[892][32] = 127,
	[892][33] = 127,
	[892][34] = 127,
	[892][35] = 127,
	[892][40] = 127,
	[893][6] = 128,
	[893][9] = 128,
	[893][13] = 128,
	[893][15] = 128,
	[893][16] = 128,
	[893][17] = 128,
	[893][18] = 128,
	[893][19] = 128,
	[893][22] = 128,
	[893][23] = 128,
	[893][24] = 128,
	[893][25] = 128,
	[893][26] = 128,
	[893][27] = 128,
	[893][28] = 128,
	[893][29] = 128,
	[893][30] = 128,
	[893][31] = 128,
	[893][32] = 128,
	[893][33] = 128,
	[893][34] = 128,
	[893][35] = 128,
	[893][40] = 128,
	[894][6] = 129,
	[894][9] = 129,
	[894][13] = 129,
	[894][15] = 129,
	[894][16] = 129,
	[894][17] = 129,
	[894][18] = 129,
	[894][19] = 129,
	[894][22] = 129,
	[894][23] = 129,
	[894][24] = 129,
	[894][25] = 129,
	[894][26] = 129,
	[894][27] = 129,
	[894][28] = 129,
	[894][29] = 129,
	[894][30] = 129,
	[894][31] = 129,
	[894][32] = 129,
	[894][33] = 129,
	[894][34] = 129,
	[894][35] = 129,
	[894][40] = 129,
	[895][6] = 130,
	[895][9] = 130,
	[895][13] = 130,
	[895][15] = 130,
	[895][16] = 130,
	[895][17] = 130,
	[895][18] = 130,
	[895][19] = 130,
	[895][22] = 130,
	[895][23] = 130,
	[895][24] = 130,
	[895][25] = 130,
	[895][26] = 130,
	[895][27] = 130,
	[895][28] = 130,
	[895][29] = 130,
	[895][30] = 130,
	[895][31] = 130,
	[895][32] = 130,
	[895][33] = 130,
	[895][34] = 130,
	[895][35] = 130,
	[895][40] = 130,
	[896][35] = 131,
	[896][40] = 131,
	[897][35] = 132,
	[897][40] = 132,
	[898][4] = 133,
	[898][6] = 133,
	[898][8] = 133,
	[898][9] = 133,
	[898][13] = 133,
	[898][15] = 133,
	[898][16] = 133,
	[898][17] = 133,
	[898][18] = 133,
	[898][19] = 133,
	[898][20] = 133,
	[898][21] = 133,
	[898][22] = 133,
	[898][23] = 133,
	[898][24] = 133,
	[898][25] = 133,
	[898][26] = 133,
	[898][27] = 133,
	[898][28] = 133,
	[898][29] = 133,
	[898][30] = 133,
	[898][31] = 133,
	[898][32] = 133,
	[898][33] = 133,
	[898][34] = 133,
	[898][35] = 133,
	[898][40] = 133,
	[902][4] = 134,
	[902][6] = 134,
	[902][8] = 134,
	[902][9] = 134,
	[902][13] = 134,
	[902][15] = 134,
	[902][16] = 134,
	[902][17] = 134,
	[902][18] = 134,
	[902][19] = 134,
	[902][20] = 134,
	[902][21] = 134,
	[902][22] = 134,
	[902][23] = 134,
	[902][24] = 134,
	[902][25] = 134,
	[902][26] = 134,
	[902][27] = 134,
	[902][28] = 134,
	[902][29] = 134,
	[902][30] = 134,
	[902][31] = 134,
	[902][32] = 134,
	[902][33] = 134,
	[902][34] = 134,
	[902][35] = 134,
	[902][40] = 134,
	[903][15] = 135,
	[903][16] = 135,
	[903][17] = 135,
	[903][18] = 135,
	[903][25] = 135,
	[903][26] = 135,
	[903][27] = 135,
	[903][28] = 135,
	[903][29] = 135,
	[903][30] = 135,
	[903][31] = 135,
	[903][32] = 135,
	[903][33] = 135,
	[903][34] = 135,
	[903][35] = 135,
	[903][40] = 135,
	[904][15] = 136,
	[904][16] = 136,
	[904][17] = 136,
	[904][18] = 136,
	[904][25] = 136,
	[904][26] = 136,
	[904][27] = 136,
	[904][28] = 136,
	[904][29] = 136,
	[904][30] = 136,
	[904][31] = 136,
	[904][32] = 136,
	[904][33] = 136,
	[904][34] = 136,
	[904][35] = 136,
	[904][40] = 136,
	[905][15] = 137,
	[905][16] = 137,
	[905][17] = 137,
	[905][18] = 137,
	[905][25] = 137,
	[905][26] = 137,
	[905][27] = 137,
	[905][28] = 137,
	[905][29] = 137,
	[905][30] = 137,
	[905][31] = 137,
	[905][32] = 137,
	[905][33] = 137,
	[905][34] = 137,
	[905][35] = 137,
	[905][40] = 137,
	[906][15] = 138,
	[906][16] = 138,
	[906][17] = 138,
	[906][18] = 138,
	[906][25] = 138,
	[906][26] = 138,
	[906][27] = 138,
	[906][28] = 138,
	[906][29] = 138,
	[906][30] = 138,
	[906][31] = 138,
	[906][32] = 138,
	[906][33] = 138,
	[906][34] = 138,
	[906][35] = 138,
	[906][40] = 138,
	[907][15] = 139,
	[907][16] = 139,
	[907][17] = 139,
	[907][18] = 139,
	[907][23] = 139,
	[907][24] = 139,
	[907][25] = 139,
	[907][26] = 139,
	[907][27] = 139,
	[907][28] = 139,
	[907][29] = 139,
	[907][30] = 139,
	[907][31] = 139,
	[907][32] = 139,
	[907][33] = 139,
	[907][34] = 139,
	[907][35] = 139,
	[907][40] = 139,
	[908][15] = 140,
	[908][16] = 140,
	[908][17] = 140,
	[908][18] = 140,
	[908][23] = 140,
	[908][24] = 140,
	[908][25] = 140,
	[908][26] = 140,
	[908][27] = 140,
	[908][28] = 140,
	[908][29] = 140,
	[908][30] = 140,
	[908][31] = 140,
	[908][32] = 140,
	[908][33] = 140,
	[908][34] = 140,
	[908][35] = 140,
	[908][40] = 140,
	[909][35] = 242,
	[909][36] = 242,
	[910][4] = 243,
	[910][6] = 243,
	[910][8] = 243,
	[910][9] = 243,
	[910][13] = 243,
	[910][15] = 243,
	[910][16] = 243,
	[910][17] = 243,
	[910][18] = 243,
	[910][19] = 243,
	[910][20] = 243,
	[910][21] = 243,
	[910][22] = 243,
	[910][23] = 243,
	[910][24] = 243,
	[910][25] = 243,
	[910][26] = 243,
	[910][27] = 243,
	[910][28] = 243,
	[910][29] = 243,
	[910][30] = 243,
	[910][31] = 243,
	[910][32] = 243,
	[910][33] = 243,
	[910][34] = 243,
	[910][35] = 243,
	[910][36] = 243,
	[912][4] = 244,
	[912][6] = 244,
	[912][8] = 244,
	[912][9] = 244,
	[912][13] = 244,
	[912][15] = 244,
	[912][16] = 244,
	[912][17] = 244,
	[912][18] = 244,
	[912][19] = 244,
	[912][20] = 244,
	[912][21] = 244,
	[912][22] = 244,
	[912][23] = 244,
	[912][24] = 244,
	[912][25] = 244,
	[912][26] = 244,
	[912][27] = 244,
	[912][28] = 244,
	[912][29] = 244,
	[912][30] = 244,
	[912][31] = 244,
	[912][32] = 244,
	[912][33] = 244,
	[912][34] = 244,
	[912][35] = 244,
	[912][36] = 244,
	[913][4] = 86,
	[913][6] = 86,
	[913][8] = 86,
	[913][9] = 86,
	[913][13] = 86,
	[913][15] = 86,
	[913][16] = 86,
	[913][17] = 86,
	[913][18] = 86,
	[913][19] = 86,
	[913][20] = 86,
	[913][21] = 86,
	[913][22] = 86,
	[913][23] = 86,
	[913][24] = 86,
	[913][25] = 86,
	[913][26] = 86,
	[913][27] = 86,
	[913][28] = 86,
	[913][29] = 86,
	[913][30] = 86,
	[913][31] = 86,
	[913][32] = 86,
	[913][33] = 86,
	[913][34] = 86,
	[913][35] = 86,
	[913][39] = 86,
	[915][4] = 87,
	[915][6] = 87,
	[915][8] = 87,
	[915][9] = 87,
	[915][13] = 87,
	[915][15] = 87,
	[915][16] = 87,
	[915][17] = 87,
	[915][18] = 87,
	[915][19] = 87,
	[915][20] = 87,
	[915][21] = 87,
	[915][22] = 87,
	[915][23] = 87,
	[915][24] = 87,
	[915][25] = 87,
	[915][26] = 87,
	[915][27] = 87,
	[915][28] = 87,
	[915][29] = 87,
	[915][30] = 87,
	[915][31] = 87,
	[915][32] = 87,
	[915][33] = 87,
	[915][34] = 87,
	[915][35] = 87,
	[915][39] = 87,
	[917][4] = 88,
	[917][6] = 88,
	[917][8] = 88,
	[917][9] = 88,
	[917][13] = 88,
	[917][15] = 88,
	[917][16] = 88,
	[917][17] = 88,
	[917][18] = 88,
	[917][19] = 88,
	[917][20] = 88,
	[917][21] = 88,
	[917][22] = 88,
	[917][23] = 88,
	[917][24] = 88,
	[917][25] = 88,
	[917][26] = 88,
	[917][27] = 88,
	[917][28] = 88,
	[917][29] = 88,
	[917][30] = 88,
	[917][31] = 88,
	[917][32] = 88,
	[917][33] = 88,
	[917][34] = 88,
	[917][35] = 88,
	[917][39] = 88,
	[920][4] = 89,
	[920][6] = 89,
	[920][8] = 89,
	[920][9] = 89,
	[920][13] = 89,
	[920][15] = 89,
	[920][16] = 89,
	[920][17] = 89,
	[920][18] = 89,
	[920][19] = 89,
	[920][20] = 89,
	[920][21] = 89,
	[920][22] = 89,
	[920][23] = 89,
	[920][24] = 89,
	[920][25] = 89,
	[920][26] = 89,
	[920][27] = 89,
	[920][28] = 89,
	[920][29] = 89,
	[920][30] = 89,
	[920][31] = 89,
	[920][32] = 89,
	[920][33] = 89,
	[920][34] = 89,
	[920][35] = 89,
	[920][39] = 89,
	[921][33] = 99,
	[921][34] = 99,
	[921][35] = 99,
	[921][39] = 99,
	[923][33] = 100,
	[923][34] = 100,
	[923][35] = 100,
	[923][39] = 100,
	[924][33] = 101,
	[924][34] = 101,
	[924][35] = 101,
	[924][39] = 101,
	[926][6] = 103,
	[926][9] = 103,
	[926][15] = 103,
	[926][16] = 103,
	[926][17] = 103,
	[926][18] = 103,
	[926][23] = 103,
	[926][24] = 103,
	[926][25] = 103,
	[926][26] = 103,
	[926][27] = 103,
	[926][28] = 103,
	[926][29] = 103,
	[926][30] = 103,
	[926][31] = 103,
	[926][32] = 103,
	[926][33] = 103,
	[926][34] = 103,
	[926][35] = 103,
	[926][39] = 103,
	[927][6] = 104,
	[927][9] = 104,
	[927][15] = 104,
	[927][16] = 104,
	[927][17] = 104,
	[927][18] = 104,
	[927][23] = 104,
	[927][24] = 104,
	[927][25] = 104,
	[927][26] = 104,
	[927][27] = 104,
	[927][28] = 104,
	[927][29] = 104,
	[927][30] = 104,
	[927][31] = 104,
	[927][32] = 104,
	[927][33] = 104,
	[927][34] = 104,
	[927][35] = 104,
	[927][39] = 104,
	[928][15] = 105,
	[928][16] = 105,
	[928][17] = 105,
	[928][18] = 105,
	[928][31] = 105,
	[928][32] = 105,
	[928][33] = 105,
	[928][34] = 105,
	[928][35] = 105,
	[928][39] = 105,
	[929][15] = 112,
	[929][16] = 112,
	[929][17] = 112,
	[929][18] = 112,
	[929][29] = 112,
	[929][30] = 112,
	[929][31] = 112,
	[929][32] = 112,
	[929][33] = 112,
	[929][34] = 112,
	[929][35] = 112,
	[929][39] = 112,
	[930][15] = 113,
	[930][16] = 113,
	[930][17] = 113,
	[930][18] = 113,
	[930][29] = 113,
	[930][30] = 113,
	[930][31] = 113,
	[930][32] = 113,
	[930][33] = 113,
	[930][34] = 113,
	[930][35] = 113,
	[930][39] = 113,
	[931][16] = 114,
	[931][17] = 114,
	[931][18] = 114,
	[931][31] = 114,
	[931][32] = 114,
	[931][33] = 114,
	[931][34] = 114,
	[931][35] = 114,
	[931][39] = 114,
	[932][6] = 115,
	[932][9] = 115,
	[932][13] = 115,
	[932][15] = 115,
	[932][16] = 115,
	[932][17] = 115,
	[932][18] = 115,
	[932][19] = 115,
	[932][21] = 115,
	[932][22] = 115,
	[932][23] = 115,
	[932][24] = 115,
	[932][25] = 115,
	[932][26] = 115,
	[932][27] = 115,
	[932][28] = 115,
	[932][29] = 115,
	[932][30] = 115,
	[932][31] = 115,
	[932][32] = 115,
	[932][33] = 115,
	[932][34] = 115,
	[932][35] = 115,
	[932][39] = 115,
	[933][39] = 122,
	[934][39] = 123,
	[935][17] = 124,
	[935][18] = 124,
	[935][31] = 124,
	[935][32] = 124,
	[935][33] = 124,
	[935][34] = 124,
	[935][35] = 124,
	[935][39] = 124,
	[936][34] = 125,
	[936][35] = 125,
	[936][39] = 125,
	[937][18] = 126,
	[937][31] = 126,
	[937][32] = 126,
	[937][33] = 126,
	[937][34] = 126,
	[937][35] = 126,
	[937][39] = 126,
	[939][18] = 127,
	[939][32] = 127,
	[939][33] = 127,
	[939][34] = 127,
	[939][35] = 127,
	[939][39] = 127,
	[940][6] = 128,
	[940][9] = 128,
	[940][13] = 128,
	[940][15] = 128,
	[940][16] = 128,
	[940][17] = 128,
	[940][18] = 128,
	[940][19] = 128,
	[940][22] = 128,
	[940][23] = 128,
	[940][24] = 128,
	[940][25] = 128,
	[940][26] = 128,
	[940][27] = 128,
	[940][28] = 128,
	[940][29] = 128,
	[940][30] = 128,
	[940][31] = 128,
	[940][32] = 128,
	[940][33] = 128,
	[940][34] = 128,
	[940][35] = 128,
	[940][39] = 128,
	[941][6] = 129,
	[941][9] = 129,
	[941][13] = 129,
	[941][15] = 129,
	[941][16] = 129,
	[941][17] = 129,
	[941][18] = 129,
	[941][19] = 129,
	[941][22] = 129,
	[941][23] = 129,
	[941][24] = 129,
	[941][25] = 129,
	[941][26] = 129,
	[941][27] = 129,
	[941][28] = 129,
	[941][29] = 129,
	[941][30] = 129,
	[941][31] = 129,
	[941][32] = 129,
	[941][33] = 129,
	[941][34] = 129,
	[941][35] = 129,
	[941][39] = 129,
	[942][6] = 130,
	[942][9] = 130,
	[942][13] = 130,
	[942][15] = 130,
	[942][16] = 130,
	[942][17] = 130,
	[942][18] = 130,
	[942][19] = 130,
	[942][22] = 130,
	[942][23] = 130,
	[942][24] = 130,
	[942][25] = 130,
	[942][26] = 130,
	[942][27] = 130,
	[942][28] = 130,
	[942][29] = 130,
	[942][30] = 130,
	[942][31] = 130,
	[942][32] = 130,
	[942][33] = 130,
	[942][34] = 130,
	[942][35] = 130,
	[942][39] = 130,
	[943][35] = 131,
	[943][39] = 131,
	[944][35] = 132,
	[944][39] = 132,
	[945][4] = 133,
	[945][6] = 133,
	[945][8] = 133,
	[945][9] = 133,
	[945][13] = 133,
	[945][15] = 133,
	[945][16] = 133,
	[945][17] = 133,
	[945][18] = 133,
	[945][19] = 133,
	[945][20] = 133,
	[945][21] = 133,
	[945][22] = 133,
	[945][23] = 133,
	[945][24] = 133,
	[945][25] = 133,
	[945][26] = 133,
	[945][27] = 133,
	[945][28] = 133,
	[945][29] = 133,
	[945][30] = 133,
	[945][31] = 133,
	[945][32] = 133,
	[945][33] = 133,
	[945][34] = 133,
	[945][35] = 133,
	[945][39] = 133,
	[949][4] = 134,
	[949][6] = 134,
	[949][8] = 134,
	[949][9] = 134,
	[949][13] = 134,
	[949][15] = 134,
	[949][16] = 134,
	[949][17] = 134,
	[949][18] = 134,
	[949][19] = 134,
	[949][20] = 134,
	[949][21] = 134,
	[949][22] = 134,
	[949][23] = 134,
	[949][24] = 134,
	[949][25] = 134,
	[949][26] = 134,
	[949][27] = 134,
	[949][28] = 134,
	[949][29] = 134,
	[949][30] = 134,
	[949][31] = 134,
	[949][32] = 134,
	[949][33] = 134,
	[949][34] = 134,
	[949][35] = 134,
	[949][39] = 134,
	[950][15] = 135,
	[950][16] = 135,
	[950][17] = 135,
	[950][18] = 135,
	[950][25] = 135,
	[950][26] = 135,
	[950][27] = 135,
	[950][28] = 135,
	[950][29] = 135,
	[950][30] = 135,
	[950][31] = 135,
	[950][32] = 135,
	[950][33] = 135,
	[950][34] = 135,
	[950][35] = 135,
	[950][39] = 135,
	[951][15] = 136,
	[951][16] = 136,
	[951][17] = 136,
	[951][18] = 136,
	[951][25] = 136,
	[951][26] = 136,
	[951][27] = 136,
	[951][28] = 136,
	[951][29] = 136,
	[951][30] = 136,
	[951][31] = 136,
	[951][32] = 136,
	[951][33] = 136,
	[951][34] = 136,
	[951][35] = 136,
	[951][39] = 136,
	[952][15] = 137,
	[952][16] = 137,
	[952][17] = 137,
	[952][18] = 137,
	[952][25] = 137,
	[952][26] = 137,
	[952][27] = 137,
	[952][28] = 137,
	[952][29] = 137,
	[952][30] = 137,
	[952][31] = 137,
	[952][32] = 137,
	[952][33] = 137,
	[952][34] = 137,
	[952][35] = 137,
	[952][39] = 137,
	[953][15] = 138,
	[953][16] = 138,
	[953][17] = 138,
	[953][18] = 138,
	[953][25] = 138,
	[953][26] = 138,
	[953][27] = 138,
	[953][28] = 138,
	[953][29] = 138,
	[953][30] = 138,
	[953][31] = 138,
	[953][32] = 138,
	[953][33] = 138,
	[953][34] = 138,
	[953][35] = 138,
	[953][39] = 138,
	[954][15] = 139,
	[954][16] = 139,
	[954][17] = 139,
	[954][18] = 139,
	[954][23] = 139,
	[954][24] = 139,
	[954][25] = 139,
	[954][26] = 139,
	[954][27] = 139,
	[954][28] = 139,
	[954][29] = 139,
	[954][30] = 139,
	[954][31] = 139,
	[954][32] = 139,
	[954][33] = 139,
	[954][34] = 139,
	[954][35] = 139,
	[954][39] = 139,
	[955][15] = 140,
	[955][16] = 140,
	[955][17] = 140,
	[955][18] = 140,
	[955][23] = 140,
	[955][24] = 140,
	[955][25] = 140,
	[955][26] = 140,
	[955][27] = 140,
	[955][28] = 140,
	[955][29] = 140,
	[955][30] = 140,
	[955][31] = 140,
	[955][32] = 140,
	[955][33] = 140,
	[955][34] = 140,
	[955][35] = 140,
	[955][39] = 140,
	[956][4] = 206,
	[956][6] = 206,
	[956][8] = 206,
	[956][9] = 206,
	[956][13] = 206,
	[956][15] = 206,
	[956][16] = 206,
	[956][17] = 206,
	[956][18] = 206,
	[956][19] = 206,
	[956][20] = 206,
	[956][21] = 206,
	[956][22] = 206,
	[956][23] = 206,
	[956][24] = 206,
	[956][25] = 206,
	[956][26] = 206,
	[956][27] = 206,
	[956][28] = 206,
	[956][29] = 206,
	[956][30] = 206,
	[956][31] = 206,
	[956][32] = 206,
	[956][33] = 206,
	[956][34] = 206,
	[956][35] = 206,
	[956][37] = 206,
	[956][38] = 206,
	[957][4] = 207,
	[957][6] = 207,
	[957][8] = 207,
	[957][9] = 207,
	[957][13] = 207,
	[957][15] = 207,
	[957][16] = 207,
	[957][17] = 207,
	[957][18] = 207,
	[957][19] = 207,
	[957][20] = 207,
	[957][21] = 207,
	[957][22] = 207,
	[957][23] = 207,
	[957][24] = 207,
	[957][25] = 207,
	[957][26] = 207,
	[957][27] = 207,
	[957][28] = 207,
	[957][29] = 207,
	[957][30] = 207,
	[957][31] = 207,
	[957][32] = 207,
	[957][33] = 207,
	[957][34] = 207,
	[957][35] = 207,
	[957][37] = 207,
	[957][38] = 207,
	[958][33] = 234,
	[958][34] = 234,
	[958][35] = 234,
	[958][37] = 234,
	[958][38] = 234,
	[959][33] = 235,
	[959][34] = 235,
	[959][35] = 235,
	[959][37] = 235,
	[959][38] = 235,
	[960][33] = 238,
	[960][34] = 238,
	[960][35] = 238,
	[960][37] = 238,
	[960][38] = 238,
	[961][33] = 239,
	[961][34] = 239,
	[961][35] = 239,
	[961][37] = 239,
	[961][38] = 239,
	[962][37] = 240,
	[962][38] = 240,
	[963][33] = 241,
	[963][34] = 241,
	[963][35] = 241,
	[963][37] = 241,
	[963][38] = 241,
	[964][35] = 242,
	[964][37] = 242,
	[964][38] = 242,
	[965][4] = 243,
	[965][6] = 243,
	[965][8] = 243,
	[965][9] = 243,
	[965][13] = 243,
	[965][15] = 243,
	[965][16] = 243,
	[965][17] = 243,
	[965][18] = 243,
	[965][19] = 243,
	[965][20] = 243,
	[965][21] = 243,
	[965][22] = 243,
	[965][23] = 243,
	[965][24] = 243,
	[965][25] = 243,
	[965][26] = 243,
	[965][27] = 243,
	[965][28] = 243,
	[965][29] = 243,
	[965][30] = 243,
	[965][31] = 243,
	[965][32] = 243,
	[965][33] = 243,
	[965][34] = 243,
	[965][35] = 243,
	[965][37] = 243,
	[965][38] = 243,
	[967][4] = 244,
	[967][6] = 244,
	[967][8] = 244,
	[967][9] = 244,
	[967][13] = 244,
	[967][15] = 244,
	[967][16] = 244,
	[967][17] = 244,
	[967][18] = 244,
	[967][19] = 244,
	[967][20] = 244,
	[967][21] = 244,
	[967][22] = 244,
	[967][23] = 244,
	[967][24] = 244,
	[967][25] = 244,
	[967][26] = 244,
	[967][27] = 244,
	[967][28] = 244,
	[967][29] = 244,
	[967][30] = 244,
	[967][31] = 244,
	[967][32] = 244,
	[967][33] = 244,
	[967][34] = 244,
	[967][35] = 244,
	[967][37] = 244,
	[967][38] = 244,
	[968][4] = 206,
	[968][6] = 206,
	[968][8] = 206,
	[968][9] = 206,
	[968][13] = 206,
	[968][15] = 206,
	[968][16] = 206,
	[968][17] = 206,
	[968][18] = 206,
	[968][19] = 206,
	[968][20] = 206,
	[968][21] = 206,
	[968][22] = 206,
	[968][23] = 206,
	[968][24] = 206,
	[968][25] = 206,
	[968][26] = 206,
	[968][27] = 206,
	[968][28] = 206,
	[968][29] = 206,
	[968][30] = 206,
	[968][31] = 206,
	[968][32] = 206,
	[968][33] = 206,
	[968][34] = 206,
	[968][35] = 206,
	[968][38] = 206,
	[968][39] = 206,
	[969][4] = 207,
	[969][6] = 207,
	[969][8] = 207,
	[969][9] = 207,
	[969][13] = 207,
	[969][15] = 207,
	[969][16] = 207,
	[969][17] = 207,
	[969][18] = 207,
	[969][19] = 207,
	[969][20] = 207,
	[969][21] = 207,
	[969][22] = 207,
	[969][23] = 207,
	[969][24] = 207,
	[969][25] = 207,
	[969][26] = 207,
	[969][27] = 207,
	[969][28] = 207,
	[969][29] = 207,
	[969][30] = 207,
	[969][31] = 207,
	[969][32] = 207,
	[969][33] = 207,
	[969][34] = 207,
	[969][35] = 207,
	[969][38] = 207,
	[969][39] = 207,
	[970][33] = 234,
	[970][34] = 234,
	[970][35] = 234,
	[970][38] = 234,
	[970][39] = 234,
	[971][33] = 235,
	[971][34] = 235,
	[971][35] = 235,
	[971][38] = 235,
	[971][39] = 235,
	[972][33] = 238,
	[972][34] = 238,
	[972][35] = 238,
	[972][38] = 238,
	[972][39] = 238,
	[973][33] = 239,
	[973][34] = 239,
	[973][35] = 239,
	[973][38] = 239,
	[973][39] = 239,
	[974][38] = 240,
	[974][39] = 240,
	[975][33] = 241,
	[975][34] = 241,
	[975][35] = 241,
	[975][38] = 241,
	[975][39] = 241,
	[976][35] = 242,
	[976][38] = 242,
	[976][39] = 242,
	[977][4] = 243,
	[977][6] = 243,
	[977][8] = 243,
	[977][9] = 243,
	[977][13] = 243,
	[977][15] = 243,
	[977][16] = 243,
	[977][17] = 243,
	[977][18] = 243,
	[977][19] = 243,
	[977][20] = 243,
	[977][21] = 243,
	[977][22] = 243,
	[977][23] = 243,
	[977][24] = 243,
	[977][25] = 243,
	[977][26] = 243,
	[977][27] = 243,
	[977][28] = 243,
	[977][29] = 243,
	[977][30] = 243,
	[977][31] = 243,
	[977][32] = 243,
	[977][33] = 243,
	[977][34] = 243,
	[977][35] = 243,
	[977][38] = 243,
	[977][39] = 243,
	[979][4] = 244,
	[979][6] = 244,
	[979][8] = 244,
	[979][9] = 244,
	[979][13] = 244,
	[979][15] = 244,
	[979][16] = 244,
	[979][17] = 244,
	[979][18] = 244,
	[979][19] = 244,
	[979][20] = 244,
	[979][21] = 244,
	[979][22] = 244,
	[979][23] = 244,
	[979][24] = 244,
	[979][25] = 244,
	[979][26] = 244,
	[979][27] = 244,
	[979][28] = 244,
	[979][29] = 244,
	[979][30] = 244,
	[979][31] = 244,
	[979][32] = 244,
	[979][33] = 244,
	[979][34] = 244,
	[979][35] = 244,
	[979][38] = 244,
	[979][39] = 244,
	[980][2] = 245,
	[980][3] = 245,
	[980][4] = 245,
	[980][7] = 245,
	[980][8] = 245,
	[980][9] = 245,
	[980][11] = 245,
	[980][17] = 245,
	[980][18] = 245,
	[980][19] = 245,
	[980][22] = 245,
	[980][36] = 245,
	[981][2] = 246,
	[981][3] = 246,
	[981][4] = 246,
	[981][7] = 246,
	[981][8] = 246,
	[981][9] = 246,
	[981][11] = 246,
	[981][17] = 246,
	[981][18] = 246,
	[981][19] = 246,
	[981][22] = 246,
	[981][36] = 246,
	[982][2] = 208,
	[982][3] = 208,
	[982][4] = 208,
	[982][7] = 208,
	[982][8] = 208,
	[982][9] = 208,
	[982][11] = 208,
	[982][17] = 208,
	[982][18] = 208,
	[982][19] = 208,
	[982][22] = 208,
	[982][37] = 208,
	[983][2] = 209,
	[983][3] = 209,
	[983][4] = 209,
	[983][7] = 209,
	[983][8] = 209,
	[983][9] = 209,
	[983][11] = 209,
	[983][17] = 209,
	[983][18] = 209,
	[983][19] = 209,
	[983][22] = 209,
	[983][37] = 209,
	[984][2] = 210,
	[984][3] = 210,
	[984][4] = 210,
	[984][7] = 210,
	[984][8] = 210,
	[984][9] = 210,
	[984][11] = 210,
	[984][17] = 210,
	[984][18] = 210,
	[984][19] = 210,
	[984][22] = 210,
	[984][37] = 210,
	[985][2] = 211,
	[985][3] = 211,
	[985][4] = 211,
	[985][7] = 211,
	[985][8] = 211,
	[985][9] = 211,
	[985][11] = 211,
	[985][17] = 211,
	[985][18] = 211,
	[985][19] = 211,
	[985][22] = 211,
	[985][37] = 211,
	[986][2] = 212,
	[986][3] = 212,
	[986][4] = 212,
	[986][7] = 212,
	[986][8] = 212,
	[986][9] = 212,
	[986][11] = 212,
	[986][17] = 212,
	[986][18] = 212,
	[986][19] = 212,
	[986][22] = 212,
	[986][37] = 212,
	[987][2] = 213,
	[987][3] = 213,
	[987][4] = 213,
	[987][7] = 213,
	[987][8] = 213,
	[987][9] = 213,
	[987][11] = 213,
	[987][17] = 213,
	[987][18] = 213,
	[987][19] = 213,
	[987][22] = 213,
	[987][37] = 213,
	[988][2] = 214,
	[988][3] = 214,
	[988][4] = 214,
	[988][7] = 214,
	[988][8] = 214,
	[988][9] = 214,
	[988][11] = 214,
	[988][17] = 214,
	[988][18] = 214,
	[988][19] = 214,
	[988][22] = 214,
	[988][37] = 214,
	[989][2] = 216,
	[989][3] = 216,
	[989][4] = 216,
	[989][7] = 216,
	[989][8] = 216,
	[989][9] = 216,
	[989][11] = 216,
	[989][17] = 216,
	[989][18] = 216,
	[989][19] = 216,
	[989][22] = 216,
	[989][37] = 216,
	[990][2] = 218,
	[990][3] = 218,
	[990][4] = 218,
	[990][7] = 218,
	[990][8] = 218,
	[990][9] = 218,
	[990][11] = 218,
	[990][17] = 218,
	[990][18] = 218,
	[990][19] = 218,
	[990][22] = 218,
	[990][37] = 218,
	[991][2] = 219,
	[991][3] = 219,
	[991][4] = 219,
	[991][7] = 219,
	[991][8] = 219,
	[991][9] = 219,
	[991][11] = 219,
	[991][17] = 219,
	[991][18] = 219,
	[991][19] = 219,
	[991][22] = 219,
	[991][37] = 219,
	[992][2] = 220,
	[992][3] = 220,
	[992][4] = 220,
	[992][7] = 220,
	[992][8] = 220,
	[992][9] = 220,
	[992][11] = 220,
	[992][17] = 220,
	[992][18] = 220,
	[992][19] = 220,
	[992][22] = 220,
	[992][37] = 220,
	[993][2] = 247,
	[993][3] = 247,
	[993][4] = 247,
	[993][7] = 247,
	[993][8] = 247,
	[993][9] = 247,
	[993][11] = 247,
	[993][17] = 247,
	[993][18] = 247,
	[993][19] = 247,
	[993][22] = 247,
	[993][36] = 247,
	[994][37] = 225,
	[995][37] = 226,
	[996][17] = 227,
	[996][37] = 227,
	[997][17] = 228,
	[997][37] = 228,
	[998][2] = 248,
	[998][3] = 248,
	[998][4] = 248,
	[998][7] = 248,
	[998][8] = 248,
	[998][9] = 248,
	[998][11] = 248,
	[998][17] = 248,
	[998][18] = 248,
	[998][19] = 248,
	[998][22] = 248,
	[998][36] = 248,
	[1000][2] = 215,
	[1000][3] = 215,
	[1000][4] = 215,
	[1000][5] = 215,
	[1000][6] = 215,
	[1000][15] = 215,
	[1000][16] = 215,
	[1000][17] = 215,
	[1000][37] = 215,
	[1000][38] = 215,
	[1001][2] = 249,
	[1001][3] = 249,
	[1001][4] = 249,
	[1001][5] = 249,
	[1001][6] = 249,
	[1001][15] = 249,
	[1001][16] = 249,
	[1001][17] = 249,
	[1001][38] = 249,
	[1001][39] = 249,
	[1007][37] = 217,
	[1008][2] = 250,
	[1008][3] = 250,
	[1008][4] = 250,
	[1008][7] = 250,
	[1008][8] = 250,
	[1008][9] = 250,
	[1008][11] = 250,
	[1008][17] = 250,
	[1008][18] = 250,
	[1008][19] = 250,
	[1008][22] = 250,
	[1008][36] = 250,
	[1009][2] = 251,
	[1009][3] = 251,
	[1009][4] = 251,
	[1009][5] = 251,
	[1009][17] = 251,
	[1009][38] = 251,
	[1009][39] = 251,
	[1010][2] = 252,
	[1010][3] = 252,
	[1010][4] = 252,
	[1010][5] = 252,
	[1010][17] = 252,
	[1010][38] = 252,
	[1010][39] = 252,
	[1011][2] = 172,
	[1011][3] = 172,
	[1011][4] = 172,
	[1011][5] = 172,
	[1011][15] = 172,
	[1011][16] = 172,
	[1011][17] = 172,
	[1011][38] = 172,
	[1011][39] = 172,
	[1012][2] = 173,
	[1012][3] = 173,
	[1012][4] = 173,
	[1012][5] = 173,
	[1012][15] = 173,
	[1012][16] = 173,
	[1012][17] = 173,
	[1012][38] = 173,
	[1012][39] = 173,
	[1015][2] = 174,
	[1015][3] = 174,
	[1015][4] = 174,
	[1015][5] = 174,
	[1015][15] = 174,
	[1015][16] = 174,
	[1015][17] = 174,
	[1015][38] = 174,
	[1015][39] = 174,
	[1016][2] = 253,
	[1016][3] = 253,
	[1016][4] = 253,
	[1016][5] = 253,
	[1016][15] = 253,
	[1016][16] = 253,
	[1016][17] = 253,
	[1016][38] = 253,
	[1016][39] = 253,
	[1017][2] = 254,
	[1017][3] = 254,
	[1017][4] = 254,
	[1017][5] = 254,
	[1017][16] = 254,
	[1017][17] = 254,
	[1017][38] = 254,
	[1017][39] = 254,
	[1018][2] = 255,
	[1018][3] = 255,
	[1018][4] = 255,
	[1018][5] = 255,
	[1018][16] = 255,
	[1018][17] = 255,
	[1018][38] = 255,
	[1018][39] = 255,
	[1019][39] = 256,
	[1020][39] = 257,
	[1021][39] = 258,
	[1022][39] = 259,
	[1025][39] = 260,
	[1026][39] = 261,
	[1027][2] = 262,
	[1027][3] = 262,
	[1027][4] = 262,
	[1027][7] = 262,
	[1027][8] = 262,
	[1027][9] = 262,
	[1027][11] = 262,
	[1027][17] = 262,
	[1027][18] = 262,
	[1027][19] = 262,
	[1027][22] = 262,
	[1027][36] = 262,
	[1030][2] = 263,
	[1030][3] = 263,
	[1030][4] = 263,
	[1030][7] = 263,
	[1030][8] = 263,
	[1030][9] = 263,
	[1030][17] = 263,
	[1030][18] = 263,
	[1030][19] = 263,
	[1030][22] = 263,
	[1031][2] = 221,
	[1031][3] = 221,
	[1031][4] = 221,
	[1031][7] = 221,
	[1031][8] = 221,
	[1031][17] = 221,
	[1031][37] = 221,
	[1032][2] = 222,
	[1032][3] = 222,
	[1032][4] = 222,
	[1032][7] = 222,
	[1032][8] = 222,
	[1032][17] = 222,
	[1032][37] = 222,
	[1033][2] = 223,
	[1033][3] = 223,
	[1033][4] = 223,
	[1033][7] = 223,
	[1033][8] = 223,
	[1033][17] = 223,
	[1033][37] = 223,
	[1035][17] = 224,
	[1035][37] = 224,
	[1036][2] = 264,
	[1036][3] = 264,
	[1036][4] = 264,
	[1036][7] = 264,
	[1036][8] = 264,
	[1036][9] = 264,
	[1036][17] = 264,
	[1036][18] = 264,
	[1036][19] = 264,
	[1036][22] = 264,
	[1037][2] = 265,
	[1037][3] = 265,
	[1037][4] = 265,
	[1037][7] = 265,
	[1037][8] = 265,
	[1037][9] = 265,
	[1037][11] = 265,
	[1037][17] = 265,
	[1037][18] = 265,
	[1037][19] = 265,
	[1037][22] = 265,
	[1037][36] = 265,
	[1038][22] = 266,
	[1039][22] = 267,
	[1040][17] = 268,
	[1040][22] = 268,
	[1041][17] = 269,
	[1041][22] = 269,
	[1043][17] = 270,
	[1043][36] = 270,
	[1044][2] = 263,
	[1044][3] = 263,
	[1044][4] = 263,
	[1044][7] = 263,
	[1044][8] = 263,
	[1044][9] = 263,
	[1044][17] = 263,
	[1044][18] = 263,
	[1044][19] = 263,
	[1044][36] = 263,
	[1045][2] = 264,
	[1045][3] = 264,
	[1045][4] = 264,
	[1045][7] = 264,
	[1045][8] = 264,
	[1045][9] = 264,
	[1045][17] = 264,
	[1045][18] = 264,
	[1045][19] = 264,
	[1045][36] = 264,
	[1046][36] = 266,
	[1047][36] = 267,
	[1048][17] = 268,
	[1048][36] = 268,
	[1049][17] = 269,
	[1049][36] = 269,
	[1050][37] = 232,
	[1050][38] = 232,
	[1050][54] = 232,
	[1052][37] = 233,
	[1052][38] = 233,
	[1052][54] = 233,
	[1053][11] = 271,
	[1053][54] = 271,
	[1056][37] = 236,
	[1056][38] = 236,
	[1057][37] = 237,
	[1057][38] = 237,
	[1058][38] = 232,
	[1058][40] = 232,
	[1058][54] = 232,
	[1060][38] = 233,
	[1060][40] = 233,
	[1060][54] = 233,
	[1061][11] = 272,
	[1062][11] = 273,
	[1065][38] = 236,
	[1065][40] = 236,
	[1066][38] = 237,
	[1066][40] = 237,
	[1067][4] = 165,
	[1067][6] = 165,
	[1067][8] = 165,
	[1067][9] = 165,
	[1067][13] = 165,
	[1067][15] = 165,
	[1067][16] = 165,
	[1067][17] = 165,
	[1067][18] = 165,
	[1067][19] = 165,
	[1067][20] = 165,
	[1067][21] = 165,
	[1067][22] = 165,
	[1067][23] = 165,
	[1067][24] = 165,
	[1067][25] = 165,
	[1067][26] = 165,
	[1067][27] = 165,
	[1067][28] = 165,
	[1067][29] = 165,
	[1067][30] = 165,
	[1067][31] = 165,
	[1067][32] = 165,
	[1067][33] = 165,
	[1067][34] = 165,
	[1067][35] = 165,
	[1067][40] = 165,
	[1069][4] = 166,
	[1069][6] = 166,
	[1069][8] = 166,
	[1069][9] = 166,
	[1069][13] = 166,
	[1069][15] = 166,
	[1069][16] = 166,
	[1069][17] = 166,
	[1069][18] = 166,
	[1069][19] = 166,
	[1069][20] = 166,
	[1069][21] = 166,
	[1069][22] = 166,
	[1069][23] = 166,
	[1069][24] = 166,
	[1069][25] = 166,
	[1069][26] = 166,
	[1069][27] = 166,
	[1069][28] = 166,
	[1069][29] = 166,
	[1069][30] = 166,
	[1069][31] = 166,
	[1069][32] = 166,
	[1069][33] = 166,
	[1069][34] = 166,
	[1069][35] = 166,
	[1069][40] = 166,
	[1071][4] = 167,
	[1071][6] = 167,
	[1071][8] = 167,
	[1071][9] = 167,
	[1071][13] = 167,
	[1071][15] = 167,
	[1071][16] = 167,
	[1071][17] = 167,
	[1071][18] = 167,
	[1071][19] = 167,
	[1071][20] = 167,
	[1071][21] = 167,
	[1071][22] = 167,
	[1071][23] = 167,
	[1071][24] = 167,
	[1071][25] = 167,
	[1071][26] = 167,
	[1071][27] = 167,
	[1071][28] = 167,
	[1071][29] = 167,
	[1071][30] = 167,
	[1071][31] = 167,
	[1071][32] = 167,
	[1071][33] = 167,
	[1071][34] = 167,
	[1071][35] = 167,
	[1071][40] = 167,
	[1072][4] = 168,
	[1072][6] = 168,
	[1072][8] = 168,
	[1072][9] = 168,
	[1072][13] = 168,
	[1072][15] = 168,
	[1072][16] = 168,
	[1072][17] = 168,
	[1072][18] = 168,
	[1072][19] = 168,
	[1072][20] = 168,
	[1072][21] = 168,
	[1072][22] = 168,
	[1072][23] = 168,
	[1072][24] = 168,
	[1072][25] = 168,
	[1072][26] = 168,
	[1072][27] = 168,
	[1072][28] = 168,
	[1072][29] = 168,
	[1072][30] = 168,
	[1072][31] = 168,
	[1072][32] = 168,
	[1072][33] = 168,
	[1072][34] = 168,
	[1072][35] = 168,
	[1072][40] = 168,
	[1080][4] = 203,
	[1080][6] = 203,
	[1080][8] = 203,
	[1080][9] = 203,
	[1080][13] = 203,
	[1080][15] = 203,
	[1080][16] = 203,
	[1080][17] = 203,
	[1080][18] = 203,
	[1080][19] = 203,
	[1080][20] = 203,
	[1080][21] = 203,
	[1080][22] = 203,
	[1080][23] = 203,
	[1080][24] = 203,
	[1080][25] = 203,
	[1080][26] = 203,
	[1080][27] = 203,
	[1080][28] = 203,
	[1080][29] = 203,
	[1080][30] = 203,
	[1080][31] = 203,
	[1080][32] = 203,
	[1080][33] = 203,
	[1080][34] = 203,
	[1080][35] = 203,
	[1080][40] = 203,
	[1082][4] = 204,
	[1082][6] = 204,
	[1082][8] = 204,
	[1082][9] = 204,
	[1082][13] = 204,
	[1082][15] = 204,
	[1082][16] = 204,
	[1082][17] = 204,
	[1082][18] = 204,
	[1082][19] = 204,
	[1082][20] = 204,
	[1082][21] = 204,
	[1082][22] = 204,
	[1082][23] = 204,
	[1082][24] = 204,
	[1082][25] = 204,
	[1082][26] = 204,
	[1082][27] = 204,
	[1082][28] = 204,
	[1082][29] = 204,
	[1082][30] = 204,
	[1082][31] = 204,
	[1082][32] = 204,
	[1082][33] = 204,
	[1082][34] = 204,
	[1082][35] = 204,
	[1082][40] = 204,
	[1084][4] = 205,
	[1084][6] = 205,
	[1084][8] = 205,
	[1084][9] = 205,
	[1084][13] = 205,
	[1084][15] = 205,
	[1084][16] = 205,
	[1084][17] = 205,
	[1084][18] = 205,
	[1084][19] = 205,
	[1084][20] = 205,
	[1084][21] = 205,
	[1084][22] = 205,
	[1084][23] = 205,
	[1084][24] = 205,
	[1084][25] = 205,
	[1084][26] = 205,
	[1084][27] = 205,
	[1084][28] = 205,
	[1084][29] = 205,
	[1084][30] = 205,
	[1084][31] = 205,
	[1084][32] = 205,
	[1084][33] = 205,
	[1084][34] = 205,
	[1084][35] = 205,
	[1084][40] = 205,
	[1085][4] = 274,
	[1085][6] = 274,
	[1085][8] = 274,
	[1085][9] = 274,
	[1085][13] = 274,
	[1085][15] = 274,
	[1085][16] = 274,
	[1085][17] = 274,
	[1085][18] = 274,
	[1085][19] = 274,
	[1085][20] = 274,
	[1085][21] = 274,
	[1085][22] = 274,
	[1085][23] = 274,
	[1085][24] = 274,
	[1085][25] = 274,
	[1085][26] = 274,
	[1085][27] = 274,
	[1085][28] = 274,
	[1085][29] = 274,
	[1085][30] = 274,
	[1085][31] = 274,
	[1085][32] = 274,
	[1085][33] = 274,
	[1085][34] = 274,
	[1085][35] = 274,
	[1085][36] = 274,
	[1086][4] = 165,
	[1086][6] = 165,
	[1086][8] = 165,
	[1086][9] = 165,
	[1086][13] = 165,
	[1086][15] = 165,
	[1086][16] = 165,
	[1086][17] = 165,
	[1086][18] = 165,
	[1086][19] = 165,
	[1086][20] = 165,
	[1086][21] = 165,
	[1086][22] = 165,
	[1086][23] = 165,
	[1086][24] = 165,
	[1086][25] = 165,
	[1086][26] = 165,
	[1086][27] = 165,
	[1086][28] = 165,
	[1086][29] = 165,
	[1086][30] = 165,
	[1086][31] = 165,
	[1086][32] = 165,
	[1086][33] = 165,
	[1086][34] = 165,
	[1086][35] = 165,
	[1086][39] = 165,
	[1088][4] = 166,
	[1088][6] = 166,
	[1088][8] = 166,
	[1088][9] = 166,
	[1088][13] = 166,
	[1088][15] = 166,
	[1088][16] = 166,
	[1088][17] = 166,
	[1088][18] = 166,
	[1088][19] = 166,
	[1088][20] = 166,
	[1088][21] = 166,
	[1088][22] = 166,
	[1088][23] = 166,
	[1088][24] = 166,
	[1088][25] = 166,
	[1088][26] = 166,
	[1088][27] = 166,
	[1088][28] = 166,
	[1088][29] = 166,
	[1088][30] = 166,
	[1088][31] = 166,
	[1088][32] = 166,
	[1088][33] = 166,
	[1088][34] = 166,
	[1088][35] = 166,
	[1088][39] = 166,
	[1090][4] = 167,
	[1090][6] = 167,
	[1090][8] = 167,
	[1090][9] = 167,
	[1090][13] = 167,
	[1090][15] = 167,
	[1090][16] = 167,
	[1090][17] = 167,
	[1090][18] = 167,
	[1090][19] = 167,
	[1090][20] = 167,
	[1090][21] = 167,
	[1090][22] = 167,
	[1090][23] = 167,
	[1090][24] = 167,
	[1090][25] = 167,
	[1090][26] = 167,
	[1090][27] = 167,
	[1090][28] = 167,
	[1090][29] = 167,
	[1090][30] = 167,
	[1090][31] = 167,
	[1090][32] = 167,
	[1090][33] = 167,
	[1090][34] = 167,
	[1090][35] = 167,
	[1090][39] = 167,
	[1091][4] = 168,
	[1091][6] = 168,
	[1091][8] = 168,
	[1091][9] = 168,
	[1091][13] = 168,
	[1091][15] = 168,
	[1091][16] = 168,
	[1091][17] = 168,
	[1091][18] = 168,
	[1091][19] = 168,
	[1091][20] = 168,
	[1091][21] = 168,
	[1091][22] = 168,
	[1091][23] = 168,
	[1091][24] = 168,
	[1091][25] = 168,
	[1091][26] = 168,
	[1091][27] = 168,
	[1091][28] = 168,
	[1091][29] = 168,
	[1091][30] = 168,
	[1091][31] = 168,
	[1091][32] = 168,
	[1091][33] = 168,
	[1091][34] = 168,
	[1091][35] = 168,
	[1091][39] = 168,
	[1099][4] = 203,
	[1099][6] = 203,
	[1099][8] = 203,
	[1099][9] = 203,
	[1099][13] = 203,
	[1099][15] = 203,
	[1099][16] = 203,
	[1099][17] = 203,
	[1099][18] = 203,
	[1099][19] = 203,
	[1099][20] = 203,
	[1099][21] = 203,
	[1099][22] = 203,
	[1099][23] = 203,
	[1099][24] = 203,
	[1099][25] = 203,
	[1099][26] = 203,
	[1099][27] = 203,
	[1099][28] = 203,
	[1099][29] = 203,
	[1099][30] = 203,
	[1099][31] = 203,
	[1099][32] = 203,
	[1099][33] = 203,
	[1099][34] = 203,
	[1099][35] = 203,
	[1099][39] = 203,
	[1101][4] = 204,
	[1101][6] = 204,
	[1101][8] = 204,
	[1101][9] = 204,
	[1101][13] = 204,
	[1101][15] = 204,
	[1101][16] = 204,
	[1101][17] = 204,
	[1101][18] = 204,
	[1101][19] = 204,
	[1101][20] = 204,
	[1101][21] = 204,
	[1101][22] = 204,
	[1101][23] = 204,
	[1101][24] = 204,
	[1101][25] = 204,
	[1101][26] = 204,
	[1101][27] = 204,
	[1101][28] = 204,
	[1101][29] = 204,
	[1101][30] = 204,
	[1101][31] = 204,
	[1101][32] = 204,
	[1101][33] = 204,
	[1101][34] = 204,
	[1101][35] = 204,
	[1101][39] = 204,
	[1103][4] = 205,
	[1103][6] = 205,
	[1103][8] = 205,
	[1103][9] = 205,
	[1103][13] = 205,
	[1103][15] = 205,
	[1103][16] = 205,
	[1103][17] = 205,
	[1103][18] = 205,
	[1103][19] = 205,
	[1103][20] = 205,
	[1103][21] = 205,
	[1103][22] = 205,
	[1103][23] = 205,
	[1103][24] = 205,
	[1103][25] = 205,
	[1103][26] = 205,
	[1103][27] = 205,
	[1103][28] = 205,
	[1103][29] = 205,
	[1103][30] = 205,
	[1103][31] = 205,
	[1103][32] = 205,
	[1103][33] = 205,
	[1103][34] = 205,
	[1103][35] = 205,
	[1103][39] = 205,
	[1104][4] = 274,
	[1104][6] = 274,
	[1104][8] = 274,
	[1104][9] = 274,
	[1104][13] = 274,
	[1104][15] = 274,
	[1104][16] = 274,
	[1104][17] = 274,
	[1104][18] = 274,
	[1104][19] = 274,
	[1104][20] = 274,
	[1104][21] = 274,
	[1104][22] = 274,
	[1104][23] = 274,
	[1104][24] = 274,
	[1104][25] = 274,
	[1104][26] = 274,
	[1104][27] = 274,
	[1104][28] = 274,
	[1104][29] = 274,
	[1104][30] = 274,
	[1104][31] = 274,
	[1104][32] = 274,
	[1104][33] = 274,
	[1104][34] = 274,
	[1104][35] = 274,
	[1104][37] = 274,
	[1104][38] = 274,
	[1105][4] = 274,
	[1105][6] = 274,
	[1105][8] = 274,
	[1105][9] = 274,
	[1105][13] = 274,
	[1105][15] = 274,
	[1105][16] = 274,
	[1105][17] = 274,
	[1105][18] = 274,
	[1105][19] = 274,
	[1105][20] = 274,
	[1105][21] = 274,
	[1105][22] = 274,
	[1105][23] = 274,
	[1105][24] = 274,
	[1105][25] = 274,
	[1105][26] = 274,
	[1105][27] = 274,
	[1105][28] = 274,
	[1105][29] = 274,
	[1105][30] = 274,
	[1105][31] = 274,
	[1105][32] = 274,
	[1105][33] = 274,
	[1105][34] = 274,
	[1105][35] = 274,
	[1105][38] = 274,
	[1105][39] = 274,
	[1106][2] = 245,
	[1106][3] = 245,
	[1106][4] = 245,
	[1106][7] = 245,
	[1106][8] = 245,
	[1106][9] = 245,
	[1106][11] = 245,
	[1106][17] = 245,
	[1106][18] = 245,
	[1106][19] = 245,
	[1106][22] = 245,
	[1106][37] = 245,
	[1107][2] = 246,
	[1107][3] = 246,
	[1107][4] = 246,
	[1107][7] = 246,
	[1107][8] = 246,
	[1107][9] = 246,
	[1107][11] = 246,
	[1107][17] = 246,
	[1107][18] = 246,
	[1107][19] = 246,
	[1107][22] = 246,
	[1107][37] = 246,
	[1108][2] = 247,
	[1108][3] = 247,
	[1108][4] = 247,
	[1108][7] = 247,
	[1108][8] = 247,
	[1108][9] = 247,
	[1108][11] = 247,
	[1108][17] = 247,
	[1108][18] = 247,
	[1108][19] = 247,
	[1108][22] = 247,
	[1108][37] = 247,
	[1109][2] = 248,
	[1109][3] = 248,
	[1109][4] = 248,
	[1109][7] = 248,
	[1109][8] = 248,
	[1109][9] = 248,
	[1109][11] = 248,
	[1109][17] = 248,
	[1109][18] = 248,
	[1109][19] = 248,
	[1109][22] = 248,
	[1109][37] = 248,
	[1110][2] = 250,
	[1110][3] = 250,
	[1110][4] = 250,
	[1110][7] = 250,
	[1110][8] = 250,
	[1110][9] = 250,
	[1110][11] = 250,
	[1110][17] = 250,
	[1110][18] = 250,
	[1110][19] = 250,
	[1110][22] = 250,
	[1110][37] = 250,
	[1111][2] = 262,
	[1111][3] = 262,
	[1111][4] = 262,
	[1111][7] = 262,
	[1111][8] = 262,
	[1111][9] = 262,
	[1111][11] = 262,
	[1111][17] = 262,
	[1111][18] = 262,
	[1111][19] = 262,
	[1111][22] = 262,
	[1111][37] = 262,
	[1112][2] = 265,
	[1112][3] = 265,
	[1112][4] = 265,
	[1112][7] = 265,
	[1112][8] = 265,
	[1112][9] = 265,
	[1112][11] = 265,
	[1112][17] = 265,
	[1112][18] = 265,
	[1112][19] = 265,
	[1112][22] = 265,
	[1112][37] = 265,
	[1113][2] = 275,
	[1113][3] = 275,
	[1113][4] = 275,
	[1113][7] = 275,
	[1113][8] = 275,
	[1113][9] = 275,
	[1113][11] = 275,
	[1113][17] = 275,
	[1113][18] = 275,
	[1113][19] = 275,
	[1113][22] = 275,
	[1113][36] = 275,
	[1115][17] = 270,
	[1115][37] = 270,
	[1116][2] = 249,
	[1116][3] = 249,
	[1116][4] = 249,
	[1116][5] = 249,
	[1116][6] = 249,
	[1116][15] = 249,
	[1116][16] = 249,
	[1116][17] = 249,
	[1116][37] = 249,
	[1116][38] = 249,
	[1117][2] = 251,
	[1117][3] = 251,
	[1117][4] = 251,
	[1117][5] = 251,
	[1117][17] = 251,
	[1117][37] = 251,
	[1117][38] = 251,
	[1118][2] = 252,
	[1118][3] = 252,
	[1118][4] = 252,
	[1118][5] = 252,
	[1118][17] = 252,
	[1118][37] = 252,
	[1118][38] = 252,
	[1119][2] = 172,
	[1119][3] = 172,
	[1119][4] = 172,
	[1119][5] = 172,
	[1119][15] = 172,
	[1119][16] = 172,
	[1119][17] = 172,
	[1119][37] = 172,
	[1119][38] = 172,
	[1120][2] = 173,
	[1120][3] = 173,
	[1120][4] = 173,
	[1120][5] = 173,
	[1120][15] = 173,
	[1120][16] = 173,
	[1120][17] = 173,
	[1120][37] = 173,
	[1120][38] = 173,
	[1123][2] = 174,
	[1123][3] = 174,
	[1123][4] = 174,
	[1123][5] = 174,
	[1123][15] = 174,
	[1123][16] = 174,
	[1123][17] = 174,
	[1123][37] = 174,
	[1123][38] = 174,
	[1124][2] = 253,
	[1124][3] = 253,
	[1124][4] = 253,
	[1124][5] = 253,
	[1124][15] = 253,
	[1124][16] = 253,
	[1124][17] = 253,
	[1124][37] = 253,
	[1124][38] = 253,
	[1125][2] = 254,
	[1125][3] = 254,
	[1125][4] = 254,
	[1125][5] = 254,
	[1125][16] = 254,
	[1125][17] = 254,
	[1125][37] = 254,
	[1125][38] = 254,
	[1126][2] = 255,
	[1126][3] = 255,
	[1126][4] = 255,
	[1126][5] = 255,
	[1126][16] = 255,
	[1126][17] = 255,
	[1126][37] = 255,
	[1126][38] = 255,
	[1127][37] = 256,
	[1128][37] = 257,
	[1129][37] = 258,
	[1130][37] = 259,
	[1133][37] = 260,
	[1134][37] = 261,
	[1135][2] = 276,
	[1135][3] = 276,
	[1135][4] = 276,
	[1135][7] = 276,
	[1135][8] = 276,
	[1135][9] = 276,
	[1135][11] = 276,
	[1135][17] = 276,
	[1135][18] = 276,
	[1135][19] = 276,
	[1135][22] = 276,
	[1135][36] = 276,
	[1136][2] = 277,
	[1136][3] = 277,
	[1136][4] = 277,
	[1136][7] = 277,
	[1136][8] = 277,
	[1136][9] = 277,
	[1136][11] = 277,
	[1136][17] = 277,
	[1136][18] = 277,
	[1136][19] = 277,
	[1136][22] = 277,
	[1136][36] = 277,
	[1139][2] = 215,
	[1139][3] = 215,
	[1139][4] = 215,
	[1139][5] = 215,
	[1139][15] = 215,
	[1139][16] = 215,
	[1139][17] = 215,
	[1139][38] = 215,
	[1139][39] = 215,
	[1141][39] = 278,
	[1142][39] = 279,
	[1143][39] = 280,
	[1144][39] = 281,
	[1145][39] = 282,
	[1146][2] = 263,
	[1146][3] = 263,
	[1146][4] = 263,
	[1146][7] = 263,
	[1146][8] = 263,
	[1146][9] = 263,
	[1146][17] = 263,
	[1146][18] = 263,
	[1146][19] = 263,
	[1146][37] = 263,
	[1147][2] = 264,
	[1147][3] = 264,
	[1147][4] = 264,
	[1147][7] = 264,
	[1147][8] = 264,
	[1147][9] = 264,
	[1147][17] = 264,
	[1147][18] = 264,
	[1147][19] = 264,
	[1147][37] = 264,
	[1148][37] = 266,
	[1149][37] = 267,
	[1150][17] = 268,
	[1150][37] = 268,
	[1151][17] = 269,
	[1151][37] = 269,
	[1152][2] = 283,
	[1152][3] = 283,
	[1152][4] = 283,
	[1152][7] = 283,
	[1152][8] = 283,
	[1152][9] = 283,
	[1152][11] = 283,
	[1152][17] = 283,
	[1152][18] = 283,
	[1152][19] = 283,
	[1152][22] = 283,
	[1152][36] = 283,
	[1153][2] = 284,
	[1153][3] = 284,
	[1153][4] = 284,
	[1153][7] = 284,
	[1153][8] = 284,
	[1153][9] = 284,
	[1153][11] = 284,
	[1153][17] = 284,
	[1153][18] = 284,
	[1153][19] = 284,
	[1153][22] = 284,
	[1153][36] = 284,
	[1155][17] = 285,
	[1155][22] = 285,
	[1156][36] = 286,
	[1158][17] = 285,
	[1158][36] = 285,
	[1159][37] = 271,
	[1159][38] = 271,
	[1159][54] = 271,
	[1160][37] = 272,
	[1160][38] = 272,
	[1161][37] = 273,
	[1161][38] = 273,
	[1162][38] = 271,
	[1162][40] = 271,
	[1162][54] = 271,
	[1163][38] = 272,
	[1163][40] = 272,
	[1164][38] = 273,
	[1164][40] = 273,
	[1165][4] = 206,
	[1165][6] = 206,
	[1165][8] = 206,
	[1165][9] = 206,
	[1165][13] = 206,
	[1165][15] = 206,
	[1165][16] = 206,
	[1165][17] = 206,
	[1165][18] = 206,
	[1165][19] = 206,
	[1165][20] = 206,
	[1165][21] = 206,
	[1165][22] = 206,
	[1165][23] = 206,
	[1165][24] = 206,
	[1165][25] = 206,
	[1165][26] = 206,
	[1165][27] = 206,
	[1165][28] = 206,
	[1165][29] = 206,
	[1165][30] = 206,
	[1165][31] = 206,
	[1165][32] = 206,
	[1165][33] = 206,
	[1165][34] = 206,
	[1165][35] = 206,
	[1165][40] = 206,
	[1166][4] = 207,
	[1166][6] = 207,
	[1166][8] = 207,
	[1166][9] = 207,
	[1166][13] = 207,
	[1166][15] = 207,
	[1166][16] = 207,
	[1166][17] = 207,
	[1166][18] = 207,
	[1166][19] = 207,
	[1166][20] = 207,
	[1166][21] = 207,
	[1166][22] = 207,
	[1166][23] = 207,
	[1166][24] = 207,
	[1166][25] = 207,
	[1166][26] = 207,
	[1166][27] = 207,
	[1166][28] = 207,
	[1166][29] = 207,
	[1166][30] = 207,
	[1166][31] = 207,
	[1166][32] = 207,
	[1166][33] = 207,
	[1166][34] = 207,
	[1166][35] = 207,
	[1166][40] = 207,
	[1167][33] = 234,
	[1167][34] = 234,
	[1167][35] = 234,
	[1167][40] = 234,
	[1168][33] = 235,
	[1168][34] = 235,
	[1168][35] = 235,
	[1168][40] = 235,
	[1169][33] = 238,
	[1169][34] = 238,
	[1169][35] = 238,
	[1169][40] = 238,
	[1170][33] = 239,
	[1170][34] = 239,
	[1170][35] = 239,
	[1170][40] = 239,
	[1171][40] = 240,
	[1172][33] = 241,
	[1172][34] = 241,
	[1172][35] = 241,
	[1172][40] = 241,
	[1173][35] = 242,
	[1173][40] = 242,
	[1174][4] = 243,
	[1174][6] = 243,
	[1174][8] = 243,
	[1174][9] = 243,
	[1174][13] = 243,
	[1174][15] = 243,
	[1174][16] = 243,
	[1174][17] = 243,
	[1174][18] = 243,
	[1174][19] = 243,
	[1174][20] = 243,
	[1174][21] = 243,
	[1174][22] = 243,
	[1174][23] = 243,
	[1174][24] = 243,
	[1174][25] = 243,
	[1174][26] = 243,
	[1174][27] = 243,
	[1174][28] = 243,
	[1174][29] = 243,
	[1174][30] = 243,
	[1174][31] = 243,
	[1174][32] = 243,
	[1174][33] = 243,
	[1174][34] = 243,
	[1174][35] = 243,
	[1174][40] = 243,
	[1176][4] = 244,
	[1176][6] = 244,
	[1176][8] = 244,
	[1176][9] = 244,
	[1176][13] = 244,
	[1176][15] = 244,
	[1176][16] = 244,
	[1176][17] = 244,
	[1176][18] = 244,
	[1176][19] = 244,
	[1176][20] = 244,
	[1176][21] = 244,
	[1176][22] = 244,
	[1176][23] = 244,
	[1176][24] = 244,
	[1176][25] = 244,
	[1176][26] = 244,
	[1176][27] = 244,
	[1176][28] = 244,
	[1176][29] = 244,
	[1176][30] = 244,
	[1176][31] = 244,
	[1176][32] = 244,
	[1176][33] = 244,
	[1176][34] = 244,
	[1176][35] = 244,
	[1176][40] = 244,
	[1177][4] = 206,
	[1177][6] = 206,
	[1177][8] = 206,
	[1177][9] = 206,
	[1177][13] = 206,
	[1177][15] = 206,
	[1177][16] = 206,
	[1177][17] = 206,
	[1177][18] = 206,
	[1177][19] = 206,
	[1177][20] = 206,
	[1177][21] = 206,
	[1177][22] = 206,
	[1177][23] = 206,
	[1177][24] = 206,
	[1177][25] = 206,
	[1177][26] = 206,
	[1177][27] = 206,
	[1177][28] = 206,
	[1177][29] = 206,
	[1177][30] = 206,
	[1177][31] = 206,
	[1177][32] = 206,
	[1177][33] = 206,
	[1177][34] = 206,
	[1177][35] = 206,
	[1177][39] = 206,
	[1178][4] = 207,
	[1178][6] = 207,
	[1178][8] = 207,
	[1178][9] = 207,
	[1178][13] = 207,
	[1178][15] = 207,
	[1178][16] = 207,
	[1178][17] = 207,
	[1178][18] = 207,
	[1178][19] = 207,
	[1178][20] = 207,
	[1178][21] = 207,
	[1178][22] = 207,
	[1178][23] = 207,
	[1178][24] = 207,
	[1178][25] = 207,
	[1178][26] = 207,
	[1178][27] = 207,
	[1178][28] = 207,
	[1178][29] = 207,
	[1178][30] = 207,
	[1178][31] = 207,
	[1178][32] = 207,
	[1178][33] = 207,
	[1178][34] = 207,
	[1178][35] = 207,
	[1178][39] = 207,
	[1179][33] = 234,
	[1179][34] = 234,
	[1179][35] = 234,
	[1179][39] = 234,
	[1180][33] = 235,
	[1180][34] = 235,
	[1180][35] = 235,
	[1180][39] = 235,
	[1181][33] = 238,
	[1181][34] = 238,
	[1181][35] = 238,
	[1181][39] = 238,
	[1182][33] = 239,
	[1182][34] = 239,
	[1182][35] = 239,
	[1182][39] = 239,
	[1183][39] = 240,
	[1184][33] = 241,
	[1184][34] = 241,
	[1184][35] = 241,
	[1184][39] = 241,
	[1185][35] = 242,
	[1185][39] = 242,
	[1186][4] = 243,
	[1186][6] = 243,
	[1186][8] = 243,
	[1186][9] = 243,
	[1186][13] = 243,
	[1186][15] = 243,
	[1186][16] = 243,
	[1186][17] = 243,
	[1186][18] = 243,
	[1186][19] = 243,
	[1186][20] = 243,
	[1186][21] = 243,
	[1186][22] = 243,
	[1186][23] = 243,
	[1186][24] = 243,
	[1186][25] = 243,
	[1186][26] = 243,
	[1186][27] = 243,
	[1186][28] = 243,
	[1186][29] = 243,
	[1186][30] = 243,
	[1186][31] = 243,
	[1186][32] = 243,
	[1186][33] = 243,
	[1186][34] = 243,
	[1186][35] = 243,
	[1186][39] = 243,
	[1188][4] = 244,
	[1188][6] = 244,
	[1188][8] = 244,
	[1188][9] = 244,
	[1188][13] = 244,
	[1188][15] = 244,
	[1188][16] = 244,
	[1188][17] = 244,
	[1188][18] = 244,
	[1188][19] = 244,
	[1188][20] = 244,
	[1188][21] = 244,
	[1188][22] = 244,
	[1188][23] = 244,
	[1188][24] = 244,
	[1188][25] = 244,
	[1188][26] = 244,
	[1188][27] = 244,
	[1188][28] = 244,
	[1188][29] = 244,
	[1188][30] = 244,
	[1188][31] = 244,
	[1188][32] = 244,
	[1188][33] = 244,
	[1188][34] = 244,
	[1188][35] = 244,
	[1188][39] = 244,
	[1189][2] = 275,
	[1189][3] = 275,
	[1189][4] = 275,
	[1189][7] = 275,
	[1189][8] = 275,
	[1189][9] = 275,
	[1189][11] = 275,
	[1189][17] = 275,
	[1189][18] = 275,
	[1189][19] = 275,
	[1189][22] = 275,
	[1189][37] = 275,
	[1190][2] = 276,
	[1190][3] = 276,
	[1190][4] = 276,
	[1190][7] = 276,
	[1190][8] = 276,
	[1190][9] = 276,
	[1190][11] = 276,
	[1190][17] = 276,
	[1190][18] = 276,
	[1190][19] = 276,
	[1190][22] = 276,
	[1190][37] = 276,
	[1191][2] = 277,
	[1191][3] = 277,
	[1191][4] = 277,
	[1191][7] = 277,
	[1191][8] = 277,
	[1191][9] = 277,
	[1191][11] = 277,
	[1191][17] = 277,
	[1191][18] = 277,
	[1191][19] = 277,
	[1191][22] = 277,
	[1191][37] = 277,
	[1192][2] = 283,
	[1192][3] = 283,
	[1192][4] = 283,
	[1192][7] = 283,
	[1192][8] = 283,
	[1192][9] = 283,
	[1192][11] = 283,
	[1192][17] = 283,
	[1192][18] = 283,
	[1192][19] = 283,
	[1192][22] = 283,
	[1192][37] = 283,
	[1193][2] = 284,
	[1193][3] = 284,
	[1193][4] = 284,
	[1193][7] = 284,
	[1193][8] = 284,
	[1193][9] = 284,
	[1193][11] = 284,
	[1193][17] = 284,
	[1193][18] = 284,
	[1193][19] = 284,
	[1193][22] = 284,
	[1193][37] = 284,
	[1194][37] = 286,
	[1197][2] = 215,
	[1197][3] = 215,
	[1197][4] = 215,
	[1197][5] = 215,
	[1197][15] = 215,
	[1197][16] = 215,
	[1197][17] = 215,
	[1197][37] = 215,
	[1197][38] = 215,
	[1199][37] = 278,
	[1200][37] = 279,
	[1201][37] = 280,
	[1202][37] = 281,
	[1203][37] = 282,
	[1204][2] = 287,
	[1204][3] = 287,
	[1204][4] = 287,
	[1204][7] = 287,
	[1204][8] = 287,
	[1204][9] = 287,
	[1204][11] = 287,
	[1204][17] = 287,
	[1204][18] = 287,
	[1204][19] = 287,
	[1204][22] = 287,
	[1204][36] = 287,
	[1205][2] = 288,
	[1205][3] = 288,
	[1205][4] = 288,
	[1205][5] = 288,
	[1205][17] = 288,
	[1205][38] = 288,
	[1205][39] = 288,
	[1206][2] = 249,
	[1206][3] = 249,
	[1206][4] = 249,
	[1206][5] = 249,
	[1206][15] = 249,
	[1206][16] = 249,
	[1206][17] = 249,
	[1206][38] = 249,
	[1206][39] = 249,
	[1207][2] = 289,
	[1207][3] = 289,
	[1207][4] = 289,
	[1207][5] = 289,
	[1207][16] = 289,
	[1207][17] = 289,
	[1207][38] = 289,
	[1207][39] = 289,
	[1209][17] = 285,
	[1209][37] = 285,
	[1210][2] = 290,
	[1210][3] = 290,
	[1210][4] = 290,
	[1210][7] = 290,
	[1210][8] = 290,
	[1210][9] = 290,
	[1210][11] = 290,
	[1210][17] = 290,
	[1210][18] = 290,
	[1210][19] = 290,
	[1210][22] = 290,
	[1210][36] = 290,
	[1211][22] = 291,
	[1212][36] = 291,
	[1213][4] = 274,
	[1213][6] = 274,
	[1213][8] = 274,
	[1213][9] = 274,
	[1213][13] = 274,
	[1213][15] = 274,
	[1213][16] = 274,
	[1213][17] = 274,
	[1213][18] = 274,
	[1213][19] = 274,
	[1213][20] = 274,
	[1213][21] = 274,
	[1213][22] = 274,
	[1213][23] = 274,
	[1213][24] = 274,
	[1213][25] = 274,
	[1213][26] = 274,
	[1213][27] = 274,
	[1213][28] = 274,
	[1213][29] = 274,
	[1213][30] = 274,
	[1213][31] = 274,
	[1213][32] = 274,
	[1213][33] = 274,
	[1213][34] = 274,
	[1213][35] = 274,
	[1213][40] = 274,
	[1214][4] = 274,
	[1214][6] = 274,
	[1214][8] = 274,
	[1214][9] = 274,
	[1214][13] = 274,
	[1214][15] = 274,
	[1214][16] = 274,
	[1214][17] = 274,
	[1214][18] = 274,
	[1214][19] = 274,
	[1214][20] = 274,
	[1214][21] = 274,
	[1214][22] = 274,
	[1214][23] = 274,
	[1214][24] = 274,
	[1214][25] = 274,
	[1214][26] = 274,
	[1214][27] = 274,
	[1214][28] = 274,
	[1214][29] = 274,
	[1214][30] = 274,
	[1214][31] = 274,
	[1214][32] = 274,
	[1214][33] = 274,
	[1214][34] = 274,
	[1214][35] = 274,
	[1214][39] = 274,
	[1215][2] = 287,
	[1215][3] = 287,
	[1215][4] = 287,
	[1215][7] = 287,
	[1215][8] = 287,
	[1215][9] = 287,
	[1215][11] = 287,
	[1215][17] = 287,
	[1215][18] = 287,
	[1215][19] = 287,
	[1215][22] = 287,
	[1215][37] = 287,
	[1216][2] = 290,
	[1216][3] = 290,
	[1216][4] = 290,
	[1216][7] = 290,
	[1216][8] = 290,
	[1216][9] = 290,
	[1216][11] = 290,
	[1216][17] = 290,
	[1216][18] = 290,
	[1216][19] = 290,
	[1216][22] = 290,
	[1216][37] = 290,
	[1217][2] = 288,
	[1217][3] = 288,
	[1217][4] = 288,
	[1217][5] = 288,
	[1217][17] = 288,
	[1217][37] = 288,
	[1217][38] = 288,
	[1218][2] = 249,
	[1218][3] = 249,
	[1218][4] = 249,
	[1218][5] = 249,
	[1218][15] = 249,
	[1218][16] = 249,
	[1218][17] = 249,
	[1218][37] = 249,
	[1218][38] = 249,
	[1219][2] = 289,
	[1219][3] = 289,
	[1219][4] = 289,
	[1219][5] = 289,
	[1219][16] = 289,
	[1219][17] = 289,
	[1219][37] = 289,
	[1219][38] = 289,
	[1220][37] = 291,
};


const unsigned zebu_gotos[1209][76] = {
	[1][1] = 15,
	[1][2] = 16,
	[1][3] = 17,
	[1][4] = 18,
	[1][5] = 19,
	[1][6] = 20,
	[1][7] = 21,
	[1][8] = 22,
	[1][9] = 23,
	[1][10] = 24,
	[1][11] = 25,
	[1][12] = 26,
	[1][13] = 27,
	[1][14] = 28,
	[1][15] = 29,
	[1][16] = 30,
	[1][17] = 31,
	[1][18] = 32,
	[1][19] = 33,
	[1][20] = 34,
	[1][21] = 35,
	[1][22] = 36,
	[1][23] = 37,
	[1][24] = 38,
	[1][25] = 39,
	[4][1] = 54,
	[4][2] = 55,
	[4][4] = 56,
	[4][5] = 57,
	[4][6] = 58,
	[4][7] = 59,
	[4][8] = 60,
	[4][10] = 61,
	[4][11] = 62,
	[4][12] = 63,
	[4][13] = 64,
	[4][14] = 65,
	[4][15] = 66,
	[4][16] = 67,
	[4][17] = 68,
	[4][18] = 69,
	[4][19] = 70,
	[4][20] = 71,
	[4][23] = 72,
	[5][17] = 31,
	[5][18] = 32,
	[5][23] = 74,
	[6][17] = 31,
	[6][18] = 32,
	[6][23] = 75,
	[8][1] = 90,
	[8][2] = 91,
	[8][4] = 92,
	[8][5] = 93,
	[8][6] = 94,
	[8][7] = 95,
	[8][8] = 96,
	[8][10] = 97,
	[8][11] = 98,
	[8][12] = 99,
	[8][13] = 100,
	[8][14] = 101,
	[8][15] = 102,
	[8][16] = 103,
	[8][17] = 104,
	[8][18] = 105,
	[8][19] = 106,
	[8][20] = 107,
	[8][23] = 108,
	[9][17] = 31,
	[9][18] = 32,
	[9][23] = 109,
	[12][17] = 31,
	[12][18] = 32,
	[12][23] = 112,
	[14][26] = 129,
	[14][27] = 130,
	[17][1] = 15,
	[17][2] = 16,
	[17][3] = 135,
	[17][4] = 18,
	[17][5] = 19,
	[17][6] = 20,
	[17][7] = 21,
	[17][8] = 22,
	[17][9] = 136,
	[17][10] = 24,
	[17][11] = 25,
	[17][12] = 26,
	[17][13] = 27,
	[17][14] = 28,
	[17][15] = 29,
	[17][16] = 30,
	[17][17] = 31,
	[17][18] = 32,
	[17][19] = 33,
	[17][20] = 34,
	[17][21] = 137,
	[17][22] = 138,
	[17][23] = 37,
	[17][24] = 139,
	[17][25] = 140,
	[17][28] = 134,
	[22][29] = 146,
	[23][1] = 15,
	[23][2] = 16,
	[23][3] = 148,
	[23][4] = 18,
	[23][5] = 19,
	[23][6] = 20,
	[23][7] = 21,
	[23][8] = 22,
	[23][9] = 149,
	[23][10] = 24,
	[23][11] = 25,
	[23][12] = 26,
	[23][13] = 27,
	[23][14] = 28,
	[23][15] = 29,
	[23][16] = 30,
	[23][17] = 31,
	[23][18] = 32,
	[23][19] = 33,
	[23][20] = 34,
	[23][21] = 150,
	[23][22] = 151,
	[23][23] = 37,
	[23][24] = 152,
	[23][25] = 153,
	[23][30] = 147,
	[35][1] = 15,
	[35][2] = 16,
	[35][3] = 174,
	[35][4] = 18,
	[35][5] = 19,
	[35][6] = 20,
	[35][7] = 21,
	[35][8] = 22,
	[35][9] = 175,
	[35][10] = 24,
	[35][11] = 25,
	[35][12] = 26,
	[35][13] = 27,
	[35][14] = 28,
	[35][15] = 29,
	[35][16] = 30,
	[35][17] = 31,
	[35][18] = 32,
	[35][19] = 33,
	[35][20] = 34,
	[35][21] = 176,
	[35][22] = 177,
	[35][23] = 37,
	[35][24] = 178,
	[35][25] = 179,
	[35][31] = 173,
	[36][1] = 15,
	[36][2] = 16,
	[36][3] = 181,
	[36][4] = 18,
	[36][5] = 19,
	[36][6] = 20,
	[36][7] = 21,
	[36][8] = 22,
	[36][9] = 182,
	[36][10] = 24,
	[36][11] = 25,
	[36][12] = 26,
	[36][13] = 27,
	[36][14] = 28,
	[36][15] = 29,
	[36][16] = 30,
	[36][17] = 31,
	[36][18] = 32,
	[36][19] = 33,
	[36][20] = 34,
	[36][21] = 183,
	[36][22] = 184,
	[36][23] = 37,
	[36][24] = 185,
	[36][25] = 186,
	[36][32] = 180,
	[38][1] = 15,
	[38][2] = 16,
	[38][3] = 188,
	[38][4] = 18,
	[38][5] = 19,
	[38][6] = 20,
	[38][7] = 21,
	[38][8] = 22,
	[38][9] = 189,
	[38][10] = 24,
	[38][11] = 25,
	[38][12] = 26,
	[38][13] = 27,
	[38][14] = 28,
	[38][15] = 29,
	[38][16] = 30,
	[38][17] = 31,
	[38][18] = 32,
	[38][19] = 33,
	[38][20] = 34,
	[38][21] = 190,
	[38][22] = 191,
	[38][23] = 37,
	[38][24] = 192,
	[38][25] = 193,
	[38][33] = 187,
	[39][1] = 15,
	[39][2] = 16,
	[39][3] = 195,
	[39][4] = 18,
	[39][5] = 19,
	[39][6] = 20,
	[39][7] = 21,
	[39][8] = 22,
	[39][9] = 196,
	[39][10] = 24,
	[39][11] = 25,
	[39][12] = 26,
	[39][13] = 27,
	[39][14] = 28,
	[39][15] = 29,
	[39][16] = 30,
	[39][17] = 31,
	[39][18] = 32,
	[39][19] = 33,
	[39][20] = 34,
	[39][21] = 197,
	[39][22] = 198,
	[39][23] = 37,
	[39][24] = 199,
	[39][25] = 200,
	[39][34] = 194,
	[42][1] = 54,
	[42][2] = 55,
	[42][4] = 56,
	[42][5] = 57,
	[42][6] = 58,
	[42][7] = 59,
	[42][8] = 203,
	[42][10] = 61,
	[42][11] = 62,
	[42][12] = 63,
	[42][13] = 64,
	[42][14] = 65,
	[42][15] = 66,
	[42][16] = 67,
	[42][17] = 68,
	[42][18] = 69,
	[42][19] = 70,
	[42][20] = 71,
	[42][23] = 72,
	[44][17] = 68,
	[44][18] = 69,
	[44][23] = 204,
	[45][17] = 68,
	[45][18] = 69,
	[45][23] = 205,
	[46][1] = 54,
	[46][2] = 55,
	[46][4] = 56,
	[46][5] = 57,
	[46][6] = 58,
	[46][7] = 59,
	[46][8] = 207,
	[46][10] = 61,
	[46][11] = 62,
	[46][12] = 63,
	[46][13] = 64,
	[46][14] = 65,
	[46][15] = 66,
	[46][16] = 67,
	[46][17] = 68,
	[46][18] = 69,
	[46][19] = 70,
	[46][20] = 71,
	[46][23] = 72,
	[46][35] = 206,
	[48][1] = 90,
	[48][2] = 91,
	[48][4] = 92,
	[48][5] = 93,
	[48][6] = 94,
	[48][7] = 95,
	[48][8] = 210,
	[48][10] = 97,
	[48][11] = 98,
	[48][12] = 99,
	[48][13] = 100,
	[48][14] = 101,
	[48][15] = 102,
	[48][16] = 103,
	[48][17] = 104,
	[48][18] = 105,
	[48][19] = 106,
	[48][20] = 107,
	[48][23] = 108,
	[49][17] = 68,
	[49][18] = 69,
	[49][23] = 211,
	[52][17] = 68,
	[52][18] = 69,
	[52][23] = 212,
	[53][26] = 129,
	[53][27] = 215,
	[78][1] = 54,
	[78][2] = 55,
	[78][4] = 56,
	[78][5] = 57,
	[78][6] = 58,
	[78][7] = 59,
	[78][8] = 246,
	[78][10] = 61,
	[78][11] = 62,
	[78][12] = 63,
	[78][13] = 64,
	[78][14] = 65,
	[78][15] = 66,
	[78][16] = 67,
	[78][17] = 68,
	[78][18] = 69,
	[78][19] = 70,
	[78][20] = 71,
	[78][23] = 72,
	[79][17] = 104,
	[79][18] = 105,
	[79][23] = 247,
	[80][17] = 104,
	[80][18] = 105,
	[80][23] = 248,
	[81][1] = 90,
	[81][2] = 91,
	[81][4] = 92,
	[81][5] = 93,
	[81][6] = 94,
	[81][7] = 95,
	[81][8] = 250,
	[81][10] = 97,
	[81][11] = 98,
	[81][12] = 99,
	[81][13] = 100,
	[81][14] = 101,
	[81][15] = 102,
	[81][16] = 103,
	[81][17] = 104,
	[81][18] = 105,
	[81][19] = 106,
	[81][20] = 107,
	[81][23] = 108,
	[81][36] = 249,
	[83][1] = 90,
	[83][2] = 91,
	[83][4] = 92,
	[83][5] = 93,
	[83][6] = 94,
	[83][7] = 95,
	[83][8] = 253,
	[83][10] = 97,
	[83][11] = 98,
	[83][12] = 99,
	[83][13] = 100,
	[83][14] = 101,
	[83][15] = 102,
	[83][16] = 103,
	[83][17] = 104,
	[83][18] = 105,
	[83][19] = 106,
	[83][20] = 107,
	[83][23] = 108,
	[85][17] = 104,
	[85][18] = 105,
	[85][23] = 254,
	[88][17] = 104,
	[88][18] = 105,
	[88][23] = 255,
	[89][26] = 129,
	[89][27] = 258,
	[110][37] = 294,
	[110][38] = 295,
	[110][39] = 296,
	[110][40] = 297,
	[111][1] = 15,
	[111][2] = 16,
	[111][4] = 18,
	[111][5] = 19,
	[111][6] = 20,
	[111][7] = 21,
	[111][8] = 298,
	[111][10] = 24,
	[111][11] = 25,
	[111][12] = 26,
	[111][13] = 27,
	[111][14] = 28,
	[111][15] = 29,
	[111][16] = 30,
	[111][17] = 31,
	[111][18] = 32,
	[111][19] = 33,
	[111][20] = 34,
	[111][23] = 37,
	[120][26] = 315,
	[120][27] = 316,
	[121][26] = 129,
	[121][27] = 320,
	[121][41] = 318,
	[121][42] = 319,
	[123][1] = 15,
	[123][2] = 16,
	[123][4] = 18,
	[123][5] = 19,
	[123][6] = 20,
	[123][7] = 21,
	[123][11] = 25,
	[123][12] = 322,
	[123][13] = 27,
	[123][14] = 28,
	[123][15] = 29,
	[123][17] = 31,
	[123][18] = 32,
	[123][19] = 33,
	[123][20] = 34,
	[123][23] = 37,
	[123][43] = 321,
	[128][26] = 332,
	[128][27] = 333,
	[131][7] = 21,
	[131][15] = 336,
	[131][17] = 31,
	[131][18] = 32,
	[131][23] = 37,
	[132][7] = 21,
	[132][15] = 337,
	[132][17] = 31,
	[132][18] = 32,
	[132][23] = 37,
	[133][1] = 15,
	[133][5] = 338,
	[133][7] = 21,
	[133][15] = 29,
	[133][17] = 31,
	[133][18] = 32,
	[133][19] = 33,
	[133][20] = 34,
	[133][23] = 37,
	[135][1] = 15,
	[135][2] = 16,
	[135][3] = 135,
	[135][4] = 18,
	[135][5] = 19,
	[135][6] = 20,
	[135][7] = 21,
	[135][8] = 22,
	[135][9] = 136,
	[135][10] = 24,
	[135][11] = 25,
	[135][12] = 26,
	[135][13] = 27,
	[135][14] = 28,
	[135][15] = 29,
	[135][16] = 30,
	[135][17] = 31,
	[135][18] = 32,
	[135][19] = 33,
	[135][20] = 34,
	[135][21] = 137,
	[135][22] = 138,
	[135][23] = 37,
	[135][24] = 139,
	[135][25] = 140,
	[135][28] = 339,
	[136][1] = 15,
	[136][2] = 16,
	[136][3] = 148,
	[136][4] = 18,
	[136][5] = 19,
	[136][6] = 20,
	[136][7] = 21,
	[136][8] = 22,
	[136][9] = 149,
	[136][10] = 24,
	[136][11] = 25,
	[136][12] = 26,
	[136][13] = 27,
	[136][14] = 28,
	[136][15] = 29,
	[136][16] = 30,
	[136][17] = 31,
	[136][18] = 32,
	[136][19] = 33,
	[136][20] = 34,
	[136][21] = 150,
	[136][22] = 151,
	[136][23] = 37,
	[136][24] = 152,
	[136][25] = 153,
	[136][30] = 340,
	[137][1] = 15,
	[137][2] = 16,
	[137][3] = 174,
	[137][4] = 18,
	[137][5] = 19,
	[137][6] = 20,
	[137][7] = 21,
	[137][8] = 22,
	[137][9] = 175,
	[137][10] = 24,
	[137][11] = 25,
	[137][12] = 26,
	[137][13] = 27,
	[137][14] = 28,
	[137][15] = 29,
	[137][16] = 30,
	[137][17] = 31,
	[137][18] = 32,
	[137][19] = 33,
	[137][20] = 34,
	[137][21] = 176,
	[137][22] = 177,
	[137][23] = 37,
	[137][24] = 178,
	[137][25] = 179,
	[137][31] = 341,
	[138][1] = 15,
	[138][2] = 16,
	[138][3] = 181,
	[138][4] = 18,
	[138][5] = 19,
	[138][6] = 20,
	[138][7] = 21,
	[138][8] = 22,
	[138][9] = 182,
	[138][10] = 24,
	[138][11] = 25,
	[138][12] = 26,
	[138][13] = 27,
	[138][14] = 28,
	[138][15] = 29,
	[138][16] = 30,
	[138][17] = 31,
	[138][18] = 32,
	[138][19] = 33,
	[138][20] = 34,
	[138][21] = 183,
	[138][22] = 184,
	[138][23] = 37,
	[138][24] = 185,
	[138][25] = 186,
	[138][32] = 342,
	[139][1] = 15,
	[139][2] = 16,
	[139][3] = 188,
	[139][4] = 18,
	[139][5] = 19,
	[139][6] = 20,
	[139][7] = 21,
	[139][8] = 22,
	[139][9] = 189,
	[139][10] = 24,
	[139][11] = 25,
	[139][12] = 26,
	[139][13] = 27,
	[139][14] = 28,
	[139][15] = 29,
	[139][16] = 30,
	[139][17] = 31,
	[139][18] = 32,
	[139][19] = 33,
	[139][20] = 34,
	[139][21] = 190,
	[139][22] = 191,
	[139][23] = 37,
	[139][24] = 192,
	[139][25] = 193,
	[139][33] = 343,
	[140][1] = 15,
	[140][2] = 16,
	[140][3] = 195,
	[140][4] = 18,
	[140][5] = 19,
	[140][6] = 20,
	[140][7] = 21,
	[140][8] = 22,
	[140][9] = 196,
	[140][10] = 24,
	[140][11] = 25,
	[140][12] = 26,
	[140][13] = 27,
	[140][14] = 28,
	[140][15] = 29,
	[140][16] = 30,
	[140][17] = 31,
	[140][18] = 32,
	[140][19] = 33,
	[140][20] = 34,
	[140][21] = 197,
	[140][22] = 198,
	[140][23] = 37,
	[140][24] = 199,
	[140][25] = 200,
	[140][34] = 344,
	[141][1] = 15,
	[141][7] = 21,
	[141][15] = 29,
	[141][17] = 31,
	[141][18] = 32,
	[141][19] = 345,
	[141][20] = 34,
	[141][23] = 37,
	[142][1] = 15,
	[142][7] = 21,
	[142][15] = 29,
	[142][17] = 31,
	[142][18] = 32,
	[142][19] = 346,
	[142][20] = 34,
	[142][23] = 37,
	[143][1] = 15,
	[143][2] = 347,
	[143][5] = 19,
	[143][7] = 21,
	[143][15] = 29,
	[143][17] = 31,
	[143][18] = 32,
	[143][19] = 33,
	[143][20] = 34,
	[143][23] = 37,
	[144][17] = 31,
	[144][18] = 32,
	[144][23] = 348,
	[148][1] = 15,
	[148][2] = 16,
	[148][3] = 135,
	[148][4] = 18,
	[148][5] = 19,
	[148][6] = 20,
	[148][7] = 21,
	[148][8] = 22,
	[148][9] = 136,
	[148][10] = 24,
	[148][11] = 25,
	[148][12] = 26,
	[148][13] = 27,
	[148][14] = 28,
	[148][15] = 29,
	[148][16] = 30,
	[148][17] = 31,
	[148][18] = 32,
	[148][19] = 33,
	[148][20] = 34,
	[148][21] = 137,
	[148][22] = 138,
	[148][23] = 37,
	[148][24] = 139,
	[148][25] = 140,
	[148][28] = 349,
	[149][1] = 15,
	[149][2] = 16,
	[149][3] = 148,
	[149][4] = 18,
	[149][5] = 19,
	[149][6] = 20,
	[149][7] = 21,
	[149][8] = 22,
	[149][9] = 149,
	[149][10] = 24,
	[149][11] = 25,
	[149][12] = 26,
	[149][13] = 27,
	[149][14] = 28,
	[149][15] = 29,
	[149][16] = 30,
	[149][17] = 31,
	[149][18] = 32,
	[149][19] = 33,
	[149][20] = 34,
	[149][21] = 150,
	[149][22] = 151,
	[149][23] = 37,
	[149][24] = 152,
	[149][25] = 153,
	[149][30] = 350,
	[150][1] = 15,
	[150][2] = 16,
	[150][3] = 174,
	[150][4] = 18,
	[150][5] = 19,
	[150][6] = 20,
	[150][7] = 21,
	[150][8] = 22,
	[150][9] = 175,
	[150][10] = 24,
	[150][11] = 25,
	[150][12] = 26,
	[150][13] = 27,
	[150][14] = 28,
	[150][15] = 29,
	[150][16] = 30,
	[150][17] = 31,
	[150][18] = 32,
	[150][19] = 33,
	[150][20] = 34,
	[150][21] = 176,
	[150][22] = 177,
	[150][23] = 37,
	[150][24] = 178,
	[150][25] = 179,
	[150][31] = 351,
	[151][1] = 15,
	[151][2] = 16,
	[151][3] = 181,
	[151][4] = 18,
	[151][5] = 19,
	[151][6] = 20,
	[151][7] = 21,
	[151][8] = 22,
	[151][9] = 182,
	[151][10] = 24,
	[151][11] = 25,
	[151][12] = 26,
	[151][13] = 27,
	[151][14] = 28,
	[151][15] = 29,
	[151][16] = 30,
	[151][17] = 31,
	[151][18] = 32,
	[151][19] = 33,
	[151][20] = 34,
	[151][21] = 183,
	[151][22] = 184,
	[151][23] = 37,
	[151][24] = 185,
	[151][25] = 186,
	[151][32] = 352,
	[152][1] = 15,
	[152][2] = 16,
	[152][3] = 188,
	[152][4] = 18,
	[152][5] = 19,
	[152][6] = 20,
	[152][7] = 21,
	[152][8] = 22,
	[152][9] = 189,
	[152][10] = 24,
	[152][11] = 25,
	[152][12] = 26,
	[152][13] = 27,
	[152][14] = 28,
	[152][15] = 29,
	[152][16] = 30,
	[152][17] = 31,
	[152][18] = 32,
	[152][19] = 33,
	[152][20] = 34,
	[152][21] = 190,
	[152][22] = 191,
	[152][23] = 37,
	[152][24] = 192,
	[152][25] = 193,
	[152][33] = 353,
	[153][1] = 15,
	[153][2] = 16,
	[153][3] = 195,
	[153][4] = 18,
	[153][5] = 19,
	[153][6] = 20,
	[153][7] = 21,
	[153][8] = 22,
	[153][9] = 196,
	[153][10] = 24,
	[153][11] = 25,
	[153][12] = 26,
	[153][13] = 27,
	[153][14] = 28,
	[153][15] = 29,
	[153][16] = 30,
	[153][17] = 31,
	[153][18] = 32,
	[153][19] = 33,
	[153][20] = 34,
	[153][21] = 197,
	[153][22] = 198,
	[153][23] = 37,
	[153][24] = 199,
	[153][25] = 200,
	[153][34] = 354,
	[154][1] = 15,
	[154][2] = 16,
	[154][4] = 18,
	[154][5] = 19,
	[154][6] = 20,
	[154][7] = 21,
	[154][10] = 356,
	[154][11] = 25,
	[154][12] = 26,
	[154][13] = 27,
	[154][14] = 28,
	[154][15] = 29,
	[154][16] = 30,
	[154][17] = 31,
	[154][18] = 32,
	[154][19] = 33,
	[154][20] = 34,
	[154][23] = 37,
	[154][44] = 355,
	[155][1] = 15,
	[155][2] = 16,
	[155][5] = 19,
	[155][6] = 357,
	[155][7] = 21,
	[155][15] = 29,
	[155][17] = 31,
	[155][18] = 32,
	[155][19] = 33,
	[155][20] = 34,
	[155][23] = 37,
	[157][1] = 15,
	[157][2] = 16,
	[157][5] = 19,
	[157][6] = 20,
	[157][7] = 21,
	[157][11] = 359,
	[157][15] = 29,
	[157][17] = 31,
	[157][18] = 32,
	[157][19] = 33,
	[157][20] = 34,
	[157][23] = 37,
	[158][1] = 372,
	[158][2] = 373,
	[158][4] = 374,
	[158][5] = 375,
	[158][6] = 376,
	[158][7] = 377,
	[158][8] = 378,
	[158][10] = 379,
	[158][11] = 380,
	[158][12] = 381,
	[158][13] = 382,
	[158][14] = 383,
	[158][15] = 384,
	[158][16] = 385,
	[158][17] = 386,
	[158][18] = 387,
	[158][19] = 388,
	[158][20] = 389,
	[158][23] = 390,
	[159][1] = 15,
	[159][2] = 16,
	[159][5] = 19,
	[159][6] = 20,
	[159][7] = 21,
	[159][11] = 25,
	[159][13] = 391,
	[159][15] = 29,
	[159][17] = 31,
	[159][18] = 32,
	[159][19] = 33,
	[159][20] = 34,
	[159][23] = 37,
	[160][7] = 392,
	[160][17] = 31,
	[160][18] = 32,
	[160][23] = 37,
	[161][7] = 393,
	[161][17] = 31,
	[161][18] = 32,
	[161][23] = 37,
	[162][7] = 394,
	[162][17] = 31,
	[162][18] = 32,
	[162][23] = 37,
	[163][1] = 15,
	[163][2] = 16,
	[163][4] = 18,
	[163][5] = 19,
	[163][6] = 20,
	[163][7] = 21,
	[163][11] = 25,
	[163][12] = 26,
	[163][13] = 27,
	[163][14] = 28,
	[163][15] = 29,
	[163][16] = 396,
	[163][17] = 31,
	[163][18] = 32,
	[163][19] = 33,
	[163][20] = 34,
	[163][23] = 37,
	[163][45] = 395,
	[164][1] = 54,
	[164][2] = 55,
	[164][4] = 56,
	[164][5] = 57,
	[164][6] = 58,
	[164][7] = 59,
	[164][8] = 399,
	[164][10] = 61,
	[164][11] = 62,
	[164][12] = 63,
	[164][13] = 64,
	[164][14] = 65,
	[164][15] = 66,
	[164][16] = 67,
	[164][17] = 68,
	[164][18] = 69,
	[164][19] = 70,
	[164][20] = 71,
	[164][23] = 72,
	[165][1] = 412,
	[165][2] = 413,
	[165][4] = 414,
	[165][5] = 415,
	[165][6] = 416,
	[165][7] = 417,
	[165][8] = 418,
	[165][10] = 419,
	[165][11] = 420,
	[165][12] = 421,
	[165][13] = 422,
	[165][14] = 423,
	[165][15] = 424,
	[165][16] = 425,
	[165][17] = 426,
	[165][18] = 427,
	[165][19] = 428,
	[165][20] = 429,
	[165][23] = 430,
	[167][1] = 15,
	[167][7] = 21,
	[167][15] = 29,
	[167][17] = 31,
	[167][18] = 32,
	[167][20] = 432,
	[167][23] = 37,
	[168][1] = 15,
	[168][7] = 21,
	[168][15] = 29,
	[168][17] = 31,
	[168][18] = 32,
	[168][20] = 433,
	[168][23] = 37,
	[169][1] = 15,
	[169][7] = 21,
	[169][15] = 29,
	[169][17] = 31,
	[169][18] = 32,
	[169][20] = 434,
	[169][23] = 37,
	[170][1] = 15,
	[170][7] = 21,
	[170][15] = 29,
	[170][17] = 31,
	[170][18] = 32,
	[170][20] = 435,
	[170][23] = 37,
	[171][1] = 436,
	[171][7] = 21,
	[171][15] = 29,
	[171][17] = 31,
	[171][18] = 32,
	[171][23] = 37,
	[172][1] = 437,
	[172][7] = 21,
	[172][15] = 29,
	[172][17] = 31,
	[172][18] = 32,
	[172][23] = 37,
	[174][1] = 15,
	[174][2] = 16,
	[174][3] = 135,
	[174][4] = 18,
	[174][5] = 19,
	[174][6] = 20,
	[174][7] = 21,
	[174][8] = 22,
	[174][9] = 136,
	[174][10] = 24,
	[174][11] = 25,
	[174][12] = 26,
	[174][13] = 27,
	[174][14] = 28,
	[174][15] = 29,
	[174][16] = 30,
	[174][17] = 31,
	[174][18] = 32,
	[174][19] = 33,
	[174][20] = 34,
	[174][21] = 137,
	[174][22] = 138,
	[174][23] = 37,
	[174][24] = 139,
	[174][25] = 140,
	[174][28] = 438,
	[175][1] = 15,
	[175][2] = 16,
	[175][3] = 148,
	[175][4] = 18,
	[175][5] = 19,
	[175][6] = 20,
	[175][7] = 21,
	[175][8] = 22,
	[175][9] = 149,
	[175][10] = 24,
	[175][11] = 25,
	[175][12] = 26,
	[175][13] = 27,
	[175][14] = 28,
	[175][15] = 29,
	[175][16] = 30,
	[175][17] = 31,
	[175][18] = 32,
	[175][19] = 33,
	[175][20] = 34,
	[175][21] = 150,
	[175][22] = 151,
	[175][23] = 37,
	[175][24] = 152,
	[175][25] = 153,
	[175][30] = 439,
	[176][1] = 15,
	[176][2] = 16,
	[176][3] = 174,
	[176][4] = 18,
	[176][5] = 19,
	[176][6] = 20,
	[176][7] = 21,
	[176][8] = 22,
	[176][9] = 175,
	[176][10] = 24,
	[176][11] = 25,
	[176][12] = 26,
	[176][13] = 27,
	[176][14] = 28,
	[176][15] = 29,
	[176][16] = 30,
	[176][17] = 31,
	[176][18] = 32,
	[176][19] = 33,
	[176][20] = 34,
	[176][21] = 176,
	[176][22] = 177,
	[176][23] = 37,
	[176][24] = 178,
	[176][25] = 179,
	[176][31] = 440,
	[177][1] = 15,
	[177][2] = 16,
	[177][3] = 181,
	[177][4] = 18,
	[177][5] = 19,
	[177][6] = 20,
	[177][7] = 21,
	[177][8] = 22,
	[177][9] = 182,
	[177][10] = 24,
	[177][11] = 25,
	[177][12] = 26,
	[177][13] = 27,
	[177][14] = 28,
	[177][15] = 29,
	[177][16] = 30,
	[177][17] = 31,
	[177][18] = 32,
	[177][19] = 33,
	[177][20] = 34,
	[177][21] = 183,
	[177][22] = 184,
	[177][23] = 37,
	[177][24] = 185,
	[177][25] = 186,
	[177][32] = 441,
	[178][1] = 15,
	[178][2] = 16,
	[178][3] = 188,
	[178][4] = 18,
	[178][5] = 19,
	[178][6] = 20,
	[178][7] = 21,
	[178][8] = 22,
	[178][9] = 189,
	[178][10] = 24,
	[178][11] = 25,
	[178][12] = 26,
	[178][13] = 27,
	[178][14] = 28,
	[178][15] = 29,
	[178][16] = 30,
	[178][17] = 31,
	[178][18] = 32,
	[178][19] = 33,
	[178][20] = 34,
	[178][21] = 190,
	[178][22] = 191,
	[178][23] = 37,
	[178][24] = 192,
	[178][25] = 193,
	[178][33] = 442,
	[179][1] = 15,
	[179][2] = 16,
	[179][3] = 195,
	[179][4] = 18,
	[179][5] = 19,
	[179][6] = 20,
	[179][7] = 21,
	[179][8] = 22,
	[179][9] = 196,
	[179][10] = 24,
	[179][11] = 25,
	[179][12] = 26,
	[179][13] = 27,
	[179][14] = 28,
	[179][15] = 29,
	[179][16] = 30,
	[179][17] = 31,
	[179][18] = 32,
	[179][19] = 33,
	[179][20] = 34,
	[179][21] = 197,
	[179][22] = 198,
	[179][23] = 37,
	[179][24] = 199,
	[179][25] = 200,
	[179][34] = 443,
	[181][1] = 15,
	[181][2] = 16,
	[181][3] = 135,
	[181][4] = 18,
	[181][5] = 19,
	[181][6] = 20,
	[181][7] = 21,
	[181][8] = 22,
	[181][9] = 136,
	[181][10] = 24,
	[181][11] = 25,
	[181][12] = 26,
	[181][13] = 27,
	[181][14] = 28,
	[181][15] = 29,
	[181][16] = 30,
	[181][17] = 31,
	[181][18] = 32,
	[181][19] = 33,
	[181][20] = 34,
	[181][21] = 137,
	[181][22] = 138,
	[181][23] = 37,
	[181][24] = 139,
	[181][25] = 140,
	[181][28] = 444,
	[182][1] = 15,
	[182][2] = 16,
	[182][3] = 148,
	[182][4] = 18,
	[182][5] = 19,
	[182][6] = 20,
	[182][7] = 21,
	[182][8] = 22,
	[182][9] = 149,
	[182][10] = 24,
	[182][11] = 25,
	[182][12] = 26,
	[182][13] = 27,
	[182][14] = 28,
	[182][15] = 29,
	[182][16] = 30,
	[182][17] = 31,
	[182][18] = 32,
	[182][19] = 33,
	[182][20] = 34,
	[182][21] = 150,
	[182][22] = 151,
	[182][23] = 37,
	[182][24] = 152,
	[182][25] = 153,
	[182][30] = 445,
	[183][1] = 15,
	[183][2] = 16,
	[183][3] = 174,
	[183][4] = 18,
	[183][5] = 19,
	[183][6] = 20,
	[183][7] = 21,
	[183][8] = 22,
	[183][9] = 175,
	[183][10] = 24,
	[183][11] = 25,
	[183][12] = 26,
	[183][13] = 27,
	[183][14] = 28,
	[183][15] = 29,
	[183][16] = 30,
	[183][17] = 31,
	[183][18] = 32,
	[183][19] = 33,
	[183][20] = 34,
	[183][21] = 176,
	[183][22] = 177,
	[183][23] = 37,
	[183][24] = 178,
	[183][25] = 179,
	[183][31] = 446,
	[184][1] = 15,
	[184][2] = 16,
	[184][3] = 181,
	[184][4] = 18,
	[184][5] = 19,
	[184][6] = 20,
	[184][7] = 21,
	[184][8] = 22,
	[184][9] = 182,
	[184][10] = 24,
	[184][11] = 25,
	[184][12] = 26,
	[184][13] = 27,
	[184][14] = 28,
	[184][15] = 29,
	[184][16] = 30,
	[184][17] = 31,
	[184][18] = 32,
	[184][19] = 33,
	[184][20] = 34,
	[184][21] = 183,
	[184][22] = 184,
	[184][23] = 37,
	[184][24] = 185,
	[184][25] = 186,
	[184][32] = 447,
	[185][1] = 15,
	[185][2] = 16,
	[185][3] = 188,
	[185][4] = 18,
	[185][5] = 19,
	[185][6] = 20,
	[185][7] = 21,
	[185][8] = 22,
	[185][9] = 189,
	[185][10] = 24,
	[185][11] = 25,
	[185][12] = 26,
	[185][13] = 27,
	[185][14] = 28,
	[185][15] = 29,
	[185][16] = 30,
	[185][17] = 31,
	[185][18] = 32,
	[185][19] = 33,
	[185][20] = 34,
	[185][21] = 190,
	[185][22] = 191,
	[185][23] = 37,
	[185][24] = 192,
	[185][25] = 193,
	[185][33] = 448,
	[186][1] = 15,
	[186][2] = 16,
	[186][3] = 195,
	[186][4] = 18,
	[186][5] = 19,
	[186][6] = 20,
	[186][7] = 21,
	[186][8] = 22,
	[186][9] = 196,
	[186][10] = 24,
	[186][11] = 25,
	[186][12] = 26,
	[186][13] = 27,
	[186][14] = 28,
	[186][15] = 29,
	[186][16] = 30,
	[186][17] = 31,
	[186][18] = 32,
	[186][19] = 33,
	[186][20] = 34,
	[186][21] = 197,
	[186][22] = 198,
	[186][23] = 37,
	[186][24] = 199,
	[186][25] = 200,
	[186][34] = 449,
	[188][1] = 15,
	[188][2] = 16,
	[188][3] = 135,
	[188][4] = 18,
	[188][5] = 19,
	[188][6] = 20,
	[188][7] = 21,
	[188][8] = 22,
	[188][9] = 136,
	[188][10] = 24,
	[188][11] = 25,
	[188][12] = 26,
	[188][13] = 27,
	[188][14] = 28,
	[188][15] = 29,
	[188][16] = 30,
	[188][17] = 31,
	[188][18] = 32,
	[188][19] = 33,
	[188][20] = 34,
	[188][21] = 137,
	[188][22] = 138,
	[188][23] = 37,
	[188][24] = 139,
	[188][25] = 140,
	[188][28] = 450,
	[189][1] = 15,
	[189][2] = 16,
	[189][3] = 148,
	[189][4] = 18,
	[189][5] = 19,
	[189][6] = 20,
	[189][7] = 21,
	[189][8] = 22,
	[189][9] = 149,
	[189][10] = 24,
	[189][11] = 25,
	[189][12] = 26,
	[189][13] = 27,
	[189][14] = 28,
	[189][15] = 29,
	[189][16] = 30,
	[189][17] = 31,
	[189][18] = 32,
	[189][19] = 33,
	[189][20] = 34,
	[189][21] = 150,
	[189][22] = 151,
	[189][23] = 37,
	[189][24] = 152,
	[189][25] = 153,
	[189][30] = 451,
	[190][1] = 15,
	[190][2] = 16,
	[190][3] = 174,
	[190][4] = 18,
	[190][5] = 19,
	[190][6] = 20,
	[190][7] = 21,
	[190][8] = 22,
	[190][9] = 175,
	[190][10] = 24,
	[190][11] = 25,
	[190][12] = 26,
	[190][13] = 27,
	[190][14] = 28,
	[190][15] = 29,
	[190][16] = 30,
	[190][17] = 31,
	[190][18] = 32,
	[190][19] = 33,
	[190][20] = 34,
	[190][21] = 176,
	[190][22] = 177,
	[190][23] = 37,
	[190][24] = 178,
	[190][25] = 179,
	[190][31] = 452,
	[191][1] = 15,
	[191][2] = 16,
	[191][3] = 181,
	[191][4] = 18,
	[191][5] = 19,
	[191][6] = 20,
	[191][7] = 21,
	[191][8] = 22,
	[191][9] = 182,
	[191][10] = 24,
	[191][11] = 25,
	[191][12] = 26,
	[191][13] = 27,
	[191][14] = 28,
	[191][15] = 29,
	[191][16] = 30,
	[191][17] = 31,
	[191][18] = 32,
	[191][19] = 33,
	[191][20] = 34,
	[191][21] = 183,
	[191][22] = 184,
	[191][23] = 37,
	[191][24] = 185,
	[191][25] = 186,
	[191][32] = 453,
	[192][1] = 15,
	[192][2] = 16,
	[192][3] = 188,
	[192][4] = 18,
	[192][5] = 19,
	[192][6] = 20,
	[192][7] = 21,
	[192][8] = 22,
	[192][9] = 189,
	[192][10] = 24,
	[192][11] = 25,
	[192][12] = 26,
	[192][13] = 27,
	[192][14] = 28,
	[192][15] = 29,
	[192][16] = 30,
	[192][17] = 31,
	[192][18] = 32,
	[192][19] = 33,
	[192][20] = 34,
	[192][21] = 190,
	[192][22] = 191,
	[192][23] = 37,
	[192][24] = 192,
	[192][25] = 193,
	[192][33] = 454,
	[193][1] = 15,
	[193][2] = 16,
	[193][3] = 195,
	[193][4] = 18,
	[193][5] = 19,
	[193][6] = 20,
	[193][7] = 21,
	[193][8] = 22,
	[193][9] = 196,
	[193][10] = 24,
	[193][11] = 25,
	[193][12] = 26,
	[193][13] = 27,
	[193][14] = 28,
	[193][15] = 29,
	[193][16] = 30,
	[193][17] = 31,
	[193][18] = 32,
	[193][19] = 33,
	[193][20] = 34,
	[193][21] = 197,
	[193][22] = 198,
	[193][23] = 37,
	[193][24] = 199,
	[193][25] = 200,
	[193][34] = 455,
	[195][1] = 15,
	[195][2] = 16,
	[195][3] = 135,
	[195][4] = 18,
	[195][5] = 19,
	[195][6] = 20,
	[195][7] = 21,
	[195][8] = 22,
	[195][9] = 136,
	[195][10] = 24,
	[195][11] = 25,
	[195][12] = 26,
	[195][13] = 27,
	[195][14] = 28,
	[195][15] = 29,
	[195][16] = 30,
	[195][17] = 31,
	[195][18] = 32,
	[195][19] = 33,
	[195][20] = 34,
	[195][21] = 137,
	[195][22] = 138,
	[195][23] = 37,
	[195][24] = 139,
	[195][25] = 140,
	[195][28] = 456,
	[196][1] = 15,
	[196][2] = 16,
	[196][3] = 148,
	[196][4] = 18,
	[196][5] = 19,
	[196][6] = 20,
	[196][7] = 21,
	[196][8] = 22,
	[196][9] = 149,
	[196][10] = 24,
	[196][11] = 25,
	[196][12] = 26,
	[196][13] = 27,
	[196][14] = 28,
	[196][15] = 29,
	[196][16] = 30,
	[196][17] = 31,
	[196][18] = 32,
	[196][19] = 33,
	[196][20] = 34,
	[196][21] = 150,
	[196][22] = 151,
	[196][23] = 37,
	[196][24] = 152,
	[196][25] = 153,
	[196][30] = 457,
	[197][1] = 15,
	[197][2] = 16,
	[197][3] = 174,
	[197][4] = 18,
	[197][5] = 19,
	[197][6] = 20,
	[197][7] = 21,
	[197][8] = 22,
	[197][9] = 175,
	[197][10] = 24,
	[197][11] = 25,
	[197][12] = 26,
	[197][13] = 27,
	[197][14] = 28,
	[197][15] = 29,
	[197][16] = 30,
	[197][17] = 31,
	[197][18] = 32,
	[197][19] = 33,
	[197][20] = 34,
	[197][21] = 176,
	[197][22] = 177,
	[197][23] = 37,
	[197][24] = 178,
	[197][25] = 179,
	[197][31] = 458,
	[198][1] = 15,
	[198][2] = 16,
	[198][3] = 181,
	[198][4] = 18,
	[198][5] = 19,
	[198][6] = 20,
	[198][7] = 21,
	[198][8] = 22,
	[198][9] = 182,
	[198][10] = 24,
	[198][11] = 25,
	[198][12] = 26,
	[198][13] = 27,
	[198][14] = 28,
	[198][15] = 29,
	[198][16] = 30,
	[198][17] = 31,
	[198][18] = 32,
	[198][19] = 33,
	[198][20] = 34,
	[198][21] = 183,
	[198][22] = 184,
	[198][23] = 37,
	[198][24] = 185,
	[198][25] = 186,
	[198][32] = 459,
	[199][1] = 15,
	[199][2] = 16,
	[199][3] = 188,
	[199][4] = 18,
	[199][5] = 19,
	[199][6] = 20,
	[199][7] = 21,
	[199][8] = 22,
	[199][9] = 189,
	[199][10] = 24,
	[199][11] = 25,
	[199][12] = 26,
	[199][13] = 27,
	[199][14] = 28,
	[199][15] = 29,
	[199][16] = 30,
	[199][17] = 31,
	[199][18] = 32,
	[199][19] = 33,
	[199][20] = 34,
	[199][21] = 190,
	[199][22] = 191,
	[199][23] = 37,
	[199][24] = 192,
	[199][25] = 193,
	[199][33] = 460,
	[200][1] = 15,
	[200][2] = 16,
	[200][3] = 195,
	[200][4] = 18,
	[200][5] = 19,
	[200][6] = 20,
	[200][7] = 21,
	[200][8] = 22,
	[200][9] = 196,
	[200][10] = 24,
	[200][11] = 25,
	[200][12] = 26,
	[200][13] = 27,
	[200][14] = 28,
	[200][15] = 29,
	[200][16] = 30,
	[200][17] = 31,
	[200][18] = 32,
	[200][19] = 33,
	[200][20] = 34,
	[200][21] = 197,
	[200][22] = 198,
	[200][23] = 37,
	[200][24] = 199,
	[200][25] = 200,
	[200][34] = 461,
	[202][1] = 54,
	[202][2] = 55,
	[202][4] = 56,
	[202][5] = 57,
	[202][6] = 58,
	[202][7] = 59,
	[202][8] = 463,
	[202][10] = 61,
	[202][11] = 62,
	[202][12] = 63,
	[202][13] = 64,
	[202][14] = 65,
	[202][15] = 66,
	[202][16] = 67,
	[202][17] = 68,
	[202][18] = 69,
	[202][19] = 70,
	[202][20] = 71,
	[202][23] = 72,
	[202][35] = 462,
	[208][1] = 90,
	[208][2] = 91,
	[208][4] = 92,
	[208][5] = 93,
	[208][6] = 94,
	[208][7] = 95,
	[208][8] = 469,
	[208][10] = 97,
	[208][11] = 98,
	[208][12] = 99,
	[208][13] = 100,
	[208][14] = 101,
	[208][15] = 102,
	[208][16] = 103,
	[208][17] = 104,
	[208][18] = 105,
	[208][19] = 106,
	[208][20] = 107,
	[208][23] = 108,
	[208][36] = 468,
	[213][26] = 129,
	[213][27] = 320,
	[213][41] = 472,
	[213][42] = 473,
	[214][1] = 54,
	[214][2] = 55,
	[214][4] = 56,
	[214][5] = 57,
	[214][6] = 58,
	[214][7] = 59,
	[214][11] = 62,
	[214][12] = 475,
	[214][13] = 64,
	[214][14] = 65,
	[214][15] = 66,
	[214][17] = 68,
	[214][18] = 69,
	[214][19] = 70,
	[214][20] = 71,
	[214][23] = 72,
	[214][43] = 474,
	[216][7] = 59,
	[216][15] = 477,
	[216][17] = 68,
	[216][18] = 69,
	[216][23] = 72,
	[217][7] = 59,
	[217][15] = 478,
	[217][17] = 68,
	[217][18] = 69,
	[217][23] = 72,
	[218][1] = 54,
	[218][5] = 479,
	[218][7] = 59,
	[218][15] = 66,
	[218][17] = 68,
	[218][18] = 69,
	[218][19] = 70,
	[218][20] = 71,
	[218][23] = 72,
	[219][1] = 54,
	[219][7] = 59,
	[219][15] = 66,
	[219][17] = 68,
	[219][18] = 69,
	[219][19] = 480,
	[219][20] = 71,
	[219][23] = 72,
	[220][1] = 54,
	[220][7] = 59,
	[220][15] = 66,
	[220][17] = 68,
	[220][18] = 69,
	[220][19] = 481,
	[220][20] = 71,
	[220][23] = 72,
	[221][1] = 54,
	[221][2] = 482,
	[221][5] = 57,
	[221][7] = 59,
	[221][15] = 66,
	[221][17] = 68,
	[221][18] = 69,
	[221][19] = 70,
	[221][20] = 71,
	[221][23] = 72,
	[222][17] = 68,
	[222][18] = 69,
	[222][23] = 483,
	[224][1] = 54,
	[224][2] = 55,
	[224][4] = 56,
	[224][5] = 57,
	[224][6] = 58,
	[224][7] = 59,
	[224][8] = 207,
	[224][10] = 61,
	[224][11] = 62,
	[224][12] = 63,
	[224][13] = 64,
	[224][14] = 65,
	[224][15] = 66,
	[224][16] = 67,
	[224][17] = 68,
	[224][18] = 69,
	[224][19] = 70,
	[224][20] = 71,
	[224][23] = 72,
	[224][35] = 484,
	[225][1] = 54,
	[225][2] = 55,
	[225][4] = 56,
	[225][5] = 57,
	[225][6] = 58,
	[225][7] = 59,
	[225][10] = 486,
	[225][11] = 62,
	[225][12] = 63,
	[225][13] = 64,
	[225][14] = 65,
	[225][15] = 66,
	[225][16] = 67,
	[225][17] = 68,
	[225][18] = 69,
	[225][19] = 70,
	[225][20] = 71,
	[225][23] = 72,
	[225][44] = 485,
	[226][1] = 54,
	[226][2] = 55,
	[226][5] = 57,
	[226][6] = 487,
	[226][7] = 59,
	[226][15] = 66,
	[226][17] = 68,
	[226][18] = 69,
	[226][19] = 70,
	[226][20] = 71,
	[226][23] = 72,
	[228][1] = 54,
	[228][2] = 55,
	[228][5] = 57,
	[228][6] = 58,
	[228][7] = 59,
	[228][11] = 489,
	[228][15] = 66,
	[228][17] = 68,
	[228][18] = 69,
	[228][19] = 70,
	[228][20] = 71,
	[228][23] = 72,
	[229][1] = 372,
	[229][2] = 373,
	[229][4] = 374,
	[229][5] = 375,
	[229][6] = 376,
	[229][7] = 377,
	[229][8] = 490,
	[229][10] = 379,
	[229][11] = 380,
	[229][12] = 381,
	[229][13] = 382,
	[229][14] = 383,
	[229][15] = 384,
	[229][16] = 385,
	[229][17] = 386,
	[229][18] = 387,
	[229][19] = 388,
	[229][20] = 389,
	[229][23] = 390,
	[230][1] = 54,
	[230][2] = 55,
	[230][5] = 57,
	[230][6] = 58,
	[230][7] = 59,
	[230][11] = 62,
	[230][13] = 491,
	[230][15] = 66,
	[230][17] = 68,
	[230][18] = 69,
	[230][19] = 70,
	[230][20] = 71,
	[230][23] = 72,
	[231][7] = 492,
	[231][17] = 68,
	[231][18] = 69,
	[231][23] = 72,
	[232][7] = 493,
	[232][17] = 68,
	[232][18] = 69,
	[232][23] = 72,
	[233][7] = 494,
	[233][17] = 68,
	[233][18] = 69,
	[233][23] = 72,
	[234][1] = 54,
	[234][2] = 55,
	[234][4] = 56,
	[234][5] = 57,
	[234][6] = 58,
	[234][7] = 59,
	[234][11] = 62,
	[234][12] = 63,
	[234][13] = 64,
	[234][14] = 65,
	[234][15] = 66,
	[234][16] = 496,
	[234][17] = 68,
	[234][18] = 69,
	[234][19] = 70,
	[234][20] = 71,
	[234][23] = 72,
	[234][45] = 495,
	[235][1] = 54,
	[235][2] = 55,
	[235][4] = 56,
	[235][5] = 57,
	[235][6] = 58,
	[235][7] = 59,
	[235][8] = 499,
	[235][10] = 61,
	[235][11] = 62,
	[235][12] = 63,
	[235][13] = 64,
	[235][14] = 65,
	[235][15] = 66,
	[235][16] = 67,
	[235][17] = 68,
	[235][18] = 69,
	[235][19] = 70,
	[235][20] = 71,
	[235][23] = 72,
	[236][1] = 412,
	[236][2] = 413,
	[236][4] = 414,
	[236][5] = 415,
	[236][6] = 416,
	[236][7] = 417,
	[236][8] = 500,
	[236][10] = 419,
	[236][11] = 420,
	[236][12] = 421,
	[236][13] = 422,
	[236][14] = 423,
	[236][15] = 424,
	[236][16] = 425,
	[236][17] = 426,
	[236][18] = 427,
	[236][19] = 428,
	[236][20] = 429,
	[236][23] = 430,
	[238][1] = 54,
	[238][7] = 59,
	[238][15] = 66,
	[238][17] = 68,
	[238][18] = 69,
	[238][20] = 502,
	[238][23] = 72,
	[239][1] = 54,
	[239][7] = 59,
	[239][15] = 66,
	[239][17] = 68,
	[239][18] = 69,
	[239][20] = 503,
	[239][23] = 72,
	[240][1] = 54,
	[240][7] = 59,
	[240][15] = 66,
	[240][17] = 68,
	[240][18] = 69,
	[240][20] = 504,
	[240][23] = 72,
	[241][1] = 54,
	[241][7] = 59,
	[241][15] = 66,
	[241][17] = 68,
	[241][18] = 69,
	[241][20] = 505,
	[241][23] = 72,
	[242][1] = 506,
	[242][7] = 59,
	[242][15] = 66,
	[242][17] = 68,
	[242][18] = 69,
	[242][23] = 72,
	[243][1] = 507,
	[243][7] = 59,
	[243][15] = 66,
	[243][17] = 68,
	[243][18] = 69,
	[243][23] = 72,
	[245][1] = 54,
	[245][2] = 55,
	[245][4] = 56,
	[245][5] = 57,
	[245][6] = 58,
	[245][7] = 59,
	[245][8] = 509,
	[245][10] = 61,
	[245][11] = 62,
	[245][12] = 63,
	[245][13] = 64,
	[245][14] = 65,
	[245][15] = 66,
	[245][16] = 67,
	[245][17] = 68,
	[245][18] = 69,
	[245][19] = 70,
	[245][20] = 71,
	[245][23] = 72,
	[245][35] = 508,
	[251][1] = 90,
	[251][2] = 91,
	[251][4] = 92,
	[251][5] = 93,
	[251][6] = 94,
	[251][7] = 95,
	[251][8] = 515,
	[251][10] = 97,
	[251][11] = 98,
	[251][12] = 99,
	[251][13] = 100,
	[251][14] = 101,
	[251][15] = 102,
	[251][16] = 103,
	[251][17] = 104,
	[251][18] = 105,
	[251][19] = 106,
	[251][20] = 107,
	[251][23] = 108,
	[251][36] = 514,
	[256][26] = 129,
	[256][27] = 320,
	[256][41] = 518,
	[256][42] = 519,
	[257][1] = 90,
	[257][2] = 91,
	[257][4] = 92,
	[257][5] = 93,
	[257][6] = 94,
	[257][7] = 95,
	[257][11] = 98,
	[257][12] = 521,
	[257][13] = 100,
	[257][14] = 101,
	[257][15] = 102,
	[257][17] = 104,
	[257][18] = 105,
	[257][19] = 106,
	[257][20] = 107,
	[257][23] = 108,
	[257][43] = 520,
	[259][7] = 95,
	[259][15] = 523,
	[259][17] = 104,
	[259][18] = 105,
	[259][23] = 108,
	[260][7] = 95,
	[260][15] = 524,
	[260][17] = 104,
	[260][18] = 105,
	[260][23] = 108,
	[261][1] = 90,
	[261][5] = 525,
	[261][7] = 95,
	[261][15] = 102,
	[261][17] = 104,
	[261][18] = 105,
	[261][19] = 106,
	[261][20] = 107,
	[261][23] = 108,
	[262][1] = 90,
	[262][7] = 95,
	[262][15] = 102,
	[262][17] = 104,
	[262][18] = 105,
	[262][19] = 526,
	[262][20] = 107,
	[262][23] = 108,
	[263][1] = 90,
	[263][7] = 95,
	[263][15] = 102,
	[263][17] = 104,
	[263][18] = 105,
	[263][19] = 527,
	[263][20] = 107,
	[263][23] = 108,
	[264][1] = 90,
	[264][2] = 528,
	[264][5] = 93,
	[264][7] = 95,
	[264][15] = 102,
	[264][17] = 104,
	[264][18] = 105,
	[264][19] = 106,
	[264][20] = 107,
	[264][23] = 108,
	[265][17] = 104,
	[265][18] = 105,
	[265][23] = 529,
	[266][1] = 90,
	[266][2] = 91,
	[266][4] = 92,
	[266][5] = 93,
	[266][6] = 94,
	[266][7] = 95,
	[266][8] = 250,
	[266][10] = 97,
	[266][11] = 98,
	[266][12] = 99,
	[266][13] = 100,
	[266][14] = 101,
	[266][15] = 102,
	[266][16] = 103,
	[266][17] = 104,
	[266][18] = 105,
	[266][19] = 106,
	[266][20] = 107,
	[266][23] = 108,
	[266][36] = 530,
	[268][1] = 90,
	[268][2] = 91,
	[268][4] = 92,
	[268][5] = 93,
	[268][6] = 94,
	[268][7] = 95,
	[268][10] = 532,
	[268][11] = 98,
	[268][12] = 99,
	[268][13] = 100,
	[268][14] = 101,
	[268][15] = 102,
	[268][16] = 103,
	[268][17] = 104,
	[268][18] = 105,
	[268][19] = 106,
	[268][20] = 107,
	[268][23] = 108,
	[268][44] = 531,
	[269][1] = 90,
	[269][2] = 91,
	[269][5] = 93,
	[269][6] = 533,
	[269][7] = 95,
	[269][15] = 102,
	[269][17] = 104,
	[269][18] = 105,
	[269][19] = 106,
	[269][20] = 107,
	[269][23] = 108,
	[271][1] = 90,
	[271][2] = 91,
	[271][5] = 93,
	[271][6] = 94,
	[271][7] = 95,
	[271][11] = 535,
	[271][15] = 102,
	[271][17] = 104,
	[271][18] = 105,
	[271][19] = 106,
	[271][20] = 107,
	[271][23] = 108,
	[272][1] = 372,
	[272][2] = 373,
	[272][4] = 374,
	[272][5] = 375,
	[272][6] = 376,
	[272][7] = 377,
	[272][8] = 536,
	[272][10] = 379,
	[272][11] = 380,
	[272][12] = 381,
	[272][13] = 382,
	[272][14] = 383,
	[272][15] = 384,
	[272][16] = 385,
	[272][17] = 386,
	[272][18] = 387,
	[272][19] = 388,
	[272][20] = 389,
	[272][23] = 390,
	[273][1] = 90,
	[273][2] = 91,
	[273][5] = 93,
	[273][6] = 94,
	[273][7] = 95,
	[273][11] = 98,
	[273][13] = 537,
	[273][15] = 102,
	[273][17] = 104,
	[273][18] = 105,
	[273][19] = 106,
	[273][20] = 107,
	[273][23] = 108,
	[274][7] = 538,
	[274][17] = 104,
	[274][18] = 105,
	[274][23] = 108,
	[275][7] = 539,
	[275][17] = 104,
	[275][18] = 105,
	[275][23] = 108,
	[276][7] = 540,
	[276][17] = 104,
	[276][18] = 105,
	[276][23] = 108,
	[277][1] = 90,
	[277][2] = 91,
	[277][4] = 92,
	[277][5] = 93,
	[277][6] = 94,
	[277][7] = 95,
	[277][11] = 98,
	[277][12] = 99,
	[277][13] = 100,
	[277][14] = 101,
	[277][15] = 102,
	[277][16] = 542,
	[277][17] = 104,
	[277][18] = 105,
	[277][19] = 106,
	[277][20] = 107,
	[277][23] = 108,
	[277][45] = 541,
	[278][1] = 54,
	[278][2] = 55,
	[278][4] = 56,
	[278][5] = 57,
	[278][6] = 58,
	[278][7] = 59,
	[278][8] = 545,
	[278][10] = 61,
	[278][11] = 62,
	[278][12] = 63,
	[278][13] = 64,
	[278][14] = 65,
	[278][15] = 66,
	[278][16] = 67,
	[278][17] = 68,
	[278][18] = 69,
	[278][19] = 70,
	[278][20] = 71,
	[278][23] = 72,
	[279][1] = 412,
	[279][2] = 413,
	[279][4] = 414,
	[279][5] = 415,
	[279][6] = 416,
	[279][7] = 417,
	[279][8] = 546,
	[279][10] = 419,
	[279][11] = 420,
	[279][12] = 421,
	[279][13] = 422,
	[279][14] = 423,
	[279][15] = 424,
	[279][16] = 425,
	[279][17] = 426,
	[279][18] = 427,
	[279][19] = 428,
	[279][20] = 429,
	[279][23] = 430,
	[281][1] = 90,
	[281][7] = 95,
	[281][15] = 102,
	[281][17] = 104,
	[281][18] = 105,
	[281][20] = 548,
	[281][23] = 108,
	[282][1] = 90,
	[282][7] = 95,
	[282][15] = 102,
	[282][17] = 104,
	[282][18] = 105,
	[282][20] = 549,
	[282][23] = 108,
	[283][1] = 90,
	[283][7] = 95,
	[283][15] = 102,
	[283][17] = 104,
	[283][18] = 105,
	[283][20] = 550,
	[283][23] = 108,
	[284][1] = 90,
	[284][7] = 95,
	[284][15] = 102,
	[284][17] = 104,
	[284][18] = 105,
	[284][20] = 551,
	[284][23] = 108,
	[285][1] = 552,
	[285][7] = 95,
	[285][15] = 102,
	[285][17] = 104,
	[285][18] = 105,
	[285][23] = 108,
	[286][1] = 553,
	[286][7] = 95,
	[286][15] = 102,
	[286][17] = 104,
	[286][18] = 105,
	[286][23] = 108,
	[289][37] = 563,
	[289][38] = 564,
	[289][39] = 565,
	[289][40] = 566,
	[291][46] = 572,
	[291][47] = 573,
	[291][48] = 574,
	[291][49] = 575,
	[291][50] = 576,
	[291][51] = 577,
	[293][52] = 584,
	[293][53] = 585,
	[293][54] = 586,
	[293][55] = 587,
	[297][38] = 295,
	[297][40] = 593,
	[300][52] = 601,
	[300][53] = 602,
	[300][54] = 603,
	[300][55] = 604,
	[301][37] = 605,
	[301][38] = 295,
	[301][39] = 296,
	[301][40] = 297,
	[302][1] = 15,
	[302][2] = 16,
	[302][4] = 18,
	[302][5] = 19,
	[302][6] = 20,
	[302][7] = 21,
	[302][8] = 607,
	[302][10] = 24,
	[302][11] = 25,
	[302][12] = 26,
	[302][13] = 27,
	[302][14] = 28,
	[302][15] = 29,
	[302][16] = 30,
	[302][17] = 31,
	[302][18] = 32,
	[302][19] = 33,
	[302][20] = 34,
	[302][23] = 37,
	[302][56] = 606,
	[303][1] = 15,
	[303][2] = 16,
	[303][4] = 18,
	[303][5] = 19,
	[303][6] = 20,
	[303][7] = 21,
	[303][8] = 607,
	[303][10] = 24,
	[303][11] = 25,
	[303][12] = 26,
	[303][13] = 27,
	[303][14] = 28,
	[303][15] = 29,
	[303][16] = 30,
	[303][17] = 31,
	[303][18] = 32,
	[303][19] = 33,
	[303][20] = 34,
	[303][23] = 37,
	[303][56] = 608,
	[304][1] = 15,
	[304][2] = 16,
	[304][4] = 18,
	[304][5] = 19,
	[304][6] = 20,
	[304][7] = 21,
	[304][8] = 607,
	[304][10] = 24,
	[304][11] = 25,
	[304][12] = 26,
	[304][13] = 27,
	[304][14] = 28,
	[304][15] = 29,
	[304][16] = 30,
	[304][17] = 31,
	[304][18] = 32,
	[304][19] = 33,
	[304][20] = 34,
	[304][23] = 37,
	[304][56] = 609,
	[305][1] = 15,
	[305][2] = 16,
	[305][4] = 18,
	[305][5] = 19,
	[305][6] = 20,
	[305][7] = 21,
	[305][8] = 607,
	[305][10] = 24,
	[305][11] = 25,
	[305][12] = 26,
	[305][13] = 27,
	[305][14] = 28,
	[305][15] = 29,
	[305][16] = 30,
	[305][17] = 31,
	[305][18] = 32,
	[305][19] = 33,
	[305][20] = 34,
	[305][23] = 37,
	[305][56] = 610,
	[306][26] = 315,
	[306][27] = 613,
	[308][26] = 315,
	[308][27] = 615,
	[308][57] = 614,
	[314][26] = 332,
	[314][27] = 618,
	[323][26] = 315,
	[323][27] = 627,
	[324][26] = 332,
	[324][27] = 629,
	[324][58] = 628,
	[326][26] = 129,
	[326][27] = 631,
	[326][59] = 630,
	[331][26] = 332,
	[331][27] = 634,
	[362][1] = 54,
	[362][2] = 55,
	[362][4] = 56,
	[362][5] = 57,
	[362][6] = 58,
	[362][7] = 59,
	[362][8] = 643,
	[362][10] = 61,
	[362][11] = 62,
	[362][12] = 63,
	[362][13] = 64,
	[362][14] = 65,
	[362][15] = 66,
	[362][16] = 67,
	[362][17] = 68,
	[362][18] = 69,
	[362][19] = 70,
	[362][20] = 71,
	[362][23] = 72,
	[363][17] = 386,
	[363][18] = 387,
	[363][23] = 644,
	[364][17] = 386,
	[364][18] = 387,
	[364][23] = 645,
	[366][1] = 90,
	[366][2] = 91,
	[366][4] = 92,
	[366][5] = 93,
	[366][6] = 94,
	[366][7] = 95,
	[366][8] = 648,
	[366][10] = 97,
	[366][11] = 98,
	[366][12] = 99,
	[366][13] = 100,
	[366][14] = 101,
	[366][15] = 102,
	[366][16] = 103,
	[366][17] = 104,
	[366][18] = 105,
	[366][19] = 106,
	[366][20] = 107,
	[366][23] = 108,
	[367][17] = 386,
	[367][18] = 387,
	[367][23] = 649,
	[370][17] = 386,
	[370][18] = 387,
	[370][23] = 650,
	[371][26] = 129,
	[371][27] = 653,
	[398][1] = 54,
	[398][2] = 55,
	[398][4] = 56,
	[398][5] = 57,
	[398][6] = 58,
	[398][7] = 59,
	[398][8] = 683,
	[398][10] = 61,
	[398][11] = 62,
	[398][12] = 63,
	[398][13] = 64,
	[398][14] = 65,
	[398][15] = 66,
	[398][16] = 67,
	[398][17] = 68,
	[398][18] = 69,
	[398][19] = 70,
	[398][20] = 71,
	[398][23] = 72,
	[398][60] = 682,
	[402][1] = 54,
	[402][2] = 55,
	[402][4] = 56,
	[402][5] = 57,
	[402][6] = 58,
	[402][7] = 59,
	[402][8] = 688,
	[402][10] = 61,
	[402][11] = 62,
	[402][12] = 63,
	[402][13] = 64,
	[402][14] = 65,
	[402][15] = 66,
	[402][16] = 67,
	[402][17] = 68,
	[402][18] = 69,
	[402][19] = 70,
	[402][20] = 71,
	[402][23] = 72,
	[403][17] = 426,
	[403][18] = 427,
	[403][23] = 689,
	[404][17] = 426,
	[404][18] = 427,
	[404][23] = 690,
	[406][1] = 90,
	[406][2] = 91,
	[406][4] = 92,
	[406][5] = 93,
	[406][6] = 94,
	[406][7] = 95,
	[406][8] = 693,
	[406][10] = 97,
	[406][11] = 98,
	[406][12] = 99,
	[406][13] = 100,
	[406][14] = 101,
	[406][15] = 102,
	[406][16] = 103,
	[406][17] = 104,
	[406][18] = 105,
	[406][19] = 106,
	[406][20] = 107,
	[406][23] = 108,
	[407][17] = 426,
	[407][18] = 427,
	[407][23] = 694,
	[410][17] = 426,
	[410][18] = 427,
	[410][23] = 695,
	[411][26] = 129,
	[411][27] = 698,
	[465][1] = 54,
	[465][2] = 55,
	[465][4] = 56,
	[465][5] = 57,
	[465][6] = 58,
	[465][7] = 59,
	[465][8] = 463,
	[465][10] = 61,
	[465][11] = 62,
	[465][12] = 63,
	[465][13] = 64,
	[465][14] = 65,
	[465][15] = 66,
	[465][16] = 67,
	[465][17] = 68,
	[465][18] = 69,
	[465][19] = 70,
	[465][20] = 71,
	[465][23] = 72,
	[465][35] = 728,
	[467][1] = 54,
	[467][2] = 55,
	[467][4] = 56,
	[467][5] = 57,
	[467][6] = 58,
	[467][7] = 59,
	[467][8] = 207,
	[467][10] = 61,
	[467][11] = 62,
	[467][12] = 63,
	[467][13] = 64,
	[467][14] = 65,
	[467][15] = 66,
	[467][16] = 67,
	[467][17] = 68,
	[467][18] = 69,
	[467][19] = 70,
	[467][20] = 71,
	[467][23] = 72,
	[467][35] = 729,
	[470][1] = 90,
	[470][2] = 91,
	[470][4] = 92,
	[470][5] = 93,
	[470][6] = 94,
	[470][7] = 95,
	[470][8] = 469,
	[470][10] = 97,
	[470][11] = 98,
	[470][12] = 99,
	[470][13] = 100,
	[470][14] = 101,
	[470][15] = 102,
	[470][16] = 103,
	[470][17] = 104,
	[470][18] = 105,
	[470][19] = 106,
	[470][20] = 107,
	[470][23] = 108,
	[470][36] = 732,
	[498][1] = 54,
	[498][2] = 55,
	[498][4] = 56,
	[498][5] = 57,
	[498][6] = 58,
	[498][7] = 59,
	[498][8] = 741,
	[498][10] = 61,
	[498][11] = 62,
	[498][12] = 63,
	[498][13] = 64,
	[498][14] = 65,
	[498][15] = 66,
	[498][16] = 67,
	[498][17] = 68,
	[498][18] = 69,
	[498][19] = 70,
	[498][20] = 71,
	[498][23] = 72,
	[498][60] = 740,
	[511][1] = 54,
	[511][2] = 55,
	[511][4] = 56,
	[511][5] = 57,
	[511][6] = 58,
	[511][7] = 59,
	[511][8] = 509,
	[511][10] = 61,
	[511][11] = 62,
	[511][12] = 63,
	[511][13] = 64,
	[511][14] = 65,
	[511][15] = 66,
	[511][16] = 67,
	[511][17] = 68,
	[511][18] = 69,
	[511][19] = 70,
	[511][20] = 71,
	[511][23] = 72,
	[511][35] = 747,
	[512][1] = 90,
	[512][2] = 91,
	[512][4] = 92,
	[512][5] = 93,
	[512][6] = 94,
	[512][7] = 95,
	[512][8] = 250,
	[512][10] = 97,
	[512][11] = 98,
	[512][12] = 99,
	[512][13] = 100,
	[512][14] = 101,
	[512][15] = 102,
	[512][16] = 103,
	[512][17] = 104,
	[512][18] = 105,
	[512][19] = 106,
	[512][20] = 107,
	[512][23] = 108,
	[512][36] = 748,
	[516][1] = 90,
	[516][2] = 91,
	[516][4] = 92,
	[516][5] = 93,
	[516][6] = 94,
	[516][7] = 95,
	[516][8] = 515,
	[516][10] = 97,
	[516][11] = 98,
	[516][12] = 99,
	[516][13] = 100,
	[516][14] = 101,
	[516][15] = 102,
	[516][16] = 103,
	[516][17] = 104,
	[516][18] = 105,
	[516][19] = 106,
	[516][20] = 107,
	[516][23] = 108,
	[516][36] = 751,
	[544][1] = 54,
	[544][2] = 55,
	[544][4] = 56,
	[544][5] = 57,
	[544][6] = 58,
	[544][7] = 59,
	[544][8] = 760,
	[544][10] = 61,
	[544][11] = 62,
	[544][12] = 63,
	[544][13] = 64,
	[544][14] = 65,
	[544][15] = 66,
	[544][16] = 67,
	[544][17] = 68,
	[544][18] = 69,
	[544][19] = 70,
	[544][20] = 71,
	[544][23] = 72,
	[544][60] = 759,
	[554][61] = 765,
	[555][62] = 767,
	[558][37] = 770,
	[558][38] = 564,
	[558][39] = 565,
	[558][40] = 566,
	[560][46] = 772,
	[560][47] = 573,
	[560][48] = 574,
	[560][49] = 575,
	[560][50] = 576,
	[560][51] = 577,
	[562][52] = 774,
	[562][53] = 585,
	[562][54] = 586,
	[562][55] = 587,
	[566][38] = 564,
	[566][40] = 780,
	[567][63] = 782,
	[570][46] = 787,
	[570][47] = 788,
	[570][48] = 789,
	[570][49] = 790,
	[570][50] = 791,
	[570][51] = 792,
	[571][47] = 793,
	[577][47] = 573,
	[577][48] = 574,
	[577][49] = 575,
	[577][50] = 576,
	[577][51] = 800,
	[578][64] = 802,
	[581][52] = 808,
	[581][53] = 809,
	[581][54] = 810,
	[581][55] = 811,
	[583][46] = 812,
	[583][47] = 573,
	[583][48] = 574,
	[583][49] = 575,
	[583][50] = 576,
	[583][51] = 577,
	[587][53] = 585,
	[587][55] = 818,
	[592][38] = 295,
	[592][39] = 820,
	[592][40] = 297,
	[592][65] = 819,
	[593][38] = 295,
	[593][40] = 822,
	[593][66] = 821,
	[598][52] = 823,
	[598][53] = 809,
	[598][54] = 810,
	[598][55] = 811,
	[600][46] = 824,
	[600][47] = 573,
	[600][48] = 574,
	[600][49] = 575,
	[600][50] = 576,
	[600][51] = 577,
	[604][53] = 602,
	[604][55] = 830,
	[607][29] = 832,
	[612][26] = 315,
	[612][27] = 834,
	[612][57] = 833,
	[616][26] = 332,
	[616][27] = 840,
	[616][58] = 839,
	[617][26] = 315,
	[617][27] = 842,
	[617][59] = 841,
	[621][26] = 315,
	[621][27] = 615,
	[621][57] = 845,
	[622][26] = 129,
	[622][27] = 320,
	[622][41] = 846,
	[622][42] = 319,
	[623][1] = 15,
	[623][2] = 16,
	[623][4] = 18,
	[623][5] = 19,
	[623][6] = 20,
	[623][7] = 21,
	[623][11] = 25,
	[623][12] = 322,
	[623][13] = 27,
	[623][14] = 28,
	[623][15] = 29,
	[623][17] = 31,
	[623][18] = 32,
	[623][19] = 33,
	[623][20] = 34,
	[623][23] = 37,
	[623][43] = 847,
	[626][26] = 315,
	[626][27] = 849,
	[626][57] = 848,
	[632][26] = 332,
	[632][27] = 855,
	[632][58] = 854,
	[633][26] = 332,
	[633][27] = 857,
	[633][59] = 856,
	[636][26] = 332,
	[636][27] = 629,
	[636][58] = 860,
	[637][26] = 129,
	[637][27] = 631,
	[637][59] = 861,
	[638][26] = 129,
	[638][27] = 320,
	[638][41] = 862,
	[638][42] = 319,
	[639][1] = 15,
	[639][2] = 16,
	[639][4] = 18,
	[639][5] = 19,
	[639][6] = 20,
	[639][7] = 21,
	[639][11] = 25,
	[639][12] = 322,
	[639][13] = 27,
	[639][14] = 28,
	[639][15] = 29,
	[639][17] = 31,
	[639][18] = 32,
	[639][19] = 33,
	[639][20] = 34,
	[639][23] = 37,
	[639][43] = 863,
	[640][1] = 15,
	[640][2] = 16,
	[640][4] = 18,
	[640][5] = 19,
	[640][6] = 20,
	[640][7] = 21,
	[640][10] = 356,
	[640][11] = 25,
	[640][12] = 26,
	[640][13] = 27,
	[640][14] = 28,
	[640][15] = 29,
	[640][16] = 30,
	[640][17] = 31,
	[640][18] = 32,
	[640][19] = 33,
	[640][20] = 34,
	[640][23] = 37,
	[640][44] = 864,
	[642][1] = 54,
	[642][2] = 55,
	[642][4] = 56,
	[642][5] = 57,
	[642][6] = 58,
	[642][7] = 59,
	[642][8] = 866,
	[642][10] = 61,
	[642][11] = 62,
	[642][12] = 63,
	[642][13] = 64,
	[642][14] = 65,
	[642][15] = 66,
	[642][16] = 67,
	[642][17] = 68,
	[642][18] = 69,
	[642][19] = 70,
	[642][20] = 71,
	[642][23] = 72,
	[642][35] = 865,
	[646][1] = 90,
	[646][2] = 91,
	[646][4] = 92,
	[646][5] = 93,
	[646][6] = 94,
	[646][7] = 95,
	[646][8] = 870,
	[646][10] = 97,
	[646][11] = 98,
	[646][12] = 99,
	[646][13] = 100,
	[646][14] = 101,
	[646][15] = 102,
	[646][16] = 103,
	[646][17] = 104,
	[646][18] = 105,
	[646][19] = 106,
	[646][20] = 107,
	[646][23] = 108,
	[646][36] = 869,
	[651][26] = 129,
	[651][27] = 320,
	[651][41] = 873,
	[651][42] = 874,
	[652][1] = 372,
	[652][2] = 373,
	[652][4] = 374,
	[652][5] = 375,
	[652][6] = 376,
	[652][7] = 377,
	[652][11] = 380,
	[652][12] = 876,
	[652][13] = 382,
	[652][14] = 383,
	[652][15] = 384,
	[652][17] = 386,
	[652][18] = 387,
	[652][19] = 388,
	[652][20] = 389,
	[652][23] = 390,
	[652][43] = 875,
	[654][7] = 377,
	[654][15] = 878,
	[654][17] = 386,
	[654][18] = 387,
	[654][23] = 390,
	[655][7] = 377,
	[655][15] = 879,
	[655][17] = 386,
	[655][18] = 387,
	[655][23] = 390,
	[656][1] = 372,
	[656][5] = 880,
	[656][7] = 377,
	[656][15] = 384,
	[656][17] = 386,
	[656][18] = 387,
	[656][19] = 388,
	[656][20] = 389,
	[656][23] = 390,
	[657][1] = 372,
	[657][7] = 377,
	[657][15] = 384,
	[657][17] = 386,
	[657][18] = 387,
	[657][19] = 881,
	[657][20] = 389,
	[657][23] = 390,
	[658][1] = 372,
	[658][7] = 377,
	[658][15] = 384,
	[658][17] = 386,
	[658][18] = 387,
	[658][19] = 882,
	[658][20] = 389,
	[658][23] = 390,
	[659][1] = 372,
	[659][2] = 883,
	[659][5] = 375,
	[659][7] = 377,
	[659][15] = 384,
	[659][17] = 386,
	[659][18] = 387,
	[659][19] = 388,
	[659][20] = 389,
	[659][23] = 390,
	[660][17] = 386,
	[660][18] = 387,
	[660][23] = 884,
	[661][1] = 15,
	[661][2] = 16,
	[661][4] = 885,
	[661][5] = 19,
	[661][6] = 20,
	[661][7] = 21,
	[661][11] = 25,
	[661][13] = 27,
	[661][14] = 28,
	[661][15] = 29,
	[661][17] = 31,
	[661][18] = 32,
	[661][19] = 33,
	[661][20] = 34,
	[661][23] = 37,
	[662][1] = 372,
	[662][2] = 373,
	[662][4] = 374,
	[662][5] = 375,
	[662][6] = 376,
	[662][7] = 377,
	[662][10] = 887,
	[662][11] = 380,
	[662][12] = 381,
	[662][13] = 382,
	[662][14] = 383,
	[662][15] = 384,
	[662][16] = 385,
	[662][17] = 386,
	[662][18] = 387,
	[662][19] = 388,
	[662][20] = 389,
	[662][23] = 390,
	[662][44] = 886,
	[663][1] = 372,
	[663][2] = 373,
	[663][5] = 375,
	[663][6] = 888,
	[663][7] = 377,
	[663][15] = 384,
	[663][17] = 386,
	[663][18] = 387,
	[663][19] = 388,
	[663][20] = 389,
	[663][23] = 390,
	[665][1] = 372,
	[665][2] = 373,
	[665][5] = 375,
	[665][6] = 376,
	[665][7] = 377,
	[665][11] = 890,
	[665][15] = 384,
	[665][17] = 386,
	[665][18] = 387,
	[665][19] = 388,
	[665][20] = 389,
	[665][23] = 390,
	[666][1] = 372,
	[666][2] = 373,
	[666][4] = 374,
	[666][5] = 375,
	[666][6] = 376,
	[666][7] = 377,
	[666][8] = 891,
	[666][10] = 379,
	[666][11] = 380,
	[666][12] = 381,
	[666][13] = 382,
	[666][14] = 383,
	[666][15] = 384,
	[666][16] = 385,
	[666][17] = 386,
	[666][18] = 387,
	[666][19] = 388,
	[666][20] = 389,
	[666][23] = 390,
	[667][1] = 372,
	[667][2] = 373,
	[667][5] = 375,
	[667][6] = 376,
	[667][7] = 377,
	[667][11] = 380,
	[667][13] = 892,
	[667][15] = 384,
	[667][17] = 386,
	[667][18] = 387,
	[667][19] = 388,
	[667][20] = 389,
	[667][23] = 390,
	[668][7] = 893,
	[668][17] = 386,
	[668][18] = 387,
	[668][23] = 390,
	[669][7] = 894,
	[669][17] = 386,
	[669][18] = 387,
	[669][23] = 390,
	[670][7] = 895,
	[670][17] = 386,
	[670][18] = 387,
	[670][23] = 390,
	[671][1] = 372,
	[671][2] = 373,
	[671][4] = 374,
	[671][5] = 375,
	[671][6] = 376,
	[671][7] = 377,
	[671][11] = 380,
	[671][12] = 381,
	[671][13] = 382,
	[671][14] = 383,
	[671][15] = 384,
	[671][16] = 897,
	[671][17] = 386,
	[671][18] = 387,
	[671][19] = 388,
	[671][20] = 389,
	[671][23] = 390,
	[671][45] = 896,
	[672][1] = 54,
	[672][2] = 55,
	[672][4] = 56,
	[672][5] = 57,
	[672][6] = 58,
	[672][7] = 59,
	[672][8] = 900,
	[672][10] = 61,
	[672][11] = 62,
	[672][12] = 63,
	[672][13] = 64,
	[672][14] = 65,
	[672][15] = 66,
	[672][16] = 67,
	[672][17] = 68,
	[672][18] = 69,
	[672][19] = 70,
	[672][20] = 71,
	[672][23] = 72,
	[673][1] = 412,
	[673][2] = 413,
	[673][4] = 414,
	[673][5] = 415,
	[673][6] = 416,
	[673][7] = 417,
	[673][8] = 901,
	[673][10] = 419,
	[673][11] = 420,
	[673][12] = 421,
	[673][13] = 422,
	[673][14] = 423,
	[673][15] = 424,
	[673][16] = 425,
	[673][17] = 426,
	[673][18] = 427,
	[673][19] = 428,
	[673][20] = 429,
	[673][23] = 430,
	[675][1] = 372,
	[675][7] = 377,
	[675][15] = 384,
	[675][17] = 386,
	[675][18] = 387,
	[675][20] = 903,
	[675][23] = 390,
	[676][1] = 372,
	[676][7] = 377,
	[676][15] = 384,
	[676][17] = 386,
	[676][18] = 387,
	[676][20] = 904,
	[676][23] = 390,
	[677][1] = 372,
	[677][7] = 377,
	[677][15] = 384,
	[677][17] = 386,
	[677][18] = 387,
	[677][20] = 905,
	[677][23] = 390,
	[678][1] = 372,
	[678][7] = 377,
	[678][15] = 384,
	[678][17] = 386,
	[678][18] = 387,
	[678][20] = 906,
	[678][23] = 390,
	[679][1] = 907,
	[679][7] = 377,
	[679][15] = 384,
	[679][17] = 386,
	[679][18] = 387,
	[679][23] = 390,
	[680][1] = 908,
	[680][7] = 377,
	[680][15] = 384,
	[680][17] = 386,
	[680][18] = 387,
	[680][23] = 390,
	[681][1] = 15,
	[681][2] = 16,
	[681][4] = 18,
	[681][5] = 19,
	[681][6] = 20,
	[681][7] = 21,
	[681][11] = 25,
	[681][12] = 26,
	[681][13] = 27,
	[681][14] = 28,
	[681][15] = 29,
	[681][16] = 396,
	[681][17] = 31,
	[681][18] = 32,
	[681][19] = 33,
	[681][20] = 34,
	[681][23] = 37,
	[681][45] = 909,
	[685][1] = 54,
	[685][2] = 55,
	[685][4] = 56,
	[685][5] = 57,
	[685][6] = 58,
	[685][7] = 59,
	[685][8] = 683,
	[685][10] = 61,
	[685][11] = 62,
	[685][12] = 63,
	[685][13] = 64,
	[685][14] = 65,
	[685][15] = 66,
	[685][16] = 67,
	[685][17] = 68,
	[685][18] = 69,
	[685][19] = 70,
	[685][20] = 71,
	[685][23] = 72,
	[685][60] = 912,
	[687][1] = 54,
	[687][2] = 55,
	[687][4] = 56,
	[687][5] = 57,
	[687][6] = 58,
	[687][7] = 59,
	[687][8] = 914,
	[687][10] = 61,
	[687][11] = 62,
	[687][12] = 63,
	[687][13] = 64,
	[687][14] = 65,
	[687][15] = 66,
	[687][16] = 67,
	[687][17] = 68,
	[687][18] = 69,
	[687][19] = 70,
	[687][20] = 71,
	[687][23] = 72,
	[687][35] = 913,
	[691][1] = 90,
	[691][2] = 91,
	[691][4] = 92,
	[691][5] = 93,
	[691][6] = 94,
	[691][7] = 95,
	[691][8] = 918,
	[691][10] = 97,
	[691][11] = 98,
	[691][12] = 99,
	[691][13] = 100,
	[691][14] = 101,
	[691][15] = 102,
	[691][16] = 103,
	[691][17] = 104,
	[691][18] = 105,
	[691][19] = 106,
	[691][20] = 107,
	[691][23] = 108,
	[691][36] = 917,
	[696][26] = 129,
	[696][27] = 320,
	[696][41] = 921,
	[696][42] = 922,
	[697][1] = 412,
	[697][2] = 413,
	[697][4] = 414,
	[697][5] = 415,
	[697][6] = 416,
	[697][7] = 417,
	[697][11] = 420,
	[697][12] = 924,
	[697][13] = 422,
	[697][14] = 423,
	[697][15] = 424,
	[697][17] = 426,
	[697][18] = 427,
	[697][19] = 428,
	[697][20] = 429,
	[697][23] = 430,
	[697][43] = 923,
	[699][7] = 417,
	[699][15] = 926,
	[699][17] = 426,
	[699][18] = 427,
	[699][23] = 430,
	[700][7] = 417,
	[700][15] = 927,
	[700][17] = 426,
	[700][18] = 427,
	[700][23] = 430,
	[701][1] = 412,
	[701][5] = 928,
	[701][7] = 417,
	[701][15] = 424,
	[701][17] = 426,
	[701][18] = 427,
	[701][19] = 428,
	[701][20] = 429,
	[701][23] = 430,
	[702][1] = 412,
	[702][7] = 417,
	[702][15] = 424,
	[702][17] = 426,
	[702][18] = 427,
	[702][19] = 929,
	[702][20] = 429,
	[702][23] = 430,
	[703][1] = 412,
	[703][7] = 417,
	[703][15] = 424,
	[703][17] = 426,
	[703][18] = 427,
	[703][19] = 930,
	[703][20] = 429,
	[703][23] = 430,
	[704][1] = 412,
	[704][2] = 931,
	[704][5] = 415,
	[704][7] = 417,
	[704][15] = 424,
	[704][17] = 426,
	[704][18] = 427,
	[704][19] = 428,
	[704][20] = 429,
	[704][23] = 430,
	[705][17] = 426,
	[705][18] = 427,
	[705][23] = 932,
	[707][1] = 412,
	[707][2] = 413,
	[707][4] = 414,
	[707][5] = 415,
	[707][6] = 416,
	[707][7] = 417,
	[707][10] = 934,
	[707][11] = 420,
	[707][12] = 421,
	[707][13] = 422,
	[707][14] = 423,
	[707][15] = 424,
	[707][16] = 425,
	[707][17] = 426,
	[707][18] = 427,
	[707][19] = 428,
	[707][20] = 429,
	[707][23] = 430,
	[707][44] = 933,
	[708][1] = 412,
	[708][2] = 413,
	[708][5] = 415,
	[708][6] = 935,
	[708][7] = 417,
	[708][15] = 424,
	[708][17] = 426,
	[708][18] = 427,
	[708][19] = 428,
	[708][20] = 429,
	[708][23] = 430,
	[710][1] = 412,
	[710][2] = 413,
	[710][5] = 415,
	[710][6] = 416,
	[710][7] = 417,
	[710][11] = 937,
	[710][15] = 424,
	[710][17] = 426,
	[710][18] = 427,
	[710][19] = 428,
	[710][20] = 429,
	[710][23] = 430,
	[711][1] = 372,
	[711][2] = 373,
	[711][4] = 374,
	[711][5] = 375,
	[711][6] = 376,
	[711][7] = 377,
	[711][8] = 938,
	[711][10] = 379,
	[711][11] = 380,
	[711][12] = 381,
	[711][13] = 382,
	[711][14] = 383,
	[711][15] = 384,
	[711][16] = 385,
	[711][17] = 386,
	[711][18] = 387,
	[711][19] = 388,
	[711][20] = 389,
	[711][23] = 390,
	[712][1] = 412,
	[712][2] = 413,
	[712][5] = 415,
	[712][6] = 416,
	[712][7] = 417,
	[712][11] = 420,
	[712][13] = 939,
	[712][15] = 424,
	[712][17] = 426,
	[712][18] = 427,
	[712][19] = 428,
	[712][20] = 429,
	[712][23] = 430,
	[713][7] = 940,
	[713][17] = 426,
	[713][18] = 427,
	[713][23] = 430,
	[714][7] = 941,
	[714][17] = 426,
	[714][18] = 427,
	[714][23] = 430,
	[715][7] = 942,
	[715][17] = 426,
	[715][18] = 427,
	[715][23] = 430,
	[716][1] = 412,
	[716][2] = 413,
	[716][4] = 414,
	[716][5] = 415,
	[716][6] = 416,
	[716][7] = 417,
	[716][11] = 420,
	[716][12] = 421,
	[716][13] = 422,
	[716][14] = 423,
	[716][15] = 424,
	[716][16] = 944,
	[716][17] = 426,
	[716][18] = 427,
	[716][19] = 428,
	[716][20] = 429,
	[716][23] = 430,
	[716][45] = 943,
	[717][1] = 54,
	[717][2] = 55,
	[717][4] = 56,
	[717][5] = 57,
	[717][6] = 58,
	[717][7] = 59,
	[717][8] = 947,
	[717][10] = 61,
	[717][11] = 62,
	[717][12] = 63,
	[717][13] = 64,
	[717][14] = 65,
	[717][15] = 66,
	[717][16] = 67,
	[717][17] = 68,
	[717][18] = 69,
	[717][19] = 70,
	[717][20] = 71,
	[717][23] = 72,
	[718][1] = 412,
	[718][2] = 413,
	[718][4] = 414,
	[718][5] = 415,
	[718][6] = 416,
	[718][7] = 417,
	[718][8] = 948,
	[718][10] = 419,
	[718][11] = 420,
	[718][12] = 421,
	[718][13] = 422,
	[718][14] = 423,
	[718][15] = 424,
	[718][16] = 425,
	[718][17] = 426,
	[718][18] = 427,
	[718][19] = 428,
	[718][20] = 429,
	[718][23] = 430,
	[720][1] = 412,
	[720][7] = 417,
	[720][15] = 424,
	[720][17] = 426,
	[720][18] = 427,
	[720][20] = 950,
	[720][23] = 430,
	[721][1] = 412,
	[721][7] = 417,
	[721][15] = 424,
	[721][17] = 426,
	[721][18] = 427,
	[721][20] = 951,
	[721][23] = 430,
	[722][1] = 412,
	[722][7] = 417,
	[722][15] = 424,
	[722][17] = 426,
	[722][18] = 427,
	[722][20] = 952,
	[722][23] = 430,
	[723][1] = 412,
	[723][7] = 417,
	[723][15] = 424,
	[723][17] = 426,
	[723][18] = 427,
	[723][20] = 953,
	[723][23] = 430,
	[724][1] = 954,
	[724][7] = 417,
	[724][15] = 424,
	[724][17] = 426,
	[724][18] = 427,
	[724][23] = 430,
	[725][1] = 955,
	[725][7] = 417,
	[725][15] = 424,
	[725][17] = 426,
	[725][18] = 427,
	[725][23] = 430,
	[727][1] = 54,
	[727][2] = 55,
	[727][4] = 56,
	[727][5] = 57,
	[727][6] = 58,
	[727][7] = 59,
	[727][8] = 463,
	[727][10] = 61,
	[727][11] = 62,
	[727][12] = 63,
	[727][13] = 64,
	[727][14] = 65,
	[727][15] = 66,
	[727][16] = 67,
	[727][17] = 68,
	[727][18] = 69,
	[727][19] = 70,
	[727][20] = 71,
	[727][23] = 72,
	[727][35] = 956,
	[730][1] = 90,
	[730][2] = 91,
	[730][4] = 92,
	[730][5] = 93,
	[730][6] = 94,
	[730][7] = 95,
	[730][8] = 469,
	[730][10] = 97,
	[730][11] = 98,
	[730][12] = 99,
	[730][13] = 100,
	[730][14] = 101,
	[730][15] = 102,
	[730][16] = 103,
	[730][17] = 104,
	[730][18] = 105,
	[730][19] = 106,
	[730][20] = 107,
	[730][23] = 108,
	[730][36] = 957,
	[733][26] = 129,
	[733][27] = 320,
	[733][41] = 958,
	[733][42] = 473,
	[734][1] = 54,
	[734][2] = 55,
	[734][4] = 56,
	[734][5] = 57,
	[734][6] = 58,
	[734][7] = 59,
	[734][11] = 62,
	[734][12] = 475,
	[734][13] = 64,
	[734][14] = 65,
	[734][15] = 66,
	[734][17] = 68,
	[734][18] = 69,
	[734][19] = 70,
	[734][20] = 71,
	[734][23] = 72,
	[734][43] = 959,
	[735][26] = 129,
	[735][27] = 320,
	[735][41] = 960,
	[735][42] = 473,
	[736][1] = 54,
	[736][2] = 55,
	[736][4] = 56,
	[736][5] = 57,
	[736][6] = 58,
	[736][7] = 59,
	[736][11] = 62,
	[736][12] = 475,
	[736][13] = 64,
	[736][14] = 65,
	[736][15] = 66,
	[736][17] = 68,
	[736][18] = 69,
	[736][19] = 70,
	[736][20] = 71,
	[736][23] = 72,
	[736][43] = 961,
	[737][1] = 54,
	[737][2] = 55,
	[737][4] = 56,
	[737][5] = 57,
	[737][6] = 58,
	[737][7] = 59,
	[737][10] = 486,
	[737][11] = 62,
	[737][12] = 63,
	[737][13] = 64,
	[737][14] = 65,
	[737][15] = 66,
	[737][16] = 67,
	[737][17] = 68,
	[737][18] = 69,
	[737][19] = 70,
	[737][20] = 71,
	[737][23] = 72,
	[737][44] = 962,
	[738][1] = 54,
	[738][2] = 55,
	[738][4] = 963,
	[738][5] = 57,
	[738][6] = 58,
	[738][7] = 59,
	[738][11] = 62,
	[738][13] = 64,
	[738][14] = 65,
	[738][15] = 66,
	[738][17] = 68,
	[738][18] = 69,
	[738][19] = 70,
	[738][20] = 71,
	[738][23] = 72,
	[739][1] = 54,
	[739][2] = 55,
	[739][4] = 56,
	[739][5] = 57,
	[739][6] = 58,
	[739][7] = 59,
	[739][11] = 62,
	[739][12] = 63,
	[739][13] = 64,
	[739][14] = 65,
	[739][15] = 66,
	[739][16] = 496,
	[739][17] = 68,
	[739][18] = 69,
	[739][19] = 70,
	[739][20] = 71,
	[739][23] = 72,
	[739][45] = 964,
	[743][1] = 54,
	[743][2] = 55,
	[743][4] = 56,
	[743][5] = 57,
	[743][6] = 58,
	[743][7] = 59,
	[743][8] = 741,
	[743][10] = 61,
	[743][11] = 62,
	[743][12] = 63,
	[743][13] = 64,
	[743][14] = 65,
	[743][15] = 66,
	[743][16] = 67,
	[743][17] = 68,
	[743][18] = 69,
	[743][19] = 70,
	[743][20] = 71,
	[743][23] = 72,
	[743][60] = 967,
	[746][1] = 54,
	[746][2] = 55,
	[746][4] = 56,
	[746][5] = 57,
	[746][6] = 58,
	[746][7] = 59,
	[746][8] = 509,
	[746][10] = 61,
	[746][11] = 62,
	[746][12] = 63,
	[746][13] = 64,
	[746][14] = 65,
	[746][15] = 66,
	[746][16] = 67,
	[746][17] = 68,
	[746][18] = 69,
	[746][19] = 70,
	[746][20] = 71,
	[746][23] = 72,
	[746][35] = 968,
	[749][1] = 90,
	[749][2] = 91,
	[749][4] = 92,
	[749][5] = 93,
	[749][6] = 94,
	[749][7] = 95,
	[749][8] = 515,
	[749][10] = 97,
	[749][11] = 98,
	[749][12] = 99,
	[749][13] = 100,
	[749][14] = 101,
	[749][15] = 102,
	[749][16] = 103,
	[749][17] = 104,
	[749][18] = 105,
	[749][19] = 106,
	[749][20] = 107,
	[749][23] = 108,
	[749][36] = 969,
	[752][26] = 129,
	[752][27] = 320,
	[752][41] = 970,
	[752][42] = 519,
	[753][1] = 90,
	[753][2] = 91,
	[753][4] = 92,
	[753][5] = 93,
	[753][6] = 94,
	[753][7] = 95,
	[753][11] = 98,
	[753][12] = 521,
	[753][13] = 100,
	[753][14] = 101,
	[753][15] = 102,
	[753][17] = 104,
	[753][18] = 105,
	[753][19] = 106,
	[753][20] = 107,
	[753][23] = 108,
	[753][43] = 971,
	[754][26] = 129,
	[754][27] = 320,
	[754][41] = 972,
	[754][42] = 519,
	[755][1] = 90,
	[755][2] = 91,
	[755][4] = 92,
	[755][5] = 93,
	[755][6] = 94,
	[755][7] = 95,
	[755][11] = 98,
	[755][12] = 521,
	[755][13] = 100,
	[755][14] = 101,
	[755][15] = 102,
	[755][17] = 104,
	[755][18] = 105,
	[755][19] = 106,
	[755][20] = 107,
	[755][23] = 108,
	[755][43] = 973,
	[756][1] = 90,
	[756][2] = 91,
	[756][4] = 92,
	[756][5] = 93,
	[756][6] = 94,
	[756][7] = 95,
	[756][10] = 532,
	[756][11] = 98,
	[756][12] = 99,
	[756][13] = 100,
	[756][14] = 101,
	[756][15] = 102,
	[756][16] = 103,
	[756][17] = 104,
	[756][18] = 105,
	[756][19] = 106,
	[756][20] = 107,
	[756][23] = 108,
	[756][44] = 974,
	[757][1] = 90,
	[757][2] = 91,
	[757][4] = 975,
	[757][5] = 93,
	[757][6] = 94,
	[757][7] = 95,
	[757][11] = 98,
	[757][13] = 100,
	[757][14] = 101,
	[757][15] = 102,
	[757][17] = 104,
	[757][18] = 105,
	[757][19] = 106,
	[757][20] = 107,
	[757][23] = 108,
	[758][1] = 90,
	[758][2] = 91,
	[758][4] = 92,
	[758][5] = 93,
	[758][6] = 94,
	[758][7] = 95,
	[758][11] = 98,
	[758][12] = 99,
	[758][13] = 100,
	[758][14] = 101,
	[758][15] = 102,
	[758][16] = 542,
	[758][17] = 104,
	[758][18] = 105,
	[758][19] = 106,
	[758][20] = 107,
	[758][23] = 108,
	[758][45] = 976,
	[762][1] = 54,
	[762][2] = 55,
	[762][4] = 56,
	[762][5] = 57,
	[762][6] = 58,
	[762][7] = 59,
	[762][8] = 760,
	[762][10] = 61,
	[762][11] = 62,
	[762][12] = 63,
	[762][13] = 64,
	[762][14] = 65,
	[762][15] = 66,
	[762][16] = 67,
	[762][17] = 68,
	[762][18] = 69,
	[762][19] = 70,
	[762][20] = 71,
	[762][23] = 72,
	[762][60] = 979,
	[764][61] = 980,
	[766][62] = 981,
	[768][61] = 983,
	[769][62] = 985,
	[771][63] = 988,
	[773][64] = 991,
	[779][38] = 564,
	[779][39] = 995,
	[779][40] = 566,
	[779][65] = 994,
	[780][38] = 564,
	[780][40] = 997,
	[780][66] = 996,
	[781][63] = 998,
	[785][46] = 999,
	[785][47] = 788,
	[785][48] = 789,
	[785][49] = 790,
	[785][50] = 791,
	[785][51] = 792,
	[786][47] = 1000,
	[792][47] = 788,
	[792][48] = 789,
	[792][49] = 790,
	[792][50] = 791,
	[792][51] = 1007,
	[795][47] = 573,
	[795][48] = 1010,
	[795][49] = 575,
	[795][50] = 576,
	[795][67] = 1009,
	[796][47] = 1015,
	[796][49] = 1016,
	[797][47] = 573,
	[797][49] = 575,
	[797][50] = 1018,
	[797][68] = 1017,
	[798][47] = 573,
	[798][48] = 574,
	[798][49] = 575,
	[798][50] = 576,
	[798][51] = 1020,
	[798][69] = 1019,
	[799][47] = 573,
	[799][48] = 574,
	[799][49] = 575,
	[799][50] = 576,
	[799][51] = 1022,
	[799][70] = 1021,
	[800][47] = 573,
	[800][48] = 574,
	[800][49] = 575,
	[800][50] = 576,
	[800][51] = 1026,
	[800][71] = 1025,
	[801][64] = 1027,
	[805][52] = 1028,
	[805][53] = 809,
	[805][54] = 810,
	[805][55] = 811,
	[807][46] = 1029,
	[807][47] = 573,
	[807][48] = 574,
	[807][49] = 575,
	[807][50] = 576,
	[807][51] = 577,
	[811][53] = 809,
	[811][55] = 1035,
	[817][53] = 585,
	[817][54] = 1039,
	[817][55] = 587,
	[817][72] = 1038,
	[818][53] = 585,
	[818][55] = 1041,
	[818][73] = 1040,
	[822][38] = 295,
	[822][40] = 822,
	[822][66] = 1043,
	[829][53] = 602,
	[829][54] = 1047,
	[829][55] = 604,
	[829][72] = 1046,
	[830][53] = 602,
	[830][55] = 1049,
	[830][73] = 1048,
	[836][26] = 315,
	[836][27] = 834,
	[836][57] = 1052,
	[838][26] = 315,
	[838][27] = 615,
	[838][57] = 1053,
	[843][26] = 332,
	[843][27] = 840,
	[843][58] = 1056,
	[844][26] = 315,
	[844][27] = 842,
	[844][59] = 1057,
	[851][26] = 315,
	[851][27] = 849,
	[851][57] = 1060,
	[852][26] = 332,
	[852][27] = 629,
	[852][58] = 1061,
	[853][26] = 129,
	[853][27] = 631,
	[853][59] = 1062,
	[858][26] = 332,
	[858][27] = 855,
	[858][58] = 1065,
	[859][26] = 332,
	[859][27] = 857,
	[859][59] = 1066,
	[868][1] = 54,
	[868][2] = 55,
	[868][4] = 56,
	[868][5] = 57,
	[868][6] = 58,
	[868][7] = 59,
	[868][8] = 866,
	[868][10] = 61,
	[868][11] = 62,
	[868][12] = 63,
	[868][13] = 64,
	[868][14] = 65,
	[868][15] = 66,
	[868][16] = 67,
	[868][17] = 68,
	[868][18] = 69,
	[868][19] = 70,
	[868][20] = 71,
	[868][23] = 72,
	[868][35] = 1069,
	[871][1] = 90,
	[871][2] = 91,
	[871][4] = 92,
	[871][5] = 93,
	[871][6] = 94,
	[871][7] = 95,
	[871][8] = 870,
	[871][10] = 97,
	[871][11] = 98,
	[871][12] = 99,
	[871][13] = 100,
	[871][14] = 101,
	[871][15] = 102,
	[871][16] = 103,
	[871][17] = 104,
	[871][18] = 105,
	[871][19] = 106,
	[871][20] = 107,
	[871][23] = 108,
	[871][36] = 1072,
	[899][1] = 54,
	[899][2] = 55,
	[899][4] = 56,
	[899][5] = 57,
	[899][6] = 58,
	[899][7] = 59,
	[899][8] = 1081,
	[899][10] = 61,
	[899][11] = 62,
	[899][12] = 63,
	[899][13] = 64,
	[899][14] = 65,
	[899][15] = 66,
	[899][16] = 67,
	[899][17] = 68,
	[899][18] = 69,
	[899][19] = 70,
	[899][20] = 71,
	[899][23] = 72,
	[899][60] = 1080,
	[911][1] = 54,
	[911][2] = 55,
	[911][4] = 56,
	[911][5] = 57,
	[911][6] = 58,
	[911][7] = 59,
	[911][8] = 683,
	[911][10] = 61,
	[911][11] = 62,
	[911][12] = 63,
	[911][13] = 64,
	[911][14] = 65,
	[911][15] = 66,
	[911][16] = 67,
	[911][17] = 68,
	[911][18] = 69,
	[911][19] = 70,
	[911][20] = 71,
	[911][23] = 72,
	[911][60] = 1085,
	[916][1] = 54,
	[916][2] = 55,
	[916][4] = 56,
	[916][5] = 57,
	[916][6] = 58,
	[916][7] = 59,
	[916][8] = 914,
	[916][10] = 61,
	[916][11] = 62,
	[916][12] = 63,
	[916][13] = 64,
	[916][14] = 65,
	[916][15] = 66,
	[916][16] = 67,
	[916][17] = 68,
	[916][18] = 69,
	[916][19] = 70,
	[916][20] = 71,
	[916][23] = 72,
	[916][35] = 1088,
	[919][1] = 90,
	[919][2] = 91,
	[919][4] = 92,
	[919][5] = 93,
	[919][6] = 94,
	[919][7] = 95,
	[919][8] = 918,
	[919][10] = 97,
	[919][11] = 98,
	[919][12] = 99,
	[919][13] = 100,
	[919][14] = 101,
	[919][15] = 102,
	[919][16] = 103,
	[919][17] = 104,
	[919][18] = 105,
	[919][19] = 106,
	[919][20] = 107,
	[919][23] = 108,
	[919][36] = 1091,
	[946][1] = 54,
	[946][2] = 55,
	[946][4] = 56,
	[946][5] = 57,
	[946][6] = 58,
	[946][7] = 59,
	[946][8] = 1100,
	[946][10] = 61,
	[946][11] = 62,
	[946][12] = 63,
	[946][13] = 64,
	[946][14] = 65,
	[946][15] = 66,
	[946][16] = 67,
	[946][17] = 68,
	[946][18] = 69,
	[946][19] = 70,
	[946][20] = 71,
	[946][23] = 72,
	[946][60] = 1099,
	[966][1] = 54,
	[966][2] = 55,
	[966][4] = 56,
	[966][5] = 57,
	[966][6] = 58,
	[966][7] = 59,
	[966][8] = 741,
	[966][10] = 61,
	[966][11] = 62,
	[966][12] = 63,
	[966][13] = 64,
	[966][14] = 65,
	[966][15] = 66,
	[966][16] = 67,
	[966][17] = 68,
	[966][18] = 69,
	[966][19] = 70,
	[966][20] = 71,
	[966][23] = 72,
	[966][60] = 1104,
	[978][1] = 54,
	[978][2] = 55,
	[978][4] = 56,
	[978][5] = 57,
	[978][6] = 58,
	[978][7] = 59,
	[978][8] = 760,
	[978][10] = 61,
	[978][11] = 62,
	[978][12] = 63,
	[978][13] = 64,
	[978][14] = 65,
	[978][15] = 66,
	[978][16] = 67,
	[978][17] = 68,
	[978][18] = 69,
	[978][19] = 70,
	[978][20] = 71,
	[978][23] = 72,
	[978][60] = 1105,
	[982][61] = 1106,
	[984][62] = 1107,
	[987][63] = 1109,
	[990][64] = 1111,
	[993][61] = 1113,
	[997][38] = 564,
	[997][40] = 997,
	[997][66] = 1115,
	[1002][47] = 788,
	[1002][48] = 1118,
	[1002][49] = 790,
	[1002][50] = 791,
	[1002][67] = 1117,
	[1003][47] = 1123,
	[1003][49] = 1124,
	[1004][47] = 788,
	[1004][49] = 790,
	[1004][50] = 1126,
	[1004][68] = 1125,
	[1005][47] = 788,
	[1005][48] = 789,
	[1005][49] = 790,
	[1005][50] = 791,
	[1005][51] = 1128,
	[1005][69] = 1127,
	[1006][47] = 788,
	[1006][48] = 789,
	[1006][49] = 790,
	[1006][50] = 791,
	[1006][51] = 1130,
	[1006][70] = 1129,
	[1007][47] = 788,
	[1007][48] = 789,
	[1007][49] = 790,
	[1007][50] = 791,
	[1007][51] = 1134,
	[1007][71] = 1133,
	[1008][74] = 1136,
	[1013][46] = 1138,
	[1013][47] = 788,
	[1013][48] = 789,
	[1013][49] = 790,
	[1013][50] = 791,
	[1013][51] = 792,
	[1014][47] = 1139,
	[1020][47] = 573,
	[1020][48] = 574,
	[1020][49] = 575,
	[1020][50] = 576,
	[1020][51] = 1026,
	[1020][71] = 1141,
	[1022][47] = 573,
	[1022][48] = 574,
	[1022][49] = 575,
	[1022][50] = 576,
	[1022][51] = 1026,
	[1022][71] = 1142,
	[1023][47] = 573,
	[1023][48] = 574,
	[1023][49] = 575,
	[1023][50] = 576,
	[1023][51] = 1020,
	[1023][69] = 1143,
	[1024][47] = 573,
	[1024][48] = 574,
	[1024][49] = 575,
	[1024][50] = 576,
	[1024][51] = 1022,
	[1024][70] = 1144,
	[1026][47] = 573,
	[1026][48] = 574,
	[1026][49] = 575,
	[1026][50] = 576,
	[1026][51] = 1026,
	[1026][71] = 1145,
	[1034][53] = 809,
	[1034][54] = 1149,
	[1034][55] = 811,
	[1034][72] = 1148,
	[1035][53] = 809,
	[1035][55] = 1151,
	[1035][73] = 1150,
	[1037][75] = 1153,
	[1041][53] = 585,
	[1041][55] = 1041,
	[1041][73] = 1155,
	[1042][38] = 295,
	[1042][39] = 820,
	[1042][40] = 297,
	[1042][65] = 1156,
	[1049][53] = 602,
	[1049][55] = 1049,
	[1049][73] = 1158,
	[1051][26] = 315,
	[1051][27] = 834,
	[1051][57] = 1159,
	[1054][26] = 332,
	[1054][27] = 840,
	[1054][58] = 1160,
	[1055][26] = 315,
	[1055][27] = 842,
	[1055][59] = 1161,
	[1059][26] = 315,
	[1059][27] = 849,
	[1059][57] = 1162,
	[1063][26] = 332,
	[1063][27] = 855,
	[1063][58] = 1163,
	[1064][26] = 332,
	[1064][27] = 857,
	[1064][59] = 1164,
	[1068][1] = 54,
	[1068][2] = 55,
	[1068][4] = 56,
	[1068][5] = 57,
	[1068][6] = 58,
	[1068][7] = 59,
	[1068][8] = 866,
	[1068][10] = 61,
	[1068][11] = 62,
	[1068][12] = 63,
	[1068][13] = 64,
	[1068][14] = 65,
	[1068][15] = 66,
	[1068][16] = 67,
	[1068][17] = 68,
	[1068][18] = 69,
	[1068][19] = 70,
	[1068][20] = 71,
	[1068][23] = 72,
	[1068][35] = 1165,
	[1070][1] = 90,
	[1070][2] = 91,
	[1070][4] = 92,
	[1070][5] = 93,
	[1070][6] = 94,
	[1070][7] = 95,
	[1070][8] = 870,
	[1070][10] = 97,
	[1070][11] = 98,
	[1070][12] = 99,
	[1070][13] = 100,
	[1070][14] = 101,
	[1070][15] = 102,
	[1070][16] = 103,
	[1070][17] = 104,
	[1070][18] = 105,
	[1070][19] = 106,
	[1070][20] = 107,
	[1070][23] = 108,
	[1070][36] = 1166,
	[1073][26] = 129,
	[1073][27] = 320,
	[1073][41] = 1167,
	[1073][42] = 874,
	[1074][1] = 372,
	[1074][2] = 373,
	[1074][4] = 374,
	[1074][5] = 375,
	[1074][6] = 376,
	[1074][7] = 377,
	[1074][11] = 380,
	[1074][12] = 876,
	[1074][13] = 382,
	[1074][14] = 383,
	[1074][15] = 384,
	[1074][17] = 386,
	[1074][18] = 387,
	[1074][19] = 388,
	[1074][20] = 389,
	[1074][23] = 390,
	[1074][43] = 1168,
	[1075][26] = 129,
	[1075][27] = 320,
	[1075][41] = 1169,
	[1075][42] = 874,
	[1076][1] = 372,
	[1076][2] = 373,
	[1076][4] = 374,
	[1076][5] = 375,
	[1076][6] = 376,
	[1076][7] = 377,
	[1076][11] = 380,
	[1076][12] = 876,
	[1076][13] = 382,
	[1076][14] = 383,
	[1076][15] = 384,
	[1076][17] = 386,
	[1076][18] = 387,
	[1076][19] = 388,
	[1076][20] = 389,
	[1076][23] = 390,
	[1076][43] = 1170,
	[1077][1] = 372,
	[1077][2] = 373,
	[1077][4] = 374,
	[1077][5] = 375,
	[1077][6] = 376,
	[1077][7] = 377,
	[1077][10] = 887,
	[1077][11] = 380,
	[1077][12] = 381,
	[1077][13] = 382,
	[1077][14] = 383,
	[1077][15] = 384,
	[1077][16] = 385,
	[1077][17] = 386,
	[1077][18] = 387,
	[1077][19] = 388,
	[1077][20] = 389,
	[1077][23] = 390,
	[1077][44] = 1171,
	[1078][1] = 372,
	[1078][2] = 373,
	[1078][4] = 1172,
	[1078][5] = 375,
	[1078][6] = 376,
	[1078][7] = 377,
	[1078][11] = 380,
	[1078][13] = 382,
	[1078][14] = 383,
	[1078][15] = 384,
	[1078][17] = 386,
	[1078][18] = 387,
	[1078][19] = 388,
	[1078][20] = 389,
	[1078][23] = 390,
	[1079][1] = 372,
	[1079][2] = 373,
	[1079][4] = 374,
	[1079][5] = 375,
	[1079][6] = 376,
	[1079][7] = 377,
	[1079][11] = 380,
	[1079][12] = 381,
	[1079][13] = 382,
	[1079][14] = 383,
	[1079][15] = 384,
	[1079][16] = 897,
	[1079][17] = 386,
	[1079][18] = 387,
	[1079][19] = 388,
	[1079][20] = 389,
	[1079][23] = 390,
	[1079][45] = 1173,
	[1083][1] = 54,
	[1083][2] = 55,
	[1083][4] = 56,
	[1083][5] = 57,
	[1083][6] = 58,
	[1083][7] = 59,
	[1083][8] = 1081,
	[1083][10] = 61,
	[1083][11] = 62,
	[1083][12] = 63,
	[1083][13] = 64,
	[1083][14] = 65,
	[1083][15] = 66,
	[1083][16] = 67,
	[1083][17] = 68,
	[1083][18] = 69,
	[1083][19] = 70,
	[1083][20] = 71,
	[1083][23] = 72,
	[1083][60] = 1176,
	[1087][1] = 54,
	[1087][2] = 55,
	[1087][4] = 56,
	[1087][5] = 57,
	[1087][6] = 58,
	[1087][7] = 59,
	[1087][8] = 914,
	[1087][10] = 61,
	[1087][11] = 62,
	[1087][12] = 63,
	[1087][13] = 64,
	[1087][14] = 65,
	[1087][15] = 66,
	[1087][16] = 67,
	[1087][17] = 68,
	[1087][18] = 69,
	[1087][19] = 70,
	[1087][20] = 71,
	[1087][23] = 72,
	[1087][35] = 1177,
	[1089][1] = 90,
	[1089][2] = 91,
	[1089][4] = 92,
	[1089][5] = 93,
	[1089][6] = 94,
	[1089][7] = 95,
	[1089][8] = 918,
	[1089][10] = 97,
	[1089][11] = 98,
	[1089][12] = 99,
	[1089][13] = 100,
	[1089][14] = 101,
	[1089][15] = 102,
	[1089][16] = 103,
	[1089][17] = 104,
	[1089][18] = 105,
	[1089][19] = 106,
	[1089][20] = 107,
	[1089][23] = 108,
	[1089][36] = 1178,
	[1092][26] = 129,
	[1092][27] = 320,
	[1092][41] = 1179,
	[1092][42] = 922,
	[1093][1] = 412,
	[1093][2] = 413,
	[1093][4] = 414,
	[1093][5] = 415,
	[1093][6] = 416,
	[1093][7] = 417,
	[1093][11] = 420,
	[1093][12] = 924,
	[1093][13] = 422,
	[1093][14] = 423,
	[1093][15] = 424,
	[1093][17] = 426,
	[1093][18] = 427,
	[1093][19] = 428,
	[1093][20] = 429,
	[1093][23] = 430,
	[1093][43] = 1180,
	[1094][26] = 129,
	[1094][27] = 320,
	[1094][41] = 1181,
	[1094][42] = 922,
	[1095][1] = 412,
	[1095][2] = 413,
	[1095][4] = 414,
	[1095][5] = 415,
	[1095][6] = 416,
	[1095][7] = 417,
	[1095][11] = 420,
	[1095][12] = 924,
	[1095][13] = 422,
	[1095][14] = 423,
	[1095][15] = 424,
	[1095][17] = 426,
	[1095][18] = 427,
	[1095][19] = 428,
	[1095][20] = 429,
	[1095][23] = 430,
	[1095][43] = 1182,
	[1096][1] = 412,
	[1096][2] = 413,
	[1096][4] = 414,
	[1096][5] = 415,
	[1096][6] = 416,
	[1096][7] = 417,
	[1096][10] = 934,
	[1096][11] = 420,
	[1096][12] = 421,
	[1096][13] = 422,
	[1096][14] = 423,
	[1096][15] = 424,
	[1096][16] = 425,
	[1096][17] = 426,
	[1096][18] = 427,
	[1096][19] = 428,
	[1096][20] = 429,
	[1096][23] = 430,
	[1096][44] = 1183,
	[1097][1] = 412,
	[1097][2] = 413,
	[1097][4] = 1184,
	[1097][5] = 415,
	[1097][6] = 416,
	[1097][7] = 417,
	[1097][11] = 420,
	[1097][13] = 422,
	[1097][14] = 423,
	[1097][15] = 424,
	[1097][17] = 426,
	[1097][18] = 427,
	[1097][19] = 428,
	[1097][20] = 429,
	[1097][23] = 430,
	[1098][1] = 412,
	[1098][2] = 413,
	[1098][4] = 414,
	[1098][5] = 415,
	[1098][6] = 416,
	[1098][7] = 417,
	[1098][11] = 420,
	[1098][12] = 421,
	[1098][13] = 422,
	[1098][14] = 423,
	[1098][15] = 424,
	[1098][16] = 944,
	[1098][17] = 426,
	[1098][18] = 427,
	[1098][19] = 428,
	[1098][20] = 429,
	[1098][23] = 430,
	[1098][45] = 1185,
	[1102][1] = 54,
	[1102][2] = 55,
	[1102][4] = 56,
	[1102][5] = 57,
	[1102][6] = 58,
	[1102][7] = 59,
	[1102][8] = 1100,
	[1102][10] = 61,
	[1102][11] = 62,
	[1102][12] = 63,
	[1102][13] = 64,
	[1102][14] = 65,
	[1102][15] = 66,
	[1102][16] = 67,
	[1102][17] = 68,
	[1102][18] = 69,
	[1102][19] = 70,
	[1102][20] = 71,
	[1102][23] = 72,
	[1102][60] = 1188,
	[1108][61] = 1189,
	[1110][74] = 1191,
	[1112][75] = 1193,
	[1114][38] = 564,
	[1114][39] = 995,
	[1114][40] = 566,
	[1114][65] = 1194,
	[1121][46] = 1196,
	[1121][47] = 788,
	[1121][48] = 789,
	[1121][49] = 790,
	[1121][50] = 791,
	[1121][51] = 792,
	[1122][47] = 1197,
	[1128][47] = 788,
	[1128][48] = 789,
	[1128][49] = 790,
	[1128][50] = 791,
	[1128][51] = 1134,
	[1128][71] = 1199,
	[1130][47] = 788,
	[1130][48] = 789,
	[1130][49] = 790,
	[1130][50] = 791,
	[1130][51] = 1134,
	[1130][71] = 1200,
	[1131][47] = 788,
	[1131][48] = 789,
	[1131][49] = 790,
	[1131][50] = 791,
	[1131][51] = 1128,
	[1131][69] = 1201,
	[1132][47] = 788,
	[1132][48] = 789,
	[1132][49] = 790,
	[1132][50] = 791,
	[1132][51] = 1130,
	[1132][70] = 1202,
	[1134][47] = 788,
	[1134][48] = 789,
	[1134][49] = 790,
	[1134][50] = 791,
	[1134][51] = 1134,
	[1134][71] = 1203,
	[1135][74] = 1204,
	[1137][47] = 573,
	[1137][48] = 1010,
	[1137][49] = 575,
	[1137][50] = 576,
	[1137][67] = 1205,
	[1140][47] = 573,
	[1140][49] = 575,
	[1140][50] = 1018,
	[1140][68] = 1207,
	[1151][53] = 809,
	[1151][55] = 1151,
	[1151][73] = 1209,
	[1152][75] = 1210,
	[1154][53] = 585,
	[1154][54] = 1039,
	[1154][55] = 587,
	[1154][72] = 1211,
	[1157][53] = 602,
	[1157][54] = 1047,
	[1157][55] = 604,
	[1157][72] = 1212,
	[1175][1] = 54,
	[1175][2] = 55,
	[1175][4] = 56,
	[1175][5] = 57,
	[1175][6] = 58,
	[1175][7] = 59,
	[1175][8] = 1081,
	[1175][10] = 61,
	[1175][11] = 62,
	[1175][12] = 63,
	[1175][13] = 64,
	[1175][14] = 65,
	[1175][15] = 66,
	[1175][16] = 67,
	[1175][17] = 68,
	[1175][18] = 69,
	[1175][19] = 70,
	[1175][20] = 71,
	[1175][23] = 72,
	[1175][60] = 1213,
	[1187][1] = 54,
	[1187][2] = 55,
	[1187][4] = 56,
	[1187][5] = 57,
	[1187][6] = 58,
	[1187][7] = 59,
	[1187][8] = 1100,
	[1187][10] = 61,
	[1187][11] = 62,
	[1187][12] = 63,
	[1187][13] = 64,
	[1187][14] = 65,
	[1187][15] = 66,
	[1187][16] = 67,
	[1187][17] = 68,
	[1187][18] = 69,
	[1187][19] = 70,
	[1187][20] = 71,
	[1187][23] = 72,
	[1187][60] = 1214,
	[1190][74] = 1215,
	[1192][75] = 1216,
	[1195][47] = 788,
	[1195][48] = 1118,
	[1195][49] = 790,
	[1195][50] = 791,
	[1195][67] = 1217,
	[1198][47] = 788,
	[1198][49] = 790,
	[1198][50] = 1126,
	[1198][68] = 1219,
	[1208][53] = 809,
	[1208][54] = 1149,
	[1208][55] = 811,
	[1208][72] = 1220,
};


const unsigned zebu_lexer[257][256] = {
	[1][9] = 129,
	[1][10] = 129,
	[1][32] = 129,
	[1][33] = 130,
	[1][34] = 131,
	[1][36] = 132,
	[1][37] = 133,
	[1][39] = 134,
	[1][40] = 135,
	[1][43] = 136,
	[1][45] = 137,
	[1][47] = 138,
	[1][48] = 139,
	[1][49] = 140,
	[1][50] = 140,
	[1][51] = 140,
	[1][52] = 140,
	[1][53] = 140,
	[1][54] = 140,
	[1][55] = 140,
	[1][56] = 140,
	[1][57] = 140,
	[1][91] = 141,
	[1][97] = 142,
	[1][98] = 142,
	[1][99] = 142,
	[1][100] = 142,
	[1][101] = 142,
	[1][102] = 142,
	[1][103] = 142,
	[1][104] = 142,
	[1][105] = 142,
	[1][106] = 142,
	[1][107] = 142,
	[1][108] = 142,
	[1][109] = 142,
	[1][110] = 142,
	[1][111] = 142,
	[1][112] = 142,
	[1][113] = 142,
	[1][114] = 142,
	[1][115] = 142,
	[1][116] = 142,
	[1][117] = 142,
	[1][118] = 142,
	[1][119] = 142,
	[1][120] = 142,
	[1][121] = 142,
	[1][122] = 142,
	[1][126] = 143,
	[2][9] = 129,
	[2][10] = 129,
	[2][32] = 129,
	[2][33] = 144,
	[2][37] = 133,
	[2][38] = 145,
	[2][40] = 135,
	[2][42] = 146,
	[2][43] = 136,
	[2][45] = 137,
	[2][46] = 147,
	[2][47] = 148,
	[2][59] = 149,
	[2][60] = 150,
	[2][61] = 151,
	[2][62] = 152,
	[2][63] = 153,
	[2][91] = 141,
	[2][94] = 154,
	[2][104] = 155,
	[2][105] = 156,
	[2][124] = 157,
	[3][9] = 129,
	[3][10] = 129,
	[3][32] = 129,
	[3][33] = 130,
	[3][34] = 131,
	[3][36] = 132,
	[3][39] = 134,
	[3][40] = 135,
	[3][41] = 158,
	[3][43] = 136,
	[3][44] = 159,
	[3][45] = 137,
	[3][47] = 138,
	[3][48] = 139,
	[3][49] = 140,
	[3][50] = 140,
	[3][51] = 140,
	[3][52] = 140,
	[3][53] = 140,
	[3][54] = 140,
	[3][55] = 140,
	[3][56] = 140,
	[3][57] = 140,
	[3][91] = 141,
	[3][97] = 142,
	[3][98] = 142,
	[3][99] = 142,
	[3][100] = 142,
	[3][101] = 142,
	[3][102] = 142,
	[3][103] = 142,
	[3][104] = 142,
	[3][105] = 142,
	[3][106] = 142,
	[3][107] = 142,
	[3][108] = 142,
	[3][109] = 142,
	[3][110] = 142,
	[3][111] = 142,
	[3][112] = 142,
	[3][113] = 142,
	[3][114] = 142,
	[3][115] = 142,
	[3][116] = 142,
	[3][117] = 142,
	[3][118] = 142,
	[3][119] = 142,
	[3][120] = 142,
	[3][121] = 142,
	[3][122] = 142,
	[3][126] = 143,
	[4][9] = 129,
	[4][10] = 129,
	[4][32] = 129,
	[4][33] = 130,
	[4][34] = 131,
	[4][39] = 134,
	[4][40] = 135,
	[4][43] = 136,
	[4][45] = 137,
	[4][47] = 138,
	[4][48] = 139,
	[4][49] = 140,
	[4][50] = 140,
	[4][51] = 140,
	[4][52] = 140,
	[4][53] = 140,
	[4][54] = 140,
	[4][55] = 140,
	[4][56] = 140,
	[4][57] = 140,
	[4][91] = 141,
	[4][97] = 142,
	[4][98] = 142,
	[4][99] = 142,
	[4][100] = 142,
	[4][101] = 142,
	[4][102] = 142,
	[4][103] = 142,
	[4][104] = 142,
	[4][105] = 142,
	[4][106] = 142,
	[4][107] = 142,
	[4][108] = 142,
	[4][109] = 142,
	[4][110] = 142,
	[4][111] = 142,
	[4][112] = 142,
	[4][113] = 142,
	[4][114] = 142,
	[4][115] = 142,
	[4][116] = 142,
	[4][117] = 142,
	[4][118] = 142,
	[4][119] = 142,
	[4][120] = 142,
	[4][121] = 142,
	[4][122] = 142,
	[4][126] = 143,
	[5][9] = 129,
	[5][10] = 129,
	[5][32] = 129,
	[5][33] = 130,
	[5][34] = 131,
	[5][36] = 132,
	[5][39] = 134,
	[5][40] = 135,
	[5][43] = 136,
	[5][44] = 159,
	[5][45] = 137,
	[5][47] = 138,
	[5][48] = 139,
	[5][49] = 140,
	[5][50] = 140,
	[5][51] = 140,
	[5][52] = 140,
	[5][53] = 140,
	[5][54] = 140,
	[5][55] = 140,
	[5][56] = 140,
	[5][57] = 140,
	[5][91] = 141,
	[5][93] = 160,
	[5][97] = 142,
	[5][98] = 142,
	[5][99] = 142,
	[5][100] = 142,
	[5][101] = 142,
	[5][102] = 142,
	[5][103] = 142,
	[5][104] = 142,
	[5][105] = 142,
	[5][106] = 142,
	[5][107] = 142,
	[5][108] = 142,
	[5][109] = 142,
	[5][110] = 142,
	[5][111] = 142,
	[5][112] = 142,
	[5][113] = 142,
	[5][114] = 142,
	[5][115] = 142,
	[5][116] = 142,
	[5][117] = 142,
	[5][118] = 142,
	[5][119] = 142,
	[5][120] = 142,
	[5][121] = 142,
	[5][122] = 142,
	[5][126] = 143,
	[6][9] = 129,
	[6][10] = 129,
	[6][32] = 129,
	[6][33] = 144,
	[6][37] = 133,
	[6][38] = 145,
	[6][40] = 135,
	[6][42] = 146,
	[6][43] = 136,
	[6][45] = 137,
	[6][46] = 147,
	[6][47] = 148,
	[6][58] = 161,
	[6][59] = 149,
	[6][60] = 150,
	[6][61] = 162,
	[6][62] = 152,
	[6][63] = 153,
	[6][91] = 141,
	[6][94] = 154,
	[6][104] = 155,
	[6][105] = 156,
	[6][124] = 157,
	[7][9] = 129,
	[7][10] = 129,
	[7][32] = 129,
	[7][47] = 138,
	[7][100] = 163,
	[7][101] = 164,
	[7][110] = 165,
	[7][115] = 166,
	[7][117] = 167,
	[7][119] = 168,
	[8][9] = 129,
	[8][10] = 129,
	[8][32] = 129,
	[8][36] = 132,
	[8][40] = 135,
	[8][44] = 159,
	[8][47] = 138,
	[8][58] = 161,
	[8][97] = 142,
	[8][98] = 169,
	[8][99] = 170,
	[8][100] = 142,
	[8][101] = 142,
	[8][102] = 171,
	[8][103] = 142,
	[8][104] = 142,
	[8][105] = 172,
	[8][106] = 142,
	[8][107] = 142,
	[8][108] = 142,
	[8][109] = 142,
	[8][110] = 142,
	[8][111] = 142,
	[8][112] = 142,
	[8][113] = 142,
	[8][114] = 142,
	[8][115] = 142,
	[8][116] = 142,
	[8][117] = 142,
	[8][118] = 142,
	[8][119] = 142,
	[8][120] = 142,
	[8][121] = 142,
	[8][122] = 142,
	[9][9] = 129,
	[9][10] = 129,
	[9][32] = 129,
	[9][33] = 144,
	[9][38] = 145,
	[9][43] = 136,
	[9][45] = 137,
	[9][47] = 138,
	[9][59] = 149,
	[9][60] = 150,
	[9][61] = 151,
	[9][62] = 152,
	[9][63] = 153,
	[9][94] = 154,
	[9][104] = 155,
	[9][105] = 156,
	[9][124] = 157,
	[10][9] = 129,
	[10][10] = 129,
	[10][32] = 129,
	[10][38] = 145,
	[10][47] = 138,
	[10][59] = 149,
	[10][63] = 153,
	[10][94] = 154,
	[10][104] = 155,
	[10][105] = 156,
	[10][124] = 157,
	[11][9] = 129,
	[11][10] = 129,
	[11][32] = 129,
	[11][33] = 130,
	[11][34] = 131,
	[11][36] = 132,
	[11][37] = 133,
	[11][39] = 134,
	[11][40] = 135,
	[11][43] = 136,
	[11][45] = 137,
	[11][47] = 138,
	[11][48] = 139,
	[11][49] = 140,
	[11][50] = 140,
	[11][51] = 140,
	[11][52] = 140,
	[11][53] = 140,
	[11][54] = 140,
	[11][55] = 140,
	[11][56] = 140,
	[11][57] = 140,
	[11][91] = 141,
	[11][97] = 142,
	[11][98] = 142,
	[11][99] = 142,
	[11][100] = 142,
	[11][101] = 142,
	[11][102] = 142,
	[11][103] = 142,
	[11][104] = 142,
	[11][105] = 142,
	[11][106] = 142,
	[11][107] = 142,
	[11][108] = 142,
	[11][109] = 142,
	[11][110] = 142,
	[11][111] = 142,
	[11][112] = 142,
	[11][113] = 142,
	[11][114] = 142,
	[11][115] = 142,
	[11][116] = 142,
	[11][117] = 142,
	[11][118] = 142,
	[11][119] = 142,
	[11][120] = 142,
	[11][121] = 142,
	[11][122] = 142,
	[11][126] = 143,
	[12][9] = 129,
	[12][10] = 129,
	[12][32] = 129,
	[12][47] = 138,
	[12][59] = 149,
	[12][104] = 155,
	[12][105] = 156,
	[13][9] = 129,
	[13][10] = 129,
	[13][32] = 129,
	[13][33] = 144,
	[13][38] = 145,
	[13][47] = 138,
	[13][59] = 149,
	[13][61] = 151,
	[13][63] = 153,
	[13][94] = 154,
	[13][104] = 155,
	[13][105] = 156,
	[13][124] = 157,
	[14][9] = 129,
	[14][10] = 129,
	[14][32] = 129,
	[14][38] = 174,
	[14][47] = 138,
	[14][59] = 149,
	[14][63] = 153,
	[14][94] = 154,
	[14][104] = 155,
	[14][105] = 156,
	[14][124] = 157,
	[15][9] = 129,
	[15][10] = 129,
	[15][32] = 129,
	[15][33] = 144,
	[15][37] = 133,
	[15][38] = 145,
	[15][42] = 146,
	[15][43] = 136,
	[15][45] = 137,
	[15][47] = 148,
	[15][59] = 149,
	[15][60] = 150,
	[15][61] = 151,
	[15][62] = 152,
	[15][63] = 153,
	[15][94] = 154,
	[15][104] = 155,
	[15][105] = 156,
	[15][124] = 157,
	[16][9] = 129,
	[16][10] = 129,
	[16][32] = 129,
	[16][47] = 138,
	[16][59] = 149,
	[17][9] = 129,
	[17][10] = 129,
	[17][32] = 129,
	[17][47] = 138,
	[17][59] = 149,
	[17][105] = 175,
	[18][9] = 129,
	[18][10] = 129,
	[18][32] = 129,
	[18][38] = 174,
	[18][47] = 138,
	[18][59] = 149,
	[18][63] = 153,
	[18][104] = 155,
	[18][105] = 156,
	[18][124] = 157,
	[19][9] = 129,
	[19][10] = 129,
	[19][32] = 129,
	[19][38] = 174,
	[19][47] = 138,
	[19][59] = 149,
	[19][63] = 153,
	[19][104] = 155,
	[19][105] = 156,
	[19][124] = 176,
	[20][9] = 129,
	[20][10] = 129,
	[20][32] = 129,
	[20][47] = 138,
	[20][59] = 149,
	[20][63] = 153,
	[20][104] = 155,
	[20][105] = 156,
	[20][124] = 176,
	[21][9] = 129,
	[21][10] = 129,
	[21][32] = 129,
	[21][33] = 144,
	[21][37] = 133,
	[21][38] = 145,
	[21][42] = 177,
	[21][43] = 136,
	[21][45] = 137,
	[21][47] = 148,
	[21][59] = 149,
	[21][60] = 150,
	[21][61] = 151,
	[21][62] = 152,
	[21][63] = 153,
	[21][94] = 154,
	[21][104] = 155,
	[21][105] = 156,
	[21][124] = 157,
	[22][9] = 129,
	[22][10] = 129,
	[22][32] = 129,
	[22][47] = 138,
	[22][59] = 149,
	[22][105] = 156,
	[23][9] = 129,
	[23][10] = 129,
	[23][32] = 129,
	[23][33] = 144,
	[23][38] = 145,
	[23][47] = 138,
	[23][59] = 149,
	[23][60] = 178,
	[23][61] = 151,
	[23][62] = 179,
	[23][63] = 153,
	[23][94] = 154,
	[23][104] = 155,
	[23][105] = 156,
	[23][124] = 157,
	[24][9] = 129,
	[24][10] = 129,
	[24][32] = 129,
	[24][33] = 144,
	[24][38] = 145,
	[24][47] = 138,
	[24][59] = 149,
	[24][60] = 150,
	[24][61] = 151,
	[24][62] = 152,
	[24][63] = 153,
	[24][94] = 154,
	[24][104] = 155,
	[24][105] = 156,
	[24][124] = 157,
	[25][9] = 129,
	[25][10] = 129,
	[25][32] = 129,
	[25][33] = 144,
	[25][37] = 133,
	[25][38] = 145,
	[25][40] = 135,
	[25][41] = 158,
	[25][42] = 146,
	[25][43] = 136,
	[25][44] = 159,
	[25][45] = 137,
	[25][46] = 147,
	[25][47] = 148,
	[25][60] = 150,
	[25][61] = 151,
	[25][62] = 152,
	[25][63] = 153,
	[25][91] = 141,
	[25][94] = 154,
	[25][104] = 155,
	[25][105] = 156,
	[25][124] = 157,
	[26][9] = 129,
	[26][10] = 129,
	[26][32] = 129,
	[26][33] = 130,
	[26][34] = 131,
	[26][36] = 132,
	[26][39] = 134,
	[26][40] = 135,
	[26][43] = 136,
	[26][45] = 137,
	[26][47] = 138,
	[26][48] = 139,
	[26][49] = 140,
	[26][50] = 140,
	[26][51] = 140,
	[26][52] = 140,
	[26][53] = 140,
	[26][54] = 140,
	[26][55] = 140,
	[26][56] = 140,
	[26][57] = 140,
	[26][91] = 141,
	[26][97] = 142,
	[26][98] = 142,
	[26][99] = 142,
	[26][100] = 142,
	[26][101] = 142,
	[26][102] = 142,
	[26][103] = 142,
	[26][104] = 142,
	[26][105] = 142,
	[26][106] = 142,
	[26][107] = 142,
	[26][108] = 142,
	[26][109] = 142,
	[26][110] = 142,
	[26][111] = 142,
	[26][112] = 142,
	[26][113] = 142,
	[26][114] = 142,
	[26][115] = 142,
	[26][116] = 142,
	[26][117] = 142,
	[26][118] = 142,
	[26][119] = 142,
	[26][120] = 142,
	[26][121] = 142,
	[26][122] = 142,
	[26][126] = 143,
	[27][9] = 129,
	[27][10] = 129,
	[27][32] = 129,
	[27][33] = 144,
	[27][38] = 145,
	[27][41] = 158,
	[27][43] = 136,
	[27][44] = 159,
	[27][45] = 137,
	[27][47] = 138,
	[27][60] = 150,
	[27][61] = 151,
	[27][62] = 152,
	[27][63] = 153,
	[27][94] = 154,
	[27][104] = 155,
	[27][105] = 156,
	[27][124] = 157,
	[28][9] = 129,
	[28][10] = 129,
	[28][32] = 129,
	[28][38] = 145,
	[28][41] = 158,
	[28][44] = 159,
	[28][47] = 138,
	[28][63] = 153,
	[28][94] = 154,
	[28][104] = 155,
	[28][105] = 156,
	[28][124] = 157,
	[29][9] = 129,
	[29][10] = 129,
	[29][32] = 129,
	[29][41] = 158,
	[29][44] = 159,
	[29][47] = 138,
	[29][104] = 155,
	[29][105] = 156,
	[30][9] = 129,
	[30][10] = 129,
	[30][32] = 129,
	[30][33] = 144,
	[30][38] = 145,
	[30][41] = 158,
	[30][44] = 159,
	[30][47] = 138,
	[30][61] = 151,
	[30][63] = 153,
	[30][94] = 154,
	[30][104] = 155,
	[30][105] = 156,
	[30][124] = 157,
	[31][9] = 129,
	[31][10] = 129,
	[31][32] = 129,
	[31][38] = 174,
	[31][41] = 158,
	[31][44] = 159,
	[31][47] = 138,
	[31][63] = 153,
	[31][94] = 154,
	[31][104] = 155,
	[31][105] = 156,
	[31][124] = 157,
	[32][9] = 129,
	[32][10] = 129,
	[32][32] = 129,
	[32][33] = 144,
	[32][37] = 133,
	[32][38] = 145,
	[32][41] = 158,
	[32][42] = 146,
	[32][43] = 136,
	[32][44] = 159,
	[32][45] = 137,
	[32][47] = 148,
	[32][60] = 150,
	[32][61] = 151,
	[32][62] = 152,
	[32][63] = 153,
	[32][94] = 154,
	[32][104] = 155,
	[32][105] = 156,
	[32][124] = 157,
	[33][9] = 129,
	[33][10] = 129,
	[33][32] = 129,
	[33][41] = 158,
	[33][44] = 159,
	[33][47] = 138,
	[34][9] = 129,
	[34][10] = 129,
	[34][32] = 129,
	[34][41] = 158,
	[34][44] = 159,
	[34][47] = 138,
	[34][105] = 175,
	[35][9] = 129,
	[35][10] = 129,
	[35][32] = 129,
	[35][38] = 174,
	[35][41] = 158,
	[35][44] = 159,
	[35][47] = 138,
	[35][63] = 153,
	[35][104] = 155,
	[35][105] = 156,
	[35][124] = 157,
	[36][9] = 129,
	[36][10] = 129,
	[36][32] = 129,
	[36][38] = 174,
	[36][41] = 158,
	[36][44] = 159,
	[36][47] = 138,
	[36][63] = 153,
	[36][104] = 155,
	[36][105] = 156,
	[36][124] = 176,
	[37][9] = 129,
	[37][10] = 129,
	[37][32] = 129,
	[37][41] = 158,
	[37][44] = 159,
	[37][47] = 138,
	[37][63] = 153,
	[37][104] = 155,
	[37][105] = 156,
	[37][124] = 176,
	[38][9] = 129,
	[38][10] = 129,
	[38][32] = 129,
	[38][33] = 144,
	[38][37] = 133,
	[38][38] = 145,
	[38][41] = 158,
	[38][42] = 177,
	[38][43] = 136,
	[38][44] = 159,
	[38][45] = 137,
	[38][47] = 148,
	[38][60] = 150,
	[38][61] = 151,
	[38][62] = 152,
	[38][63] = 153,
	[38][94] = 154,
	[38][104] = 155,
	[38][105] = 156,
	[38][124] = 157,
	[39][9] = 129,
	[39][10] = 129,
	[39][32] = 129,
	[39][41] = 158,
	[39][44] = 159,
	[39][47] = 138,
	[39][105] = 156,
	[40][9] = 129,
	[40][10] = 129,
	[40][32] = 129,
	[40][33] = 144,
	[40][38] = 145,
	[40][41] = 158,
	[40][44] = 159,
	[40][47] = 138,
	[40][60] = 178,
	[40][61] = 151,
	[40][62] = 179,
	[40][63] = 153,
	[40][94] = 154,
	[40][104] = 155,
	[40][105] = 156,
	[40][124] = 157,
	[41][9] = 129,
	[41][10] = 129,
	[41][32] = 129,
	[41][33] = 144,
	[41][38] = 145,
	[41][41] = 158,
	[41][44] = 159,
	[41][47] = 138,
	[41][60] = 150,
	[41][61] = 151,
	[41][62] = 152,
	[41][63] = 153,
	[41][94] = 154,
	[41][104] = 155,
	[41][105] = 156,
	[41][124] = 157,
	[42][9] = 129,
	[42][10] = 129,
	[42][32] = 129,
	[42][33] = 144,
	[42][37] = 133,
	[42][38] = 145,
	[42][40] = 135,
	[42][42] = 146,
	[42][43] = 136,
	[42][44] = 159,
	[42][45] = 137,
	[42][46] = 147,
	[42][47] = 148,
	[42][60] = 150,
	[42][61] = 151,
	[42][62] = 152,
	[42][63] = 153,
	[42][91] = 141,
	[42][93] = 160,
	[42][94] = 154,
	[42][104] = 155,
	[42][105] = 156,
	[42][124] = 157,
	[43][9] = 129,
	[43][10] = 129,
	[43][32] = 129,
	[43][33] = 144,
	[43][38] = 145,
	[43][43] = 136,
	[43][44] = 159,
	[43][45] = 137,
	[43][47] = 138,
	[43][60] = 150,
	[43][61] = 151,
	[43][62] = 152,
	[43][63] = 153,
	[43][93] = 160,
	[43][94] = 154,
	[43][104] = 155,
	[43][105] = 156,
	[43][124] = 157,
	[44][9] = 129,
	[44][10] = 129,
	[44][32] = 129,
	[44][38] = 145,
	[44][44] = 159,
	[44][47] = 138,
	[44][63] = 153,
	[44][93] = 160,
	[44][94] = 154,
	[44][104] = 155,
	[44][105] = 156,
	[44][124] = 157,
	[45][9] = 129,
	[45][10] = 129,
	[45][32] = 129,
	[45][44] = 159,
	[45][47] = 138,
	[45][93] = 160,
	[45][104] = 155,
	[45][105] = 156,
	[46][9] = 129,
	[46][10] = 129,
	[46][32] = 129,
	[46][33] = 144,
	[46][38] = 145,
	[46][44] = 159,
	[46][47] = 138,
	[46][61] = 151,
	[46][63] = 153,
	[46][93] = 160,
	[46][94] = 154,
	[46][104] = 155,
	[46][105] = 156,
	[46][124] = 157,
	[47][9] = 129,
	[47][10] = 129,
	[47][32] = 129,
	[47][38] = 174,
	[47][44] = 159,
	[47][47] = 138,
	[47][63] = 153,
	[47][93] = 160,
	[47][94] = 154,
	[47][104] = 155,
	[47][105] = 156,
	[47][124] = 157,
	[48][9] = 129,
	[48][10] = 129,
	[48][32] = 129,
	[48][33] = 144,
	[48][37] = 133,
	[48][38] = 145,
	[48][42] = 146,
	[48][43] = 136,
	[48][44] = 159,
	[48][45] = 137,
	[48][47] = 148,
	[48][60] = 150,
	[48][61] = 151,
	[48][62] = 152,
	[48][63] = 153,
	[48][93] = 160,
	[48][94] = 154,
	[48][104] = 155,
	[48][105] = 156,
	[48][124] = 157,
	[49][9] = 129,
	[49][10] = 129,
	[49][32] = 129,
	[49][44] = 159,
	[49][47] = 138,
	[49][93] = 160,
	[50][9] = 129,
	[50][10] = 129,
	[50][32] = 129,
	[50][44] = 159,
	[50][47] = 138,
	[50][93] = 160,
	[50][105] = 175,
	[51][9] = 129,
	[51][10] = 129,
	[51][32] = 129,
	[51][38] = 174,
	[51][44] = 159,
	[51][47] = 138,
	[51][63] = 153,
	[51][93] = 160,
	[51][104] = 155,
	[51][105] = 156,
	[51][124] = 157,
	[52][9] = 129,
	[52][10] = 129,
	[52][32] = 129,
	[52][38] = 174,
	[52][44] = 159,
	[52][47] = 138,
	[52][63] = 153,
	[52][93] = 160,
	[52][104] = 155,
	[52][105] = 156,
	[52][124] = 176,
	[53][9] = 129,
	[53][10] = 129,
	[53][32] = 129,
	[53][44] = 159,
	[53][47] = 138,
	[53][63] = 153,
	[53][93] = 160,
	[53][104] = 155,
	[53][105] = 156,
	[53][124] = 176,
	[54][9] = 129,
	[54][10] = 129,
	[54][32] = 129,
	[54][33] = 144,
	[54][37] = 133,
	[54][38] = 145,
	[54][42] = 177,
	[54][43] = 136,
	[54][44] = 159,
	[54][45] = 137,
	[54][47] = 148,
	[54][60] = 150,
	[54][61] = 151,
	[54][62] = 152,
	[54][63] = 153,
	[54][93] = 160,
	[54][94] = 154,
	[54][104] = 155,
	[54][105] = 156,
	[54][124] = 157,
	[55][9] = 129,
	[55][10] = 129,
	[55][32] = 129,
	[55][44] = 159,
	[55][47] = 138,
	[55][93] = 160,
	[55][105] = 156,
	[56][9] = 129,
	[56][10] = 129,
	[56][32] = 129,
	[56][33] = 144,
	[56][38] = 145,
	[56][44] = 159,
	[56][47] = 138,
	[56][60] = 178,
	[56][61] = 151,
	[56][62] = 179,
	[56][63] = 153,
	[56][93] = 160,
	[56][94] = 154,
	[56][104] = 155,
	[56][105] = 156,
	[56][124] = 157,
	[57][9] = 129,
	[57][10] = 129,
	[57][32] = 129,
	[57][33] = 144,
	[57][38] = 145,
	[57][44] = 159,
	[57][47] = 138,
	[57][60] = 150,
	[57][61] = 151,
	[57][62] = 152,
	[57][63] = 153,
	[57][93] = 160,
	[57][94] = 154,
	[57][104] = 155,
	[57][105] = 156,
	[57][124] = 157,
	[58][9] = 129,
	[58][10] = 129,
	[58][32] = 129,
	[58][34] = 131,
	[58][39] = 134,
	[58][40] = 135,
	[58][47] = 148,
	[58][48] = 180,
	[58][49] = 181,
	[58][50] = 181,
	[58][51] = 181,
	[58][52] = 181,
	[58][53] = 181,
	[58][54] = 181,
	[58][55] = 181,
	[58][56] = 181,
	[58][57] = 181,
	[58][91] = 141,
	[58][97] = 142,
	[58][98] = 142,
	[58][99] = 142,
	[58][100] = 142,
	[58][101] = 142,
	[58][102] = 142,
	[58][103] = 142,
	[58][104] = 142,
	[58][105] = 142,
	[58][106] = 142,
	[58][107] = 142,
	[58][108] = 142,
	[58][109] = 142,
	[58][110] = 142,
	[58][111] = 142,
	[58][112] = 142,
	[58][113] = 142,
	[58][114] = 142,
	[58][115] = 142,
	[58][116] = 142,
	[58][117] = 142,
	[58][118] = 142,
	[58][119] = 142,
	[58][120] = 142,
	[58][121] = 142,
	[58][122] = 142,
	[59][9] = 129,
	[59][10] = 129,
	[59][32] = 129,
	[59][34] = 131,
	[59][47] = 138,
	[60][9] = 129,
	[60][10] = 129,
	[60][32] = 129,
	[60][47] = 138,
	[60][58] = 161,
	[61][9] = 129,
	[61][10] = 129,
	[61][32] = 129,
	[61][36] = 132,
	[61][40] = 135,
	[61][41] = 158,
	[61][44] = 159,
	[61][47] = 138,
	[61][97] = 142,
	[61][98] = 169,
	[61][99] = 170,
	[61][100] = 142,
	[61][101] = 142,
	[61][102] = 171,
	[61][103] = 142,
	[61][104] = 142,
	[61][105] = 172,
	[61][106] = 142,
	[61][107] = 142,
	[61][108] = 142,
	[61][109] = 142,
	[61][110] = 142,
	[61][111] = 142,
	[61][112] = 142,
	[61][113] = 142,
	[61][114] = 142,
	[61][115] = 142,
	[61][116] = 142,
	[61][117] = 142,
	[61][118] = 142,
	[61][119] = 142,
	[61][120] = 142,
	[61][121] = 142,
	[61][122] = 142,
	[62][9] = 129,
	[62][10] = 129,
	[62][32] = 129,
	[62][36] = 132,
	[62][40] = 135,
	[62][47] = 138,
	[62][97] = 142,
	[62][98] = 169,
	[62][99] = 170,
	[62][100] = 142,
	[62][101] = 142,
	[62][102] = 171,
	[62][103] = 142,
	[62][104] = 142,
	[62][105] = 172,
	[62][106] = 142,
	[62][107] = 142,
	[62][108] = 142,
	[62][109] = 142,
	[62][110] = 142,
	[62][111] = 142,
	[62][112] = 142,
	[62][113] = 142,
	[62][114] = 142,
	[62][115] = 142,
	[62][116] = 142,
	[62][117] = 142,
	[62][118] = 142,
	[62][119] = 142,
	[62][120] = 142,
	[62][121] = 142,
	[62][122] = 142,
	[63][9] = 129,
	[63][10] = 129,
	[63][32] = 129,
	[63][47] = 138,
	[63][91] = 182,
	[63][97] = 142,
	[63][98] = 142,
	[63][99] = 142,
	[63][100] = 142,
	[63][101] = 142,
	[63][102] = 142,
	[63][103] = 142,
	[63][104] = 142,
	[63][105] = 142,
	[63][106] = 142,
	[63][107] = 142,
	[63][108] = 142,
	[63][109] = 142,
	[63][110] = 142,
	[63][111] = 142,
	[63][112] = 142,
	[63][113] = 142,
	[63][114] = 142,
	[63][115] = 142,
	[63][116] = 142,
	[63][117] = 142,
	[63][118] = 142,
	[63][119] = 142,
	[63][120] = 142,
	[63][121] = 142,
	[63][122] = 142,
	[64][9] = 129,
	[64][10] = 129,
	[64][32] = 129,
	[64][47] = 138,
	[64][97] = 142,
	[64][98] = 142,
	[64][99] = 142,
	[64][100] = 142,
	[64][101] = 142,
	[64][102] = 142,
	[64][103] = 142,
	[64][104] = 142,
	[64][105] = 142,
	[64][106] = 142,
	[64][107] = 142,
	[64][108] = 142,
	[64][109] = 142,
	[64][110] = 142,
	[64][111] = 142,
	[64][112] = 142,
	[64][113] = 142,
	[64][114] = 142,
	[64][115] = 142,
	[64][116] = 142,
	[64][117] = 142,
	[64][118] = 142,
	[64][119] = 142,
	[64][120] = 142,
	[64][121] = 142,
	[64][122] = 142,
	[65][9] = 129,
	[65][10] = 129,
	[65][32] = 129,
	[65][47] = 138,
	[66][9] = 129,
	[66][10] = 129,
	[66][32] = 129,
	[66][34] = 131,
	[66][35] = 183,
	[66][39] = 134,
	[66][40] = 135,
	[66][42] = 177,
	[66][43] = 136,
	[66][47] = 148,
	[66][48] = 180,
	[66][49] = 181,
	[66][50] = 181,
	[66][51] = 181,
	[66][52] = 181,
	[66][53] = 181,
	[66][54] = 181,
	[66][55] = 181,
	[66][56] = 181,
	[66][57] = 181,
	[66][59] = 149,
	[66][63] = 153,
	[66][91] = 141,
	[66][97] = 142,
	[66][98] = 142,
	[66][99] = 142,
	[66][100] = 142,
	[66][101] = 142,
	[66][102] = 142,
	[66][103] = 142,
	[66][104] = 142,
	[66][105] = 142,
	[66][106] = 142,
	[66][107] = 142,
	[66][108] = 142,
	[66][109] = 142,
	[66][110] = 142,
	[66][111] = 142,
	[66][112] = 142,
	[66][113] = 142,
	[66][114] = 142,
	[66][115] = 142,
	[66][116] = 142,
	[66][117] = 142,
	[66][118] = 142,
	[66][119] = 142,
	[66][120] = 142,
	[66][121] = 142,
	[66][122] = 142,
	[66][124] = 184,
	[67][9] = 129,
	[67][10] = 129,
	[67][32] = 129,
	[67][33] = 130,
	[67][39] = 134,
	[67][40] = 135,
	[67][47] = 138,
	[67][48] = 180,
	[67][49] = 181,
	[67][50] = 181,
	[67][51] = 181,
	[67][52] = 181,
	[67][53] = 181,
	[67][54] = 181,
	[67][55] = 181,
	[67][56] = 181,
	[67][57] = 181,
	[68][9] = 129,
	[68][10] = 129,
	[68][32] = 129,
	[68][34] = 131,
	[68][39] = 134,
	[68][40] = 135,
	[68][47] = 138,
	[68][48] = 180,
	[68][49] = 181,
	[68][50] = 181,
	[68][51] = 181,
	[68][52] = 181,
	[68][53] = 181,
	[68][54] = 181,
	[68][55] = 181,
	[68][56] = 181,
	[68][57] = 181,
	[68][91] = 141,
	[69][9] = 129,
	[69][10] = 129,
	[69][32] = 129,
	[69][34] = 131,
	[69][39] = 134,
	[69][40] = 135,
	[69][42] = 177,
	[69][43] = 136,
	[69][47] = 148,
	[69][48] = 180,
	[69][49] = 181,
	[69][50] = 181,
	[69][51] = 181,
	[69][52] = 181,
	[69][53] = 181,
	[69][54] = 181,
	[69][55] = 181,
	[69][56] = 181,
	[69][57] = 181,
	[69][59] = 149,
	[69][63] = 153,
	[69][91] = 141,
	[69][97] = 142,
	[69][98] = 142,
	[69][99] = 142,
	[69][100] = 142,
	[69][101] = 142,
	[69][102] = 142,
	[69][103] = 142,
	[69][104] = 142,
	[69][105] = 142,
	[69][106] = 142,
	[69][107] = 142,
	[69][108] = 142,
	[69][109] = 142,
	[69][110] = 142,
	[69][111] = 142,
	[69][112] = 142,
	[69][113] = 142,
	[69][114] = 142,
	[69][115] = 142,
	[69][116] = 142,
	[69][117] = 142,
	[69][118] = 142,
	[69][119] = 142,
	[69][120] = 142,
	[69][121] = 142,
	[69][122] = 142,
	[69][124] = 184,
	[70][9] = 129,
	[70][10] = 129,
	[70][32] = 129,
	[70][47] = 138,
	[70][59] = 149,
	[70][124] = 184,
	[71][9] = 129,
	[71][10] = 129,
	[71][32] = 129,
	[71][34] = 131,
	[71][39] = 134,
	[71][40] = 135,
	[71][47] = 148,
	[71][48] = 180,
	[71][49] = 181,
	[71][50] = 181,
	[71][51] = 181,
	[71][52] = 181,
	[71][53] = 181,
	[71][54] = 181,
	[71][55] = 181,
	[71][56] = 181,
	[71][57] = 181,
	[71][59] = 149,
	[71][91] = 141,
	[71][97] = 142,
	[71][98] = 142,
	[71][99] = 142,
	[71][100] = 142,
	[71][101] = 142,
	[71][102] = 142,
	[71][103] = 142,
	[71][104] = 142,
	[71][105] = 142,
	[71][106] = 142,
	[71][107] = 142,
	[71][108] = 142,
	[71][109] = 142,
	[71][110] = 142,
	[71][111] = 142,
	[71][112] = 142,
	[71][113] = 142,
	[71][114] = 142,
	[71][115] = 142,
	[71][116] = 142,
	[71][117] = 142,
	[71][118] = 142,
	[71][119] = 142,
	[71][120] = 142,
	[71][121] = 142,
	[71][122] = 142,
	[71][124] = 184,
	[72][9] = 129,
	[72][10] = 129,
	[72][32] = 129,
	[72][41] = 158,
	[72][44] = 159,
	[72][47] = 138,
	[72][91] = 182,
	[73][9] = 129,
	[73][10] = 129,
	[73][32] = 129,
	[73][44] = 159,
	[73][47] = 138,
	[73][58] = 161,
	[73][91] = 182,
	[73][97] = 142,
	[73][98] = 142,
	[73][99] = 142,
	[73][100] = 142,
	[73][101] = 142,
	[73][102] = 142,
	[73][103] = 142,
	[73][104] = 142,
	[73][105] = 142,
	[73][106] = 142,
	[73][107] = 142,
	[73][108] = 142,
	[73][109] = 142,
	[73][110] = 142,
	[73][111] = 142,
	[73][112] = 142,
	[73][113] = 142,
	[73][114] = 142,
	[73][115] = 142,
	[73][116] = 142,
	[73][117] = 142,
	[73][118] = 142,
	[73][119] = 142,
	[73][120] = 142,
	[73][121] = 142,
	[73][122] = 142,
	[74][9] = 129,
	[74][10] = 129,
	[74][32] = 129,
	[74][44] = 159,
	[74][47] = 138,
	[74][58] = 161,
	[75][9] = 129,
	[75][10] = 129,
	[75][32] = 129,
	[75][44] = 159,
	[75][47] = 138,
	[75][58] = 161,
	[75][91] = 182,
	[76][9] = 129,
	[76][10] = 129,
	[76][32] = 129,
	[76][33] = 144,
	[76][37] = 133,
	[76][38] = 145,
	[76][40] = 135,
	[76][42] = 146,
	[76][43] = 136,
	[76][45] = 137,
	[76][46] = 147,
	[76][47] = 148,
	[76][58] = 161,
	[76][60] = 150,
	[76][61] = 151,
	[76][62] = 152,
	[76][63] = 153,
	[76][91] = 141,
	[76][94] = 154,
	[76][104] = 155,
	[76][105] = 156,
	[76][124] = 157,
	[77][9] = 129,
	[77][10] = 129,
	[77][32] = 129,
	[77][33] = 144,
	[77][38] = 145,
	[77][43] = 136,
	[77][45] = 137,
	[77][47] = 138,
	[77][58] = 161,
	[77][60] = 150,
	[77][61] = 151,
	[77][62] = 152,
	[77][63] = 153,
	[77][94] = 154,
	[77][104] = 155,
	[77][105] = 156,
	[77][124] = 157,
	[78][9] = 129,
	[78][10] = 129,
	[78][32] = 129,
	[78][38] = 145,
	[78][47] = 138,
	[78][58] = 161,
	[78][63] = 153,
	[78][94] = 154,
	[78][104] = 155,
	[78][105] = 156,
	[78][124] = 157,
	[79][9] = 129,
	[79][10] = 129,
	[79][32] = 129,
	[79][47] = 138,
	[79][58] = 161,
	[79][104] = 155,
	[79][105] = 156,
	[80][9] = 129,
	[80][10] = 129,
	[80][32] = 129,
	[80][33] = 144,
	[80][38] = 145,
	[80][47] = 138,
	[80][58] = 161,
	[80][61] = 151,
	[80][63] = 153,
	[80][94] = 154,
	[80][104] = 155,
	[80][105] = 156,
	[80][124] = 157,
	[81][9] = 129,
	[81][10] = 129,
	[81][32] = 129,
	[81][38] = 174,
	[81][47] = 138,
	[81][58] = 161,
	[81][63] = 153,
	[81][94] = 154,
	[81][104] = 155,
	[81][105] = 156,
	[81][124] = 157,
	[82][9] = 129,
	[82][10] = 129,
	[82][32] = 129,
	[82][33] = 144,
	[82][37] = 133,
	[82][38] = 145,
	[82][42] = 146,
	[82][43] = 136,
	[82][45] = 137,
	[82][47] = 148,
	[82][58] = 161,
	[82][60] = 150,
	[82][61] = 151,
	[82][62] = 152,
	[82][63] = 153,
	[82][94] = 154,
	[82][104] = 155,
	[82][105] = 156,
	[82][124] = 157,
	[83][9] = 129,
	[83][10] = 129,
	[83][32] = 129,
	[83][47] = 138,
	[83][58] = 161,
	[83][105] = 175,
	[84][9] = 129,
	[84][10] = 129,
	[84][32] = 129,
	[84][38] = 174,
	[84][47] = 138,
	[84][58] = 161,
	[84][63] = 153,
	[84][104] = 155,
	[84][105] = 156,
	[84][124] = 157,
	[85][9] = 129,
	[85][10] = 129,
	[85][32] = 129,
	[85][38] = 174,
	[85][47] = 138,
	[85][58] = 161,
	[85][63] = 153,
	[85][104] = 155,
	[85][105] = 156,
	[85][124] = 176,
	[86][9] = 129,
	[86][10] = 129,
	[86][32] = 129,
	[86][47] = 138,
	[86][58] = 161,
	[86][63] = 153,
	[86][104] = 155,
	[86][105] = 156,
	[86][124] = 176,
	[87][9] = 129,
	[87][10] = 129,
	[87][32] = 129,
	[87][33] = 144,
	[87][37] = 133,
	[87][38] = 145,
	[87][42] = 177,
	[87][43] = 136,
	[87][45] = 137,
	[87][47] = 148,
	[87][58] = 161,
	[87][60] = 150,
	[87][61] = 151,
	[87][62] = 152,
	[87][63] = 153,
	[87][94] = 154,
	[87][104] = 155,
	[87][105] = 156,
	[87][124] = 157,
	[88][9] = 129,
	[88][10] = 129,
	[88][32] = 129,
	[88][47] = 138,
	[88][58] = 161,
	[88][105] = 156,
	[89][9] = 129,
	[89][10] = 129,
	[89][32] = 129,
	[89][33] = 144,
	[89][38] = 145,
	[89][47] = 138,
	[89][58] = 161,
	[89][60] = 178,
	[89][61] = 151,
	[89][62] = 179,
	[89][63] = 153,
	[89][94] = 154,
	[89][104] = 155,
	[89][105] = 156,
	[89][124] = 157,
	[90][9] = 129,
	[90][10] = 129,
	[90][32] = 129,
	[90][33] = 144,
	[90][38] = 145,
	[90][47] = 138,
	[90][58] = 161,
	[90][60] = 150,
	[90][61] = 151,
	[90][62] = 152,
	[90][63] = 153,
	[90][94] = 154,
	[90][104] = 155,
	[90][105] = 156,
	[90][124] = 157,
	[91][9] = 129,
	[91][10] = 129,
	[91][32] = 129,
	[91][33] = 144,
	[91][37] = 133,
	[91][38] = 145,
	[91][40] = 135,
	[91][42] = 146,
	[91][43] = 136,
	[91][45] = 137,
	[91][46] = 147,
	[91][47] = 148,
	[91][60] = 150,
	[91][61] = 151,
	[91][62] = 152,
	[91][63] = 153,
	[91][91] = 141,
	[91][93] = 160,
	[91][94] = 154,
	[91][104] = 155,
	[91][105] = 156,
	[91][124] = 157,
	[92][9] = 129,
	[92][10] = 129,
	[92][32] = 129,
	[92][33] = 144,
	[92][38] = 145,
	[92][43] = 136,
	[92][45] = 137,
	[92][47] = 138,
	[92][60] = 150,
	[92][61] = 151,
	[92][62] = 152,
	[92][63] = 153,
	[92][93] = 160,
	[92][94] = 154,
	[92][104] = 155,
	[92][105] = 156,
	[92][124] = 157,
	[93][9] = 129,
	[93][10] = 129,
	[93][32] = 129,
	[93][38] = 145,
	[93][47] = 138,
	[93][63] = 153,
	[93][93] = 160,
	[93][94] = 154,
	[93][104] = 155,
	[93][105] = 156,
	[93][124] = 157,
	[94][9] = 129,
	[94][10] = 129,
	[94][32] = 129,
	[94][47] = 138,
	[94][93] = 160,
	[94][104] = 155,
	[94][105] = 156,
	[95][9] = 129,
	[95][10] = 129,
	[95][32] = 129,
	[95][33] = 144,
	[95][38] = 145,
	[95][47] = 138,
	[95][61] = 151,
	[95][63] = 153,
	[95][93] = 160,
	[95][94] = 154,
	[95][104] = 155,
	[95][105] = 156,
	[95][124] = 157,
	[96][9] = 129,
	[96][10] = 129,
	[96][32] = 129,
	[96][38] = 174,
	[96][47] = 138,
	[96][63] = 153,
	[96][93] = 160,
	[96][94] = 154,
	[96][104] = 155,
	[96][105] = 156,
	[96][124] = 157,
	[97][9] = 129,
	[97][10] = 129,
	[97][32] = 129,
	[97][33] = 144,
	[97][37] = 133,
	[97][38] = 145,
	[97][42] = 146,
	[97][43] = 136,
	[97][45] = 137,
	[97][47] = 148,
	[97][60] = 150,
	[97][61] = 151,
	[97][62] = 152,
	[97][63] = 153,
	[97][93] = 160,
	[97][94] = 154,
	[97][104] = 155,
	[97][105] = 156,
	[97][124] = 157,
	[98][9] = 129,
	[98][10] = 129,
	[98][32] = 129,
	[98][47] = 138,
	[98][93] = 160,
	[99][9] = 129,
	[99][10] = 129,
	[99][32] = 129,
	[99][47] = 138,
	[99][93] = 160,
	[99][105] = 175,
	[100][9] = 129,
	[100][10] = 129,
	[100][32] = 129,
	[100][38] = 174,
	[100][47] = 138,
	[100][63] = 153,
	[100][93] = 160,
	[100][104] = 155,
	[100][105] = 156,
	[100][124] = 157,
	[101][9] = 129,
	[101][10] = 129,
	[101][32] = 129,
	[101][38] = 174,
	[101][47] = 138,
	[101][63] = 153,
	[101][93] = 160,
	[101][104] = 155,
	[101][105] = 156,
	[101][124] = 176,
	[102][9] = 129,
	[102][10] = 129,
	[102][32] = 129,
	[102][47] = 138,
	[102][63] = 153,
	[102][93] = 160,
	[102][104] = 155,
	[102][105] = 156,
	[102][124] = 176,
	[103][9] = 129,
	[103][10] = 129,
	[103][32] = 129,
	[103][33] = 144,
	[103][37] = 133,
	[103][38] = 145,
	[103][42] = 177,
	[103][43] = 136,
	[103][45] = 137,
	[103][47] = 148,
	[103][60] = 150,
	[103][61] = 151,
	[103][62] = 152,
	[103][63] = 153,
	[103][93] = 160,
	[103][94] = 154,
	[103][104] = 155,
	[103][105] = 156,
	[103][124] = 157,
	[104][9] = 129,
	[104][10] = 129,
	[104][32] = 129,
	[104][47] = 138,
	[104][93] = 160,
	[104][105] = 156,
	[105][9] = 129,
	[105][10] = 129,
	[105][32] = 129,
	[105][33] = 144,
	[105][38] = 145,
	[105][47] = 138,
	[105][60] = 178,
	[105][61] = 151,
	[105][62] = 179,
	[105][63] = 153,
	[105][93] = 160,
	[105][94] = 154,
	[105][104] = 155,
	[105][105] = 156,
	[105][124] = 157,
	[106][9] = 129,
	[106][10] = 129,
	[106][32] = 129,
	[106][33] = 144,
	[106][38] = 145,
	[106][47] = 138,
	[106][60] = 150,
	[106][61] = 151,
	[106][62] = 152,
	[106][63] = 153,
	[106][93] = 160,
	[106][94] = 154,
	[106][104] = 155,
	[106][105] = 156,
	[106][124] = 157,
	[107][9] = 129,
	[107][10] = 129,
	[107][32] = 129,
	[107][34] = 131,
	[107][35] = 183,
	[107][39] = 134,
	[107][40] = 135,
	[107][41] = 158,
	[107][42] = 177,
	[107][43] = 136,
	[107][47] = 148,
	[107][48] = 180,
	[107][49] = 181,
	[107][50] = 181,
	[107][51] = 181,
	[107][52] = 181,
	[107][53] = 181,
	[107][54] = 181,
	[107][55] = 181,
	[107][56] = 181,
	[107][57] = 181,
	[107][63] = 153,
	[107][91] = 141,
	[107][97] = 142,
	[107][98] = 142,
	[107][99] = 142,
	[107][100] = 142,
	[107][101] = 142,
	[107][102] = 142,
	[107][103] = 142,
	[107][104] = 142,
	[107][105] = 142,
	[107][106] = 142,
	[107][107] = 142,
	[107][108] = 142,
	[107][109] = 142,
	[107][110] = 142,
	[107][111] = 142,
	[107][112] = 142,
	[107][113] = 142,
	[107][114] = 142,
	[107][115] = 142,
	[107][116] = 142,
	[107][117] = 142,
	[107][118] = 142,
	[107][119] = 142,
	[107][120] = 142,
	[107][121] = 142,
	[107][122] = 142,
	[107][124] = 184,
	[108][9] = 129,
	[108][10] = 129,
	[108][32] = 129,
	[108][41] = 158,
	[108][47] = 138,
	[109][9] = 129,
	[109][10] = 129,
	[109][32] = 129,
	[109][34] = 131,
	[109][39] = 134,
	[109][40] = 135,
	[109][41] = 158,
	[109][42] = 177,
	[109][43] = 136,
	[109][47] = 148,
	[109][48] = 180,
	[109][49] = 181,
	[109][50] = 181,
	[109][51] = 181,
	[109][52] = 181,
	[109][53] = 181,
	[109][54] = 181,
	[109][55] = 181,
	[109][56] = 181,
	[109][57] = 181,
	[109][63] = 153,
	[109][91] = 141,
	[109][97] = 142,
	[109][98] = 142,
	[109][99] = 142,
	[109][100] = 142,
	[109][101] = 142,
	[109][102] = 142,
	[109][103] = 142,
	[109][104] = 142,
	[109][105] = 142,
	[109][106] = 142,
	[109][107] = 142,
	[109][108] = 142,
	[109][109] = 142,
	[109][110] = 142,
	[109][111] = 142,
	[109][112] = 142,
	[109][113] = 142,
	[109][114] = 142,
	[109][115] = 142,
	[109][116] = 142,
	[109][117] = 142,
	[109][118] = 142,
	[109][119] = 142,
	[109][120] = 142,
	[109][121] = 142,
	[109][122] = 142,
	[109][124] = 184,
	[110][9] = 129,
	[110][10] = 129,
	[110][32] = 129,
	[110][41] = 158,
	[110][47] = 138,
	[110][124] = 184,
	[111][9] = 129,
	[111][10] = 129,
	[111][32] = 129,
	[111][34] = 131,
	[111][39] = 134,
	[111][40] = 135,
	[111][41] = 158,
	[111][47] = 148,
	[111][48] = 180,
	[111][49] = 181,
	[111][50] = 181,
	[111][51] = 181,
	[111][52] = 181,
	[111][53] = 181,
	[111][54] = 181,
	[111][55] = 181,
	[111][56] = 181,
	[111][57] = 181,
	[111][91] = 141,
	[111][97] = 142,
	[111][98] = 142,
	[111][99] = 142,
	[111][100] = 142,
	[111][101] = 142,
	[111][102] = 142,
	[111][103] = 142,
	[111][104] = 142,
	[111][105] = 142,
	[111][106] = 142,
	[111][107] = 142,
	[111][108] = 142,
	[111][109] = 142,
	[111][110] = 142,
	[111][111] = 142,
	[111][112] = 142,
	[111][113] = 142,
	[111][114] = 142,
	[111][115] = 142,
	[111][116] = 142,
	[111][117] = 142,
	[111][118] = 142,
	[111][119] = 142,
	[111][120] = 142,
	[111][121] = 142,
	[111][122] = 142,
	[111][124] = 184,
	[112][9] = 129,
	[112][10] = 129,
	[112][32] = 129,
	[112][33] = 130,
	[112][38] = 185,
	[112][39] = 134,
	[112][40] = 135,
	[112][44] = 159,
	[112][45] = 137,
	[112][47] = 138,
	[112][48] = 180,
	[112][49] = 181,
	[112][50] = 181,
	[112][51] = 181,
	[112][52] = 181,
	[112][53] = 181,
	[112][54] = 181,
	[112][55] = 181,
	[112][56] = 181,
	[112][57] = 181,
	[112][93] = 160,
	[112][94] = 154,
	[112][124] = 184,
	[113][9] = 129,
	[113][10] = 129,
	[113][32] = 129,
	[113][39] = 134,
	[113][40] = 135,
	[113][47] = 138,
	[113][48] = 180,
	[113][49] = 181,
	[113][50] = 181,
	[113][51] = 181,
	[113][52] = 181,
	[113][53] = 181,
	[113][54] = 181,
	[113][55] = 181,
	[113][56] = 181,
	[113][57] = 181,
	[114][9] = 129,
	[114][10] = 129,
	[114][32] = 129,
	[114][33] = 130,
	[114][39] = 134,
	[114][40] = 135,
	[114][44] = 159,
	[114][47] = 138,
	[114][48] = 180,
	[114][49] = 181,
	[114][50] = 181,
	[114][51] = 181,
	[114][52] = 181,
	[114][53] = 181,
	[114][54] = 181,
	[114][55] = 181,
	[114][56] = 181,
	[114][57] = 181,
	[114][93] = 160,
	[114][94] = 154,
	[114][124] = 184,
	[115][9] = 129,
	[115][10] = 129,
	[115][32] = 129,
	[115][33] = 130,
	[115][38] = 185,
	[115][39] = 134,
	[115][40] = 135,
	[115][44] = 159,
	[115][47] = 138,
	[115][48] = 180,
	[115][49] = 181,
	[115][50] = 181,
	[115][51] = 181,
	[115][52] = 181,
	[115][53] = 181,
	[115][54] = 181,
	[115][55] = 181,
	[115][56] = 181,
	[115][57] = 181,
	[115][93] = 160,
	[115][94] = 154,
	[115][124] = 184,
	[116][9] = 129,
	[116][10] = 129,
	[116][32] = 129,
	[116][33] = 130,
	[116][39] = 134,
	[116][40] = 135,
	[116][44] = 159,
	[116][47] = 138,
	[116][48] = 180,
	[116][49] = 181,
	[116][50] = 181,
	[116][51] = 181,
	[116][52] = 181,
	[116][53] = 181,
	[116][54] = 181,
	[116][55] = 181,
	[116][56] = 181,
	[116][57] = 181,
	[116][93] = 160,
	[116][124] = 184,
	[117][9] = 129,
	[117][10] = 129,
	[117][32] = 129,
	[117][34] = 131,
	[117][39] = 134,
	[117][40] = 135,
	[117][42] = 177,
	[117][43] = 136,
	[117][47] = 148,
	[117][48] = 180,
	[117][49] = 181,
	[117][50] = 181,
	[117][51] = 181,
	[117][52] = 181,
	[117][53] = 181,
	[117][54] = 181,
	[117][55] = 181,
	[117][56] = 181,
	[117][57] = 181,
	[117][63] = 153,
	[117][91] = 141,
	[117][124] = 184,
	[118][9] = 129,
	[118][10] = 129,
	[118][32] = 129,
	[118][47] = 148,
	[119][9] = 129,
	[119][10] = 129,
	[119][32] = 129,
	[119][47] = 148,
	[119][124] = 184,
	[120][9] = 129,
	[120][10] = 129,
	[120][32] = 129,
	[120][34] = 131,
	[120][39] = 134,
	[120][40] = 135,
	[120][47] = 148,
	[120][48] = 180,
	[120][49] = 181,
	[120][50] = 181,
	[120][51] = 181,
	[120][52] = 181,
	[120][53] = 181,
	[120][54] = 181,
	[120][55] = 181,
	[120][56] = 181,
	[120][57] = 181,
	[120][91] = 141,
	[120][124] = 184,
	[121][9] = 129,
	[121][10] = 129,
	[121][32] = 129,
	[121][34] = 131,
	[121][39] = 134,
	[121][40] = 135,
	[121][42] = 177,
	[121][43] = 136,
	[121][47] = 138,
	[121][48] = 180,
	[121][49] = 181,
	[121][50] = 181,
	[121][51] = 181,
	[121][52] = 181,
	[121][53] = 181,
	[121][54] = 181,
	[121][55] = 181,
	[121][56] = 181,
	[121][57] = 181,
	[121][59] = 149,
	[121][63] = 153,
	[121][91] = 141,
	[121][124] = 184,
	[122][9] = 129,
	[122][10] = 129,
	[122][32] = 129,
	[122][34] = 131,
	[122][39] = 134,
	[122][40] = 135,
	[122][47] = 138,
	[122][48] = 180,
	[122][49] = 181,
	[122][50] = 181,
	[122][51] = 181,
	[122][52] = 181,
	[122][53] = 181,
	[122][54] = 181,
	[122][55] = 181,
	[122][56] = 181,
	[122][57] = 181,
	[122][59] = 149,
	[122][91] = 141,
	[122][124] = 184,
	[123][9] = 129,
	[123][10] = 129,
	[123][32] = 129,
	[123][33] = 130,
	[123][38] = 185,
	[123][39] = 134,
	[123][40] = 135,
	[123][41] = 158,
	[123][44] = 159,
	[123][45] = 137,
	[123][47] = 138,
	[123][48] = 180,
	[123][49] = 181,
	[123][50] = 181,
	[123][51] = 181,
	[123][52] = 181,
	[123][53] = 181,
	[123][54] = 181,
	[123][55] = 181,
	[123][56] = 181,
	[123][57] = 181,
	[123][94] = 154,
	[123][124] = 184,
	[124][9] = 129,
	[124][10] = 129,
	[124][32] = 129,
	[124][33] = 130,
	[124][39] = 134,
	[124][40] = 135,
	[124][41] = 158,
	[124][44] = 159,
	[124][47] = 138,
	[124][48] = 180,
	[124][49] = 181,
	[124][50] = 181,
	[124][51] = 181,
	[124][52] = 181,
	[124][53] = 181,
	[124][54] = 181,
	[124][55] = 181,
	[124][56] = 181,
	[124][57] = 181,
	[124][94] = 154,
	[124][124] = 184,
	[125][9] = 129,
	[125][10] = 129,
	[125][32] = 129,
	[125][33] = 130,
	[125][38] = 185,
	[125][39] = 134,
	[125][40] = 135,
	[125][41] = 158,
	[125][44] = 159,
	[125][47] = 138,
	[125][48] = 180,
	[125][49] = 181,
	[125][50] = 181,
	[125][51] = 181,
	[125][52] = 181,
	[125][53] = 181,
	[125][54] = 181,
	[125][55] = 181,
	[125][56] = 181,
	[125][57] = 181,
	[125][94] = 154,
	[125][124] = 184,
	[126][9] = 129,
	[126][10] = 129,
	[126][32] = 129,
	[126][33] = 130,
	[126][39] = 134,
	[126][40] = 135,
	[126][41] = 158,
	[126][44] = 159,
	[126][47] = 138,
	[126][48] = 180,
	[126][49] = 181,
	[126][50] = 181,
	[126][51] = 181,
	[126][52] = 181,
	[126][53] = 181,
	[126][54] = 181,
	[126][55] = 181,
	[126][56] = 181,
	[126][57] = 181,
	[126][124] = 184,
	[127][9] = 129,
	[127][10] = 129,
	[127][32] = 129,
	[127][34] = 131,
	[127][39] = 134,
	[127][40] = 135,
	[127][41] = 158,
	[127][42] = 177,
	[127][43] = 136,
	[127][47] = 138,
	[127][48] = 180,
	[127][49] = 181,
	[127][50] = 181,
	[127][51] = 181,
	[127][52] = 181,
	[127][53] = 181,
	[127][54] = 181,
	[127][55] = 181,
	[127][56] = 181,
	[127][57] = 181,
	[127][63] = 153,
	[127][91] = 141,
	[127][124] = 184,
	[128][9] = 129,
	[128][10] = 129,
	[128][32] = 129,
	[128][34] = 131,
	[128][39] = 134,
	[128][40] = 135,
	[128][41] = 158,
	[128][47] = 138,
	[128][48] = 180,
	[128][49] = 181,
	[128][50] = 181,
	[128][51] = 181,
	[128][52] = 181,
	[128][53] = 181,
	[128][54] = 181,
	[128][55] = 181,
	[128][56] = 181,
	[128][57] = 181,
	[128][91] = 141,
	[128][124] = 184,
	[129][9] = 129,
	[129][10] = 129,
	[129][32] = 129,
	[129][47] = 138,
	[131][0] = 131,
	[131][1] = 131,
	[131][2] = 131,
	[131][3] = 131,
	[131][4] = 131,
	[131][5] = 131,
	[131][6] = 131,
	[131][7] = 131,
	[131][8] = 131,
	[131][9] = 131,
	[131][10] = 131,
	[131][11] = 131,
	[131][12] = 131,
	[131][13] = 131,
	[131][14] = 131,
	[131][15] = 131,
	[131][16] = 131,
	[131][17] = 131,
	[131][18] = 131,
	[131][19] = 131,
	[131][20] = 131,
	[131][21] = 131,
	[131][22] = 131,
	[131][23] = 131,
	[131][24] = 131,
	[131][25] = 131,
	[131][26] = 131,
	[131][27] = 131,
	[131][28] = 131,
	[131][29] = 131,
	[131][30] = 131,
	[131][31] = 131,
	[131][32] = 131,
	[131][33] = 131,
	[131][34] = 186,
	[131][35] = 131,
	[131][36] = 131,
	[131][37] = 131,
	[131][38] = 131,
	[131][39] = 131,
	[131][40] = 131,
	[131][41] = 131,
	[131][42] = 131,
	[131][43] = 131,
	[131][44] = 131,
	[131][45] = 131,
	[131][46] = 131,
	[131][47] = 131,
	[131][48] = 131,
	[131][49] = 131,
	[131][50] = 131,
	[131][51] = 131,
	[131][52] = 131,
	[131][53] = 131,
	[131][54] = 131,
	[131][55] = 131,
	[131][56] = 131,
	[131][57] = 131,
	[131][58] = 131,
	[131][59] = 131,
	[131][60] = 131,
	[131][61] = 131,
	[131][62] = 131,
	[131][63] = 131,
	[131][64] = 131,
	[131][65] = 131,
	[131][66] = 131,
	[131][67] = 131,
	[131][68] = 131,
	[131][69] = 131,
	[131][70] = 131,
	[131][71] = 131,
	[131][72] = 131,
	[131][73] = 131,
	[131][74] = 131,
	[131][75] = 131,
	[131][76] = 131,
	[131][77] = 131,
	[131][78] = 131,
	[131][79] = 131,
	[131][80] = 131,
	[131][81] = 131,
	[131][82] = 131,
	[131][83] = 131,
	[131][84] = 131,
	[131][85] = 131,
	[131][86] = 131,
	[131][87] = 131,
	[131][88] = 131,
	[131][89] = 131,
	[131][90] = 131,
	[131][91] = 131,
	[131][92] = 187,
	[131][93] = 131,
	[131][94] = 131,
	[131][95] = 131,
	[131][96] = 131,
	[131][97] = 131,
	[131][98] = 131,
	[131][99] = 131,
	[131][100] = 131,
	[131][101] = 131,
	[131][102] = 131,
	[131][103] = 131,
	[131][104] = 131,
	[131][105] = 131,
	[131][106] = 131,
	[131][107] = 131,
	[131][108] = 131,
	[131][109] = 131,
	[131][110] = 131,
	[131][111] = 131,
	[131][112] = 131,
	[131][113] = 131,
	[131][114] = 131,
	[131][115] = 131,
	[131][116] = 131,
	[131][117] = 131,
	[131][118] = 131,
	[131][119] = 131,
	[131][120] = 131,
	[131][121] = 131,
	[131][122] = 131,
	[131][123] = 131,
	[131][124] = 131,
	[131][125] = 131,
	[131][126] = 131,
	[131][127] = 131,
	[131][128] = 131,
	[131][129] = 131,
	[131][130] = 131,
	[131][131] = 131,
	[131][132] = 131,
	[131][133] = 131,
	[131][134] = 131,
	[131][135] = 131,
	[131][136] = 131,
	[131][137] = 131,
	[131][138] = 131,
	[131][139] = 131,
	[131][140] = 131,
	[131][141] = 131,
	[131][142] = 131,
	[131][143] = 131,
	[131][144] = 131,
	[131][145] = 131,
	[131][146] = 131,
	[131][147] = 131,
	[131][148] = 131,
	[131][149] = 131,
	[131][150] = 131,
	[131][151] = 131,
	[131][152] = 131,
	[131][153] = 131,
	[131][154] = 131,
	[131][155] = 131,
	[131][156] = 131,
	[131][157] = 131,
	[131][158] = 131,
	[131][159] = 131,
	[131][160] = 131,
	[131][161] = 131,
	[131][162] = 131,
	[131][163] = 131,
	[131][164] = 131,
	[131][165] = 131,
	[131][166] = 131,
	[131][167] = 131,
	[131][168] = 131,
	[131][169] = 131,
	[131][170] = 131,
	[131][171] = 131,
	[131][172] = 131,
	[131][173] = 131,
	[131][174] = 131,
	[131][175] = 131,
	[131][176] = 131,
	[131][177] = 131,
	[131][178] = 131,
	[131][179] = 131,
	[131][180] = 131,
	[131][181] = 131,
	[131][182] = 131,
	[131][183] = 131,
	[131][184] = 131,
	[131][185] = 131,
	[131][186] = 131,
	[131][187] = 131,
	[131][188] = 131,
	[131][189] = 131,
	[131][190] = 131,
	[131][191] = 131,
	[131][192] = 131,
	[131][193] = 131,
	[131][194] = 131,
	[131][195] = 131,
	[131][196] = 131,
	[131][197] = 131,
	[131][198] = 131,
	[131][199] = 131,
	[131][200] = 131,
	[131][201] = 131,
	[131][202] = 131,
	[131][203] = 131,
	[131][204] = 131,
	[131][205] = 131,
	[131][206] = 131,
	[131][207] = 131,
	[131][208] = 131,
	[131][209] = 131,
	[131][210] = 131,
	[131][211] = 131,
	[131][212] = 131,
	[131][213] = 131,
	[131][214] = 131,
	[131][215] = 131,
	[131][216] = 131,
	[131][217] = 131,
	[131][218] = 131,
	[131][219] = 131,
	[131][220] = 131,
	[131][221] = 131,
	[131][222] = 131,
	[131][223] = 131,
	[131][224] = 131,
	[131][225] = 131,
	[131][226] = 131,
	[131][227] = 131,
	[131][228] = 131,
	[131][229] = 131,
	[131][230] = 131,
	[131][231] = 131,
	[131][232] = 131,
	[131][233] = 131,
	[131][234] = 131,
	[131][235] = 131,
	[131][236] = 131,
	[131][237] = 131,
	[131][238] = 131,
	[131][239] = 131,
	[131][240] = 131,
	[131][241] = 131,
	[131][242] = 131,
	[131][243] = 131,
	[131][244] = 131,
	[131][245] = 131,
	[131][246] = 131,
	[131][247] = 131,
	[131][248] = 131,
	[131][249] = 131,
	[131][250] = 131,
	[131][251] = 131,
	[131][252] = 131,
	[131][253] = 131,
	[131][254] = 131,
	[131][255] = 131,
	[134][0] = 188,
	[134][1] = 188,
	[134][2] = 188,
	[134][3] = 188,
	[134][4] = 188,
	[134][5] = 188,
	[134][6] = 188,
	[134][7] = 188,
	[134][8] = 188,
	[134][9] = 188,
	[134][10] = 188,
	[134][11] = 188,
	[134][12] = 188,
	[134][13] = 188,
	[134][14] = 188,
	[134][15] = 188,
	[134][16] = 188,
	[134][17] = 188,
	[134][18] = 188,
	[134][19] = 188,
	[134][20] = 188,
	[134][21] = 188,
	[134][22] = 188,
	[134][23] = 188,
	[134][24] = 188,
	[134][25] = 188,
	[134][26] = 188,
	[134][27] = 188,
	[134][28] = 188,
	[134][29] = 188,
	[134][30] = 188,
	[134][31] = 188,
	[134][32] = 188,
	[134][33] = 188,
	[134][34] = 188,
	[134][35] = 188,
	[134][36] = 188,
	[134][37] = 188,
	[134][38] = 188,
	[134][40] = 188,
	[134][41] = 188,
	[134][42] = 188,
	[134][43] = 188,
	[134][44] = 188,
	[134][45] = 188,
	[134][46] = 188,
	[134][47] = 188,
	[134][48] = 188,
	[134][49] = 188,
	[134][50] = 188,
	[134][51] = 188,
	[134][52] = 188,
	[134][53] = 188,
	[134][54] = 188,
	[134][55] = 188,
	[134][56] = 188,
	[134][57] = 188,
	[134][58] = 188,
	[134][59] = 188,
	[134][60] = 188,
	[134][61] = 188,
	[134][62] = 188,
	[134][63] = 188,
	[134][64] = 188,
	[134][65] = 188,
	[134][66] = 188,
	[134][67] = 188,
	[134][68] = 188,
	[134][69] = 188,
	[134][70] = 188,
	[134][71] = 188,
	[134][72] = 188,
	[134][73] = 188,
	[134][74] = 188,
	[134][75] = 188,
	[134][76] = 188,
	[134][77] = 188,
	[134][78] = 188,
	[134][79] = 188,
	[134][80] = 188,
	[134][81] = 188,
	[134][82] = 188,
	[134][83] = 188,
	[134][84] = 188,
	[134][85] = 188,
	[134][86] = 188,
	[134][87] = 188,
	[134][88] = 188,
	[134][89] = 188,
	[134][90] = 188,
	[134][91] = 188,
	[134][92] = 189,
	[134][93] = 188,
	[134][94] = 188,
	[134][95] = 188,
	[134][96] = 188,
	[134][97] = 188,
	[134][98] = 188,
	[134][99] = 188,
	[134][100] = 188,
	[134][101] = 188,
	[134][102] = 188,
	[134][103] = 188,
	[134][104] = 188,
	[134][105] = 188,
	[134][106] = 188,
	[134][107] = 188,
	[134][108] = 188,
	[134][109] = 188,
	[134][110] = 188,
	[134][111] = 188,
	[134][112] = 188,
	[134][113] = 188,
	[134][114] = 188,
	[134][115] = 188,
	[134][116] = 188,
	[134][117] = 188,
	[134][118] = 188,
	[134][119] = 188,
	[134][120] = 188,
	[134][121] = 188,
	[134][122] = 188,
	[134][123] = 188,
	[134][124] = 188,
	[134][125] = 188,
	[134][126] = 188,
	[134][127] = 188,
	[134][128] = 188,
	[134][129] = 188,
	[134][130] = 188,
	[134][131] = 188,
	[134][132] = 188,
	[134][133] = 188,
	[134][134] = 188,
	[134][135] = 188,
	[134][136] = 188,
	[134][137] = 188,
	[134][138] = 188,
	[134][139] = 188,
	[134][140] = 188,
	[134][141] = 188,
	[134][142] = 188,
	[134][143] = 188,
	[134][144] = 188,
	[134][145] = 188,
	[134][146] = 188,
	[134][147] = 188,
	[134][148] = 188,
	[134][149] = 188,
	[134][150] = 188,
	[134][151] = 188,
	[134][152] = 188,
	[134][153] = 188,
	[134][154] = 188,
	[134][155] = 188,
	[134][156] = 188,
	[134][157] = 188,
	[134][158] = 188,
	[134][159] = 188,
	[134][160] = 188,
	[134][161] = 188,
	[134][162] = 188,
	[134][163] = 188,
	[134][164] = 188,
	[134][165] = 188,
	[134][166] = 188,
	[134][167] = 188,
	[134][168] = 188,
	[134][169] = 188,
	[134][170] = 188,
	[134][171] = 188,
	[134][172] = 188,
	[134][173] = 188,
	[134][174] = 188,
	[134][175] = 188,
	[134][176] = 188,
	[134][177] = 188,
	[134][178] = 188,
	[134][179] = 188,
	[134][180] = 188,
	[134][181] = 188,
	[134][182] = 188,
	[134][183] = 188,
	[134][184] = 188,
	[134][185] = 188,
	[134][186] = 188,
	[134][187] = 188,
	[134][188] = 188,
	[134][189] = 188,
	[134][190] = 188,
	[134][191] = 188,
	[134][192] = 188,
	[134][193] = 188,
	[134][194] = 188,
	[134][195] = 188,
	[134][196] = 188,
	[134][197] = 188,
	[134][198] = 188,
	[134][199] = 188,
	[134][200] = 188,
	[134][201] = 188,
	[134][202] = 188,
	[134][203] = 188,
	[134][204] = 188,
	[134][205] = 188,
	[134][206] = 188,
	[134][207] = 188,
	[134][208] = 188,
	[134][209] = 188,
	[134][210] = 188,
	[134][211] = 188,
	[134][212] = 188,
	[134][213] = 188,
	[134][214] = 188,
	[134][215] = 188,
	[134][216] = 188,
	[134][217] = 188,
	[134][218] = 188,
	[134][219] = 188,
	[134][220] = 188,
	[134][221] = 188,
	[134][222] = 188,
	[134][223] = 188,
	[134][224] = 188,
	[134][225] = 188,
	[134][226] = 188,
	[134][227] = 188,
	[134][228] = 188,
	[134][229] = 188,
	[134][230] = 188,
	[134][231] = 188,
	[134][232] = 188,
	[134][233] = 188,
	[134][234] = 188,
	[134][235] = 188,
	[134][236] = 188,
	[134][237] = 188,
	[134][238] = 188,
	[134][239] = 188,
	[134][240] = 188,
	[134][241] = 188,
	[134][242] = 188,
	[134][243] = 188,
	[134][244] = 188,
	[134][245] = 188,
	[134][246] = 188,
	[134][247] = 188,
	[134][248] = 188,
	[134][249] = 188,
	[134][250] = 188,
	[134][251] = 188,
	[134][252] = 188,
	[134][253] = 188,
	[134][254] = 188,
	[134][255] = 188,
	[138][47] = 190,
	[139][46] = 191,
	[139][48] = 192,
	[139][49] = 140,
	[139][50] = 140,
	[139][51] = 140,
	[139][52] = 140,
	[139][53] = 140,
	[139][54] = 140,
	[139][55] = 140,
	[139][56] = 140,
	[139][57] = 140,
	[139][120] = 193,
	[140][46] = 191,
	[140][48] = 140,
	[140][49] = 140,
	[140][50] = 140,
	[140][51] = 140,
	[140][52] = 140,
	[140][53] = 140,
	[140][54] = 140,
	[140][55] = 140,
	[140][56] = 140,
	[140][57] = 140,
	[142][48] = 142,
	[142][49] = 142,
	[142][50] = 142,
	[142][51] = 142,
	[142][52] = 142,
	[142][53] = 142,
	[142][54] = 142,
	[142][55] = 142,
	[142][56] = 142,
	[142][57] = 142,
	[142][95] = 142,
	[142][97] = 142,
	[142][98] = 142,
	[142][99] = 142,
	[142][100] = 142,
	[142][101] = 142,
	[142][102] = 142,
	[142][103] = 142,
	[142][104] = 142,
	[142][105] = 142,
	[142][106] = 142,
	[142][107] = 142,
	[142][108] = 142,
	[142][109] = 142,
	[142][110] = 142,
	[142][111] = 142,
	[142][112] = 142,
	[142][113] = 142,
	[142][114] = 142,
	[142][115] = 142,
	[142][116] = 142,
	[142][117] = 142,
	[142][118] = 142,
	[142][119] = 142,
	[142][120] = 142,
	[142][121] = 142,
	[142][122] = 142,
	[144][61] = 194,
	[145][38] = 195,
	[146][42] = 196,
	[148][47] = 190,
	[150][60] = 197,
	[150][61] = 198,
	[151][61] = 199,
	[152][61] = 200,
	[152][62] = 201,
	[155][97] = 202,
	[156][102] = 203,
	[156][109] = 204,
	[157][124] = 205,
	[162][61] = 199,
	[163][101] = 206,
	[164][114] = 207,
	[165][111] = 208,
	[166][107] = 209,
	[166][116] = 210,
	[167][115] = 211,
	[168][97] = 212,
	[169][48] = 142,
	[169][49] = 142,
	[169][50] = 142,
	[169][51] = 142,
	[169][52] = 142,
	[169][53] = 142,
	[169][54] = 142,
	[169][55] = 142,
	[169][56] = 142,
	[169][57] = 142,
	[169][95] = 142,
	[169][97] = 142,
	[169][98] = 142,
	[169][99] = 142,
	[169][100] = 142,
	[169][101] = 142,
	[169][102] = 142,
	[169][103] = 142,
	[169][104] = 142,
	[169][105] = 142,
	[169][106] = 142,
	[169][107] = 142,
	[169][108] = 142,
	[169][109] = 142,
	[169][110] = 142,
	[169][111] = 213,
	[169][112] = 142,
	[169][113] = 142,
	[169][114] = 142,
	[169][115] = 142,
	[169][116] = 142,
	[169][117] = 142,
	[169][118] = 142,
	[169][119] = 142,
	[169][120] = 142,
	[169][121] = 142,
	[169][122] = 142,
	[170][48] = 142,
	[170][49] = 142,
	[170][50] = 142,
	[170][51] = 142,
	[170][52] = 142,
	[170][53] = 142,
	[170][54] = 142,
	[170][55] = 142,
	[170][56] = 142,
	[170][57] = 142,
	[170][95] = 142,
	[170][97] = 142,
	[170][98] = 142,
	[170][99] = 142,
	[170][100] = 142,
	[170][101] = 142,
	[170][102] = 142,
	[170][103] = 142,
	[170][104] = 214,
	[170][105] = 142,
	[170][106] = 142,
	[170][107] = 142,
	[170][108] = 142,
	[170][109] = 142,
	[170][110] = 142,
	[170][111] = 142,
	[170][112] = 142,
	[170][113] = 142,
	[170][114] = 142,
	[170][115] = 142,
	[170][116] = 142,
	[170][117] = 142,
	[170][118] = 142,
	[170][119] = 142,
	[170][120] = 142,
	[170][121] = 142,
	[170][122] = 142,
	[171][48] = 142,
	[171][49] = 142,
	[171][50] = 142,
	[171][51] = 142,
	[171][52] = 142,
	[171][53] = 142,
	[171][54] = 142,
	[171][55] = 142,
	[171][56] = 142,
	[171][57] = 142,
	[171][95] = 142,
	[171][97] = 142,
	[171][98] = 142,
	[171][99] = 142,
	[171][100] = 142,
	[171][101] = 142,
	[171][102] = 142,
	[171][103] = 142,
	[171][104] = 142,
	[171][105] = 142,
	[171][106] = 142,
	[171][107] = 142,
	[171][108] = 215,
	[171][109] = 142,
	[171][110] = 142,
	[171][111] = 142,
	[171][112] = 142,
	[171][113] = 142,
	[171][114] = 142,
	[171][115] = 142,
	[171][116] = 142,
	[171][117] = 142,
	[171][118] = 142,
	[171][119] = 142,
	[171][120] = 142,
	[171][121] = 142,
	[171][122] = 142,
	[172][48] = 142,
	[172][49] = 142,
	[172][50] = 142,
	[172][51] = 142,
	[172][52] = 142,
	[172][53] = 142,
	[172][54] = 142,
	[172][55] = 142,
	[172][56] = 142,
	[172][57] = 142,
	[172][95] = 142,
	[172][97] = 142,
	[172][98] = 142,
	[172][99] = 142,
	[172][100] = 142,
	[172][101] = 142,
	[172][102] = 142,
	[172][103] = 142,
	[172][104] = 142,
	[172][105] = 142,
	[172][106] = 142,
	[172][107] = 142,
	[172][108] = 142,
	[172][109] = 142,
	[172][110] = 216,
	[172][111] = 142,
	[172][112] = 142,
	[172][113] = 142,
	[172][114] = 142,
	[172][115] = 142,
	[172][116] = 142,
	[172][117] = 142,
	[172][118] = 142,
	[172][119] = 142,
	[172][120] = 142,
	[172][121] = 142,
	[172][122] = 142,
	[174][38] = 195,
	[175][102] = 203,
	[176][124] = 205,
	[178][61] = 198,
	[179][61] = 200,
	[180][49] = 181,
	[180][50] = 181,
	[180][51] = 181,
	[180][52] = 181,
	[180][53] = 181,
	[180][54] = 181,
	[180][55] = 181,
	[180][56] = 181,
	[180][57] = 181,
	[180][120] = 193,
	[181][48] = 181,
	[181][49] = 181,
	[181][50] = 181,
	[181][51] = 181,
	[181][52] = 181,
	[181][53] = 181,
	[181][54] = 181,
	[181][55] = 181,
	[181][56] = 181,
	[181][57] = 181,
	[182][93] = 217,
	[183][95] = 218,
	[183][97] = 218,
	[183][98] = 218,
	[183][99] = 218,
	[183][100] = 218,
	[183][101] = 218,
	[183][102] = 218,
	[183][103] = 218,
	[183][104] = 218,
	[183][105] = 218,
	[183][106] = 218,
	[183][107] = 218,
	[183][108] = 218,
	[183][109] = 218,
	[183][110] = 218,
	[183][111] = 218,
	[183][112] = 218,
	[183][113] = 218,
	[183][114] = 218,
	[183][115] = 218,
	[183][116] = 218,
	[183][117] = 218,
	[183][118] = 218,
	[183][119] = 218,
	[183][120] = 218,
	[183][121] = 218,
	[183][122] = 218,
	[187][0] = 131,
	[187][1] = 131,
	[187][2] = 131,
	[187][3] = 131,
	[187][4] = 131,
	[187][5] = 131,
	[187][6] = 131,
	[187][7] = 131,
	[187][8] = 131,
	[187][9] = 131,
	[187][10] = 131,
	[187][11] = 131,
	[187][12] = 131,
	[187][13] = 131,
	[187][14] = 131,
	[187][15] = 131,
	[187][16] = 131,
	[187][17] = 131,
	[187][18] = 131,
	[187][19] = 131,
	[187][20] = 131,
	[187][21] = 131,
	[187][22] = 131,
	[187][23] = 131,
	[187][24] = 131,
	[187][25] = 131,
	[187][26] = 131,
	[187][27] = 131,
	[187][28] = 131,
	[187][29] = 131,
	[187][30] = 131,
	[187][31] = 131,
	[187][32] = 131,
	[187][33] = 131,
	[187][34] = 131,
	[187][35] = 131,
	[187][36] = 131,
	[187][37] = 131,
	[187][38] = 131,
	[187][39] = 131,
	[187][40] = 131,
	[187][41] = 131,
	[187][42] = 131,
	[187][43] = 131,
	[187][44] = 131,
	[187][45] = 131,
	[187][46] = 131,
	[187][47] = 131,
	[187][48] = 131,
	[187][49] = 131,
	[187][50] = 131,
	[187][51] = 131,
	[187][52] = 131,
	[187][53] = 131,
	[187][54] = 131,
	[187][55] = 131,
	[187][56] = 131,
	[187][57] = 131,
	[187][58] = 131,
	[187][59] = 131,
	[187][60] = 131,
	[187][61] = 131,
	[187][62] = 131,
	[187][63] = 131,
	[187][64] = 131,
	[187][65] = 131,
	[187][66] = 131,
	[187][67] = 131,
	[187][68] = 131,
	[187][69] = 131,
	[187][70] = 131,
	[187][71] = 131,
	[187][72] = 131,
	[187][73] = 131,
	[187][74] = 131,
	[187][75] = 131,
	[187][76] = 131,
	[187][77] = 131,
	[187][78] = 131,
	[187][79] = 131,
	[187][80] = 131,
	[187][81] = 131,
	[187][82] = 131,
	[187][83] = 131,
	[187][84] = 131,
	[187][85] = 131,
	[187][86] = 131,
	[187][87] = 131,
	[187][88] = 131,
	[187][89] = 131,
	[187][90] = 131,
	[187][91] = 131,
	[187][92] = 131,
	[187][93] = 131,
	[187][94] = 131,
	[187][95] = 131,
	[187][96] = 131,
	[187][97] = 131,
	[187][98] = 131,
	[187][99] = 131,
	[187][100] = 131,
	[187][101] = 131,
	[187][102] = 131,
	[187][103] = 131,
	[187][104] = 131,
	[187][105] = 131,
	[187][106] = 131,
	[187][107] = 131,
	[187][108] = 131,
	[187][109] = 131,
	[187][110] = 131,
	[187][111] = 131,
	[187][112] = 131,
	[187][113] = 131,
	[187][114] = 131,
	[187][115] = 131,
	[187][116] = 131,
	[187][117] = 131,
	[187][118] = 131,
	[187][119] = 131,
	[187][120] = 131,
	[187][121] = 131,
	[187][122] = 131,
	[187][123] = 131,
	[187][124] = 131,
	[187][125] = 131,
	[187][126] = 131,
	[187][127] = 131,
	[187][128] = 131,
	[187][129] = 131,
	[187][130] = 131,
	[187][131] = 131,
	[187][132] = 131,
	[187][133] = 131,
	[187][134] = 131,
	[187][135] = 131,
	[187][136] = 131,
	[187][137] = 131,
	[187][138] = 131,
	[187][139] = 131,
	[187][140] = 131,
	[187][141] = 131,
	[187][142] = 131,
	[187][143] = 131,
	[187][144] = 131,
	[187][145] = 131,
	[187][146] = 131,
	[187][147] = 131,
	[187][148] = 131,
	[187][149] = 131,
	[187][150] = 131,
	[187][151] = 131,
	[187][152] = 131,
	[187][153] = 131,
	[187][154] = 131,
	[187][155] = 131,
	[187][156] = 131,
	[187][157] = 131,
	[187][158] = 131,
	[187][159] = 131,
	[187][160] = 131,
	[187][161] = 131,
	[187][162] = 131,
	[187][163] = 131,
	[187][164] = 131,
	[187][165] = 131,
	[187][166] = 131,
	[187][167] = 131,
	[187][168] = 131,
	[187][169] = 131,
	[187][170] = 131,
	[187][171] = 131,
	[187][172] = 131,
	[187][173] = 131,
	[187][174] = 131,
	[187][175] = 131,
	[187][176] = 131,
	[187][177] = 131,
	[187][178] = 131,
	[187][179] = 131,
	[187][180] = 131,
	[187][181] = 131,
	[187][182] = 131,
	[187][183] = 131,
	[187][184] = 131,
	[187][185] = 131,
	[187][186] = 131,
	[187][187] = 131,
	[187][188] = 131,
	[187][189] = 131,
	[187][190] = 131,
	[187][191] = 131,
	[187][192] = 131,
	[187][193] = 131,
	[187][194] = 131,
	[187][195] = 131,
	[187][196] = 131,
	[187][197] = 131,
	[187][198] = 131,
	[187][199] = 131,
	[187][200] = 131,
	[187][201] = 131,
	[187][202] = 131,
	[187][203] = 131,
	[187][204] = 131,
	[187][205] = 131,
	[187][206] = 131,
	[187][207] = 131,
	[187][208] = 131,
	[187][209] = 131,
	[187][210] = 131,
	[187][211] = 131,
	[187][212] = 131,
	[187][213] = 131,
	[187][214] = 131,
	[187][215] = 131,
	[187][216] = 131,
	[187][217] = 131,
	[187][218] = 131,
	[187][219] = 131,
	[187][220] = 131,
	[187][221] = 131,
	[187][222] = 131,
	[187][223] = 131,
	[187][224] = 131,
	[187][225] = 131,
	[187][226] = 131,
	[187][227] = 131,
	[187][228] = 131,
	[187][229] = 131,
	[187][230] = 131,
	[187][231] = 131,
	[187][232] = 131,
	[187][233] = 131,
	[187][234] = 131,
	[187][235] = 131,
	[187][236] = 131,
	[187][237] = 131,
	[187][238] = 131,
	[187][239] = 131,
	[187][240] = 131,
	[187][241] = 131,
	[187][242] = 131,
	[187][243] = 131,
	[187][244] = 131,
	[187][245] = 131,
	[187][246] = 131,
	[187][247] = 131,
	[187][248] = 131,
	[187][249] = 131,
	[187][250] = 131,
	[187][251] = 131,
	[187][252] = 131,
	[187][253] = 131,
	[187][254] = 131,
	[187][255] = 131,
	[188][39] = 219,
	[189][0] = 188,
	[189][1] = 188,
	[189][2] = 188,
	[189][3] = 188,
	[189][4] = 188,
	[189][5] = 188,
	[189][6] = 188,
	[189][7] = 188,
	[189][8] = 188,
	[189][9] = 188,
	[189][10] = 188,
	[189][11] = 188,
	[189][12] = 188,
	[189][13] = 188,
	[189][14] = 188,
	[189][15] = 188,
	[189][16] = 188,
	[189][17] = 188,
	[189][18] = 188,
	[189][19] = 188,
	[189][20] = 188,
	[189][21] = 188,
	[189][22] = 188,
	[189][23] = 188,
	[189][24] = 188,
	[189][25] = 188,
	[189][26] = 188,
	[189][27] = 188,
	[189][28] = 188,
	[189][29] = 188,
	[189][30] = 188,
	[189][31] = 188,
	[189][32] = 188,
	[189][33] = 188,
	[189][34] = 188,
	[189][35] = 188,
	[189][36] = 188,
	[189][37] = 188,
	[189][38] = 188,
	[189][39] = 188,
	[189][40] = 188,
	[189][41] = 188,
	[189][42] = 188,
	[189][43] = 188,
	[189][44] = 188,
	[189][45] = 188,
	[189][46] = 188,
	[189][47] = 188,
	[189][48] = 188,
	[189][49] = 188,
	[189][50] = 188,
	[189][51] = 188,
	[189][52] = 188,
	[189][53] = 188,
	[189][54] = 188,
	[189][55] = 188,
	[189][56] = 188,
	[189][57] = 188,
	[189][58] = 188,
	[189][59] = 188,
	[189][60] = 188,
	[189][61] = 188,
	[189][62] = 188,
	[189][63] = 188,
	[189][64] = 188,
	[189][65] = 188,
	[189][66] = 188,
	[189][67] = 188,
	[189][68] = 188,
	[189][69] = 188,
	[189][70] = 188,
	[189][71] = 188,
	[189][72] = 188,
	[189][73] = 188,
	[189][74] = 188,
	[189][75] = 188,
	[189][76] = 188,
	[189][77] = 188,
	[189][78] = 188,
	[189][79] = 188,
	[189][80] = 188,
	[189][81] = 188,
	[189][82] = 188,
	[189][83] = 188,
	[189][84] = 188,
	[189][85] = 188,
	[189][86] = 188,
	[189][87] = 188,
	[189][88] = 188,
	[189][89] = 188,
	[189][90] = 188,
	[189][91] = 188,
	[189][92] = 188,
	[189][93] = 188,
	[189][94] = 188,
	[189][95] = 188,
	[189][96] = 188,
	[189][97] = 188,
	[189][98] = 188,
	[189][99] = 188,
	[189][100] = 188,
	[189][101] = 188,
	[189][102] = 188,
	[189][103] = 188,
	[189][104] = 188,
	[189][105] = 188,
	[189][106] = 188,
	[189][107] = 188,
	[189][108] = 188,
	[189][109] = 188,
	[189][110] = 188,
	[189][111] = 188,
	[189][112] = 188,
	[189][113] = 188,
	[189][114] = 188,
	[189][115] = 188,
	[189][116] = 188,
	[189][117] = 188,
	[189][118] = 188,
	[189][119] = 188,
	[189][120] = 188,
	[189][121] = 188,
	[189][122] = 188,
	[189][123] = 188,
	[189][124] = 188,
	[189][125] = 188,
	[189][126] = 188,
	[189][127] = 188,
	[189][128] = 188,
	[189][129] = 188,
	[189][130] = 188,
	[189][131] = 188,
	[189][132] = 188,
	[189][133] = 188,
	[189][134] = 188,
	[189][135] = 188,
	[189][136] = 188,
	[189][137] = 188,
	[189][138] = 188,
	[189][139] = 188,
	[189][140] = 188,
	[189][141] = 188,
	[189][142] = 188,
	[189][143] = 188,
	[189][144] = 188,
	[189][145] = 188,
	[189][146] = 188,
	[189][147] = 188,
	[189][148] = 188,
	[189][149] = 188,
	[189][150] = 188,
	[189][151] = 188,
	[189][152] = 188,
	[189][153] = 188,
	[189][154] = 188,
	[189][155] = 188,
	[189][156] = 188,
	[189][157] = 188,
	[189][158] = 188,
	[189][159] = 188,
	[189][160] = 188,
	[189][161] = 188,
	[189][162] = 188,
	[189][163] = 188,
	[189][164] = 188,
	[189][165] = 188,
	[189][166] = 188,
	[189][167] = 188,
	[189][168] = 188,
	[189][169] = 188,
	[189][170] = 188,
	[189][171] = 188,
	[189][172] = 188,
	[189][173] = 188,
	[189][174] = 188,
	[189][175] = 188,
	[189][176] = 188,
	[189][177] = 188,
	[189][178] = 188,
	[189][179] = 188,
	[189][180] = 188,
	[189][181] = 188,
	[189][182] = 188,
	[189][183] = 188,
	[189][184] = 188,
	[189][185] = 188,
	[189][186] = 188,
	[189][187] = 188,
	[189][188] = 188,
	[189][189] = 188,
	[189][190] = 188,
	[189][191] = 188,
	[189][192] = 188,
	[189][193] = 188,
	[189][194] = 188,
	[189][195] = 188,
	[189][196] = 188,
	[189][197] = 188,
	[189][198] = 188,
	[189][199] = 188,
	[189][200] = 188,
	[189][201] = 188,
	[189][202] = 188,
	[189][203] = 188,
	[189][204] = 188,
	[189][205] = 188,
	[189][206] = 188,
	[189][207] = 188,
	[189][208] = 188,
	[189][209] = 188,
	[189][210] = 188,
	[189][211] = 188,
	[189][212] = 188,
	[189][213] = 188,
	[189][214] = 188,
	[189][215] = 188,
	[189][216] = 188,
	[189][217] = 188,
	[189][218] = 188,
	[189][219] = 188,
	[189][220] = 188,
	[189][221] = 188,
	[189][222] = 188,
	[189][223] = 188,
	[189][224] = 188,
	[189][225] = 188,
	[189][226] = 188,
	[189][227] = 188,
	[189][228] = 188,
	[189][229] = 188,
	[189][230] = 188,
	[189][231] = 188,
	[189][232] = 188,
	[189][233] = 188,
	[189][234] = 188,
	[189][235] = 188,
	[189][236] = 188,
	[189][237] = 188,
	[189][238] = 188,
	[189][239] = 188,
	[189][240] = 188,
	[189][241] = 188,
	[189][242] = 188,
	[189][243] = 188,
	[189][244] = 188,
	[189][245] = 188,
	[189][246] = 188,
	[189][247] = 188,
	[189][248] = 188,
	[189][249] = 188,
	[189][250] = 188,
	[189][251] = 188,
	[189][252] = 188,
	[189][253] = 188,
	[189][254] = 188,
	[189][255] = 188,
	[190][0] = 190,
	[190][1] = 190,
	[190][2] = 190,
	[190][3] = 190,
	[190][4] = 190,
	[190][5] = 190,
	[190][6] = 190,
	[190][7] = 190,
	[190][8] = 190,
	[190][9] = 190,
	[190][10] = 129,
	[190][11] = 190,
	[190][12] = 190,
	[190][13] = 190,
	[190][14] = 190,
	[190][15] = 190,
	[190][16] = 190,
	[190][17] = 190,
	[190][18] = 190,
	[190][19] = 190,
	[190][20] = 190,
	[190][21] = 190,
	[190][22] = 190,
	[190][23] = 190,
	[190][24] = 190,
	[190][25] = 190,
	[190][26] = 190,
	[190][27] = 190,
	[190][28] = 190,
	[190][29] = 190,
	[190][30] = 190,
	[190][31] = 190,
	[190][32] = 190,
	[190][33] = 190,
	[190][34] = 190,
	[190][35] = 190,
	[190][36] = 190,
	[190][37] = 190,
	[190][38] = 190,
	[190][39] = 190,
	[190][40] = 190,
	[190][41] = 190,
	[190][42] = 190,
	[190][43] = 190,
	[190][44] = 190,
	[190][45] = 190,
	[190][46] = 190,
	[190][47] = 190,
	[190][48] = 190,
	[190][49] = 190,
	[190][50] = 190,
	[190][51] = 190,
	[190][52] = 190,
	[190][53] = 190,
	[190][54] = 190,
	[190][55] = 190,
	[190][56] = 190,
	[190][57] = 190,
	[190][58] = 190,
	[190][59] = 190,
	[190][60] = 190,
	[190][61] = 190,
	[190][62] = 190,
	[190][63] = 190,
	[190][64] = 190,
	[190][65] = 190,
	[190][66] = 190,
	[190][67] = 190,
	[190][68] = 190,
	[190][69] = 190,
	[190][70] = 190,
	[190][71] = 190,
	[190][72] = 190,
	[190][73] = 190,
	[190][74] = 190,
	[190][75] = 190,
	[190][76] = 190,
	[190][77] = 190,
	[190][78] = 190,
	[190][79] = 190,
	[190][80] = 190,
	[190][81] = 190,
	[190][82] = 190,
	[190][83] = 190,
	[190][84] = 190,
	[190][85] = 190,
	[190][86] = 190,
	[190][87] = 190,
	[190][88] = 190,
	[190][89] = 190,
	[190][90] = 190,
	[190][91] = 190,
	[190][92] = 190,
	[190][93] = 190,
	[190][94] = 190,
	[190][95] = 190,
	[190][96] = 190,
	[190][97] = 190,
	[190][98] = 190,
	[190][99] = 190,
	[190][100] = 190,
	[190][101] = 190,
	[190][102] = 190,
	[190][103] = 190,
	[190][104] = 190,
	[190][105] = 190,
	[190][106] = 190,
	[190][107] = 190,
	[190][108] = 190,
	[190][109] = 190,
	[190][110] = 190,
	[190][111] = 190,
	[190][112] = 190,
	[190][113] = 190,
	[190][114] = 190,
	[190][115] = 190,
	[190][116] = 190,
	[190][117] = 190,
	[190][118] = 190,
	[190][119] = 190,
	[190][120] = 190,
	[190][121] = 190,
	[190][122] = 190,
	[190][123] = 190,
	[190][124] = 190,
	[190][125] = 190,
	[190][126] = 190,
	[190][127] = 190,
	[190][128] = 190,
	[190][129] = 190,
	[190][130] = 190,
	[190][131] = 190,
	[190][132] = 190,
	[190][133] = 190,
	[190][134] = 190,
	[190][135] = 190,
	[190][136] = 190,
	[190][137] = 190,
	[190][138] = 190,
	[190][139] = 190,
	[190][140] = 190,
	[190][141] = 190,
	[190][142] = 190,
	[190][143] = 190,
	[190][144] = 190,
	[190][145] = 190,
	[190][146] = 190,
	[190][147] = 190,
	[190][148] = 190,
	[190][149] = 190,
	[190][150] = 190,
	[190][151] = 190,
	[190][152] = 190,
	[190][153] = 190,
	[190][154] = 190,
	[190][155] = 190,
	[190][156] = 190,
	[190][157] = 190,
	[190][158] = 190,
	[190][159] = 190,
	[190][160] = 190,
	[190][161] = 190,
	[190][162] = 190,
	[190][163] = 190,
	[190][164] = 190,
	[190][165] = 190,
	[190][166] = 190,
	[190][167] = 190,
	[190][168] = 190,
	[190][169] = 190,
	[190][170] = 190,
	[190][171] = 190,
	[190][172] = 190,
	[190][173] = 190,
	[190][174] = 190,
	[190][175] = 190,
	[190][176] = 190,
	[190][177] = 190,
	[190][178] = 190,
	[190][179] = 190,
	[190][180] = 190,
	[190][181] = 190,
	[190][182] = 190,
	[190][183] = 190,
	[190][184] = 190,
	[190][185] = 190,
	[190][186] = 190,
	[190][187] = 190,
	[190][188] = 190,
	[190][189] = 190,
	[190][190] = 190,
	[190][191] = 190,
	[190][192] = 190,
	[190][193] = 190,
	[190][194] = 190,
	[190][195] = 190,
	[190][196] = 190,
	[190][197] = 190,
	[190][198] = 190,
	[190][199] = 190,
	[190][200] = 190,
	[190][201] = 190,
	[190][202] = 190,
	[190][203] = 190,
	[190][204] = 190,
	[190][205] = 190,
	[190][206] = 190,
	[190][207] = 190,
	[190][208] = 190,
	[190][209] = 190,
	[190][210] = 190,
	[190][211] = 190,
	[190][212] = 190,
	[190][213] = 190,
	[190][214] = 190,
	[190][215] = 190,
	[190][216] = 190,
	[190][217] = 190,
	[190][218] = 190,
	[190][219] = 190,
	[190][220] = 190,
	[190][221] = 190,
	[190][222] = 190,
	[190][223] = 190,
	[190][224] = 190,
	[190][225] = 190,
	[190][226] = 190,
	[190][227] = 190,
	[190][228] = 190,
	[190][229] = 190,
	[190][230] = 190,
	[190][231] = 190,
	[190][232] = 190,
	[190][233] = 190,
	[190][234] = 190,
	[190][235] = 190,
	[190][236] = 190,
	[190][237] = 190,
	[190][238] = 190,
	[190][239] = 190,
	[190][240] = 190,
	[190][241] = 190,
	[190][242] = 190,
	[190][243] = 190,
	[190][244] = 190,
	[190][245] = 190,
	[190][246] = 190,
	[190][247] = 190,
	[190][248] = 190,
	[190][249] = 190,
	[190][250] = 190,
	[190][251] = 190,
	[190][252] = 190,
	[190][253] = 190,
	[190][254] = 190,
	[190][255] = 190,
	[191][48] = 220,
	[191][49] = 220,
	[191][50] = 220,
	[191][51] = 220,
	[191][52] = 220,
	[191][53] = 220,
	[191][54] = 220,
	[191][55] = 220,
	[191][56] = 220,
	[191][57] = 220,
	[192][46] = 191,
	[192][48] = 192,
	[192][49] = 192,
	[192][50] = 192,
	[192][51] = 192,
	[192][52] = 192,
	[192][53] = 192,
	[192][54] = 192,
	[192][55] = 192,
	[192][56] = 192,
	[192][57] = 192,
	[193][49] = 181,
	[193][50] = 181,
	[193][51] = 181,
	[193][52] = 181,
	[193][53] = 181,
	[193][54] = 181,
	[193][55] = 181,
	[193][56] = 181,
	[193][57] = 181,
	[202][115] = 221,
	[203][102] = 222,
	[204][112] = 223,
	[206][98] = 224,
	[207][114] = 225,
	[208][116] = 226,
	[209][105] = 227,
	[210][97] = 228,
	[211][105] = 229,
	[212][114] = 230,
	[213][48] = 142,
	[213][49] = 142,
	[213][50] = 142,
	[213][51] = 142,
	[213][52] = 142,
	[213][53] = 142,
	[213][54] = 142,
	[213][55] = 142,
	[213][56] = 142,
	[213][57] = 142,
	[213][95] = 142,
	[213][97] = 142,
	[213][98] = 142,
	[213][99] = 142,
	[213][100] = 142,
	[213][101] = 142,
	[213][102] = 142,
	[213][103] = 142,
	[213][104] = 142,
	[213][105] = 142,
	[213][106] = 142,
	[213][107] = 142,
	[213][108] = 142,
	[213][109] = 142,
	[213][110] = 142,
	[213][111] = 231,
	[213][112] = 142,
	[213][113] = 142,
	[213][114] = 142,
	[213][115] = 142,
	[213][116] = 142,
	[213][117] = 142,
	[213][118] = 142,
	[213][119] = 142,
	[213][120] = 142,
	[213][121] = 142,
	[213][122] = 142,
	[214][48] = 142,
	[214][49] = 142,
	[214][50] = 142,
	[214][51] = 142,
	[214][52] = 142,
	[214][53] = 142,
	[214][54] = 142,
	[214][55] = 142,
	[214][56] = 142,
	[214][57] = 142,
	[214][95] = 142,
	[214][97] = 232,
	[214][98] = 142,
	[214][99] = 142,
	[214][100] = 142,
	[214][101] = 142,
	[214][102] = 142,
	[214][103] = 142,
	[214][104] = 142,
	[214][105] = 142,
	[214][106] = 142,
	[214][107] = 142,
	[214][108] = 142,
	[214][109] = 142,
	[214][110] = 142,
	[214][111] = 142,
	[214][112] = 142,
	[214][113] = 142,
	[214][114] = 142,
	[214][115] = 142,
	[214][116] = 142,
	[214][117] = 142,
	[214][118] = 142,
	[214][119] = 142,
	[214][120] = 142,
	[214][121] = 142,
	[214][122] = 142,
	[215][48] = 142,
	[215][49] = 142,
	[215][50] = 142,
	[215][51] = 142,
	[215][52] = 142,
	[215][53] = 142,
	[215][54] = 142,
	[215][55] = 142,
	[215][56] = 142,
	[215][57] = 142,
	[215][95] = 142,
	[215][97] = 142,
	[215][98] = 142,
	[215][99] = 142,
	[215][100] = 142,
	[215][101] = 142,
	[215][102] = 142,
	[215][103] = 142,
	[215][104] = 142,
	[215][105] = 142,
	[215][106] = 142,
	[215][107] = 142,
	[215][108] = 142,
	[215][109] = 142,
	[215][110] = 142,
	[215][111] = 233,
	[215][112] = 142,
	[215][113] = 142,
	[215][114] = 142,
	[215][115] = 142,
	[215][116] = 142,
	[215][117] = 142,
	[215][118] = 142,
	[215][119] = 142,
	[215][120] = 142,
	[215][121] = 142,
	[215][122] = 142,
	[216][48] = 142,
	[216][49] = 142,
	[216][50] = 142,
	[216][51] = 142,
	[216][52] = 142,
	[216][53] = 142,
	[216][54] = 142,
	[216][55] = 142,
	[216][56] = 142,
	[216][57] = 142,
	[216][95] = 142,
	[216][97] = 142,
	[216][98] = 142,
	[216][99] = 142,
	[216][100] = 142,
	[216][101] = 142,
	[216][102] = 142,
	[216][103] = 142,
	[216][104] = 142,
	[216][105] = 142,
	[216][106] = 142,
	[216][107] = 142,
	[216][108] = 142,
	[216][109] = 142,
	[216][110] = 142,
	[216][111] = 142,
	[216][112] = 142,
	[216][113] = 142,
	[216][114] = 142,
	[216][115] = 142,
	[216][116] = 234,
	[216][117] = 142,
	[216][118] = 142,
	[216][119] = 142,
	[216][120] = 142,
	[216][121] = 142,
	[216][122] = 142,
	[218][91] = 235,
	[218][95] = 218,
	[218][97] = 218,
	[218][98] = 218,
	[218][99] = 218,
	[218][100] = 218,
	[218][101] = 218,
	[218][102] = 218,
	[218][103] = 218,
	[218][104] = 218,
	[218][105] = 218,
	[218][106] = 218,
	[218][107] = 218,
	[218][108] = 218,
	[218][109] = 218,
	[218][110] = 218,
	[218][111] = 218,
	[218][112] = 218,
	[218][113] = 218,
	[218][114] = 218,
	[218][115] = 218,
	[218][116] = 218,
	[218][117] = 218,
	[218][118] = 218,
	[218][119] = 218,
	[218][120] = 218,
	[218][121] = 218,
	[218][122] = 218,
	[220][48] = 220,
	[220][49] = 220,
	[220][50] = 220,
	[220][51] = 220,
	[220][52] = 220,
	[220][53] = 220,
	[220][54] = 220,
	[220][55] = 220,
	[220][56] = 220,
	[220][57] = 220,
	[223][108] = 236,
	[224][117] = 237,
	[225][111] = 238,
	[226][101] = 239,
	[227][112] = 240,
	[228][114] = 241,
	[229][110] = 242,
	[230][110] = 243,
	[231][48] = 142,
	[231][49] = 142,
	[231][50] = 142,
	[231][51] = 142,
	[231][52] = 142,
	[231][53] = 142,
	[231][54] = 142,
	[231][55] = 142,
	[231][56] = 142,
	[231][57] = 142,
	[231][95] = 142,
	[231][97] = 142,
	[231][98] = 142,
	[231][99] = 142,
	[231][100] = 142,
	[231][101] = 142,
	[231][102] = 142,
	[231][103] = 142,
	[231][104] = 142,
	[231][105] = 142,
	[231][106] = 142,
	[231][107] = 142,
	[231][108] = 244,
	[231][109] = 142,
	[231][110] = 142,
	[231][111] = 142,
	[231][112] = 142,
	[231][113] = 142,
	[231][114] = 142,
	[231][115] = 142,
	[231][116] = 142,
	[231][117] = 142,
	[231][118] = 142,
	[231][119] = 142,
	[231][120] = 142,
	[231][121] = 142,
	[231][122] = 142,
	[232][48] = 142,
	[232][49] = 142,
	[232][50] = 142,
	[232][51] = 142,
	[232][52] = 142,
	[232][53] = 142,
	[232][54] = 142,
	[232][55] = 142,
	[232][56] = 142,
	[232][57] = 142,
	[232][95] = 142,
	[232][97] = 142,
	[232][98] = 142,
	[232][99] = 142,
	[232][100] = 142,
	[232][101] = 142,
	[232][102] = 142,
	[232][103] = 142,
	[232][104] = 142,
	[232][105] = 142,
	[232][106] = 142,
	[232][107] = 142,
	[232][108] = 142,
	[232][109] = 142,
	[232][110] = 142,
	[232][111] = 142,
	[232][112] = 142,
	[232][113] = 142,
	[232][114] = 245,
	[232][115] = 142,
	[232][116] = 142,
	[232][117] = 142,
	[232][118] = 142,
	[232][119] = 142,
	[232][120] = 142,
	[232][121] = 142,
	[232][122] = 142,
	[233][48] = 142,
	[233][49] = 142,
	[233][50] = 142,
	[233][51] = 142,
	[233][52] = 142,
	[233][53] = 142,
	[233][54] = 142,
	[233][55] = 142,
	[233][56] = 142,
	[233][57] = 142,
	[233][95] = 142,
	[233][97] = 246,
	[233][98] = 142,
	[233][99] = 142,
	[233][100] = 142,
	[233][101] = 142,
	[233][102] = 142,
	[233][103] = 142,
	[233][104] = 142,
	[233][105] = 142,
	[233][106] = 142,
	[233][107] = 142,
	[233][108] = 142,
	[233][109] = 142,
	[233][110] = 142,
	[233][111] = 142,
	[233][112] = 142,
	[233][113] = 142,
	[233][114] = 142,
	[233][115] = 142,
	[233][116] = 142,
	[233][117] = 142,
	[233][118] = 142,
	[233][119] = 142,
	[233][120] = 142,
	[233][121] = 142,
	[233][122] = 142,
	[234][48] = 142,
	[234][49] = 142,
	[234][50] = 142,
	[234][51] = 142,
	[234][52] = 142,
	[234][53] = 142,
	[234][54] = 142,
	[234][55] = 142,
	[234][56] = 142,
	[234][57] = 142,
	[234][95] = 142,
	[234][97] = 142,
	[234][98] = 142,
	[234][99] = 142,
	[234][100] = 142,
	[234][101] = 142,
	[234][102] = 142,
	[234][103] = 142,
	[234][104] = 142,
	[234][105] = 142,
	[234][106] = 142,
	[234][107] = 142,
	[234][108] = 142,
	[234][109] = 142,
	[234][110] = 142,
	[234][111] = 142,
	[234][112] = 142,
	[234][113] = 142,
	[234][114] = 142,
	[234][115] = 142,
	[234][116] = 142,
	[234][117] = 142,
	[234][118] = 142,
	[234][119] = 142,
	[234][120] = 142,
	[234][121] = 142,
	[234][122] = 142,
	[235][93] = 247,
	[236][105] = 248,
	[237][103] = 249,
	[238][114] = 250,
	[241][116] = 251,
	[242][103] = 252,
	[243][105] = 253,
	[244][48] = 142,
	[244][49] = 142,
	[244][50] = 142,
	[244][51] = 142,
	[244][52] = 142,
	[244][53] = 142,
	[244][54] = 142,
	[244][55] = 142,
	[244][56] = 142,
	[244][57] = 142,
	[244][95] = 142,
	[244][97] = 142,
	[244][98] = 142,
	[244][99] = 142,
	[244][100] = 142,
	[244][101] = 142,
	[244][102] = 142,
	[244][103] = 142,
	[244][104] = 142,
	[244][105] = 142,
	[244][106] = 142,
	[244][107] = 142,
	[244][108] = 142,
	[244][109] = 142,
	[244][110] = 142,
	[244][111] = 142,
	[244][112] = 142,
	[244][113] = 142,
	[244][114] = 142,
	[244][115] = 142,
	[244][116] = 142,
	[244][117] = 142,
	[244][118] = 142,
	[244][119] = 142,
	[244][120] = 142,
	[244][121] = 142,
	[244][122] = 142,
	[245][48] = 142,
	[245][49] = 142,
	[245][50] = 142,
	[245][51] = 142,
	[245][52] = 142,
	[245][53] = 142,
	[245][54] = 142,
	[245][55] = 142,
	[245][56] = 142,
	[245][57] = 142,
	[245][95] = 142,
	[245][97] = 142,
	[245][98] = 142,
	[245][99] = 142,
	[245][100] = 142,
	[245][101] = 142,
	[245][102] = 142,
	[245][103] = 142,
	[245][104] = 142,
	[245][105] = 142,
	[245][106] = 142,
	[245][107] = 142,
	[245][108] = 142,
	[245][109] = 142,
	[245][110] = 142,
	[245][111] = 142,
	[245][112] = 142,
	[245][113] = 142,
	[245][114] = 142,
	[245][115] = 142,
	[245][116] = 142,
	[245][117] = 142,
	[245][118] = 142,
	[245][119] = 142,
	[245][120] = 142,
	[245][121] = 142,
	[245][122] = 142,
	[246][48] = 142,
	[246][49] = 142,
	[246][50] = 142,
	[246][51] = 142,
	[246][52] = 142,
	[246][53] = 142,
	[246][54] = 142,
	[246][55] = 142,
	[246][56] = 142,
	[246][57] = 142,
	[246][95] = 142,
	[246][97] = 142,
	[246][98] = 142,
	[246][99] = 142,
	[246][100] = 142,
	[246][101] = 142,
	[246][102] = 142,
	[246][103] = 142,
	[246][104] = 142,
	[246][105] = 142,
	[246][106] = 142,
	[246][107] = 142,
	[246][108] = 142,
	[246][109] = 142,
	[246][110] = 142,
	[246][111] = 142,
	[246][112] = 142,
	[246][113] = 142,
	[246][114] = 142,
	[246][115] = 142,
	[246][116] = 254,
	[246][117] = 142,
	[246][118] = 142,
	[246][119] = 142,
	[246][120] = 142,
	[246][121] = 142,
	[246][122] = 142,
	[248][101] = 255,
	[253][110] = 256,
	[254][48] = 142,
	[254][49] = 142,
	[254][50] = 142,
	[254][51] = 142,
	[254][52] = 142,
	[254][53] = 142,
	[254][54] = 142,
	[254][55] = 142,
	[254][56] = 142,
	[254][57] = 142,
	[254][95] = 142,
	[254][97] = 142,
	[254][98] = 142,
	[254][99] = 142,
	[254][100] = 142,
	[254][101] = 142,
	[254][102] = 142,
	[254][103] = 142,
	[254][104] = 142,
	[254][105] = 142,
	[254][106] = 142,
	[254][107] = 142,
	[254][108] = 142,
	[254][109] = 142,
	[254][110] = 142,
	[254][111] = 142,
	[254][112] = 142,
	[254][113] = 142,
	[254][114] = 142,
	[254][115] = 142,
	[254][116] = 142,
	[254][117] = 142,
	[254][118] = 142,
	[254][119] = 142,
	[254][120] = 142,
	[254][121] = 142,
	[254][122] = 142,
	[255][115] = 257,
	[256][103] = 258,
};


const unsigned zebu_lexer_starts[1221] = {
	[1] = 1,
	[2] = 2,
	[3] = 2,
	[4] = 3,
	[5] = 4,
	[6] = 4,
	[7] = 2,
	[8] = 5,
	[9] = 4,
	[10] = 2,
	[11] = 6,
	[12] = 4,
	[13] = 7,
	[14] = 8,
	[15] = 9,
	[16] = 10,
	[17] = 11,
	[18] = 12,
	[19] = 13,
	[20] = 14,
	[21] = 15,
	[22] = 16,
	[23] = 11,
	[24] = 17,
	[25] = 18,
	[26] = 12,
	[27] = 19,
	[28] = 20,
	[29] = 21,
	[30] = 22,
	[31] = 2,
	[32] = 2,
	[33] = 23,
	[34] = 24,
	[35] = 11,
	[36] = 11,
	[37] = 15,
	[38] = 11,
	[39] = 11,
	[40] = 25,
	[41] = 25,
	[42] = 3,
	[43] = 2,
	[44] = 4,
	[45] = 4,
	[46] = 26,
	[47] = 25,
	[48] = 5,
	[49] = 4,
	[50] = 25,
	[51] = 25,
	[52] = 4,
	[53] = 8,
	[54] = 27,
	[55] = 28,
	[56] = 29,
	[57] = 30,
	[58] = 31,
	[59] = 32,
	[60] = 33,
	[61] = 34,
	[62] = 35,
	[63] = 29,
	[64] = 36,
	[65] = 37,
	[66] = 38,
	[67] = 39,
	[68] = 25,
	[69] = 25,
	[70] = 40,
	[71] = 41,
	[72] = 32,
	[73] = 2,
	[74] = 15,
	[75] = 15,
	[76] = 42,
	[77] = 42,
	[78] = 3,
	[79] = 4,
	[80] = 4,
	[81] = 26,
	[82] = 42,
	[83] = 5,
	[84] = 2,
	[85] = 4,
	[86] = 42,
	[87] = 42,
	[88] = 4,
	[89] = 8,
	[90] = 43,
	[91] = 44,
	[92] = 45,
	[93] = 46,
	[94] = 47,
	[95] = 48,
	[96] = 49,
	[97] = 50,
	[98] = 51,
	[99] = 45,
	[100] = 52,
	[101] = 53,
	[102] = 54,
	[103] = 55,
	[104] = 42,
	[105] = 42,
	[106] = 56,
	[107] = 57,
	[108] = 48,
	[109] = 15,
	[110] = 58,
	[111] = 26,
	[112] = 15,
	[113] = 59,
	[114] = 60,
	[115] = 60,
	[116] = 60,
	[117] = 60,
	[118] = 60,
	[119] = 60,
	[120] = 61,
	[121] = 62,
	[122] = 63,
	[123] = 26,
	[124] = 63,
	[125] = 63,
	[126] = 63,
	[127] = 63,
	[128] = 8,
	[129] = 63,
	[130] = 64,
	[131] = 4,
	[132] = 4,
	[133] = 4,
	[134] = 65,
	[135] = 11,
	[136] = 11,
	[137] = 11,
	[138] = 11,
	[139] = 11,
	[140] = 11,
	[141] = 4,
	[142] = 4,
	[143] = 4,
	[144] = 4,
	[145] = 11,
	[146] = 11,
	[147] = 65,
	[148] = 11,
	[149] = 11,
	[150] = 11,
	[151] = 11,
	[152] = 11,
	[153] = 11,
	[154] = 26,
	[155] = 4,
	[156] = 64,
	[157] = 4,
	[158] = 26,
	[159] = 4,
	[160] = 4,
	[161] = 4,
	[162] = 4,
	[163] = 26,
	[164] = 3,
	[165] = 26,
	[166] = 64,
	[167] = 4,
	[168] = 4,
	[169] = 4,
	[170] = 4,
	[171] = 4,
	[172] = 4,
	[173] = 65,
	[174] = 11,
	[175] = 11,
	[176] = 11,
	[177] = 11,
	[178] = 11,
	[179] = 11,
	[180] = 65,
	[181] = 11,
	[182] = 11,
	[183] = 11,
	[184] = 11,
	[185] = 11,
	[186] = 11,
	[187] = 65,
	[188] = 11,
	[189] = 11,
	[190] = 11,
	[191] = 11,
	[192] = 11,
	[193] = 11,
	[194] = 65,
	[195] = 11,
	[196] = 11,
	[197] = 11,
	[198] = 11,
	[199] = 11,
	[200] = 11,
	[201] = 25,
	[202] = 26,
	[203] = 33,
	[204] = 32,
	[205] = 32,
	[206] = 2,
	[207] = 33,
	[208] = 26,
	[209] = 25,
	[210] = 49,
	[211] = 32,
	[212] = 32,
	[213] = 62,
	[214] = 26,
	[215] = 64,
	[216] = 4,
	[217] = 4,
	[218] = 4,
	[219] = 4,
	[220] = 4,
	[221] = 4,
	[222] = 4,
	[223] = 2,
	[224] = 26,
	[225] = 26,
	[226] = 4,
	[227] = 64,
	[228] = 4,
	[229] = 26,
	[230] = 4,
	[231] = 4,
	[232] = 4,
	[233] = 4,
	[234] = 26,
	[235] = 3,
	[236] = 26,
	[237] = 64,
	[238] = 4,
	[239] = 4,
	[240] = 4,
	[241] = 4,
	[242] = 4,
	[243] = 4,
	[244] = 42,
	[245] = 26,
	[246] = 33,
	[247] = 48,
	[248] = 48,
	[249] = 2,
	[250] = 49,
	[251] = 26,
	[252] = 42,
	[253] = 49,
	[254] = 48,
	[255] = 48,
	[256] = 62,
	[257] = 26,
	[258] = 64,
	[259] = 4,
	[260] = 4,
	[261] = 4,
	[262] = 4,
	[263] = 4,
	[264] = 4,
	[265] = 4,
	[266] = 26,
	[267] = 2,
	[268] = 26,
	[269] = 4,
	[270] = 64,
	[271] = 4,
	[272] = 26,
	[273] = 4,
	[274] = 4,
	[275] = 4,
	[276] = 4,
	[277] = 26,
	[278] = 3,
	[279] = 26,
	[280] = 64,
	[281] = 4,
	[282] = 4,
	[283] = 4,
	[284] = 4,
	[285] = 4,
	[286] = 4,
	[287] = 66,
	[288] = 66,
	[289] = 58,
	[290] = 66,
	[291] = 67,
	[292] = 66,
	[293] = 68,
	[294] = 16,
	[295] = 69,
	[296] = 70,
	[297] = 71,
	[298] = 16,
	[299] = 16,
	[300] = 68,
	[301] = 58,
	[302] = 26,
	[303] = 26,
	[304] = 26,
	[305] = 26,
	[306] = 61,
	[307] = 63,
	[308] = 62,
	[309] = 72,
	[310] = 72,
	[311] = 72,
	[312] = 72,
	[313] = 72,
	[314] = 8,
	[315] = 72,
	[316] = 33,
	[317] = 73,
	[318] = 12,
	[319] = 74,
	[320] = 64,
	[321] = 12,
	[322] = 12,
	[323] = 61,
	[324] = 62,
	[325] = 75,
	[326] = 62,
	[327] = 75,
	[328] = 75,
	[329] = 75,
	[330] = 75,
	[331] = 8,
	[332] = 75,
	[333] = 74,
	[334] = 63,
	[335] = 74,
	[336] = 21,
	[337] = 21,
	[338] = 13,
	[339] = 65,
	[340] = 65,
	[341] = 65,
	[342] = 65,
	[343] = 65,
	[344] = 65,
	[345] = 23,
	[346] = 23,
	[347] = 10,
	[348] = 15,
	[349] = 65,
	[350] = 65,
	[351] = 65,
	[352] = 65,
	[353] = 65,
	[354] = 65,
	[355] = 16,
	[356] = 17,
	[357] = 14,
	[358] = 22,
	[359] = 18,
	[360] = 76,
	[361] = 76,
	[362] = 3,
	[363] = 4,
	[364] = 4,
	[365] = 76,
	[366] = 5,
	[367] = 4,
	[368] = 76,
	[369] = 76,
	[370] = 4,
	[371] = 8,
	[372] = 77,
	[373] = 78,
	[374] = 79,
	[375] = 80,
	[376] = 81,
	[377] = 82,
	[378] = 60,
	[379] = 83,
	[380] = 84,
	[381] = 79,
	[382] = 85,
	[383] = 86,
	[384] = 87,
	[385] = 88,
	[386] = 76,
	[387] = 76,
	[388] = 89,
	[389] = 90,
	[390] = 82,
	[391] = 19,
	[392] = 15,
	[393] = 15,
	[394] = 15,
	[395] = 17,
	[396] = 22,
	[397] = 2,
	[398] = 26,
	[399] = 33,
	[400] = 91,
	[401] = 91,
	[402] = 3,
	[403] = 4,
	[404] = 4,
	[405] = 91,
	[406] = 5,
	[407] = 4,
	[408] = 91,
	[409] = 91,
	[410] = 4,
	[411] = 8,
	[412] = 92,
	[413] = 93,
	[414] = 94,
	[415] = 95,
	[416] = 96,
	[417] = 97,
	[418] = 98,
	[419] = 99,
	[420] = 100,
	[421] = 94,
	[422] = 101,
	[423] = 102,
	[424] = 103,
	[425] = 104,
	[426] = 91,
	[427] = 91,
	[428] = 105,
	[429] = 106,
	[430] = 97,
	[431] = 2,
	[432] = 24,
	[433] = 24,
	[434] = 24,
	[435] = 24,
	[436] = 9,
	[437] = 9,
	[438] = 65,
	[439] = 65,
	[440] = 65,
	[441] = 65,
	[442] = 65,
	[443] = 65,
	[444] = 65,
	[445] = 65,
	[446] = 65,
	[447] = 65,
	[448] = 65,
	[449] = 65,
	[450] = 65,
	[451] = 65,
	[452] = 65,
	[453] = 65,
	[454] = 65,
	[455] = 65,
	[456] = 65,
	[457] = 65,
	[458] = 65,
	[459] = 65,
	[460] = 65,
	[461] = 65,
	[462] = 25,
	[463] = 33,
	[464] = 25,
	[465] = 26,
	[466] = 2,
	[467] = 26,
	[468] = 25,
	[469] = 49,
	[470] = 26,
	[471] = 25,
	[472] = 29,
	[473] = 74,
	[474] = 29,
	[475] = 29,
	[476] = 74,
	[477] = 38,
	[478] = 38,
	[479] = 30,
	[480] = 40,
	[481] = 40,
	[482] = 28,
	[483] = 32,
	[484] = 2,
	[485] = 33,
	[486] = 34,
	[487] = 31,
	[488] = 39,
	[489] = 35,
	[490] = 60,
	[491] = 36,
	[492] = 32,
	[493] = 32,
	[494] = 32,
	[495] = 34,
	[496] = 39,
	[497] = 25,
	[498] = 26,
	[499] = 33,
	[500] = 98,
	[501] = 25,
	[502] = 41,
	[503] = 41,
	[504] = 41,
	[505] = 41,
	[506] = 27,
	[507] = 27,
	[508] = 42,
	[509] = 33,
	[510] = 42,
	[511] = 26,
	[512] = 26,
	[513] = 2,
	[514] = 42,
	[515] = 49,
	[516] = 26,
	[517] = 42,
	[518] = 45,
	[519] = 74,
	[520] = 45,
	[521] = 45,
	[522] = 74,
	[523] = 54,
	[524] = 54,
	[525] = 46,
	[526] = 56,
	[527] = 56,
	[528] = 44,
	[529] = 48,
	[530] = 2,
	[531] = 49,
	[532] = 50,
	[533] = 47,
	[534] = 55,
	[535] = 51,
	[536] = 60,
	[537] = 52,
	[538] = 48,
	[539] = 48,
	[540] = 48,
	[541] = 50,
	[542] = 55,
	[543] = 42,
	[544] = 26,
	[545] = 33,
	[546] = 98,
	[547] = 42,
	[548] = 57,
	[549] = 57,
	[550] = 57,
	[551] = 57,
	[552] = 43,
	[553] = 43,
	[554] = 66,
	[555] = 66,
	[556] = 107,
	[557] = 107,
	[558] = 58,
	[559] = 107,
	[560] = 67,
	[561] = 107,
	[562] = 68,
	[563] = 108,
	[564] = 109,
	[565] = 110,
	[566] = 111,
	[567] = 66,
	[568] = 112,
	[569] = 112,
	[570] = 67,
	[571] = 113,
	[572] = 98,
	[573] = 112,
	[574] = 114,
	[575] = 112,
	[576] = 115,
	[577] = 116,
	[578] = 66,
	[579] = 117,
	[580] = 117,
	[581] = 68,
	[582] = 117,
	[583] = 67,
	[584] = 118,
	[585] = 117,
	[586] = 119,
	[587] = 120,
	[588] = 11,
	[589] = 71,
	[590] = 71,
	[591] = 71,
	[592] = 58,
	[593] = 71,
	[594] = 11,
	[595] = 11,
	[596] = 121,
	[597] = 121,
	[598] = 68,
	[599] = 121,
	[600] = 67,
	[601] = 16,
	[602] = 121,
	[603] = 70,
	[604] = 122,
	[605] = 16,
	[606] = 11,
	[607] = 16,
	[608] = 11,
	[609] = 11,
	[610] = 11,
	[611] = 72,
	[612] = 62,
	[613] = 33,
	[614] = 63,
	[615] = 33,
	[616] = 62,
	[617] = 62,
	[618] = 74,
	[619] = 72,
	[620] = 63,
	[621] = 62,
	[622] = 62,
	[623] = 26,
	[624] = 74,
	[625] = 75,
	[626] = 62,
	[627] = 33,
	[628] = 64,
	[629] = 74,
	[630] = 64,
	[631] = 64,
	[632] = 62,
	[633] = 62,
	[634] = 74,
	[635] = 75,
	[636] = 62,
	[637] = 62,
	[638] = 62,
	[639] = 26,
	[640] = 26,
	[641] = 76,
	[642] = 26,
	[643] = 33,
	[644] = 82,
	[645] = 82,
	[646] = 26,
	[647] = 76,
	[648] = 49,
	[649] = 82,
	[650] = 82,
	[651] = 62,
	[652] = 26,
	[653] = 64,
	[654] = 4,
	[655] = 4,
	[656] = 4,
	[657] = 4,
	[658] = 4,
	[659] = 4,
	[660] = 4,
	[661] = 4,
	[662] = 26,
	[663] = 4,
	[664] = 64,
	[665] = 4,
	[666] = 26,
	[667] = 4,
	[668] = 4,
	[669] = 4,
	[670] = 4,
	[671] = 26,
	[672] = 3,
	[673] = 26,
	[674] = 64,
	[675] = 4,
	[676] = 4,
	[677] = 4,
	[678] = 4,
	[679] = 4,
	[680] = 4,
	[681] = 26,
	[682] = 2,
	[683] = 33,
	[684] = 2,
	[685] = 26,
	[686] = 91,
	[687] = 26,
	[688] = 33,
	[689] = 97,
	[690] = 97,
	[691] = 26,
	[692] = 91,
	[693] = 49,
	[694] = 97,
	[695] = 97,
	[696] = 62,
	[697] = 26,
	[698] = 64,
	[699] = 4,
	[700] = 4,
	[701] = 4,
	[702] = 4,
	[703] = 4,
	[704] = 4,
	[705] = 4,
	[706] = 2,
	[707] = 26,
	[708] = 4,
	[709] = 64,
	[710] = 4,
	[711] = 26,
	[712] = 4,
	[713] = 4,
	[714] = 4,
	[715] = 4,
	[716] = 26,
	[717] = 3,
	[718] = 26,
	[719] = 64,
	[720] = 4,
	[721] = 4,
	[722] = 4,
	[723] = 4,
	[724] = 4,
	[725] = 4,
	[726] = 25,
	[727] = 26,
	[728] = 25,
	[729] = 2,
	[730] = 26,
	[731] = 25,
	[732] = 25,
	[733] = 62,
	[734] = 26,
	[735] = 62,
	[736] = 26,
	[737] = 26,
	[738] = 4,
	[739] = 26,
	[740] = 25,
	[741] = 33,
	[742] = 25,
	[743] = 26,
	[744] = 25,
	[745] = 42,
	[746] = 26,
	[747] = 42,
	[748] = 2,
	[749] = 26,
	[750] = 42,
	[751] = 42,
	[752] = 62,
	[753] = 26,
	[754] = 62,
	[755] = 26,
	[756] = 26,
	[757] = 4,
	[758] = 26,
	[759] = 42,
	[760] = 33,
	[761] = 42,
	[762] = 26,
	[763] = 42,
	[764] = 66,
	[765] = 69,
	[766] = 66,
	[767] = 69,
	[768] = 107,
	[769] = 107,
	[770] = 108,
	[771] = 107,
	[772] = 98,
	[773] = 107,
	[774] = 118,
	[775] = 66,
	[776] = 111,
	[777] = 111,
	[778] = 111,
	[779] = 58,
	[780] = 111,
	[781] = 66,
	[782] = 69,
	[783] = 123,
	[784] = 123,
	[785] = 67,
	[786] = 113,
	[787] = 108,
	[788] = 123,
	[789] = 124,
	[790] = 123,
	[791] = 125,
	[792] = 126,
	[793] = 112,
	[794] = 66,
	[795] = 67,
	[796] = 67,
	[797] = 67,
	[798] = 67,
	[799] = 67,
	[800] = 116,
	[801] = 66,
	[802] = 69,
	[803] = 127,
	[804] = 127,
	[805] = 68,
	[806] = 127,
	[807] = 67,
	[808] = 108,
	[809] = 127,
	[810] = 110,
	[811] = 128,
	[812] = 98,
	[813] = 66,
	[814] = 120,
	[815] = 120,
	[816] = 120,
	[817] = 68,
	[818] = 120,
	[819] = 16,
	[820] = 70,
	[821] = 70,
	[822] = 71,
	[823] = 108,
	[824] = 98,
	[825] = 11,
	[826] = 122,
	[827] = 122,
	[828] = 122,
	[829] = 68,
	[830] = 122,
	[831] = 11,
	[832] = 11,
	[833] = 72,
	[834] = 33,
	[835] = 72,
	[836] = 62,
	[837] = 63,
	[838] = 62,
	[839] = 33,
	[840] = 74,
	[841] = 33,
	[842] = 33,
	[843] = 62,
	[844] = 62,
	[845] = 63,
	[846] = 12,
	[847] = 12,
	[848] = 75,
	[849] = 33,
	[850] = 75,
	[851] = 62,
	[852] = 62,
	[853] = 62,
	[854] = 74,
	[855] = 74,
	[856] = 74,
	[857] = 74,
	[858] = 62,
	[859] = 62,
	[860] = 64,
	[861] = 64,
	[862] = 12,
	[863] = 12,
	[864] = 16,
	[865] = 76,
	[866] = 33,
	[867] = 76,
	[868] = 26,
	[869] = 76,
	[870] = 49,
	[871] = 26,
	[872] = 76,
	[873] = 79,
	[874] = 74,
	[875] = 79,
	[876] = 79,
	[877] = 74,
	[878] = 87,
	[879] = 87,
	[880] = 80,
	[881] = 89,
	[882] = 89,
	[883] = 78,
	[884] = 82,
	[885] = 12,
	[886] = 60,
	[887] = 83,
	[888] = 81,
	[889] = 88,
	[890] = 84,
	[891] = 60,
	[892] = 85,
	[893] = 82,
	[894] = 82,
	[895] = 82,
	[896] = 83,
	[897] = 88,
	[898] = 76,
	[899] = 26,
	[900] = 33,
	[901] = 98,
	[902] = 76,
	[903] = 90,
	[904] = 90,
	[905] = 90,
	[906] = 90,
	[907] = 77,
	[908] = 77,
	[909] = 17,
	[910] = 2,
	[911] = 26,
	[912] = 2,
	[913] = 91,
	[914] = 33,
	[915] = 91,
	[916] = 26,
	[917] = 91,
	[918] = 49,
	[919] = 26,
	[920] = 91,
	[921] = 94,
	[922] = 74,
	[923] = 94,
	[924] = 94,
	[925] = 74,
	[926] = 103,
	[927] = 103,
	[928] = 95,
	[929] = 105,
	[930] = 105,
	[931] = 93,
	[932] = 97,
	[933] = 98,
	[934] = 99,
	[935] = 96,
	[936] = 104,
	[937] = 100,
	[938] = 60,
	[939] = 101,
	[940] = 97,
	[941] = 97,
	[942] = 97,
	[943] = 99,
	[944] = 104,
	[945] = 91,
	[946] = 26,
	[947] = 33,
	[948] = 98,
	[949] = 91,
	[950] = 106,
	[951] = 106,
	[952] = 106,
	[953] = 106,
	[954] = 92,
	[955] = 92,
	[956] = 25,
	[957] = 25,
	[958] = 29,
	[959] = 29,
	[960] = 29,
	[961] = 29,
	[962] = 33,
	[963] = 29,
	[964] = 34,
	[965] = 25,
	[966] = 26,
	[967] = 25,
	[968] = 42,
	[969] = 42,
	[970] = 45,
	[971] = 45,
	[972] = 45,
	[973] = 45,
	[974] = 49,
	[975] = 45,
	[976] = 50,
	[977] = 42,
	[978] = 26,
	[979] = 42,
	[980] = 69,
	[981] = 69,
	[982] = 107,
	[983] = 109,
	[984] = 107,
	[985] = 109,
	[986] = 107,
	[987] = 107,
	[988] = 109,
	[989] = 107,
	[990] = 107,
	[991] = 109,
	[992] = 107,
	[993] = 66,
	[994] = 108,
	[995] = 110,
	[996] = 110,
	[997] = 111,
	[998] = 69,
	[999] = 108,
	[1000] = 123,
	[1001] = 112,
	[1002] = 67,
	[1003] = 67,
	[1004] = 67,
	[1005] = 67,
	[1006] = 67,
	[1007] = 126,
	[1008] = 66,
	[1009] = 116,
	[1010] = 114,
	[1011] = 115,
	[1012] = 115,
	[1013] = 67,
	[1014] = 113,
	[1015] = 115,
	[1016] = 115,
	[1017] = 114,
	[1018] = 115,
	[1019] = 98,
	[1020] = 116,
	[1021] = 98,
	[1022] = 116,
	[1023] = 67,
	[1024] = 67,
	[1025] = 98,
	[1026] = 116,
	[1027] = 69,
	[1028] = 108,
	[1029] = 98,
	[1030] = 117,
	[1031] = 128,
	[1032] = 128,
	[1033] = 128,
	[1034] = 68,
	[1035] = 128,
	[1036] = 117,
	[1037] = 66,
	[1038] = 118,
	[1039] = 119,
	[1040] = 119,
	[1041] = 120,
	[1042] = 58,
	[1043] = 70,
	[1044] = 121,
	[1045] = 121,
	[1046] = 16,
	[1047] = 70,
	[1048] = 70,
	[1049] = 122,
	[1050] = 72,
	[1051] = 62,
	[1052] = 72,
	[1053] = 63,
	[1054] = 62,
	[1055] = 62,
	[1056] = 33,
	[1057] = 33,
	[1058] = 75,
	[1059] = 62,
	[1060] = 75,
	[1061] = 64,
	[1062] = 64,
	[1063] = 62,
	[1064] = 62,
	[1065] = 74,
	[1066] = 74,
	[1067] = 76,
	[1068] = 26,
	[1069] = 76,
	[1070] = 26,
	[1071] = 76,
	[1072] = 76,
	[1073] = 62,
	[1074] = 26,
	[1075] = 62,
	[1076] = 26,
	[1077] = 26,
	[1078] = 4,
	[1079] = 26,
	[1080] = 76,
	[1081] = 33,
	[1082] = 76,
	[1083] = 26,
	[1084] = 76,
	[1085] = 2,
	[1086] = 91,
	[1087] = 26,
	[1088] = 91,
	[1089] = 26,
	[1090] = 91,
	[1091] = 91,
	[1092] = 62,
	[1093] = 26,
	[1094] = 62,
	[1095] = 26,
	[1096] = 26,
	[1097] = 4,
	[1098] = 26,
	[1099] = 91,
	[1100] = 33,
	[1101] = 91,
	[1102] = 26,
	[1103] = 91,
	[1104] = 25,
	[1105] = 42,
	[1106] = 109,
	[1107] = 109,
	[1108] = 107,
	[1109] = 109,
	[1110] = 107,
	[1111] = 109,
	[1112] = 107,
	[1113] = 69,
	[1114] = 58,
	[1115] = 110,
	[1116] = 123,
	[1117] = 126,
	[1118] = 124,
	[1119] = 125,
	[1120] = 125,
	[1121] = 67,
	[1122] = 113,
	[1123] = 125,
	[1124] = 125,
	[1125] = 124,
	[1126] = 125,
	[1127] = 108,
	[1128] = 126,
	[1129] = 108,
	[1130] = 126,
	[1131] = 67,
	[1132] = 67,
	[1133] = 108,
	[1134] = 126,
	[1135] = 66,
	[1136] = 69,
	[1137] = 67,
	[1138] = 108,
	[1139] = 115,
	[1140] = 67,
	[1141] = 98,
	[1142] = 98,
	[1143] = 98,
	[1144] = 98,
	[1145] = 98,
	[1146] = 127,
	[1147] = 127,
	[1148] = 108,
	[1149] = 110,
	[1150] = 110,
	[1151] = 128,
	[1152] = 66,
	[1153] = 69,
	[1154] = 68,
	[1155] = 119,
	[1156] = 16,
	[1157] = 68,
	[1158] = 70,
	[1159] = 72,
	[1160] = 33,
	[1161] = 33,
	[1162] = 75,
	[1163] = 74,
	[1164] = 74,
	[1165] = 76,
	[1166] = 76,
	[1167] = 79,
	[1168] = 79,
	[1169] = 79,
	[1170] = 79,
	[1171] = 60,
	[1172] = 79,
	[1173] = 83,
	[1174] = 76,
	[1175] = 26,
	[1176] = 76,
	[1177] = 91,
	[1178] = 91,
	[1179] = 94,
	[1180] = 94,
	[1181] = 94,
	[1182] = 94,
	[1183] = 98,
	[1184] = 94,
	[1185] = 99,
	[1186] = 91,
	[1187] = 26,
	[1188] = 91,
	[1189] = 109,
	[1190] = 107,
	[1191] = 109,
	[1192] = 107,
	[1193] = 109,
	[1194] = 108,
	[1195] = 67,
	[1196] = 108,
	[1197] = 125,
	[1198] = 67,
	[1199] = 108,
	[1200] = 108,
	[1201] = 108,
	[1202] = 108,
	[1203] = 108,
	[1204] = 69,
	[1205] = 116,
	[1206] = 115,
	[1207] = 114,
	[1208] = 68,
	[1209] = 110,
	[1210] = 69,
	[1211] = 118,
	[1212] = 16,
	[1213] = 76,
	[1214] = 91,
	[1215] = 109,
	[1216] = 109,
	[1217] = 126,
	[1218] = 125,
	[1219] = 124,
	[1220] = 108,
};


const unsigned zebu_lexer_accepts[259] = {
	[129] = 1,
	[130] = 5,
	[132] = 14,
	[133] = 13,
	[135] = 4,
	[136] = 9,
	[137] = 6,
	[139] = 3,
	[140] = 3,
	[141] = 8,
	[142] = 11,
	[143] = 12,
	[145] = 15,
	[146] = 19,
	[147] = 20,
	[148] = 22,
	[149] = 36,
	[150] = 25,
	[152] = 26,
	[153] = 18,
	[154] = 16,
	[157] = 17,
	[158] = 37,
	[159] = 38,
	[160] = 39,
	[161] = 40,
	[162] = 41,
	[169] = 11,
	[170] = 11,
	[171] = 11,
	[172] = 11,
	[173] = 53,
	[177] = 19,
	[178] = 25,
	[179] = 26,
	[180] = 3,
	[181] = 3,
	[184] = 17,
	[185] = 15,
	[186] = 7,
	[194] = 30,
	[195] = 31,
	[196] = 21,
	[197] = 23,
	[198] = 27,
	[199] = 29,
	[200] = 28,
	[201] = 24,
	[205] = 32,
	[213] = 11,
	[214] = 11,
	[215] = 11,
	[216] = 11,
	[217] = 54,
	[218] = 55,
	[219] = 2,
	[220] = 10,
	[221] = 33,
	[222] = 35,
	[231] = 11,
	[232] = 11,
	[233] = 11,
	[234] = 49,
	[239] = 46,
	[240] = 43,
	[244] = 51,
	[245] = 50,
	[246] = 11,
	[247] = 55,
	[249] = 45,
	[250] = 48,
	[251] = 44,
	[252] = 42,
	[254] = 52,
	[257] = 34,
	[258] = 47,
};


const unsigned zebu_lexer_EOFs[66] = {
	[11] = 173,
	[65] = 173,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs(" ", stdout); break;
		case p_last_child: fputs(" ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m)\n");
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs(" ", stdout); break;
		case p_last_child: fputs(" ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs(" ", stdout); break;
		case p_last_child: fputs(" ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_0$parameter(struct link* links, enum prefix p, const char* name, struct zebu_0$parameter* ptree);

void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree);

void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree);

void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree);

void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree);

void print_zebu_charset_highest(struct link* links, enum prefix p, const char* name, struct zebu_charset_highest* ptree);

void print_zebu_charset_intersect(struct link* links, enum prefix p, const char* name, struct zebu_charset_intersect* ptree);

void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree);

void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree);

void print_zebu_charset_symdiff(struct link* links, enum prefix p, const char* name, struct zebu_charset_symdiff* ptree);

void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree);

void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree);

void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree);

void print_zebu_exponentiation_expression(struct link* links, enum prefix p, const char* name, struct zebu_exponentiation_expression* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_grammar(struct link* links, enum prefix p, const char* name, struct zebu_grammar* ptree);

void print_zebu_grammar_highest(struct link* links, enum prefix p, const char* name, struct zebu_grammar_highest* ptree);

void print_zebu_grammar_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_grammar_juxtaposition* ptree);

void print_zebu_grammar_postfix(struct link* links, enum prefix p, const char* name, struct zebu_grammar_postfix* ptree);

void print_zebu_grammar_rule(struct link* links, enum prefix p, const char* name, struct zebu_grammar_rule* ptree);

void print_zebu_implication_expression(struct link* links, enum prefix p, const char* name, struct zebu_implication_expression* ptree);

void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree);

void print_zebu_lambda_expression(struct link* links, enum prefix p, const char* name, struct zebu_lambda_expression* ptree);

void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree);

void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree);

void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree);

void print_zebu_possession_expression(struct link* links, enum prefix p, const char* name, struct zebu_possession_expression* ptree);

void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree);

void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree);

void print_zebu_primary_type(struct link* links, enum prefix p, const char* name, struct zebu_primary_type* ptree);

void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree);

void print_zebu_regex_highest(struct link* links, enum prefix p, const char* name, struct zebu_regex_highest* ptree);

void print_zebu_regex_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_regex_juxtaposition* ptree);

void print_zebu_regex_postfix(struct link* links, enum prefix p, const char* name, struct zebu_regex_postfix* ptree);

void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree);

void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree);

void print_zebu_skip_directive(struct link* links, enum prefix p, const char* name, struct zebu_skip_directive* ptree);

void print_zebu_start_directive(struct link* links, enum prefix p, const char* name, struct zebu_start_directive* ptree);

void print_zebu_type(struct link* links, enum prefix p, const char* name, struct zebu_type* ptree);

void print_zebu_unary_expression(struct link* links, enum prefix p, const char* name, struct zebu_unary_expression* ptree);

void print_zebu_using_directive(struct link* links, enum prefix p, const char* name, struct zebu_using_directive* ptree);

void print_zebu_value_declare(struct link* links, enum prefix p, const char* name, struct zebu_value_declare* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m)\n", name);
	if (ptree->assertions.n)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "assertions[%u]", i);
			print_zebu_assertion(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->assertions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "assertion[]", "assertions");
	}
	if (ptree->declares.n)
	{
		for (unsigned i = 0, n = ptree->declares.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "declares[%u]", i);
			print_zebu_value_declare(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->declares.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "value_declare[]", "declares");
	}
	if (ptree->grammars.n)
	{
		for (unsigned i = 0, n = ptree->grammars.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "grammars[%u]", i);
			print_zebu_grammar_rule(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->grammars.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_rule[]", "grammars");
	}
	if (ptree->skips.n)
	{
		for (unsigned i = 0, n = ptree->skips.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "skips[%u]", i);
			print_zebu_skip_directive(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->skips.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "skip_directive[]", "skips");
	}
	if (ptree->starts.n)
	{
		for (unsigned i = 0, n = ptree->starts.n; i < n; i++)
		{
			char label[6 + 30];
			snprintf(label, sizeof(label), "starts[%u]", i);
			print_zebu_start_directive(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->starts.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "start_directive[]", "starts");
	}
	if (ptree->usings.n)
	{
		for (unsigned i = 0, n = ptree->usings.n; i < n; i++)
		{
			char label[6 + 30];
			snprintf(label, sizeof(label), "usings[%u]", i);
			print_zebu_using_directive(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->usings.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "using_directive[]", "usings");
	}
	free(new);
}
void print_zebu_0$parameter(struct link* links, enum prefix p, const char* name, struct zebu_0$parameter* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m0$parameter\e[m)\n", name);
	if (ptree->name)
		print_token_leaf(new ?: links, p_not_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "name");
	if (ptree->type)
		print_zebu_type(new ?: links, p_last_child, "type", ptree->type);
	else
		print_empty_leaf(new ?: links, p_last_child, "type", "type");
	free(new);
}
void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36madditive_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "base");
	if (ptree->left)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "left");
	if (ptree->right)
		print_zebu_multiplicative_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "multiplicative_expression", "right");
	free(new);
}
void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mand_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "base");
	if (ptree->left)
		print_zebu_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "left");
	if (ptree->right)
		print_zebu_equality_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "equality_expression", "right");
	free(new);
}
void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36massertion\e[m)\n", name);
	if (ptree->debug)
		print_token_leaf(new ?: links, p_not_last_child, "debug", ptree->debug);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "debug");
	if (ptree->error)
		print_token_leaf(new ?: links, p_not_last_child, "error", ptree->error);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "error");
	if (ptree->expression)
		print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
	if (ptree->note)
		print_token_leaf(new ?: links, p_not_last_child, "note", ptree->note);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "note");
	if (ptree->warning)
		print_token_leaf(new ?: links, p_last_child, "warning", ptree->warning);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "warning");
	free(new);
}
void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_symdiff(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_symdiff", "base");
	if (ptree->ors.n)
	{
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
		{
			char label[3 + 30];
			snprintf(label, sizeof(label), "ors[%u]", i);
			print_zebu_charset_symdiff(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->ors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "charset_symdiff[]", "ors");
	}
	free(new);
}
void print_zebu_charset_highest(struct link* links, enum prefix p, const char* name, struct zebu_charset_highest* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_highest\e[m)\n", name);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->subcharset)
		print_zebu_charset(new ?: links, p_last_child, "subcharset", ptree->subcharset);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset", "subcharset");
	free(new);
}
void print_zebu_charset_intersect(struct link* links, enum prefix p, const char* name, struct zebu_charset_intersect* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_intersect\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_range(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_range", "base");
	if (ptree->intersects.n)
	{
		for (unsigned i = 0, n = ptree->intersects.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "intersects[%u]", i);
			print_zebu_charset_range(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->intersects.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "charset_range[]", "intersects");
	}
	free(new);
}
void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_prefix\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_highest(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_highest", "base");
	if (ptree->emark)
		print_token_leaf(new ?: links, p_last_child, "emark", ptree->emark);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "emark");
	free(new);
}
void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_range\e[m)\n", name);
	if (ptree->left)
		print_zebu_charset_prefix(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_prefix", "left");
	if (ptree->right)
		print_zebu_charset_prefix(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset_prefix", "right");
	free(new);
}
void print_zebu_charset_symdiff(struct link* links, enum prefix p, const char* name, struct zebu_charset_symdiff* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_symdiff\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_intersect(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_intersect", "base");
	if (ptree->xors.n)
	{
		for (unsigned i = 0, n = ptree->xors.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "xors[%u]", i);
			print_zebu_charset_intersect(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->xors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "charset_intersect[]", "xors");
	}
	free(new);
}
void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mconditional_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "base");
	if (ptree->false_case)
		print_zebu_conditional_expression(new ?: links, p_not_last_child, "false_case", ptree->false_case);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "conditional_expression", "false_case");
	if (ptree->true_case)
		print_zebu_expression(new ?: links, p_last_child, "true_case", ptree->true_case);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "true_case");
	free(new);
}
void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mequality_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "base");
	if (ptree->left)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "left");
	if (ptree->right)
		print_zebu_relational_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "relational_expression", "right");
	free(new);
}
void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexclusive_or_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_and_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "base");
	if (ptree->left)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "and_expression", "right");
	free(new);
}
void print_zebu_exponentiation_expression(struct link* links, enum prefix p, const char* name, struct zebu_exponentiation_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexponentiation_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_unary_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "unary_expression", "base");
	if (ptree->left)
		print_zebu_exponentiation_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exponentiation_expression", "left");
	if (ptree->right)
		print_zebu_unary_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "unary_expression", "right");
	free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression\e[m)\n", name);
	if (ptree->base)
		print_zebu_implication_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "implication_expression", "base");
	if (ptree->iffs.n)
	{
		for (unsigned i = 0, n = ptree->iffs.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "iffs[%u]", i);
			print_zebu_implication_expression(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->iffs.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "implication_expression[]", "iffs");
	}
	free(new);
}
void print_zebu_grammar(struct link* links, enum prefix p, const char* name, struct zebu_grammar* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar\e[m)\n", name);
	if (ptree->base)
		print_zebu_grammar_juxtaposition(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_juxtaposition", "base");
	if (ptree->ors.n)
	{
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
		{
			char label[3 + 30];
			snprintf(label, sizeof(label), "ors[%u]", i);
			print_zebu_grammar_juxtaposition(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->ors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "grammar_juxtaposition[]", "ors");
	}
	free(new);
}
void print_zebu_grammar_highest(struct link* links, enum prefix p, const char* name, struct zebu_grammar_highest* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_highest\e[m)\n", name);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->charset)
		print_zebu_charset(new ?: links, p_not_last_child, "charset", ptree->charset);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset", "charset");
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->name)
		print_token_leaf(new ?: links, p_not_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "name");
	if (ptree->regex)
		print_zebu_regex(new ?: links, p_not_last_child, "regex", ptree->regex);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex", "regex");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->subgrammar)
		print_zebu_grammar(new ?: links, p_not_last_child, "subgrammar", ptree->subgrammar);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar", "subgrammar");
	if (ptree->tags.n)
	{
		for (unsigned i = 0, n = ptree->tags.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "tags[%u]", i);
			print_token_leaf(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->tags.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "token[]", "tags");
	}
	free(new);
}
void print_zebu_grammar_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_grammar_juxtaposition* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_juxtaposition\e[m)\n", name);
	if (ptree->base)
		print_zebu_grammar_postfix(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_postfix", "base");
	if (ptree->juxtapositions.n)
	{
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
		{
			char label[14 + 30];
			snprintf(label, sizeof(label), "juxtapositions[%u]", i);
			print_zebu_grammar_postfix(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->juxtapositions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "grammar_postfix[]", "juxtapositions");
	}
	free(new);
}
void print_zebu_grammar_postfix(struct link* links, enum prefix p, const char* name, struct zebu_grammar_postfix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_postfix\e[m)\n", name);
	if (ptree->base)
		print_zebu_grammar_highest(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_highest", "base");
	if (ptree->plus)
		print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
	if (ptree->qmark)
		print_token_leaf(new ?: links, p_not_last_child, "qmark", ptree->qmark);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "qmark");
	if (ptree->star)
		print_token_leaf(new ?: links, p_last_child, "star", ptree->star);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "star");
	free(new);
}
void print_zebu_grammar_rule(struct link* links, enum prefix p, const char* name, struct zebu_grammar_rule* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_rule\e[m)\n", name);
	if (ptree->grammar)
		print_zebu_grammar(new ?: links, p_not_last_child, "grammar", ptree->grammar);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar", "grammar");
	if (ptree->name)
		print_token_leaf(new ?: links, p_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "name");
	free(new);
}
void print_zebu_implication_expression(struct link* links, enum prefix p, const char* name, struct zebu_implication_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mimplication_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_possession_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "possession_expression", "base");
	if (ptree->implies.n)
	{
		for (unsigned i = 0, n = ptree->implies.n; i < n; i++)
		{
			char label[7 + 30];
			snprintf(label, sizeof(label), "implies[%u]", i);
			print_zebu_possession_expression(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->implies.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "possession_expression[]", "implies");
	}
	free(new);
}
void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36minclusive_or_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "base");
	if (ptree->left)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_exclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "exclusive_or_expression", "right");
	free(new);
}
void print_zebu_lambda_expression(struct link* links, enum prefix p, const char* name, struct zebu_lambda_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlambda_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_conditional_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "conditional_expression", "base");
	if (ptree->lambda)
		print_zebu_lambda_expression(new ?: links, p_not_last_child, "lambda", ptree->lambda);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "lambda_expression", "lambda");
	print_empty_leaf(new ?: links, p_not_last_child, "struct unresolved*", "lambda_captures");
	if (ptree->name)
		print_token_leaf(new ?: links, p_not_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "name");
	if (ptree->parameters.n)
	{
		for (unsigned i = 0, n = ptree->parameters.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "parameters[%u]", i);
			print_zebu_0$parameter(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->parameters.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "0$parameter[]", "parameters");
	}
	if (ptree->type)
		print_zebu_type(new ?: links, p_last_child, "type", ptree->type);
	else
		print_empty_leaf(new ?: links, p_last_child, "type", "type");
	free(new);
}
void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_and_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "base");
	if (ptree->left)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "left");
	if (ptree->right)
		print_zebu_inclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "inclusive_or_expression", "right");
	free(new);
}
void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_or_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "base");
	if (ptree->left)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "left");
	if (ptree->right)
		print_zebu_logical_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "logical_and_expression", "right");
	free(new);
}
void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mmultiplicative_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_exponentiation_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exponentiation_expression", "base");
	if (ptree->left)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "left");
	if (ptree->right)
		print_zebu_exponentiation_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "exponentiation_expression", "right");
	free(new);
}
void print_zebu_possession_expression(struct link* links, enum prefix p, const char* name, struct zebu_possession_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mpossession_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_lambda_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "lambda_expression", "base");
	if (ptree->has)
		print_token_leaf(new ?: links, p_last_child, "has", ptree->has);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "has");
	free(new);
}
void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mpostfix_expression\e[m)\n", name);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_expression(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "expression[]", "args");
	}
	if (ptree->base)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "base");
	if (ptree->call)
		print_token_leaf(new ?: links, p_not_last_child, "call", ptree->call);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "call");
	if (ptree->field)
		print_token_leaf(new ?: links, p_not_last_child, "field", ptree->field);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "field");
	if (ptree->index)
		print_zebu_expression(new ?: links, p_not_last_child, "index", ptree->index);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "index");
	if (ptree->sub)
		print_zebu_postfix_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "postfix_expression", "sub");
	free(new);
}
void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprimary_expression\e[m)\n", name);
	if (ptree->character_literal)
		print_token_leaf(new ?: links, p_not_last_child, "character_literal", ptree->character_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character_literal");
	if (ptree->elements.n)
	{
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "elements[%u]", i);
			print_zebu_expression(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->elements.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "expression[]", "elements");
	}
	if (ptree->float_literal)
		print_token_leaf(new ?: links, p_not_last_child, "float_literal", ptree->float_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "float_literal");
	if (ptree->identifier)
		print_token_leaf(new ?: links, p_not_last_child, "identifier", ptree->identifier);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "identifier");
	if (ptree->integer_literal)
		print_token_leaf(new ?: links, p_not_last_child, "integer_literal", ptree->integer_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer_literal");
	if (ptree->list)
		print_token_leaf(new ?: links, p_not_last_child, "list", ptree->list);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "list");
	if (ptree->string_literal)
		print_token_leaf(new ?: links, p_not_last_child, "string_literal", ptree->string_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string_literal");
	if (ptree->tuple)
		print_token_leaf(new ?: links, p_not_last_child, "tuple", ptree->tuple);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "tuple");
	print_empty_leaf(new ?: links, p_not_last_child, "struct type*", "type");
	print_empty_leaf(new ?: links, p_last_child, "struct value*", "value");
	free(new);
}
void print_zebu_primary_type(struct link* links, enum prefix p, const char* name, struct zebu_primary_type* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprimary_type\e[m)\n", name);
	if (ptree->array)
		print_zebu_primary_type(new ?: links, p_not_last_child, "array", ptree->array);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_type", "array");
	if (ptree->bool_type)
		print_token_leaf(new ?: links, p_not_last_child, "bool_type", ptree->bool_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "bool_type");
	if (ptree->char_type)
		print_token_leaf(new ?: links, p_not_last_child, "char_type", ptree->char_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "char_type");
	if (ptree->elements.n)
	{
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "elements[%u]", i);
			print_zebu_type(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->elements.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "type[]", "elements");
	}
	if (ptree->float_type)
		print_token_leaf(new ?: links, p_not_last_child, "float_type", ptree->float_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "float_type");
	if (ptree->grammar)
		print_token_leaf(new ?: links, p_not_last_child, "grammar", ptree->grammar);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "grammar");
	if (ptree->int_type)
		print_token_leaf(new ?: links, p_not_last_child, "int_type", ptree->int_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "int_type");
	if (ptree->tuple)
		print_token_leaf(new ?: links, p_last_child, "tuple", ptree->tuple);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "tuple");
	free(new);
}
void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex\e[m)\n", name);
	if (ptree->base)
		print_zebu_regex_juxtaposition(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_juxtaposition", "base");
	if (ptree->ors.n)
	{
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
		{
			char label[3 + 30];
			snprintf(label, sizeof(label), "ors[%u]", i);
			print_zebu_regex_juxtaposition(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->ors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "regex_juxtaposition[]", "ors");
	}
	free(new);
}
void print_zebu_regex_highest(struct link* links, enum prefix p, const char* name, struct zebu_regex_highest* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_highest\e[m)\n", name);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->charset)
		print_zebu_charset(new ?: links, p_not_last_child, "charset", ptree->charset);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset", "charset");
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->subregex)
		print_zebu_regex(new ?: links, p_last_child, "subregex", ptree->subregex);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex", "subregex");
	free(new);
}
void print_zebu_regex_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_regex_juxtaposition* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_juxtaposition\e[m)\n", name);
	if (ptree->base)
		print_zebu_regex_postfix(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_postfix", "base");
	if (ptree->juxtapositions.n)
	{
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
		{
			char label[14 + 30];
			snprintf(label, sizeof(label), "juxtapositions[%u]", i);
			print_zebu_regex_postfix(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->juxtapositions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "regex_postfix[]", "juxtapositions");
	}
	free(new);
}
void print_zebu_regex_postfix(struct link* links, enum prefix p, const char* name, struct zebu_regex_postfix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_postfix\e[m)\n", name);
	if (ptree->base)
		print_zebu_regex_highest(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_highest", "base");
	if (ptree->plus)
		print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
	if (ptree->qmark)
		print_token_leaf(new ?: links, p_not_last_child, "qmark", ptree->qmark);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "qmark");
	if (ptree->star)
		print_token_leaf(new ?: links, p_last_child, "star", ptree->star);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "star");
	free(new);
}
void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mrelational_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "base");
	if (ptree->left)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "left");
	if (ptree->right)
		print_zebu_shift_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "shift_expression", "right");
	free(new);
}
void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mshift_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "base");
	if (ptree->left)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "left");
	if (ptree->right)
		print_zebu_additive_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "additive_expression", "right");
	free(new);
}
void print_zebu_skip_directive(struct link* links, enum prefix p, const char* name, struct zebu_skip_directive* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mskip_directive\e[m)\n", name);
	if (ptree->regex)
		print_zebu_regex(new ?: links, p_last_child, "regex", ptree->regex);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex", "regex");
	free(new);
}
void print_zebu_start_directive(struct link* links, enum prefix p, const char* name, struct zebu_start_directive* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mstart_directive\e[m)\n", name);
	if (ptree->grammar)
		print_zebu_grammar(new ?: links, p_last_child, "grammar", ptree->grammar);
	else
		print_empty_leaf(new ?: links, p_last_child, "grammar", "grammar");
	free(new);
}
void print_zebu_type(struct link* links, enum prefix p, const char* name, struct zebu_type* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mtype\e[m)\n", name);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_type(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "type[]", "args");
	}
	if (ptree->base)
		print_zebu_primary_type(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_type", "base");
	if (ptree->rettype)
		print_zebu_type(new ?: links, p_last_child, "rettype", ptree->rettype);
	else
		print_empty_leaf(new ?: links, p_last_child, "type", "rettype");
	free(new);
}
void print_zebu_unary_expression(struct link* links, enum prefix p, const char* name, struct zebu_unary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36munary_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "base");
	if (ptree->sub)
		print_zebu_unary_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "unary_expression", "sub");
	free(new);
}
void print_zebu_using_directive(struct link* links, enum prefix p, const char* name, struct zebu_using_directive* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36musing_directive\e[m)\n", name);
	if (ptree->path)
		print_token_leaf(new ?: links, p_last_child, "path", ptree->path);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "path");
	free(new);
}
void print_zebu_value_declare(struct link* links, enum prefix p, const char* name, struct zebu_value_declare* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs(" ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mvalue_declare\e[m)\n", name);
	if (ptree->expression)
		print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
	if (ptree->name)
		print_token_leaf(new ?: links, p_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "name");
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* this)
{
	if (this) this->refcount++;
	return this;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_0$parameter* inc_zebu_0$parameter(struct zebu_0$parameter* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_additive_expression* inc_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_and_expression* inc_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_assertion* inc_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset* inc_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_highest* inc_zebu_charset_highest(struct zebu_charset_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_intersect* inc_zebu_charset_intersect(struct zebu_charset_intersect* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_prefix* inc_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_range* inc_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_symdiff* inc_zebu_charset_symdiff(struct zebu_charset_symdiff* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_conditional_expression* inc_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_equality_expression* inc_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_exclusive_or_expression* inc_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_exponentiation_expression* inc_zebu_exponentiation_expression(struct zebu_exponentiation_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar* inc_zebu_grammar(struct zebu_grammar* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_highest* inc_zebu_grammar_highest(struct zebu_grammar_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_juxtaposition* inc_zebu_grammar_juxtaposition(struct zebu_grammar_juxtaposition* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_postfix* inc_zebu_grammar_postfix(struct zebu_grammar_postfix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_rule* inc_zebu_grammar_rule(struct zebu_grammar_rule* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_implication_expression* inc_zebu_implication_expression(struct zebu_implication_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_inclusive_or_expression* inc_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_lambda_expression* inc_zebu_lambda_expression(struct zebu_lambda_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_and_expression* inc_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_or_expression* inc_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_multiplicative_expression* inc_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_possession_expression* inc_zebu_possession_expression(struct zebu_possession_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_postfix_expression* inc_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_expression* inc_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_type* inc_zebu_primary_type(struct zebu_primary_type* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex* inc_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_highest* inc_zebu_regex_highest(struct zebu_regex_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_juxtaposition* inc_zebu_regex_juxtaposition(struct zebu_regex_juxtaposition* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_postfix* inc_zebu_regex_postfix(struct zebu_regex_postfix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_relational_expression* inc_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_shift_expression* inc_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_skip_directive* inc_zebu_skip_directive(struct zebu_skip_directive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_start_directive* inc_zebu_start_directive(struct zebu_start_directive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_type* inc_zebu_type(struct zebu_type* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_unary_expression* inc_zebu_unary_expression(struct zebu_unary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_using_directive* inc_zebu_using_directive(struct zebu_using_directive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_value_declare* inc_zebu_value_declare(struct zebu_value_declare* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* this);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_0$parameter(struct zebu_0$parameter* ptree);

extern void free_zebu_additive_expression(struct zebu_additive_expression* ptree);

extern void free_zebu_and_expression(struct zebu_and_expression* ptree);

extern void free_zebu_assertion(struct zebu_assertion* ptree);

extern void free_zebu_charset(struct zebu_charset* ptree);

extern void free_zebu_charset_highest(struct zebu_charset_highest* ptree);

extern void free_zebu_charset_intersect(struct zebu_charset_intersect* ptree);

extern void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree);

extern void free_zebu_charset_range(struct zebu_charset_range* ptree);

extern void free_zebu_charset_symdiff(struct zebu_charset_symdiff* ptree);

extern void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree);

extern void free_zebu_equality_expression(struct zebu_equality_expression* ptree);

extern void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree);

extern void free_zebu_exponentiation_expression(struct zebu_exponentiation_expression* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_grammar(struct zebu_grammar* ptree);

extern void free_zebu_grammar_highest(struct zebu_grammar_highest* ptree);

extern void free_zebu_grammar_juxtaposition(struct zebu_grammar_juxtaposition* ptree);

extern void free_zebu_grammar_postfix(struct zebu_grammar_postfix* ptree);

extern void free_zebu_grammar_rule(struct zebu_grammar_rule* ptree);

extern void free_zebu_implication_expression(struct zebu_implication_expression* ptree);

extern void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree);

extern void free_zebu_lambda_expression(struct zebu_lambda_expression* ptree);

extern void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree);

extern void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree);

extern void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree);

extern void free_zebu_possession_expression(struct zebu_possession_expression* ptree);

extern void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree);

extern void free_zebu_primary_expression(struct zebu_primary_expression* ptree);

extern void free_zebu_primary_type(struct zebu_primary_type* ptree);

extern void free_zebu_regex(struct zebu_regex* ptree);

extern void free_zebu_regex_highest(struct zebu_regex_highest* ptree);

extern void free_zebu_regex_juxtaposition(struct zebu_regex_juxtaposition* ptree);

extern void free_zebu_regex_postfix(struct zebu_regex_postfix* ptree);

extern void free_zebu_relational_expression(struct zebu_relational_expression* ptree);

extern void free_zebu_shift_expression(struct zebu_shift_expression* ptree);

extern void free_zebu_skip_directive(struct zebu_skip_directive* ptree);

extern void free_zebu_start_directive(struct zebu_start_directive* ptree);

extern void free_zebu_type(struct zebu_type* ptree);

extern void free_zebu_unary_expression(struct zebu_unary_expression* ptree);

extern void free_zebu_using_directive(struct zebu_using_directive* ptree);

extern void free_zebu_value_declare(struct zebu_value_declare* ptree);

void free_zebu_token(struct zebu_token* this)
{
	if (this && !--this->refcount)
	{
		free(this->data);
		free(this);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
			free_zebu_assertion(ptree->assertions.data[i]);
		free(ptree->assertions.data);
		for (unsigned i = 0, n = ptree->declares.n; i < n; i++)
			free_zebu_value_declare(ptree->declares.data[i]);
		free(ptree->declares.data);
		for (unsigned i = 0, n = ptree->grammars.n; i < n; i++)
			free_zebu_grammar_rule(ptree->grammars.data[i]);
		free(ptree->grammars.data);
		for (unsigned i = 0, n = ptree->skips.n; i < n; i++)
			free_zebu_skip_directive(ptree->skips.data[i]);
		free(ptree->skips.data);
		for (unsigned i = 0, n = ptree->starts.n; i < n; i++)
			free_zebu_start_directive(ptree->starts.data[i]);
		free(ptree->starts.data);
		for (unsigned i = 0, n = ptree->usings.n; i < n; i++)
			free_zebu_using_directive(ptree->usings.data[i]);
		free(ptree->usings.data);
		free(ptree);
	}
}

void free_zebu_0$parameter(struct zebu_0$parameter* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->name);
		free_zebu_type(ptree->type);
		free(ptree);
	}
}

void free_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_multiplicative_expression(ptree->base);
		free_zebu_additive_expression(ptree->left);
		free_zebu_multiplicative_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_equality_expression(ptree->base);
		free_zebu_and_expression(ptree->left);
		free_zebu_equality_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->debug);
		free_zebu_token(ptree->error);
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->note);
		free_zebu_token(ptree->warning);
		free(ptree);
	}
}

void free_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_symdiff(ptree->base);
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
			free_zebu_charset_symdiff(ptree->ors.data[i]);
		free(ptree->ors.data);
		free(ptree);
	}
}

void free_zebu_charset_highest(struct zebu_charset_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_token(ptree->integer);
		free_zebu_charset(ptree->subcharset);
		free(ptree);
	}
}

void free_zebu_charset_intersect(struct zebu_charset_intersect* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_range(ptree->base);
		for (unsigned i = 0, n = ptree->intersects.n; i < n; i++)
			free_zebu_charset_range(ptree->intersects.data[i]);
		free(ptree->intersects.data);
		free(ptree);
	}
}

void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_highest(ptree->base);
		free_zebu_token(ptree->emark);
		free(ptree);
	}
}

void free_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_prefix(ptree->left);
		free_zebu_charset_prefix(ptree->right);
		free(ptree);
	}
}

void free_zebu_charset_symdiff(struct zebu_charset_symdiff* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_intersect(ptree->base);
		for (unsigned i = 0, n = ptree->xors.n; i < n; i++)
			free_zebu_charset_intersect(ptree->xors.data[i]);
		free(ptree->xors.data);
		free(ptree);
	}
}

void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_or_expression(ptree->base);
		free_zebu_conditional_expression(ptree->false_case);
		free_zebu_expression(ptree->true_case);
		free(ptree);
	}
}

void free_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_relational_expression(ptree->base);
		free_zebu_equality_expression(ptree->left);
		free_zebu_relational_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_and_expression(ptree->base);
		free_zebu_exclusive_or_expression(ptree->left);
		free_zebu_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_exponentiation_expression(struct zebu_exponentiation_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_unary_expression(ptree->base);
		free_zebu_exponentiation_expression(ptree->left);
		free_zebu_unary_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_implication_expression(ptree->base);
		for (unsigned i = 0, n = ptree->iffs.n; i < n; i++)
			free_zebu_implication_expression(ptree->iffs.data[i]);
		free(ptree->iffs.data);
		free(ptree);
	}
}

void free_zebu_grammar(struct zebu_grammar* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar_juxtaposition(ptree->base);
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
			free_zebu_grammar_juxtaposition(ptree->ors.data[i]);
		free(ptree->ors.data);
		free(ptree);
	}
}

void free_zebu_grammar_highest(struct zebu_grammar_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->charset);
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->name);
		free_zebu_regex(ptree->regex);
		free_zebu_token(ptree->string);
		free_zebu_grammar(ptree->subgrammar);
		for (unsigned i = 0, n = ptree->tags.n; i < n; i++)
			free_zebu_token(ptree->tags.data[i]);
		free(ptree->tags.data);
		free(ptree);
	}
}

void free_zebu_grammar_juxtaposition(struct zebu_grammar_juxtaposition* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar_postfix(ptree->base);
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
			free_zebu_grammar_postfix(ptree->juxtapositions.data[i]);
		free(ptree->juxtapositions.data);
		free(ptree);
	}
}

void free_zebu_grammar_postfix(struct zebu_grammar_postfix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar_highest(ptree->base);
		free_zebu_token(ptree->plus);
		free_zebu_token(ptree->qmark);
		free_zebu_token(ptree->star);
		free(ptree);
	}
}

void free_zebu_grammar_rule(struct zebu_grammar_rule* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar(ptree->grammar);
		free_zebu_token(ptree->name);
		free(ptree);
	}
}

void free_zebu_implication_expression(struct zebu_implication_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_possession_expression(ptree->base);
		for (unsigned i = 0, n = ptree->implies.n; i < n; i++)
			free_zebu_possession_expression(ptree->implies.data[i]);
		free(ptree->implies.data);
		free(ptree);
	}
}

void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_exclusive_or_expression(ptree->base);
		free_zebu_inclusive_or_expression(ptree->left);
		free_zebu_exclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_lambda_expression(struct zebu_lambda_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_conditional_expression(ptree->base);
		free_zebu_lambda_expression(ptree->lambda);
		void free_unresolved(struct unresolved*);
		free_unresolved(ptree->lambda_captures);
		free_zebu_token(ptree->name);
		for (unsigned i = 0, n = ptree->parameters.n; i < n; i++)
			free_zebu_0$parameter(ptree->parameters.data[i]);
		free(ptree->parameters.data);
		free_zebu_type(ptree->type);
		free(ptree);
	}
}

void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_inclusive_or_expression(ptree->base);
		free_zebu_logical_and_expression(ptree->left);
		free_zebu_inclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_and_expression(ptree->base);
		free_zebu_logical_or_expression(ptree->left);
		free_zebu_logical_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_exponentiation_expression(ptree->base);
		free_zebu_multiplicative_expression(ptree->left);
		free_zebu_exponentiation_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_possession_expression(struct zebu_possession_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_lambda_expression(ptree->base);
		free_zebu_token(ptree->has);
		free(ptree);
	}
}

void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_expression(ptree->args.data[i]);
		free(ptree->args.data);
		free_zebu_primary_expression(ptree->base);
		free_zebu_token(ptree->call);
		free_zebu_token(ptree->field);
		free_zebu_expression(ptree->index);
		free_zebu_postfix_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character_literal);
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
			free_zebu_expression(ptree->elements.data[i]);
		free(ptree->elements.data);
		free_zebu_token(ptree->float_literal);
		free_zebu_token(ptree->identifier);
		free_zebu_token(ptree->integer_literal);
		free_zebu_token(ptree->list);
		free_zebu_token(ptree->string_literal);
		free_zebu_token(ptree->tuple);
		void free_type(struct type*);
		free_type(ptree->type);
		void free_value(struct value*);
		free_value(ptree->value);
		free(ptree);
	}
}

void free_zebu_primary_type(struct zebu_primary_type* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_primary_type(ptree->array);
		free_zebu_token(ptree->bool_type);
		free_zebu_token(ptree->char_type);
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
			free_zebu_type(ptree->elements.data[i]);
		free(ptree->elements.data);
		free_zebu_token(ptree->float_type);
		free_zebu_token(ptree->grammar);
		free_zebu_token(ptree->int_type);
		free_zebu_token(ptree->tuple);
		free(ptree);
	}
}

void free_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_juxtaposition(ptree->base);
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
			free_zebu_regex_juxtaposition(ptree->ors.data[i]);
		free(ptree->ors.data);
		free(ptree);
	}
}

void free_zebu_regex_highest(struct zebu_regex_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->charset);
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->string);
		free_zebu_regex(ptree->subregex);
		free(ptree);
	}
}

void free_zebu_regex_juxtaposition(struct zebu_regex_juxtaposition* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_postfix(ptree->base);
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
			free_zebu_regex_postfix(ptree->juxtapositions.data[i]);
		free(ptree->juxtapositions.data);
		free(ptree);
	}
}

void free_zebu_regex_postfix(struct zebu_regex_postfix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_highest(ptree->base);
		free_zebu_token(ptree->plus);
		free_zebu_token(ptree->qmark);
		free_zebu_token(ptree->star);
		free(ptree);
	}
}

void free_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_shift_expression(ptree->base);
		free_zebu_relational_expression(ptree->left);
		free_zebu_shift_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_additive_expression(ptree->base);
		free_zebu_shift_expression(ptree->left);
		free_zebu_additive_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_skip_directive(struct zebu_skip_directive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex(ptree->regex);
		free(ptree);
	}
}

void free_zebu_start_directive(struct zebu_start_directive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar(ptree->grammar);
		free(ptree);
	}
}

void free_zebu_type(struct zebu_type* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_type(ptree->args.data[i]);
		free(ptree->args.data);
		free_zebu_primary_type(ptree->base);
		free_zebu_type(ptree->rettype);
		free(ptree);
	}
}

void free_zebu_unary_expression(struct zebu_unary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_postfix_expression(ptree->base);
		free_zebu_unary_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_using_directive(struct zebu_using_directive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->path);
		free(ptree);
	}
}

void free_zebu_value_declare(struct zebu_value_declare* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->name);
		free(ptree);
	}
}



#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap; } lexer = {};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		void append(unsigned char c)
		{
			while (lexer.n + 1 >= lexer.cap)
			{
				lexer.cap = lexer.cap << 1 ?: 1;
				#ifdef ZEBU_DEBUG
				ddprintf("lexer.cap == %u\n", lexer.cap);
				#endif
				lexer.data = realloc(lexer.data, lexer.cap);
			}
			
			lexer.data[lexer.n++] = c;
		}
		
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				append(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\"\n", i, lexer.data);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->len = i;
					token->data[i] = 0;
					t = b, td = token;
					
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (f)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->len = f;
					token->data[f] = 0;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				assert(!"168");
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 42:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 13:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 8:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 28:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 72:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 79:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 26:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 51:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 29:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 65:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 58:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 25:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 76;
		break;
	}
	case 44:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 45:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 46:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 43:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 110:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 111:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 48:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 106:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 108:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 109:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 47:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 107:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 52:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 56:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 117:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 120:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 121:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 53:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 116:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 57:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 55:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 54:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 118:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 119:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 259:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 70;
		break;
	}
	case 279:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 70;
		break;
	}
	case 255:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		if (value->intersects.n == value->intersects.cap)
		{
			value->intersects.cap = value->intersects.cap << 1 ?: 1;
			value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
		}
		memmove(value->intersects.data + 1, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
		value->intersects.data[0] = inc_zebu_charset_range(subgrammar), value->intersects.n++;
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 68;
		break;
	}
	case 289:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_intersect* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_range(value->base); value->base = inc_zebu_charset_range(trie->base); }
			if (trie->intersects.n)
			{
				while (value->intersects.n + trie->intersects.n > value->intersects.cap)
				{
					value->intersects.cap = value->intersects.cap << 1 ?: 1;
					value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
				}
				memmove(value->intersects.data + trie->intersects.n, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
				for (unsigned i = 0, n = trie->intersects.n; i < n; i++)
					value->intersects.data[i] = inc_zebu_charset_range(trie->intersects.data[i]);
				value->intersects.n += trie->intersects.n;
			}
			free_zebu_charset_intersect(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		if (value->intersects.n == value->intersects.cap)
		{
			value->intersects.cap = value->intersects.cap << 1 ?: 1;
			value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
		}
		memmove(value->intersects.data + 1, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
		value->intersects.data[0] = inc_zebu_charset_range(subgrammar), value->intersects.n++;
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 68;
		break;
	}
	case 252:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		if (value->xors.n == value->xors.cap)
		{
			value->xors.cap = value->xors.cap << 1 ?: 1;
			value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
		}
		memmove(value->xors.data + 1, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
		value->xors.data[0] = inc_zebu_charset_intersect(subgrammar), value->xors.n++;
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 67;
		break;
	}
	case 288:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_symdiff* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_intersect(value->base); value->base = inc_zebu_charset_intersect(trie->base); }
			if (trie->xors.n)
			{
				while (value->xors.n + trie->xors.n > value->xors.cap)
				{
					value->xors.cap = value->xors.cap << 1 ?: 1;
					value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
				}
				memmove(value->xors.data + trie->xors.n, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
				for (unsigned i = 0, n = trie->xors.n; i < n; i++)
					value->xors.data[i] = inc_zebu_charset_intersect(trie->xors.data[i]);
				value->xors.n += trie->xors.n;
			}
			free_zebu_charset_symdiff(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		if (value->xors.n == value->xors.cap)
		{
			value->xors.cap = value->xors.cap << 1 ?: 1;
			value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
		}
		memmove(value->xors.data + 1, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
		value->xors.data[0] = inc_zebu_charset_intersect(subgrammar), value->xors.n++;
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 67;
		break;
	}
	case 123:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->iffs.n == value->iffs.cap)
		{
			value->iffs.cap = value->iffs.cap << 1 ?: 1;
			value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
		}
		memmove(value->iffs.data + 1, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
		value->iffs.data[0] = inc_zebu_implication_expression(subgrammar), value->iffs.n++;
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 44;
		break;
	}
	case 240:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_implication_expression(value->base); value->base = inc_zebu_implication_expression(trie->base); }
			if (trie->iffs.n)
			{
				while (value->iffs.n + trie->iffs.n > value->iffs.cap)
				{
					value->iffs.cap = value->iffs.cap << 1 ?: 1;
					value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
				}
				memmove(value->iffs.data + trie->iffs.n, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
				for (unsigned i = 0, n = trie->iffs.n; i < n; i++)
					value->iffs.data[i] = inc_zebu_implication_expression(trie->iffs.data[i]);
				value->iffs.n += trie->iffs.n;
			}
			free_zebu_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->iffs.n == value->iffs.cap)
		{
			value->iffs.cap = value->iffs.cap << 1 ?: 1;
			value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
		}
		memmove(value->iffs.data + 1, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
		value->iffs.data[0] = inc_zebu_implication_expression(subgrammar), value->iffs.n++;
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 44;
		break;
	}
	case 226:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_grammar_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 65;
		break;
	}
	case 286:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_juxtaposition(value->base); value->base = inc_zebu_grammar_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_grammar_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_grammar(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_grammar_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 65;
		break;
	}
	case 208:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 61;
		break;
	}
	case 245:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 61;
		break;
	}
	case 210:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 62;
		break;
	}
	case 246:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 62;
		break;
	}
	case 213:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 63;
		break;
	}
	case 248:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 63;
		break;
	}
	case 218:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 64;
		break;
	}
	case 262:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 64;
		break;
	}
	case 276:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 74;
		break;
	}
	case 287:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 74;
		break;
	}
	case 143:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 60:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 64:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 62:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 141:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 142:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 61:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 59:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 146:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 144:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 63:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 145:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 283:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 75;
		break;
	}
	case 290:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 75;
		break;
	}
	case 228:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 66;
		break;
	}
	case 270:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_postfix(value->base); value->base = inc_zebu_grammar_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_grammar_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_grammar_juxtaposition(trie);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 66;
		break;
	}
	case 132:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->implies.n == value->implies.cap)
		{
			value->implies.cap = value->implies.cap << 1 ?: 1;
			value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
		}
		memmove(value->implies.data + 1, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
		value->implies.data[0] = inc_zebu_possession_expression(subgrammar), value->implies.n++;
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 45;
		break;
	}
	case 242:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_implication_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_possession_expression(value->base); value->base = inc_zebu_possession_expression(trie->base); }
			if (trie->implies.n)
			{
				while (value->implies.n + trie->implies.n > value->implies.cap)
				{
					value->implies.cap = value->implies.cap << 1 ?: 1;
					value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
				}
				memmove(value->implies.data + trie->implies.n, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
				for (unsigned i = 0, n = trie->implies.n; i < n; i++)
					value->implies.data[i] = inc_zebu_possession_expression(trie->implies.data[i]);
				value->implies.n += trie->implies.n;
			}
			free_zebu_implication_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->implies.n == value->implies.cap)
		{
			value->implies.cap = value->implies.cap << 1 ?: 1;
			value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
		}
		memmove(value->implies.data + 1, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
		value->implies.data[0] = inc_zebu_possession_expression(subgrammar), value->implies.n++;
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 45;
		break;
	}
	case 234:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_0$parameter* subgrammar = data.data[--yacc.n, --data.n];
		if (value->parameters.n == value->parameters.cap)
		{
			value->parameters.cap = value->parameters.cap << 1 ?: 1;
			value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
		}
		memmove(value->parameters.data + 1, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
		value->parameters.data[0] = inc_zebu_0$parameter(subgrammar), value->parameters.n++;
		free_zebu_0$parameter(subgrammar);
		}
		d = value, g = 41;
		break;
	}
	case 235:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_0$parameter* subgrammar = data.data[--yacc.n, --data.n];
		if (value->parameters.n == value->parameters.cap)
		{
			value->parameters.cap = value->parameters.cap << 1 ?: 1;
			value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
		}
		memmove(value->parameters.data + 1, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
		value->parameters.data[0] = inc_zebu_0$parameter(subgrammar), value->parameters.n++;
		free_zebu_0$parameter(subgrammar);
		}
		d = value, g = 41;
		break;
	}
	case 101:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_lambda_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_lambda_expression(value->lambda), value->lambda = inc_zebu_lambda_expression(subgrammar);
		free_zebu_lambda_expression(subgrammar);
		}
		d = value, g = 43;
		break;
	}
	case 243:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 60;
		break;
	}
	case 274:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_expression(value->base); value->base = inc_zebu_primary_expression(trie->base); }
			if (trie->call) { free_zebu_token(value->call); value->call = inc_zebu_token(trie->call); }
			if (trie->field) { free_zebu_token(value->field); value->field = inc_zebu_token(trie->field); }
			if (trie->index) { free_zebu_expression(value->index); value->index = inc_zebu_expression(trie->index); }
			if (trie->sub) { free_zebu_postfix_expression(value->sub); value->sub = inc_zebu_postfix_expression(trie->sub); }
			free_zebu_postfix_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 60;
		break;
	}
	case 165:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 35;
		break;
	}
	case 206:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 35;
		break;
	}
	case 207:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 36;
		break;
	}
	case 167:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 36;
		break;
	}
	case 232:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 57;
		break;
	}
	case 271:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_type* trie = data.data[--yacc.n, --data.n];
			if (trie->array) { free_zebu_primary_type(value->array); value->array = inc_zebu_primary_type(trie->array); }
			if (trie->bool_type) { free_zebu_token(value->bool_type); value->bool_type = inc_zebu_token(trie->bool_type); }
			if (trie->char_type) { free_zebu_token(value->char_type); value->char_type = inc_zebu_token(trie->char_type); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_type(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_type) { free_zebu_token(value->float_type); value->float_type = inc_zebu_token(trie->float_type); }
			if (trie->grammar) { free_zebu_token(value->grammar); value->grammar = inc_zebu_token(trie->grammar); }
			if (trie->int_type) { free_zebu_token(value->int_type); value->int_type = inc_zebu_token(trie->int_type); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 57;
		break;
	}
	case 267:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_regex_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 72;
		break;
	}
	case 291:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_juxtaposition(value->base); value->base = inc_zebu_regex_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_regex_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_regex(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_regex_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 72;
		break;
	}
	case 149:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 71:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 69:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 150:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 70:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 151:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 152:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 148:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 68:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 66:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 147:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 67:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 269:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 73;
		break;
	}
	case 285:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_postfix(value->base); value->base = inc_zebu_regex_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_regex_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_regex_juxtaposition(trie);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 73;
		break;
	}
	case 272:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 58;
		break;
	}
	case 273:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 58;
		break;
	}
	case 202:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->rettype), value->rettype = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		d = value, g = 59;
		break;
	}
	case 153:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 77:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 157:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 156:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 155:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 73:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 74:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 75:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 154:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 78:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 76:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 158:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 80:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 159:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 81:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 160:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 82:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 161:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 85:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 83:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 162:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 84:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 163:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 164:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 231:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		d = value, g = 56;
		break;
	}
	case 49:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 29;
		break;
	}
	case 280:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 71;
		break;
	}
	case 281:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 71;
		break;
	}
	case 261:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 71;
		break;
	}
	case 282:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 71;
		break;
	}
	case 257:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 69;
		break;
	}
	case 278:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 69;
		break;
	}
	case 98:
	{
		struct zebu_0$parameter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 42;
		break;
	}
	case 199:
	{
		struct zebu_0$parameter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->type), value->type = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		d = value, g = 42;
		break;
	}
	case 103:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		d = value, g = 1;
		break;
	}
	case 104:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		d = value, g = 1;
		break;
	}
	case 19:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->base), value->base = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 1;
		break;
	}
	case 105:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->right), value->right = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_and_expression(value->left), value->left = inc_zebu_and_expression(subgrammar);
		free_zebu_and_expression(subgrammar);
		}
		d = value, g = 2;
		break;
	}
	case 10:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->base), value->base = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		d = value, g = 2;
		break;
	}
	case 193:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->debug), value->debug = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 194:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->note), value->note = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 195:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->warning), value->warning = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 196:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->error), value->error = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 50:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		d = value, g = 3;
		break;
	}
	case 178:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 256:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 258:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 217:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 260:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 172:
	{
		struct zebu_charset_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 47;
		break;
	}
	case 173:
	{
		struct zebu_charset_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 47;
		break;
	}
	case 249:
	{
		struct zebu_charset_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->subcharset), value->subcharset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 47;
		break;
	}
	case 177:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_range(value->base), value->base = inc_zebu_charset_range(subgrammar);
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 48;
		break;
	}
	case 254:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_intersect* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_range(value->base); value->base = inc_zebu_charset_range(trie->base); }
			if (trie->intersects.n)
			{
				while (value->intersects.n + trie->intersects.n > value->intersects.cap)
				{
					value->intersects.cap = value->intersects.cap << 1 ?: 1;
					value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
				}
				memmove(value->intersects.data + trie->intersects.n, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
				for (unsigned i = 0, n = trie->intersects.n; i < n; i++)
					value->intersects.data[i] = inc_zebu_charset_range(trie->intersects.data[i]);
				value->intersects.n += trie->intersects.n;
			}
			free_zebu_charset_intersect(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_range(value->base), value->base = inc_zebu_charset_range(subgrammar);
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 48;
		break;
	}
	case 215:
	{
		struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_highest(value->base), value->base = inc_zebu_charset_highest(subgrammar);
		free_zebu_charset_highest(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->emark), value->emark = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 49;
		break;
	}
	case 174:
	{
		struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_highest(value->base), value->base = inc_zebu_charset_highest(subgrammar);
		free_zebu_charset_highest(subgrammar);
		}
		d = value, g = 49;
		break;
	}
	case 176:
	{
		struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
		free_zebu_charset_prefix(subgrammar);
		}
		d = value, g = 50;
		break;
	}
	case 253:
	{
		struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_prefix(value->right), value->right = inc_zebu_charset_prefix(subgrammar);
		free_zebu_charset_prefix(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
		free_zebu_charset_prefix(subgrammar);
		}
		d = value, g = 50;
		break;
	}
	case 175:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_intersect(value->base), value->base = inc_zebu_charset_intersect(subgrammar);
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 51;
		break;
	}
	case 251:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_symdiff* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_intersect(value->base); value->base = inc_zebu_charset_intersect(trie->base); }
			if (trie->xors.n)
			{
				while (value->xors.n + trie->xors.n > value->xors.cap)
				{
					value->xors.cap = value->xors.cap << 1 ?: 1;
					value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
				}
				memmove(value->xors.data + trie->xors.n, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
				for (unsigned i = 0, n = trie->xors.n; i < n; i++)
					value->xors.data[i] = inc_zebu_charset_intersect(trie->xors.data[i]);
				value->xors.n += trie->xors.n;
			}
			free_zebu_charset_symdiff(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_intersect(value->base), value->base = inc_zebu_charset_intersect(subgrammar);
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 51;
		break;
	}
	case 18:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_or_expression(value->base), value->base = inc_zebu_logical_or_expression(subgrammar);
		free_zebu_logical_or_expression(subgrammar);
		}
		d = value, g = 4;
		break;
	}
	case 241:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_conditional_expression(value->false_case), value->false_case = inc_zebu_conditional_expression(subgrammar);
		free_zebu_conditional_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->true_case), value->true_case = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_or_expression(value->base), value->base = inc_zebu_logical_or_expression(subgrammar);
		free_zebu_logical_or_expression(subgrammar);
		}
		d = value, g = 4;
		break;
	}
	case 112:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->right), value->right = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		d = value, g = 5;
		break;
	}
	case 113:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->right), value->right = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		d = value, g = 5;
		break;
	}
	case 23:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->base), value->base = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 5;
		break;
	}
	case 7:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_and_expression(value->base), value->base = inc_zebu_and_expression(subgrammar);
		free_zebu_and_expression(subgrammar);
		}
		d = value, g = 6;
		break;
	}
	case 114:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_and_expression(value->right), value->right = inc_zebu_and_expression(subgrammar);
		free_zebu_and_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exclusive_or_expression(value->left), value->left = inc_zebu_exclusive_or_expression(subgrammar);
		free_zebu_exclusive_or_expression(subgrammar);
		}
		d = value, g = 6;
		break;
	}
	case 115:
	{
		struct zebu_exponentiation_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->right), value->right = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->left), value->left = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		d = value, g = 7;
		break;
	}
	case 27:
	{
		struct zebu_exponentiation_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->base), value->base = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		d = value, g = 7;
		break;
	}
	case 14:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_implication_expression(value->base), value->base = inc_zebu_implication_expression(subgrammar);
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 8;
		break;
	}
	case 122:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_implication_expression(value->base); value->base = inc_zebu_implication_expression(trie->base); }
			if (trie->iffs.n)
			{
				while (value->iffs.n + trie->iffs.n > value->iffs.cap)
				{
					value->iffs.cap = value->iffs.cap << 1 ?: 1;
					value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
				}
				memmove(value->iffs.data + trie->iffs.n, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
				for (unsigned i = 0, n = trie->iffs.n; i < n; i++)
					value->iffs.data[i] = inc_zebu_implication_expression(trie->iffs.data[i]);
				value->iffs.n += trie->iffs.n;
			}
			free_zebu_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_implication_expression(value->base), value->base = inc_zebu_implication_expression(subgrammar);
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 8;
		break;
	}
	case 95:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_juxtaposition(value->base), value->base = inc_zebu_grammar_juxtaposition(subgrammar);
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 37;
		break;
	}
	case 225:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_juxtaposition(value->base); value->base = inc_zebu_grammar_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_grammar_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_grammar(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_juxtaposition(value->base), value->base = inc_zebu_grammar_juxtaposition(subgrammar);
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 37;
		break;
	}
	case 90:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 169:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 209:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 91:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 170:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 211:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 212:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->subgrammar), value->subgrammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 247:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->subgrammar), value->subgrammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 275:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->subgrammar), value->subgrammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 93:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 92:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 171:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 214:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 216:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 250:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 277:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 179:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 219:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 220:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 265:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 284:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 96:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_postfix(value->base), value->base = inc_zebu_grammar_postfix(subgrammar);
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 39;
		break;
	}
	case 190:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_postfix(value->base), value->base = inc_zebu_grammar_postfix(subgrammar);
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 39;
		break;
	}
	case 227:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_postfix(value->base); value->base = inc_zebu_grammar_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_grammar_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_grammar_juxtaposition(trie);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_postfix(value->base), value->base = inc_zebu_grammar_postfix(subgrammar);
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 39;
		break;
	}
	case 94:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 187:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 188:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->qmark), value->qmark = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 189:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->star), value->star = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 186:
	{
		struct zebu_grammar_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->grammar), value->grammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 9;
		break;
	}
	case 20:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_possession_expression(value->base), value->base = inc_zebu_possession_expression(subgrammar);
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 10;
		break;
	}
	case 131:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_implication_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_possession_expression(value->base); value->base = inc_zebu_possession_expression(trie->base); }
			if (trie->implies.n)
			{
				while (value->implies.n + trie->implies.n > value->implies.cap)
				{
					value->implies.cap = value->implies.cap << 1 ?: 1;
					value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
				}
				memmove(value->implies.data + trie->implies.n, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
				for (unsigned i = 0, n = trie->implies.n; i < n; i++)
					value->implies.data[i] = inc_zebu_possession_expression(trie->implies.data[i]);
				value->implies.n += trie->implies.n;
			}
			free_zebu_implication_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_possession_expression(value->base), value->base = inc_zebu_possession_expression(subgrammar);
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 10;
		break;
	}
	case 11:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exclusive_or_expression(value->base), value->base = inc_zebu_exclusive_or_expression(subgrammar);
		free_zebu_exclusive_or_expression(subgrammar);
		}
		d = value, g = 11;
		break;
	}
	case 124:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exclusive_or_expression(value->right), value->right = inc_zebu_exclusive_or_expression(subgrammar);
		free_zebu_exclusive_or_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_inclusive_or_expression(value->left), value->left = inc_zebu_inclusive_or_expression(subgrammar);
		free_zebu_inclusive_or_expression(subgrammar);
		}
		d = value, g = 11;
		break;
	}
	case 99:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 100:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 238:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->type), value->type = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 239:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->type), value->type = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 9:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_conditional_expression(value->base), value->base = inc_zebu_conditional_expression(subgrammar);
		free_zebu_conditional_expression(subgrammar);
		}
		d = value, g = 12;
		break;
	}
	case 15:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_inclusive_or_expression(value->base), value->base = inc_zebu_inclusive_or_expression(subgrammar);
		free_zebu_inclusive_or_expression(subgrammar);
		}
		d = value, g = 13;
		break;
	}
	case 126:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_inclusive_or_expression(value->right), value->right = inc_zebu_inclusive_or_expression(subgrammar);
		free_zebu_inclusive_or_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_and_expression(value->left), value->left = inc_zebu_logical_and_expression(subgrammar);
		free_zebu_logical_and_expression(subgrammar);
		}
		d = value, g = 13;
		break;
	}
	case 17:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_and_expression(value->base), value->base = inc_zebu_logical_and_expression(subgrammar);
		free_zebu_logical_and_expression(subgrammar);
		}
		d = value, g = 14;
		break;
	}
	case 127:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_and_expression(value->right), value->right = inc_zebu_logical_and_expression(subgrammar);
		free_zebu_logical_and_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_or_expression(value->left), value->left = inc_zebu_logical_or_expression(subgrammar);
		free_zebu_logical_or_expression(subgrammar);
		}
		d = value, g = 14;
		break;
	}
	case 12:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->base), value->base = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 128:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->right), value->right = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 129:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->right), value->right = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 130:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->right), value->right = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 16:
	{
		struct zebu_possession_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_lambda_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_lambda_expression(value->base), value->base = inc_zebu_lambda_expression(subgrammar);
		free_zebu_lambda_expression(subgrammar);
		}
		d = value, g = 16;
		break;
	}
	case 125:
	{
		struct zebu_possession_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->has), value->has = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_lambda_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_lambda_expression(value->base), value->base = inc_zebu_lambda_expression(subgrammar);
		free_zebu_lambda_expression(subgrammar);
		}
		d = value, g = 16;
		break;
	}
	case 133:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 203:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_expression(value->base); value->base = inc_zebu_primary_expression(trie->base); }
			if (trie->call) { free_zebu_token(value->call); value->call = inc_zebu_token(trie->call); }
			if (trie->field) { free_zebu_token(value->field); value->field = inc_zebu_token(trie->field); }
			if (trie->index) { free_zebu_expression(value->index); value->index = inc_zebu_expression(trie->index); }
			if (trie->sub) { free_zebu_postfix_expression(value->sub); value->sub = inc_zebu_postfix_expression(trie->sub); }
			free_zebu_postfix_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 204:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 244:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_expression(value->base); value->base = inc_zebu_primary_expression(trie->base); }
			if (trie->call) { free_zebu_token(value->call); value->call = inc_zebu_token(trie->call); }
			if (trie->field) { free_zebu_token(value->field); value->field = inc_zebu_token(trie->field); }
			if (trie->index) { free_zebu_expression(value->index); value->index = inc_zebu_expression(trie->index); }
			if (trie->sub) { free_zebu_postfix_expression(value->sub); value->sub = inc_zebu_postfix_expression(trie->sub); }
			free_zebu_postfix_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 205:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->index), value->index = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 134:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->field), value->field = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 22:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_primary_expression(value->base), value->base = inc_zebu_primary_expression(subgrammar);
		free_zebu_primary_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 1:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character_literal), value->character_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 2:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer_literal), value->integer_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 30:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 86:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 87:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 166:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 4:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->float_literal), value->float_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 3:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string_literal), value->string_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 88:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 33:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 168:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 89:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 5:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->identifier), value->identifier = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 97:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 197:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_type* trie = data.data[--yacc.n, --data.n];
			if (trie->array) { free_zebu_primary_type(value->array); value->array = inc_zebu_primary_type(trie->array); }
			if (trie->bool_type) { free_zebu_token(value->bool_type); value->bool_type = inc_zebu_token(trie->bool_type); }
			if (trie->char_type) { free_zebu_token(value->char_type); value->char_type = inc_zebu_token(trie->char_type); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_type(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_type) { free_zebu_token(value->float_type); value->float_type = inc_zebu_token(trie->float_type); }
			if (trie->grammar) { free_zebu_token(value->grammar); value->grammar = inc_zebu_token(trie->grammar); }
			if (trie->int_type) { free_zebu_token(value->int_type); value->int_type = inc_zebu_token(trie->int_type); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 198:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 233:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_type* trie = data.data[--yacc.n, --data.n];
			if (trie->array) { free_zebu_primary_type(value->array); value->array = inc_zebu_primary_type(trie->array); }
			if (trie->bool_type) { free_zebu_token(value->bool_type); value->bool_type = inc_zebu_token(trie->bool_type); }
			if (trie->char_type) { free_zebu_token(value->char_type); value->char_type = inc_zebu_token(trie->char_type); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_type(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_type) { free_zebu_token(value->float_type); value->float_type = inc_zebu_token(trie->float_type); }
			if (trie->grammar) { free_zebu_token(value->grammar); value->grammar = inc_zebu_token(trie->grammar); }
			if (trie->int_type) { free_zebu_token(value->int_type); value->int_type = inc_zebu_token(trie->int_type); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 36:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->grammar), value->grammar = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 37:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->int_type), value->int_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 40:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->float_type), value->float_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 38:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->char_type), value->char_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 39:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->bool_type), value->bool_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 102:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_primary_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_primary_type(value->array), value->array = inc_zebu_primary_type(subgrammar);
		free_zebu_primary_type(subgrammar);
		}
		d = value, g = 26;
		break;
	}
	case 184:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_juxtaposition(value->base), value->base = inc_zebu_regex_juxtaposition(subgrammar);
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 52;
		break;
	}
	case 266:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_juxtaposition(value->base); value->base = inc_zebu_regex_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_regex_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_regex(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_juxtaposition(value->base), value->base = inc_zebu_regex_juxtaposition(subgrammar);
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 52;
		break;
	}
	case 180:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 181:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 263:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->subregex), value->subregex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 182:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 264:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 185:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_postfix(value->base), value->base = inc_zebu_regex_postfix(subgrammar);
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 54;
		break;
	}
	case 224:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_postfix(value->base), value->base = inc_zebu_regex_postfix(subgrammar);
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 54;
		break;
	}
	case 268:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_postfix(value->base); value->base = inc_zebu_regex_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_regex_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_regex_juxtaposition(trie);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_postfix(value->base), value->base = inc_zebu_regex_postfix(subgrammar);
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 54;
		break;
	}
	case 183:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 221:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 222:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->qmark), value->qmark = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 223:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->star), value->star = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 135:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 136:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 137:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 138:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 24:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->base), value->base = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 6:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->base), value->base = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		d = value, g = 20;
		break;
	}
	case 139:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		d = value, g = 20;
		break;
	}
	case 140:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		d = value, g = 20;
		break;
	}
	case 229:
	{
		struct zebu_skip_directive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 21;
		break;
	}
	case 230:
	{
		struct zebu_start_directive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->grammar), value->grammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 22;
		break;
	}
	case 200:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 201:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 236:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 237:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 41:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_primary_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_primary_type(value->base), value->base = inc_zebu_primary_type(subgrammar);
		free_zebu_primary_type(subgrammar);
		}
		d = value, g = 27;
		break;
	}
	case 31:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 32:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 34:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 35:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 21:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->base), value->base = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 23;
		break;
	}
	case 192:
	{
		struct zebu_using_directive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->path), value->path = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 24;
		break;
	}
	case 191:
	{
		struct zebu_value_declare* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 25;
		break;
	}
}
			
			if (g == 76)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			assert(!"266");
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















