
%extra_field: primary_expression, "unsigned", kind;
%extra_field: primary_expression, "struct type*", type;
%extra_field: primary_expression, "struct value*", value, free_value();

%include "type.zb"

primary_expression
	: `int` #integer_literal
	| `float` #float_literal
	| `char` #character_literal
	| `string` #string_literal
	| "true" #true_literal
	| "false" #false_literal
	| `identifier` #identifier
	| ("all" #all | "any" #any | "filter" #filter | "len" #len | "map" #map
	  | "max" #max | "min" #min | "product" #product | "range" #range
	  | "reduce" #reduce | "sort" #sort | "sum" #sum | "unique" #unique
	  | "zip" #zip) '(' expression #args[]  (',' expression #args[])* ')'
	| '(' #paren expression #elements[] (',' #tuple (expression #elements[] (',' expression #elements[])*)?)? ')'
	| '[' #list ':' type #emptytype ':' ']'
	| '[' #list expression #elements[]  (',' expression #elements[])* ']'
	;

postfix_expression
	: primary_expression #base
	| postfix_expression #sub '[' expression #index ']'
	| postfix_expression #sub '.' `identifier` #field
	| postfix_expression #sub '(' #call (expression #args[] (',' expression #args[])*)? ')'
	;

unary_expression
	: postfix_expression #base
	| "+" unary_expression #sub
	| "-" unary_expression #sub
	| "!" unary_expression #sub
	| "~" unary_expression #sub
	;
	
exponentiation_expression
	: unary_expression #base
	| exponentiation_expression #left "**" unary_expression #right
	;

multiplicative_expression
	: exponentiation_expression #base
	| multiplicative_expression #left '*' exponentiation_expression #right
	| multiplicative_expression #left '/' exponentiation_expression #right
	| multiplicative_expression #left '%' exponentiation_expression #right
	;

additive_expression
	: multiplicative_expression #base
	| additive_expression #left '+' #add multiplicative_expression #right
	| additive_expression #left '-' #sub multiplicative_expression #right
	;

shift_expression
	: additive_expression #base
	| shift_expression #left "<<" additive_expression #right
	| shift_expression #left ">>" additive_expression #right
	;

relational_expression
	: shift_expression #base
	| relational_expression #left '<'  #lt  shift_expression #right
	| relational_expression #left '>'  #gt  shift_expression #right
	| relational_expression #left "<=" #lte shift_expression #right
	| relational_expression #left ">=" #gte shift_expression #right
	;

equality_expression
	: relational_expression #base
	| equality_expression #left "==" relational_expression #right
	| equality_expression #left "!=" #not relational_expression #right
	;

and_expression
	: equality_expression #base
	| and_expression #left '&' equality_expression #right
	;

exclusive_or_expression
	: and_expression #base
	| exclusive_or_expression #left '^' and_expression #right
	;

inclusive_or_expression
	: exclusive_or_expression #base
	| inclusive_or_expression #left '|' exclusive_or_expression #right
	;

logical_and_expression
	: inclusive_or_expression #base
	| logical_and_expression #left "&&" inclusive_or_expression #right
	;

logical_or_expression
	: logical_and_expression #base
	| logical_or_expression #left "||" logical_and_expression #right
	;

inclusion_expression: logical_or_expression #base ("in" logical_or_expression #list)?;

possession_expression: inclusion_expression #base ("has" `identifier` #has)?;

implication_expression: possession_expression #base ("implies" implication_expression #implies)?;

conditional_expression
	: implication_expression #base
	| implication_expression #base
		'?' #qmark expression #true_case
		':' conditional_expression #false_case
	;

%include "type.zb"

%extra_field: lambda_expression, "struct unresolved*", lambda_captures, free_unresolved();

lambda_expression
	: conditional_expression #base
	| %parameter: (type #type)? `identifier` #name:
		('$' (type #type `identifier` #name (',' parameter #parameters[])*)?
			"->" type #rettype ':' lambda_expression #lambda)
	;

expression: lambda_expression #base;




















