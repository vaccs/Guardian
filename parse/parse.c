#include "parse.h"

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[1272][57] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[1][7] = 7,
	[1][8] = 8,
	[1][9] = 9,
	[1][10] = 10,
	[1][11] = 11,
	[1][12] = 12,
	[1][13] = 13,
	[1][14] = 14,
	[1][15] = 15,
	[4][2] = 41,
	[4][3] = 42,
	[4][4] = 43,
	[4][5] = 45,
	[4][6] = 46,
	[4][7] = 48,
	[4][8] = 49,
	[4][9] = 50,
	[4][10] = 51,
	[4][11] = 52,
	[4][12] = 53,
	[4][13] = 54,
	[4][15] = 55,
	[4][38] = 44,
	[4][39] = 47,
	[5][2] = 2,
	[5][3] = 3,
	[5][4] = 4,
	[5][5] = 5,
	[5][6] = 6,
	[5][7] = 7,
	[5][8] = 8,
	[5][9] = 9,
	[5][10] = 10,
	[5][11] = 75,
	[5][12] = 12,
	[5][13] = 13,
	[6][2] = 2,
	[6][3] = 3,
	[6][4] = 4,
	[6][5] = 5,
	[6][6] = 6,
	[6][7] = 7,
	[6][8] = 8,
	[6][9] = 9,
	[6][10] = 10,
	[6][11] = 75,
	[6][12] = 12,
	[6][13] = 13,
	[8][2] = 78,
	[8][3] = 79,
	[8][4] = 80,
	[8][5] = 81,
	[8][6] = 82,
	[8][7] = 84,
	[8][8] = 85,
	[8][9] = 87,
	[8][10] = 88,
	[8][11] = 89,
	[8][12] = 90,
	[8][13] = 91,
	[8][15] = 92,
	[8][39] = 83,
	[8][40] = 86,
	[9][2] = 2,
	[9][3] = 3,
	[9][4] = 4,
	[9][5] = 5,
	[9][6] = 6,
	[9][7] = 7,
	[9][8] = 8,
	[9][9] = 9,
	[9][10] = 10,
	[9][11] = 75,
	[9][12] = 12,
	[9][13] = 13,
	[11][41] = 113,
	[11][42] = 114,
	[12][4] = 115,
	[13][2] = 2,
	[13][3] = 3,
	[13][4] = 4,
	[13][5] = 5,
	[13][6] = 6,
	[13][7] = 7,
	[13][8] = 8,
	[13][9] = 9,
	[13][10] = 10,
	[13][11] = 75,
	[13][12] = 12,
	[13][13] = 13,
	[14][43] = 117,
	[14][44] = 118,
	[14][45] = 119,
	[14][46] = 120,
	[14][47] = 121,
	[14][48] = 122,
	[14][49] = 123,
	[15][4] = 124,
	[15][11] = 126,
	[15][15] = 132,
	[15][39] = 125,
	[15][41] = 127,
	[15][50] = 128,
	[15][51] = 129,
	[15][52] = 130,
	[15][53] = 131,
	[16][6] = 135,
	[16][9] = 136,
	[17][16] = 137,
	[18][2] = 2,
	[18][3] = 3,
	[18][4] = 4,
	[18][5] = 5,
	[18][6] = 6,
	[18][7] = 7,
	[18][8] = 8,
	[18][9] = 9,
	[18][10] = 10,
	[18][11] = 11,
	[18][12] = 12,
	[18][13] = 13,
	[18][14] = 14,
	[18][15] = 15,
	[20][30] = 145,
	[20][31] = 146,
	[21][17] = 147,
	[22][22] = 148,
	[23][37] = 149,
	[24][2] = 2,
	[24][3] = 3,
	[24][4] = 4,
	[24][5] = 5,
	[24][6] = 6,
	[24][7] = 7,
	[24][8] = 8,
	[24][9] = 9,
	[24][10] = 10,
	[24][11] = 11,
	[24][12] = 12,
	[24][13] = 13,
	[24][14] = 14,
	[24][15] = 15,
	[25][36] = 158,
	[26][18] = 159,
	[27][34] = 160,
	[28][32] = 161,
	[29][19] = 162,
	[29][33] = 163,
	[30][14] = 166,
	[30][20] = 164,
	[30][23] = 165,
	[31][35] = 167,
	[32][4] = 168,
	[32][8] = 169,
	[32][21] = 170,
	[34][26] = 171,
	[34][27] = 172,
	[34][28] = 173,
	[34][29] = 174,
	[35][24] = 175,
	[35][25] = 176,
	[36][2] = 2,
	[36][3] = 3,
	[36][4] = 4,
	[36][5] = 5,
	[36][6] = 6,
	[36][7] = 7,
	[36][8] = 8,
	[36][9] = 9,
	[36][10] = 10,
	[36][11] = 11,
	[36][12] = 12,
	[36][13] = 13,
	[36][14] = 14,
	[36][15] = 15,
	[37][2] = 2,
	[37][3] = 3,
	[37][4] = 4,
	[37][5] = 5,
	[37][6] = 6,
	[37][7] = 7,
	[37][8] = 8,
	[37][9] = 9,
	[37][10] = 10,
	[37][11] = 11,
	[37][12] = 12,
	[37][13] = 13,
	[37][14] = 14,
	[37][15] = 15,
	[39][2] = 2,
	[39][3] = 3,
	[39][4] = 4,
	[39][5] = 5,
	[39][6] = 6,
	[39][7] = 7,
	[39][8] = 8,
	[39][9] = 9,
	[39][10] = 10,
	[39][11] = 11,
	[39][12] = 12,
	[39][13] = 13,
	[39][14] = 14,
	[39][15] = 15,
	[40][2] = 2,
	[40][3] = 3,
	[40][4] = 4,
	[40][5] = 5,
	[40][6] = 6,
	[40][7] = 7,
	[40][8] = 8,
	[40][9] = 9,
	[40][10] = 10,
	[40][11] = 11,
	[40][12] = 12,
	[40][13] = 13,
	[40][14] = 14,
	[40][15] = 15,
	[43][2] = 41,
	[43][3] = 42,
	[43][4] = 43,
	[43][5] = 45,
	[43][6] = 46,
	[43][7] = 48,
	[43][8] = 49,
	[43][9] = 50,
	[43][10] = 51,
	[43][11] = 52,
	[43][12] = 53,
	[43][13] = 54,
	[43][15] = 55,
	[43][38] = 205,
	[43][39] = 206,
	[45][2] = 41,
	[45][3] = 42,
	[45][4] = 43,
	[45][5] = 45,
	[45][6] = 46,
	[45][7] = 48,
	[45][8] = 49,
	[45][9] = 50,
	[45][10] = 51,
	[45][11] = 52,
	[45][12] = 53,
	[45][13] = 54,
	[46][2] = 41,
	[46][3] = 42,
	[46][4] = 43,
	[46][5] = 45,
	[46][6] = 46,
	[46][7] = 48,
	[46][8] = 49,
	[46][9] = 50,
	[46][10] = 51,
	[46][11] = 52,
	[46][12] = 53,
	[46][13] = 54,
	[47][2] = 41,
	[47][3] = 42,
	[47][4] = 43,
	[47][5] = 45,
	[47][6] = 46,
	[47][7] = 48,
	[47][8] = 49,
	[47][9] = 50,
	[47][10] = 51,
	[47][11] = 52,
	[47][12] = 53,
	[47][13] = 54,
	[47][15] = 55,
	[49][2] = 78,
	[49][3] = 79,
	[49][4] = 80,
	[49][5] = 81,
	[49][6] = 82,
	[49][7] = 84,
	[49][8] = 85,
	[49][9] = 87,
	[49][10] = 88,
	[49][11] = 89,
	[49][12] = 90,
	[49][13] = 91,
	[49][15] = 92,
	[49][39] = 212,
	[49][40] = 213,
	[50][2] = 41,
	[50][3] = 42,
	[50][4] = 43,
	[50][5] = 45,
	[50][6] = 46,
	[50][7] = 48,
	[50][8] = 49,
	[50][9] = 50,
	[50][10] = 51,
	[50][11] = 52,
	[50][12] = 53,
	[50][13] = 54,
	[53][4] = 216,
	[54][2] = 41,
	[54][3] = 42,
	[54][4] = 43,
	[54][5] = 45,
	[54][6] = 46,
	[54][7] = 48,
	[54][8] = 49,
	[54][9] = 50,
	[54][10] = 51,
	[54][11] = 52,
	[54][12] = 53,
	[54][13] = 54,
	[55][4] = 124,
	[55][11] = 126,
	[55][15] = 132,
	[55][39] = 218,
	[55][41] = 219,
	[55][50] = 128,
	[55][51] = 129,
	[55][52] = 130,
	[55][53] = 131,
	[56][6] = 221,
	[56][9] = 222,
	[57][16] = 223,
	[59][30] = 224,
	[59][31] = 225,
	[60][17] = 226,
	[61][22] = 227,
	[62][38] = 228,
	[62][39] = 229,
	[63][36] = 230,
	[64][18] = 231,
	[65][34] = 232,
	[66][32] = 233,
	[67][19] = 234,
	[67][33] = 235,
	[68][14] = 238,
	[68][20] = 236,
	[68][23] = 237,
	[69][35] = 239,
	[70][4] = 240,
	[70][8] = 241,
	[70][21] = 242,
	[72][26] = 243,
	[72][27] = 244,
	[72][28] = 245,
	[72][29] = 246,
	[73][24] = 247,
	[73][25] = 248,
	[80][2] = 41,
	[80][3] = 42,
	[80][4] = 43,
	[80][5] = 45,
	[80][6] = 46,
	[80][7] = 48,
	[80][8] = 49,
	[80][9] = 50,
	[80][10] = 51,
	[80][11] = 52,
	[80][12] = 53,
	[80][13] = 54,
	[80][15] = 55,
	[80][38] = 249,
	[80][39] = 250,
	[81][2] = 78,
	[81][3] = 79,
	[81][4] = 80,
	[81][5] = 81,
	[81][6] = 82,
	[81][7] = 84,
	[81][8] = 85,
	[81][9] = 87,
	[81][10] = 88,
	[81][11] = 89,
	[81][12] = 90,
	[81][13] = 91,
	[82][2] = 78,
	[82][3] = 79,
	[82][4] = 80,
	[82][5] = 81,
	[82][6] = 82,
	[82][7] = 84,
	[82][8] = 85,
	[82][9] = 87,
	[82][10] = 88,
	[82][11] = 89,
	[82][12] = 90,
	[82][13] = 91,
	[83][2] = 78,
	[83][3] = 79,
	[83][4] = 80,
	[83][5] = 81,
	[83][6] = 82,
	[83][7] = 84,
	[83][8] = 85,
	[83][9] = 87,
	[83][10] = 88,
	[83][11] = 89,
	[83][12] = 90,
	[83][13] = 91,
	[83][15] = 92,
	[85][2] = 78,
	[85][3] = 79,
	[85][4] = 80,
	[85][5] = 81,
	[85][6] = 82,
	[85][7] = 84,
	[85][8] = 85,
	[85][9] = 87,
	[85][10] = 88,
	[85][11] = 89,
	[85][12] = 90,
	[85][13] = 91,
	[85][15] = 92,
	[85][39] = 256,
	[85][40] = 257,
	[87][2] = 78,
	[87][3] = 79,
	[87][4] = 80,
	[87][5] = 81,
	[87][6] = 82,
	[87][7] = 84,
	[87][8] = 85,
	[87][9] = 87,
	[87][10] = 88,
	[87][11] = 89,
	[87][12] = 90,
	[87][13] = 91,
	[90][4] = 260,
	[91][2] = 78,
	[91][3] = 79,
	[91][4] = 80,
	[91][5] = 81,
	[91][6] = 82,
	[91][7] = 84,
	[91][8] = 85,
	[91][9] = 87,
	[91][10] = 88,
	[91][11] = 89,
	[91][12] = 90,
	[91][13] = 91,
	[92][4] = 124,
	[92][11] = 126,
	[92][15] = 132,
	[92][39] = 262,
	[92][41] = 263,
	[92][50] = 128,
	[92][51] = 129,
	[92][52] = 130,
	[92][53] = 131,
	[93][6] = 265,
	[93][9] = 266,
	[94][16] = 267,
	[96][30] = 268,
	[96][31] = 269,
	[97][17] = 270,
	[98][22] = 271,
	[99][39] = 272,
	[99][40] = 273,
	[100][36] = 274,
	[101][18] = 275,
	[102][34] = 276,
	[103][32] = 277,
	[104][19] = 278,
	[104][33] = 279,
	[105][14] = 282,
	[105][20] = 280,
	[105][23] = 281,
	[106][35] = 283,
	[107][4] = 284,
	[107][8] = 285,
	[107][21] = 286,
	[109][26] = 287,
	[109][27] = 288,
	[109][28] = 289,
	[109][29] = 290,
	[110][24] = 291,
	[110][25] = 292,
	[113][2] = 293,
	[113][3] = 294,
	[113][4] = 295,
	[113][7] = 296,
	[113][8] = 297,
	[113][11] = 298,
	[113][23] = 299,
	[114][2] = 2,
	[114][3] = 3,
	[114][4] = 4,
	[114][5] = 5,
	[114][6] = 6,
	[114][7] = 7,
	[114][8] = 8,
	[114][9] = 9,
	[114][10] = 10,
	[114][11] = 75,
	[114][12] = 12,
	[114][13] = 13,
	[114][15] = 15,
	[115][2] = 41,
	[115][3] = 42,
	[115][4] = 43,
	[115][5] = 45,
	[115][6] = 46,
	[115][7] = 48,
	[115][8] = 49,
	[115][9] = 50,
	[115][10] = 51,
	[115][11] = 52,
	[115][12] = 53,
	[115][13] = 54,
	[115][15] = 55,
	[115][38] = 305,
	[115][39] = 306,
	[117][7] = 308,
	[118][41] = 309,
	[119][41] = 310,
	[120][41] = 311,
	[121][41] = 312,
	[122][41] = 313,
	[123][41] = 314,
	[124][4] = 315,
	[124][11] = 318,
	[124][15] = 323,
	[124][38] = 316,
	[124][39] = 317,
	[124][50] = 319,
	[124][51] = 320,
	[124][52] = 321,
	[124][53] = 322,
	[125][4] = 124,
	[125][11] = 326,
	[125][15] = 132,
	[125][50] = 128,
	[125][51] = 129,
	[125][52] = 130,
	[125][53] = 131,
	[127][2] = 2,
	[127][3] = 3,
	[127][4] = 4,
	[127][5] = 5,
	[127][6] = 6,
	[127][7] = 7,
	[127][8] = 8,
	[127][9] = 9,
	[127][10] = 10,
	[127][11] = 75,
	[127][12] = 12,
	[127][13] = 13,
	[127][15] = 15,
	[132][4] = 332,
	[132][11] = 334,
	[132][15] = 340,
	[132][39] = 333,
	[132][41] = 335,
	[132][50] = 336,
	[132][51] = 337,
	[132][52] = 338,
	[132][53] = 339,
	[133][55] = 343,
	[134][11] = 344,
	[135][2] = 2,
	[135][3] = 3,
	[135][4] = 4,
	[135][5] = 5,
	[135][6] = 6,
	[135][7] = 7,
	[135][8] = 8,
	[135][9] = 9,
	[135][10] = 10,
	[135][11] = 75,
	[135][12] = 12,
	[135][13] = 13,
	[136][2] = 2,
	[136][3] = 3,
	[136][4] = 4,
	[136][5] = 5,
	[136][6] = 6,
	[136][7] = 7,
	[136][8] = 8,
	[136][9] = 9,
	[136][10] = 10,
	[136][11] = 75,
	[136][12] = 12,
	[136][13] = 13,
	[137][2] = 2,
	[137][3] = 3,
	[137][4] = 4,
	[137][5] = 5,
	[137][6] = 6,
	[137][7] = 7,
	[137][8] = 8,
	[137][9] = 9,
	[137][10] = 10,
	[137][11] = 75,
	[137][12] = 12,
	[137][13] = 13,
	[139][2] = 2,
	[139][3] = 3,
	[139][4] = 4,
	[139][5] = 5,
	[139][6] = 6,
	[139][7] = 7,
	[139][8] = 8,
	[139][9] = 9,
	[139][10] = 10,
	[139][11] = 11,
	[139][12] = 12,
	[139][13] = 13,
	[139][14] = 14,
	[139][15] = 15,
	[140][2] = 2,
	[140][3] = 3,
	[140][4] = 4,
	[140][5] = 5,
	[140][6] = 6,
	[140][7] = 7,
	[140][8] = 8,
	[140][9] = 9,
	[140][10] = 10,
	[140][11] = 11,
	[140][12] = 12,
	[140][13] = 13,
	[140][14] = 14,
	[140][15] = 15,
	[141][2] = 2,
	[141][3] = 3,
	[141][4] = 4,
	[141][5] = 5,
	[141][6] = 6,
	[141][7] = 7,
	[141][8] = 8,
	[141][9] = 9,
	[141][10] = 10,
	[141][11] = 11,
	[141][12] = 12,
	[141][13] = 13,
	[141][14] = 14,
	[141][15] = 15,
	[142][2] = 2,
	[142][3] = 3,
	[142][4] = 4,
	[142][5] = 5,
	[142][6] = 6,
	[142][7] = 7,
	[142][8] = 8,
	[142][9] = 9,
	[142][10] = 10,
	[142][11] = 11,
	[142][12] = 12,
	[142][13] = 13,
	[142][14] = 14,
	[142][15] = 15,
	[143][2] = 2,
	[143][3] = 3,
	[143][4] = 4,
	[143][5] = 5,
	[143][6] = 6,
	[143][7] = 7,
	[143][8] = 8,
	[143][9] = 9,
	[143][10] = 10,
	[143][11] = 11,
	[143][12] = 12,
	[143][13] = 13,
	[143][14] = 14,
	[143][15] = 15,
	[144][2] = 2,
	[144][3] = 3,
	[144][4] = 4,
	[144][5] = 5,
	[144][6] = 6,
	[144][7] = 7,
	[144][8] = 8,
	[144][9] = 9,
	[144][10] = 10,
	[144][11] = 11,
	[144][12] = 12,
	[144][13] = 13,
	[144][14] = 14,
	[144][15] = 15,
	[145][2] = 2,
	[145][3] = 3,
	[145][4] = 4,
	[145][5] = 5,
	[145][6] = 6,
	[145][7] = 7,
	[145][8] = 8,
	[145][9] = 9,
	[145][10] = 10,
	[145][11] = 75,
	[145][12] = 12,
	[145][13] = 13,
	[146][2] = 2,
	[146][3] = 3,
	[146][4] = 4,
	[146][5] = 5,
	[146][6] = 6,
	[146][7] = 7,
	[146][8] = 8,
	[146][9] = 9,
	[146][10] = 10,
	[146][11] = 75,
	[146][12] = 12,
	[146][13] = 13,
	[147][2] = 2,
	[147][3] = 3,
	[147][4] = 4,
	[147][5] = 5,
	[147][6] = 6,
	[147][7] = 7,
	[147][8] = 8,
	[147][9] = 9,
	[147][10] = 10,
	[147][11] = 75,
	[147][12] = 12,
	[147][13] = 13,
	[148][2] = 2,
	[148][3] = 3,
	[148][4] = 4,
	[148][5] = 5,
	[148][6] = 6,
	[148][7] = 7,
	[148][8] = 8,
	[148][9] = 9,
	[148][10] = 10,
	[148][11] = 75,
	[148][12] = 12,
	[148][13] = 13,
	[152][2] = 2,
	[152][3] = 3,
	[152][4] = 4,
	[152][5] = 5,
	[152][6] = 6,
	[152][7] = 7,
	[152][8] = 8,
	[152][9] = 9,
	[152][10] = 10,
	[152][11] = 11,
	[152][12] = 12,
	[152][13] = 13,
	[152][14] = 14,
	[152][15] = 15,
	[153][2] = 2,
	[153][3] = 3,
	[153][4] = 4,
	[153][5] = 5,
	[153][6] = 6,
	[153][7] = 7,
	[153][8] = 8,
	[153][9] = 9,
	[153][10] = 10,
	[153][11] = 11,
	[153][12] = 12,
	[153][13] = 13,
	[153][14] = 14,
	[153][15] = 15,
	[154][2] = 2,
	[154][3] = 3,
	[154][4] = 4,
	[154][5] = 5,
	[154][6] = 6,
	[154][7] = 7,
	[154][8] = 8,
	[154][9] = 9,
	[154][10] = 10,
	[154][11] = 11,
	[154][12] = 12,
	[154][13] = 13,
	[154][14] = 14,
	[154][15] = 15,
	[155][2] = 2,
	[155][3] = 3,
	[155][4] = 4,
	[155][5] = 5,
	[155][6] = 6,
	[155][7] = 7,
	[155][8] = 8,
	[155][9] = 9,
	[155][10] = 10,
	[155][11] = 11,
	[155][12] = 12,
	[155][13] = 13,
	[155][14] = 14,
	[155][15] = 15,
	[156][2] = 2,
	[156][3] = 3,
	[156][4] = 4,
	[156][5] = 5,
	[156][6] = 6,
	[156][7] = 7,
	[156][8] = 8,
	[156][9] = 9,
	[156][10] = 10,
	[156][11] = 11,
	[156][12] = 12,
	[156][13] = 13,
	[156][14] = 14,
	[156][15] = 15,
	[157][2] = 2,
	[157][3] = 3,
	[157][4] = 4,
	[157][5] = 5,
	[157][6] = 6,
	[157][7] = 7,
	[157][8] = 8,
	[157][9] = 9,
	[157][10] = 10,
	[157][11] = 11,
	[157][12] = 12,
	[157][13] = 13,
	[157][14] = 14,
	[157][15] = 15,
	[158][2] = 2,
	[158][3] = 3,
	[158][4] = 4,
	[158][5] = 5,
	[158][6] = 6,
	[158][7] = 7,
	[158][8] = 8,
	[158][9] = 9,
	[158][10] = 10,
	[158][11] = 75,
	[158][12] = 12,
	[158][13] = 13,
	[158][15] = 15,
	[159][2] = 2,
	[159][3] = 3,
	[159][4] = 4,
	[159][5] = 5,
	[159][6] = 6,
	[159][7] = 7,
	[159][8] = 8,
	[159][9] = 9,
	[159][10] = 10,
	[159][11] = 75,
	[159][12] = 12,
	[159][13] = 13,
	[160][11] = 367,
	[161][2] = 2,
	[161][3] = 3,
	[161][4] = 4,
	[161][5] = 5,
	[161][6] = 6,
	[161][7] = 7,
	[161][8] = 8,
	[161][9] = 9,
	[161][10] = 10,
	[161][11] = 75,
	[161][12] = 12,
	[161][13] = 13,
	[162][2] = 369,
	[162][3] = 370,
	[162][4] = 371,
	[162][5] = 372,
	[162][6] = 373,
	[162][7] = 374,
	[162][8] = 375,
	[162][9] = 376,
	[162][10] = 377,
	[162][11] = 378,
	[162][12] = 379,
	[162][13] = 380,
	[162][15] = 381,
	[163][2] = 2,
	[163][3] = 3,
	[163][4] = 4,
	[163][5] = 5,
	[163][6] = 6,
	[163][7] = 7,
	[163][8] = 8,
	[163][9] = 9,
	[163][10] = 10,
	[163][11] = 75,
	[163][12] = 12,
	[163][13] = 13,
	[164][2] = 2,
	[164][3] = 3,
	[164][4] = 4,
	[164][5] = 5,
	[164][6] = 6,
	[164][7] = 7,
	[164][8] = 8,
	[164][9] = 9,
	[164][10] = 10,
	[164][11] = 75,
	[164][12] = 12,
	[164][13] = 13,
	[165][2] = 2,
	[165][3] = 3,
	[165][4] = 4,
	[165][5] = 5,
	[165][6] = 6,
	[165][7] = 7,
	[165][8] = 8,
	[165][9] = 9,
	[165][10] = 10,
	[165][11] = 75,
	[165][12] = 12,
	[165][13] = 13,
	[166][2] = 2,
	[166][3] = 3,
	[166][4] = 4,
	[166][5] = 5,
	[166][6] = 6,
	[166][7] = 7,
	[166][8] = 8,
	[166][9] = 9,
	[166][10] = 10,
	[166][11] = 75,
	[166][12] = 12,
	[166][13] = 13,
	[167][2] = 2,
	[167][3] = 3,
	[167][4] = 4,
	[167][5] = 5,
	[167][6] = 6,
	[167][7] = 7,
	[167][8] = 8,
	[167][9] = 9,
	[167][10] = 10,
	[167][11] = 75,
	[167][12] = 12,
	[167][13] = 13,
	[167][15] = 15,
	[168][2] = 41,
	[168][3] = 42,
	[168][4] = 43,
	[168][5] = 45,
	[168][6] = 46,
	[168][7] = 48,
	[168][8] = 49,
	[168][9] = 50,
	[168][10] = 51,
	[168][11] = 52,
	[168][12] = 53,
	[168][13] = 54,
	[168][15] = 55,
	[168][38] = 407,
	[168][39] = 408,
	[169][2] = 410,
	[169][3] = 411,
	[169][4] = 412,
	[169][5] = 413,
	[169][6] = 414,
	[169][7] = 415,
	[169][8] = 416,
	[169][9] = 417,
	[169][10] = 418,
	[169][11] = 419,
	[169][12] = 420,
	[169][13] = 421,
	[169][15] = 422,
	[170][11] = 442,
	[171][2] = 2,
	[171][3] = 3,
	[171][4] = 4,
	[171][5] = 5,
	[171][6] = 6,
	[171][7] = 7,
	[171][8] = 8,
	[171][9] = 9,
	[171][10] = 10,
	[171][11] = 75,
	[171][12] = 12,
	[171][13] = 13,
	[172][2] = 2,
	[172][3] = 3,
	[172][4] = 4,
	[172][5] = 5,
	[172][6] = 6,
	[172][7] = 7,
	[172][8] = 8,
	[172][9] = 9,
	[172][10] = 10,
	[172][11] = 75,
	[172][12] = 12,
	[172][13] = 13,
	[173][2] = 2,
	[173][3] = 3,
	[173][4] = 4,
	[173][5] = 5,
	[173][6] = 6,
	[173][7] = 7,
	[173][8] = 8,
	[173][9] = 9,
	[173][10] = 10,
	[173][11] = 75,
	[173][12] = 12,
	[173][13] = 13,
	[174][2] = 2,
	[174][3] = 3,
	[174][4] = 4,
	[174][5] = 5,
	[174][6] = 6,
	[174][7] = 7,
	[174][8] = 8,
	[174][9] = 9,
	[174][10] = 10,
	[174][11] = 75,
	[174][12] = 12,
	[174][13] = 13,
	[175][2] = 2,
	[175][3] = 3,
	[175][4] = 4,
	[175][5] = 5,
	[175][6] = 6,
	[175][7] = 7,
	[175][8] = 8,
	[175][9] = 9,
	[175][10] = 10,
	[175][11] = 75,
	[175][12] = 12,
	[175][13] = 13,
	[176][2] = 2,
	[176][3] = 3,
	[176][4] = 4,
	[176][5] = 5,
	[176][6] = 6,
	[176][7] = 7,
	[176][8] = 8,
	[176][9] = 9,
	[176][10] = 10,
	[176][11] = 75,
	[176][12] = 12,
	[176][13] = 13,
	[178][2] = 2,
	[178][3] = 3,
	[178][4] = 4,
	[178][5] = 5,
	[178][6] = 6,
	[178][7] = 7,
	[178][8] = 8,
	[178][9] = 9,
	[178][10] = 10,
	[178][11] = 11,
	[178][12] = 12,
	[178][13] = 13,
	[178][14] = 14,
	[178][15] = 15,
	[179][2] = 2,
	[179][3] = 3,
	[179][4] = 4,
	[179][5] = 5,
	[179][6] = 6,
	[179][7] = 7,
	[179][8] = 8,
	[179][9] = 9,
	[179][10] = 10,
	[179][11] = 11,
	[179][12] = 12,
	[179][13] = 13,
	[179][14] = 14,
	[179][15] = 15,
	[180][2] = 2,
	[180][3] = 3,
	[180][4] = 4,
	[180][5] = 5,
	[180][6] = 6,
	[180][7] = 7,
	[180][8] = 8,
	[180][9] = 9,
	[180][10] = 10,
	[180][11] = 11,
	[180][12] = 12,
	[180][13] = 13,
	[180][14] = 14,
	[180][15] = 15,
	[181][2] = 2,
	[181][3] = 3,
	[181][4] = 4,
	[181][5] = 5,
	[181][6] = 6,
	[181][7] = 7,
	[181][8] = 8,
	[181][9] = 9,
	[181][10] = 10,
	[181][11] = 11,
	[181][12] = 12,
	[181][13] = 13,
	[181][14] = 14,
	[181][15] = 15,
	[182][2] = 2,
	[182][3] = 3,
	[182][4] = 4,
	[182][5] = 5,
	[182][6] = 6,
	[182][7] = 7,
	[182][8] = 8,
	[182][9] = 9,
	[182][10] = 10,
	[182][11] = 11,
	[182][12] = 12,
	[182][13] = 13,
	[182][14] = 14,
	[182][15] = 15,
	[183][2] = 2,
	[183][3] = 3,
	[183][4] = 4,
	[183][5] = 5,
	[183][6] = 6,
	[183][7] = 7,
	[183][8] = 8,
	[183][9] = 9,
	[183][10] = 10,
	[183][11] = 11,
	[183][12] = 12,
	[183][13] = 13,
	[183][14] = 14,
	[183][15] = 15,
	[185][2] = 2,
	[185][3] = 3,
	[185][4] = 4,
	[185][5] = 5,
	[185][6] = 6,
	[185][7] = 7,
	[185][8] = 8,
	[185][9] = 9,
	[185][10] = 10,
	[185][11] = 11,
	[185][12] = 12,
	[185][13] = 13,
	[185][14] = 14,
	[185][15] = 15,
	[186][2] = 2,
	[186][3] = 3,
	[186][4] = 4,
	[186][5] = 5,
	[186][6] = 6,
	[186][7] = 7,
	[186][8] = 8,
	[186][9] = 9,
	[186][10] = 10,
	[186][11] = 11,
	[186][12] = 12,
	[186][13] = 13,
	[186][14] = 14,
	[186][15] = 15,
	[187][2] = 2,
	[187][3] = 3,
	[187][4] = 4,
	[187][5] = 5,
	[187][6] = 6,
	[187][7] = 7,
	[187][8] = 8,
	[187][9] = 9,
	[187][10] = 10,
	[187][11] = 11,
	[187][12] = 12,
	[187][13] = 13,
	[187][14] = 14,
	[187][15] = 15,
	[188][2] = 2,
	[188][3] = 3,
	[188][4] = 4,
	[188][5] = 5,
	[188][6] = 6,
	[188][7] = 7,
	[188][8] = 8,
	[188][9] = 9,
	[188][10] = 10,
	[188][11] = 11,
	[188][12] = 12,
	[188][13] = 13,
	[188][14] = 14,
	[188][15] = 15,
	[189][2] = 2,
	[189][3] = 3,
	[189][4] = 4,
	[189][5] = 5,
	[189][6] = 6,
	[189][7] = 7,
	[189][8] = 8,
	[189][9] = 9,
	[189][10] = 10,
	[189][11] = 11,
	[189][12] = 12,
	[189][13] = 13,
	[189][14] = 14,
	[189][15] = 15,
	[190][2] = 2,
	[190][3] = 3,
	[190][4] = 4,
	[190][5] = 5,
	[190][6] = 6,
	[190][7] = 7,
	[190][8] = 8,
	[190][9] = 9,
	[190][10] = 10,
	[190][11] = 11,
	[190][12] = 12,
	[190][13] = 13,
	[190][14] = 14,
	[190][15] = 15,
	[192][2] = 2,
	[192][3] = 3,
	[192][4] = 4,
	[192][5] = 5,
	[192][6] = 6,
	[192][7] = 7,
	[192][8] = 8,
	[192][9] = 9,
	[192][10] = 10,
	[192][11] = 11,
	[192][12] = 12,
	[192][13] = 13,
	[192][14] = 14,
	[192][15] = 15,
	[193][2] = 2,
	[193][3] = 3,
	[193][4] = 4,
	[193][5] = 5,
	[193][6] = 6,
	[193][7] = 7,
	[193][8] = 8,
	[193][9] = 9,
	[193][10] = 10,
	[193][11] = 11,
	[193][12] = 12,
	[193][13] = 13,
	[193][14] = 14,
	[193][15] = 15,
	[194][2] = 2,
	[194][3] = 3,
	[194][4] = 4,
	[194][5] = 5,
	[194][6] = 6,
	[194][7] = 7,
	[194][8] = 8,
	[194][9] = 9,
	[194][10] = 10,
	[194][11] = 11,
	[194][12] = 12,
	[194][13] = 13,
	[194][14] = 14,
	[194][15] = 15,
	[195][2] = 2,
	[195][3] = 3,
	[195][4] = 4,
	[195][5] = 5,
	[195][6] = 6,
	[195][7] = 7,
	[195][8] = 8,
	[195][9] = 9,
	[195][10] = 10,
	[195][11] = 11,
	[195][12] = 12,
	[195][13] = 13,
	[195][14] = 14,
	[195][15] = 15,
	[196][2] = 2,
	[196][3] = 3,
	[196][4] = 4,
	[196][5] = 5,
	[196][6] = 6,
	[196][7] = 7,
	[196][8] = 8,
	[196][9] = 9,
	[196][10] = 10,
	[196][11] = 11,
	[196][12] = 12,
	[196][13] = 13,
	[196][14] = 14,
	[196][15] = 15,
	[197][2] = 2,
	[197][3] = 3,
	[197][4] = 4,
	[197][5] = 5,
	[197][6] = 6,
	[197][7] = 7,
	[197][8] = 8,
	[197][9] = 9,
	[197][10] = 10,
	[197][11] = 11,
	[197][12] = 12,
	[197][13] = 13,
	[197][14] = 14,
	[197][15] = 15,
	[199][2] = 2,
	[199][3] = 3,
	[199][4] = 4,
	[199][5] = 5,
	[199][6] = 6,
	[199][7] = 7,
	[199][8] = 8,
	[199][9] = 9,
	[199][10] = 10,
	[199][11] = 11,
	[199][12] = 12,
	[199][13] = 13,
	[199][14] = 14,
	[199][15] = 15,
	[200][2] = 2,
	[200][3] = 3,
	[200][4] = 4,
	[200][5] = 5,
	[200][6] = 6,
	[200][7] = 7,
	[200][8] = 8,
	[200][9] = 9,
	[200][10] = 10,
	[200][11] = 11,
	[200][12] = 12,
	[200][13] = 13,
	[200][14] = 14,
	[200][15] = 15,
	[201][2] = 2,
	[201][3] = 3,
	[201][4] = 4,
	[201][5] = 5,
	[201][6] = 6,
	[201][7] = 7,
	[201][8] = 8,
	[201][9] = 9,
	[201][10] = 10,
	[201][11] = 11,
	[201][12] = 12,
	[201][13] = 13,
	[201][14] = 14,
	[201][15] = 15,
	[202][2] = 2,
	[202][3] = 3,
	[202][4] = 4,
	[202][5] = 5,
	[202][6] = 6,
	[202][7] = 7,
	[202][8] = 8,
	[202][9] = 9,
	[202][10] = 10,
	[202][11] = 11,
	[202][12] = 12,
	[202][13] = 13,
	[202][14] = 14,
	[202][15] = 15,
	[203][2] = 2,
	[203][3] = 3,
	[203][4] = 4,
	[203][5] = 5,
	[203][6] = 6,
	[203][7] = 7,
	[203][8] = 8,
	[203][9] = 9,
	[203][10] = 10,
	[203][11] = 11,
	[203][12] = 12,
	[203][13] = 13,
	[203][14] = 14,
	[203][15] = 15,
	[204][2] = 2,
	[204][3] = 3,
	[204][4] = 4,
	[204][5] = 5,
	[204][6] = 6,
	[204][7] = 7,
	[204][8] = 8,
	[204][9] = 9,
	[204][10] = 10,
	[204][11] = 11,
	[204][12] = 12,
	[204][13] = 13,
	[204][14] = 14,
	[204][15] = 15,
	[206][2] = 41,
	[206][3] = 42,
	[206][4] = 43,
	[206][5] = 45,
	[206][6] = 46,
	[206][7] = 48,
	[206][8] = 49,
	[206][9] = 50,
	[206][10] = 51,
	[206][11] = 52,
	[206][12] = 53,
	[206][13] = 54,
	[206][15] = 55,
	[207][38] = 475,
	[207][39] = 476,
	[211][38] = 477,
	[211][39] = 478,
	[212][2] = 78,
	[212][3] = 79,
	[212][4] = 80,
	[212][5] = 81,
	[212][6] = 82,
	[212][7] = 84,
	[212][8] = 85,
	[212][9] = 87,
	[212][10] = 88,
	[212][11] = 89,
	[212][12] = 90,
	[212][13] = 91,
	[212][15] = 92,
	[214][39] = 481,
	[214][40] = 482,
	[216][2] = 41,
	[216][3] = 42,
	[216][4] = 43,
	[216][5] = 45,
	[216][6] = 46,
	[216][7] = 48,
	[216][8] = 49,
	[216][9] = 50,
	[216][10] = 51,
	[216][11] = 52,
	[216][12] = 53,
	[216][13] = 54,
	[216][15] = 55,
	[216][38] = 483,
	[216][39] = 484,
	[218][4] = 124,
	[218][11] = 326,
	[218][15] = 132,
	[218][50] = 128,
	[218][51] = 129,
	[218][52] = 130,
	[218][53] = 131,
	[219][2] = 41,
	[219][3] = 42,
	[219][4] = 43,
	[219][5] = 45,
	[219][6] = 46,
	[219][7] = 48,
	[219][8] = 49,
	[219][9] = 50,
	[219][10] = 51,
	[219][11] = 52,
	[219][12] = 53,
	[219][13] = 54,
	[219][15] = 55,
	[220][11] = 490,
	[221][2] = 41,
	[221][3] = 42,
	[221][4] = 43,
	[221][5] = 45,
	[221][6] = 46,
	[221][7] = 48,
	[221][8] = 49,
	[221][9] = 50,
	[221][10] = 51,
	[221][11] = 52,
	[221][12] = 53,
	[221][13] = 54,
	[222][2] = 41,
	[222][3] = 42,
	[222][4] = 43,
	[222][5] = 45,
	[222][6] = 46,
	[222][7] = 48,
	[222][8] = 49,
	[222][9] = 50,
	[222][10] = 51,
	[222][11] = 52,
	[222][12] = 53,
	[222][13] = 54,
	[223][2] = 41,
	[223][3] = 42,
	[223][4] = 43,
	[223][5] = 45,
	[223][6] = 46,
	[223][7] = 48,
	[223][8] = 49,
	[223][9] = 50,
	[223][10] = 51,
	[223][11] = 52,
	[223][12] = 53,
	[223][13] = 54,
	[224][2] = 41,
	[224][3] = 42,
	[224][4] = 43,
	[224][5] = 45,
	[224][6] = 46,
	[224][7] = 48,
	[224][8] = 49,
	[224][9] = 50,
	[224][10] = 51,
	[224][11] = 52,
	[224][12] = 53,
	[224][13] = 54,
	[225][2] = 41,
	[225][3] = 42,
	[225][4] = 43,
	[225][5] = 45,
	[225][6] = 46,
	[225][7] = 48,
	[225][8] = 49,
	[225][9] = 50,
	[225][10] = 51,
	[225][11] = 52,
	[225][12] = 53,
	[225][13] = 54,
	[226][2] = 41,
	[226][3] = 42,
	[226][4] = 43,
	[226][5] = 45,
	[226][6] = 46,
	[226][7] = 48,
	[226][8] = 49,
	[226][9] = 50,
	[226][10] = 51,
	[226][11] = 52,
	[226][12] = 53,
	[226][13] = 54,
	[227][2] = 41,
	[227][3] = 42,
	[227][4] = 43,
	[227][5] = 45,
	[227][6] = 46,
	[227][7] = 48,
	[227][8] = 49,
	[227][9] = 50,
	[227][10] = 51,
	[227][11] = 52,
	[227][12] = 53,
	[227][13] = 54,
	[229][2] = 41,
	[229][3] = 42,
	[229][4] = 43,
	[229][5] = 45,
	[229][6] = 46,
	[229][7] = 48,
	[229][8] = 49,
	[229][9] = 50,
	[229][10] = 51,
	[229][11] = 52,
	[229][12] = 53,
	[229][13] = 54,
	[229][15] = 55,
	[230][2] = 41,
	[230][3] = 42,
	[230][4] = 43,
	[230][5] = 45,
	[230][6] = 46,
	[230][7] = 48,
	[230][8] = 49,
	[230][9] = 50,
	[230][10] = 51,
	[230][11] = 52,
	[230][12] = 53,
	[230][13] = 54,
	[230][15] = 55,
	[231][2] = 41,
	[231][3] = 42,
	[231][4] = 43,
	[231][5] = 45,
	[231][6] = 46,
	[231][7] = 48,
	[231][8] = 49,
	[231][9] = 50,
	[231][10] = 51,
	[231][11] = 52,
	[231][12] = 53,
	[231][13] = 54,
	[232][11] = 502,
	[233][2] = 41,
	[233][3] = 42,
	[233][4] = 43,
	[233][5] = 45,
	[233][6] = 46,
	[233][7] = 48,
	[233][8] = 49,
	[233][9] = 50,
	[233][10] = 51,
	[233][11] = 52,
	[233][12] = 53,
	[233][13] = 54,
	[234][2] = 369,
	[234][3] = 370,
	[234][4] = 371,
	[234][5] = 372,
	[234][6] = 373,
	[234][7] = 374,
	[234][8] = 375,
	[234][9] = 376,
	[234][10] = 377,
	[234][11] = 378,
	[234][12] = 379,
	[234][13] = 380,
	[234][15] = 381,
	[235][2] = 41,
	[235][3] = 42,
	[235][4] = 43,
	[235][5] = 45,
	[235][6] = 46,
	[235][7] = 48,
	[235][8] = 49,
	[235][9] = 50,
	[235][10] = 51,
	[235][11] = 52,
	[235][12] = 53,
	[235][13] = 54,
	[236][2] = 41,
	[236][3] = 42,
	[236][4] = 43,
	[236][5] = 45,
	[236][6] = 46,
	[236][7] = 48,
	[236][8] = 49,
	[236][9] = 50,
	[236][10] = 51,
	[236][11] = 52,
	[236][12] = 53,
	[236][13] = 54,
	[237][2] = 41,
	[237][3] = 42,
	[237][4] = 43,
	[237][5] = 45,
	[237][6] = 46,
	[237][7] = 48,
	[237][8] = 49,
	[237][9] = 50,
	[237][10] = 51,
	[237][11] = 52,
	[237][12] = 53,
	[237][13] = 54,
	[238][2] = 41,
	[238][3] = 42,
	[238][4] = 43,
	[238][5] = 45,
	[238][6] = 46,
	[238][7] = 48,
	[238][8] = 49,
	[238][9] = 50,
	[238][10] = 51,
	[238][11] = 52,
	[238][12] = 53,
	[238][13] = 54,
	[239][2] = 41,
	[239][3] = 42,
	[239][4] = 43,
	[239][5] = 45,
	[239][6] = 46,
	[239][7] = 48,
	[239][8] = 49,
	[239][9] = 50,
	[239][10] = 51,
	[239][11] = 52,
	[239][12] = 53,
	[239][13] = 54,
	[239][15] = 55,
	[240][2] = 41,
	[240][3] = 42,
	[240][4] = 43,
	[240][5] = 45,
	[240][6] = 46,
	[240][7] = 48,
	[240][8] = 49,
	[240][9] = 50,
	[240][10] = 51,
	[240][11] = 52,
	[240][12] = 53,
	[240][13] = 54,
	[240][15] = 55,
	[240][38] = 511,
	[240][39] = 512,
	[241][2] = 410,
	[241][3] = 411,
	[241][4] = 412,
	[241][5] = 413,
	[241][6] = 414,
	[241][7] = 415,
	[241][8] = 416,
	[241][9] = 417,
	[241][10] = 418,
	[241][11] = 419,
	[241][12] = 420,
	[241][13] = 421,
	[241][15] = 422,
	[242][11] = 515,
	[243][2] = 41,
	[243][3] = 42,
	[243][4] = 43,
	[243][5] = 45,
	[243][6] = 46,
	[243][7] = 48,
	[243][8] = 49,
	[243][9] = 50,
	[243][10] = 51,
	[243][11] = 52,
	[243][12] = 53,
	[243][13] = 54,
	[244][2] = 41,
	[244][3] = 42,
	[244][4] = 43,
	[244][5] = 45,
	[244][6] = 46,
	[244][7] = 48,
	[244][8] = 49,
	[244][9] = 50,
	[244][10] = 51,
	[244][11] = 52,
	[244][12] = 53,
	[244][13] = 54,
	[245][2] = 41,
	[245][3] = 42,
	[245][4] = 43,
	[245][5] = 45,
	[245][6] = 46,
	[245][7] = 48,
	[245][8] = 49,
	[245][9] = 50,
	[245][10] = 51,
	[245][11] = 52,
	[245][12] = 53,
	[245][13] = 54,
	[246][2] = 41,
	[246][3] = 42,
	[246][4] = 43,
	[246][5] = 45,
	[246][6] = 46,
	[246][7] = 48,
	[246][8] = 49,
	[246][9] = 50,
	[246][10] = 51,
	[246][11] = 52,
	[246][12] = 53,
	[246][13] = 54,
	[247][2] = 41,
	[247][3] = 42,
	[247][4] = 43,
	[247][5] = 45,
	[247][6] = 46,
	[247][7] = 48,
	[247][8] = 49,
	[247][9] = 50,
	[247][10] = 51,
	[247][11] = 52,
	[247][12] = 53,
	[247][13] = 54,
	[248][2] = 41,
	[248][3] = 42,
	[248][4] = 43,
	[248][5] = 45,
	[248][6] = 46,
	[248][7] = 48,
	[248][8] = 49,
	[248][9] = 50,
	[248][10] = 51,
	[248][11] = 52,
	[248][12] = 53,
	[248][13] = 54,
	[250][2] = 41,
	[250][3] = 42,
	[250][4] = 43,
	[250][5] = 45,
	[250][6] = 46,
	[250][7] = 48,
	[250][8] = 49,
	[250][9] = 50,
	[250][10] = 51,
	[250][11] = 52,
	[250][12] = 53,
	[250][13] = 54,
	[250][15] = 55,
	[251][38] = 524,
	[251][39] = 525,
	[255][39] = 526,
	[255][40] = 527,
	[256][2] = 78,
	[256][3] = 79,
	[256][4] = 80,
	[256][5] = 81,
	[256][6] = 82,
	[256][7] = 84,
	[256][8] = 85,
	[256][9] = 87,
	[256][10] = 88,
	[256][11] = 89,
	[256][12] = 90,
	[256][13] = 91,
	[256][15] = 92,
	[258][39] = 530,
	[258][40] = 531,
	[260][2] = 41,
	[260][3] = 42,
	[260][4] = 43,
	[260][5] = 45,
	[260][6] = 46,
	[260][7] = 48,
	[260][8] = 49,
	[260][9] = 50,
	[260][10] = 51,
	[260][11] = 52,
	[260][12] = 53,
	[260][13] = 54,
	[260][15] = 55,
	[260][38] = 532,
	[260][39] = 533,
	[262][4] = 124,
	[262][11] = 326,
	[262][15] = 132,
	[262][50] = 128,
	[262][51] = 129,
	[262][52] = 130,
	[262][53] = 131,
	[263][2] = 78,
	[263][3] = 79,
	[263][4] = 80,
	[263][5] = 81,
	[263][6] = 82,
	[263][7] = 84,
	[263][8] = 85,
	[263][9] = 87,
	[263][10] = 88,
	[263][11] = 89,
	[263][12] = 90,
	[263][13] = 91,
	[263][15] = 92,
	[264][11] = 539,
	[265][2] = 78,
	[265][3] = 79,
	[265][4] = 80,
	[265][5] = 81,
	[265][6] = 82,
	[265][7] = 84,
	[265][8] = 85,
	[265][9] = 87,
	[265][10] = 88,
	[265][11] = 89,
	[265][12] = 90,
	[265][13] = 91,
	[266][2] = 78,
	[266][3] = 79,
	[266][4] = 80,
	[266][5] = 81,
	[266][6] = 82,
	[266][7] = 84,
	[266][8] = 85,
	[266][9] = 87,
	[266][10] = 88,
	[266][11] = 89,
	[266][12] = 90,
	[266][13] = 91,
	[267][2] = 78,
	[267][3] = 79,
	[267][4] = 80,
	[267][5] = 81,
	[267][6] = 82,
	[267][7] = 84,
	[267][8] = 85,
	[267][9] = 87,
	[267][10] = 88,
	[267][11] = 89,
	[267][12] = 90,
	[267][13] = 91,
	[268][2] = 78,
	[268][3] = 79,
	[268][4] = 80,
	[268][5] = 81,
	[268][6] = 82,
	[268][7] = 84,
	[268][8] = 85,
	[268][9] = 87,
	[268][10] = 88,
	[268][11] = 89,
	[268][12] = 90,
	[268][13] = 91,
	[269][2] = 78,
	[269][3] = 79,
	[269][4] = 80,
	[269][5] = 81,
	[269][6] = 82,
	[269][7] = 84,
	[269][8] = 85,
	[269][9] = 87,
	[269][10] = 88,
	[269][11] = 89,
	[269][12] = 90,
	[269][13] = 91,
	[270][2] = 78,
	[270][3] = 79,
	[270][4] = 80,
	[270][5] = 81,
	[270][6] = 82,
	[270][7] = 84,
	[270][8] = 85,
	[270][9] = 87,
	[270][10] = 88,
	[270][11] = 89,
	[270][12] = 90,
	[270][13] = 91,
	[271][2] = 78,
	[271][3] = 79,
	[271][4] = 80,
	[271][5] = 81,
	[271][6] = 82,
	[271][7] = 84,
	[271][8] = 85,
	[271][9] = 87,
	[271][10] = 88,
	[271][11] = 89,
	[271][12] = 90,
	[271][13] = 91,
	[272][2] = 78,
	[272][3] = 79,
	[272][4] = 80,
	[272][5] = 81,
	[272][6] = 82,
	[272][7] = 84,
	[272][8] = 85,
	[272][9] = 87,
	[272][10] = 88,
	[272][11] = 89,
	[272][12] = 90,
	[272][13] = 91,
	[272][15] = 92,
	[274][2] = 78,
	[274][3] = 79,
	[274][4] = 80,
	[274][5] = 81,
	[274][6] = 82,
	[274][7] = 84,
	[274][8] = 85,
	[274][9] = 87,
	[274][10] = 88,
	[274][11] = 89,
	[274][12] = 90,
	[274][13] = 91,
	[274][15] = 92,
	[275][2] = 78,
	[275][3] = 79,
	[275][4] = 80,
	[275][5] = 81,
	[275][6] = 82,
	[275][7] = 84,
	[275][8] = 85,
	[275][9] = 87,
	[275][10] = 88,
	[275][11] = 89,
	[275][12] = 90,
	[275][13] = 91,
	[276][11] = 551,
	[277][2] = 78,
	[277][3] = 79,
	[277][4] = 80,
	[277][5] = 81,
	[277][6] = 82,
	[277][7] = 84,
	[277][8] = 85,
	[277][9] = 87,
	[277][10] = 88,
	[277][11] = 89,
	[277][12] = 90,
	[277][13] = 91,
	[278][2] = 369,
	[278][3] = 370,
	[278][4] = 371,
	[278][5] = 372,
	[278][6] = 373,
	[278][7] = 374,
	[278][8] = 375,
	[278][9] = 376,
	[278][10] = 377,
	[278][11] = 378,
	[278][12] = 379,
	[278][13] = 380,
	[278][15] = 381,
	[279][2] = 78,
	[279][3] = 79,
	[279][4] = 80,
	[279][5] = 81,
	[279][6] = 82,
	[279][7] = 84,
	[279][8] = 85,
	[279][9] = 87,
	[279][10] = 88,
	[279][11] = 89,
	[279][12] = 90,
	[279][13] = 91,
	[280][2] = 78,
	[280][3] = 79,
	[280][4] = 80,
	[280][5] = 81,
	[280][6] = 82,
	[280][7] = 84,
	[280][8] = 85,
	[280][9] = 87,
	[280][10] = 88,
	[280][11] = 89,
	[280][12] = 90,
	[280][13] = 91,
	[281][2] = 78,
	[281][3] = 79,
	[281][4] = 80,
	[281][5] = 81,
	[281][6] = 82,
	[281][7] = 84,
	[281][8] = 85,
	[281][9] = 87,
	[281][10] = 88,
	[281][11] = 89,
	[281][12] = 90,
	[281][13] = 91,
	[282][2] = 78,
	[282][3] = 79,
	[282][4] = 80,
	[282][5] = 81,
	[282][6] = 82,
	[282][7] = 84,
	[282][8] = 85,
	[282][9] = 87,
	[282][10] = 88,
	[282][11] = 89,
	[282][12] = 90,
	[282][13] = 91,
	[283][2] = 78,
	[283][3] = 79,
	[283][4] = 80,
	[283][5] = 81,
	[283][6] = 82,
	[283][7] = 84,
	[283][8] = 85,
	[283][9] = 87,
	[283][10] = 88,
	[283][11] = 89,
	[283][12] = 90,
	[283][13] = 91,
	[283][15] = 92,
	[284][2] = 41,
	[284][3] = 42,
	[284][4] = 43,
	[284][5] = 45,
	[284][6] = 46,
	[284][7] = 48,
	[284][8] = 49,
	[284][9] = 50,
	[284][10] = 51,
	[284][11] = 52,
	[284][12] = 53,
	[284][13] = 54,
	[284][15] = 55,
	[284][38] = 560,
	[284][39] = 561,
	[285][2] = 410,
	[285][3] = 411,
	[285][4] = 412,
	[285][5] = 413,
	[285][6] = 414,
	[285][7] = 415,
	[285][8] = 416,
	[285][9] = 417,
	[285][10] = 418,
	[285][11] = 419,
	[285][12] = 420,
	[285][13] = 421,
	[285][15] = 422,
	[286][11] = 564,
	[287][2] = 78,
	[287][3] = 79,
	[287][4] = 80,
	[287][5] = 81,
	[287][6] = 82,
	[287][7] = 84,
	[287][8] = 85,
	[287][9] = 87,
	[287][10] = 88,
	[287][11] = 89,
	[287][12] = 90,
	[287][13] = 91,
	[288][2] = 78,
	[288][3] = 79,
	[288][4] = 80,
	[288][5] = 81,
	[288][6] = 82,
	[288][7] = 84,
	[288][8] = 85,
	[288][9] = 87,
	[288][10] = 88,
	[288][11] = 89,
	[288][12] = 90,
	[288][13] = 91,
	[289][2] = 78,
	[289][3] = 79,
	[289][4] = 80,
	[289][5] = 81,
	[289][6] = 82,
	[289][7] = 84,
	[289][8] = 85,
	[289][9] = 87,
	[289][10] = 88,
	[289][11] = 89,
	[289][12] = 90,
	[289][13] = 91,
	[290][2] = 78,
	[290][3] = 79,
	[290][4] = 80,
	[290][5] = 81,
	[290][6] = 82,
	[290][7] = 84,
	[290][8] = 85,
	[290][9] = 87,
	[290][10] = 88,
	[290][11] = 89,
	[290][12] = 90,
	[290][13] = 91,
	[291][2] = 78,
	[291][3] = 79,
	[291][4] = 80,
	[291][5] = 81,
	[291][6] = 82,
	[291][7] = 84,
	[291][8] = 85,
	[291][9] = 87,
	[291][10] = 88,
	[291][11] = 89,
	[291][12] = 90,
	[291][13] = 91,
	[292][2] = 78,
	[292][3] = 79,
	[292][4] = 80,
	[292][5] = 81,
	[292][6] = 82,
	[292][7] = 84,
	[292][8] = 85,
	[292][9] = 87,
	[292][10] = 88,
	[292][11] = 89,
	[292][12] = 90,
	[292][13] = 91,
	[293][56] = 571,
	[294][56] = 572,
	[295][2] = 573,
	[295][3] = 574,
	[295][4] = 575,
	[295][7] = 576,
	[295][8] = 577,
	[295][11] = 578,
	[295][23] = 579,
	[296][56] = 584,
	[297][2] = 585,
	[297][3] = 586,
	[297][4] = 587,
	[297][5] = 588,
	[298][56] = 595,
	[299][2] = 596,
	[299][3] = 597,
	[299][4] = 598,
	[299][7] = 599,
	[299][8] = 600,
	[300][37] = 605,
	[301][9] = 606,
	[301][19] = 607,
	[301][20] = 608,
	[302][18] = 609,
	[303][2] = 293,
	[303][3] = 294,
	[303][4] = 295,
	[303][7] = 296,
	[303][8] = 297,
	[303][11] = 298,
	[303][23] = 299,
	[304][37] = 611,
	[306][2] = 41,
	[306][3] = 42,
	[306][4] = 43,
	[306][5] = 45,
	[306][6] = 46,
	[306][7] = 48,
	[306][8] = 49,
	[306][9] = 50,
	[306][10] = 51,
	[306][11] = 52,
	[306][12] = 53,
	[306][13] = 54,
	[306][15] = 55,
	[307][38] = 614,
	[307][39] = 615,
	[308][37] = 616,
	[309][2] = 617,
	[309][3] = 618,
	[309][4] = 619,
	[309][7] = 620,
	[309][8] = 621,
	[310][2] = 293,
	[310][3] = 294,
	[310][4] = 295,
	[310][7] = 296,
	[310][8] = 297,
	[310][11] = 298,
	[310][23] = 299,
	[311][2] = 2,
	[311][3] = 3,
	[311][4] = 4,
	[311][5] = 5,
	[311][6] = 6,
	[311][7] = 7,
	[311][8] = 8,
	[311][9] = 9,
	[311][10] = 10,
	[311][11] = 75,
	[311][12] = 12,
	[311][13] = 13,
	[311][15] = 15,
	[312][2] = 2,
	[312][3] = 3,
	[312][4] = 4,
	[312][5] = 5,
	[312][6] = 6,
	[312][7] = 7,
	[312][8] = 8,
	[312][9] = 9,
	[312][10] = 10,
	[312][11] = 75,
	[312][12] = 12,
	[312][13] = 13,
	[312][15] = 15,
	[313][2] = 2,
	[313][3] = 3,
	[313][4] = 4,
	[313][5] = 5,
	[313][6] = 6,
	[313][7] = 7,
	[313][8] = 8,
	[313][9] = 9,
	[313][10] = 10,
	[313][11] = 75,
	[313][12] = 12,
	[313][13] = 13,
	[313][15] = 15,
	[314][2] = 2,
	[314][3] = 3,
	[314][4] = 4,
	[314][5] = 5,
	[314][6] = 6,
	[314][7] = 7,
	[314][8] = 8,
	[314][9] = 9,
	[314][10] = 10,
	[314][11] = 75,
	[314][12] = 12,
	[314][13] = 13,
	[314][15] = 15,
	[315][4] = 315,
	[315][11] = 318,
	[315][15] = 323,
	[315][38] = 632,
	[315][39] = 633,
	[315][50] = 319,
	[315][51] = 320,
	[315][52] = 321,
	[315][53] = 322,
	[317][4] = 315,
	[317][11] = 318,
	[317][15] = 323,
	[317][50] = 319,
	[317][51] = 320,
	[317][52] = 321,
	[317][53] = 322,
	[323][4] = 332,
	[323][11] = 334,
	[323][15] = 340,
	[323][39] = 637,
	[323][41] = 638,
	[323][50] = 336,
	[323][51] = 337,
	[323][52] = 338,
	[323][53] = 339,
	[324][55] = 640,
	[325][38] = 641,
	[325][39] = 642,
	[328][39] = 643,
	[328][41] = 644,
	[329][11] = 645,
	[332][4] = 315,
	[332][11] = 318,
	[332][15] = 323,
	[332][38] = 646,
	[332][39] = 647,
	[332][50] = 319,
	[332][51] = 320,
	[332][52] = 321,
	[332][53] = 322,
	[333][4] = 332,
	[333][11] = 334,
	[333][15] = 340,
	[333][50] = 336,
	[333][51] = 337,
	[333][52] = 338,
	[333][53] = 339,
	[335][4] = 124,
	[335][11] = 126,
	[335][15] = 132,
	[335][50] = 128,
	[335][51] = 129,
	[335][52] = 130,
	[335][53] = 131,
	[340][4] = 332,
	[340][11] = 334,
	[340][15] = 340,
	[340][39] = 653,
	[340][41] = 654,
	[340][50] = 336,
	[340][51] = 337,
	[340][52] = 338,
	[340][53] = 339,
	[341][55] = 656,
	[342][39] = 657,
	[342][41] = 658,
	[344][39] = 659,
	[344][41] = 660,
	[345][14] = 166,
	[345][20] = 164,
	[345][23] = 165,
	[346][14] = 166,
	[346][20] = 164,
	[346][23] = 165,
	[347][30] = 145,
	[347][31] = 146,
	[354][26] = 171,
	[354][27] = 172,
	[354][28] = 173,
	[354][29] = 174,
	[355][26] = 171,
	[355][27] = 172,
	[355][28] = 173,
	[355][29] = 174,
	[356][16] = 137,
	[365][36] = 661,
	[366][17] = 147,
	[368][18] = 159,
	[371][2] = 41,
	[371][3] = 42,
	[371][4] = 43,
	[371][5] = 45,
	[371][6] = 46,
	[371][7] = 48,
	[371][8] = 49,
	[371][9] = 50,
	[371][10] = 51,
	[371][11] = 52,
	[371][12] = 53,
	[371][13] = 54,
	[371][15] = 55,
	[371][38] = 662,
	[371][39] = 663,
	[372][2] = 369,
	[372][3] = 370,
	[372][4] = 371,
	[372][5] = 372,
	[372][6] = 373,
	[372][7] = 374,
	[372][8] = 375,
	[372][9] = 376,
	[372][10] = 377,
	[372][11] = 378,
	[372][12] = 379,
	[372][13] = 380,
	[373][2] = 369,
	[373][3] = 370,
	[373][4] = 371,
	[373][5] = 372,
	[373][6] = 373,
	[373][7] = 374,
	[373][8] = 375,
	[373][9] = 376,
	[373][10] = 377,
	[373][11] = 378,
	[373][12] = 379,
	[373][13] = 380,
	[375][2] = 78,
	[375][3] = 79,
	[375][4] = 80,
	[375][5] = 81,
	[375][6] = 82,
	[375][7] = 84,
	[375][8] = 85,
	[375][9] = 87,
	[375][10] = 88,
	[375][11] = 89,
	[375][12] = 90,
	[375][13] = 91,
	[375][15] = 92,
	[375][39] = 667,
	[375][40] = 668,
	[376][2] = 369,
	[376][3] = 370,
	[376][4] = 371,
	[376][5] = 372,
	[376][6] = 373,
	[376][7] = 374,
	[376][8] = 375,
	[376][9] = 376,
	[376][10] = 377,
	[376][11] = 378,
	[376][12] = 379,
	[376][13] = 380,
	[379][4] = 671,
	[380][2] = 369,
	[380][3] = 370,
	[380][4] = 371,
	[380][5] = 372,
	[380][6] = 373,
	[380][7] = 374,
	[380][8] = 375,
	[380][9] = 376,
	[380][10] = 377,
	[380][11] = 378,
	[380][12] = 379,
	[380][13] = 380,
	[381][4] = 124,
	[381][11] = 126,
	[381][15] = 132,
	[381][39] = 673,
	[381][41] = 674,
	[381][50] = 128,
	[381][51] = 129,
	[381][52] = 130,
	[381][53] = 131,
	[382][6] = 676,
	[382][9] = 677,
	[383][16] = 678,
	[385][30] = 679,
	[385][31] = 680,
	[386][17] = 681,
	[387][22] = 682,
	[388][41] = 683,
	[389][36] = 684,
	[390][18] = 685,
	[391][34] = 686,
	[392][32] = 687,
	[393][19] = 688,
	[393][33] = 689,
	[394][14] = 692,
	[394][20] = 690,
	[394][23] = 691,
	[395][35] = 693,
	[396][4] = 694,
	[396][8] = 695,
	[396][21] = 696,
	[398][26] = 697,
	[398][27] = 698,
	[398][28] = 699,
	[398][29] = 700,
	[399][24] = 701,
	[399][25] = 702,
	[401][32] = 161,
	[402][22] = 148,
	[403][22] = 148,
	[404][22] = 148,
	[406][35] = 703,
	[408][2] = 41,
	[408][3] = 42,
	[408][4] = 43,
	[408][5] = 45,
	[408][6] = 46,
	[408][7] = 48,
	[408][8] = 49,
	[408][9] = 50,
	[408][10] = 51,
	[408][11] = 52,
	[408][12] = 53,
	[408][13] = 54,
	[408][15] = 55,
	[409][38] = 706,
	[409][39] = 707,
	[412][2] = 41,
	[412][3] = 42,
	[412][4] = 43,
	[412][5] = 45,
	[412][6] = 46,
	[412][7] = 48,
	[412][8] = 49,
	[412][9] = 50,
	[412][10] = 51,
	[412][11] = 52,
	[412][12] = 53,
	[412][13] = 54,
	[412][15] = 55,
	[412][38] = 708,
	[412][39] = 709,
	[413][2] = 410,
	[413][3] = 411,
	[413][4] = 412,
	[413][5] = 413,
	[413][6] = 414,
	[413][7] = 415,
	[413][8] = 416,
	[413][9] = 417,
	[413][10] = 418,
	[413][11] = 419,
	[413][12] = 420,
	[413][13] = 421,
	[414][2] = 410,
	[414][3] = 411,
	[414][4] = 412,
	[414][5] = 413,
	[414][6] = 414,
	[414][7] = 415,
	[414][8] = 416,
	[414][9] = 417,
	[414][10] = 418,
	[414][11] = 419,
	[414][12] = 420,
	[414][13] = 421,
	[416][2] = 78,
	[416][3] = 79,
	[416][4] = 80,
	[416][5] = 81,
	[416][6] = 82,
	[416][7] = 84,
	[416][8] = 85,
	[416][9] = 87,
	[416][10] = 88,
	[416][11] = 89,
	[416][12] = 90,
	[416][13] = 91,
	[416][15] = 92,
	[416][39] = 713,
	[416][40] = 714,
	[417][2] = 410,
	[417][3] = 411,
	[417][4] = 412,
	[417][5] = 413,
	[417][6] = 414,
	[417][7] = 415,
	[417][8] = 416,
	[417][9] = 417,
	[417][10] = 418,
	[417][11] = 419,
	[417][12] = 420,
	[417][13] = 421,
	[420][4] = 717,
	[421][2] = 410,
	[421][3] = 411,
	[421][4] = 412,
	[421][5] = 413,
	[421][6] = 414,
	[421][7] = 415,
	[421][8] = 416,
	[421][9] = 417,
	[421][10] = 418,
	[421][11] = 419,
	[421][12] = 420,
	[421][13] = 421,
	[422][4] = 124,
	[422][11] = 126,
	[422][15] = 132,
	[422][39] = 719,
	[422][41] = 720,
	[422][50] = 128,
	[422][51] = 129,
	[422][52] = 130,
	[422][53] = 131,
	[423][6] = 722,
	[423][9] = 723,
	[424][16] = 724,
	[426][30] = 725,
	[426][31] = 726,
	[427][17] = 727,
	[428][22] = 728,
	[429][40] = 729,
	[430][36] = 730,
	[431][18] = 731,
	[432][34] = 732,
	[433][32] = 733,
	[434][19] = 734,
	[434][33] = 735,
	[435][14] = 738,
	[435][20] = 736,
	[435][23] = 737,
	[436][35] = 739,
	[437][4] = 740,
	[437][8] = 741,
	[437][21] = 742,
	[439][26] = 743,
	[439][27] = 744,
	[439][28] = 745,
	[439][29] = 746,
	[440][24] = 747,
	[440][25] = 748,
	[443][24] = 175,
	[443][25] = 176,
	[444][24] = 175,
	[444][25] = 176,
	[445][24] = 175,
	[445][25] = 176,
	[446][24] = 175,
	[446][25] = 176,
	[447][6] = 135,
	[447][9] = 136,
	[448][6] = 135,
	[448][9] = 136,
	[474][38] = 749,
	[474][39] = 750,
	[476][2] = 41,
	[476][3] = 42,
	[476][4] = 43,
	[476][5] = 45,
	[476][6] = 46,
	[476][7] = 48,
	[476][8] = 49,
	[476][9] = 50,
	[476][10] = 51,
	[476][11] = 52,
	[476][12] = 53,
	[476][13] = 54,
	[476][15] = 55,
	[478][2] = 41,
	[478][3] = 42,
	[478][4] = 43,
	[478][5] = 45,
	[478][6] = 46,
	[478][7] = 48,
	[478][8] = 49,
	[478][9] = 50,
	[478][10] = 51,
	[478][11] = 52,
	[478][12] = 53,
	[478][13] = 54,
	[478][15] = 55,
	[480][39] = 753,
	[480][40] = 754,
	[481][2] = 78,
	[481][3] = 79,
	[481][4] = 80,
	[481][5] = 81,
	[481][6] = 82,
	[481][7] = 84,
	[481][8] = 85,
	[481][9] = 87,
	[481][10] = 88,
	[481][11] = 89,
	[481][12] = 90,
	[481][13] = 91,
	[481][15] = 92,
	[484][2] = 41,
	[484][3] = 42,
	[484][4] = 43,
	[484][5] = 45,
	[484][6] = 46,
	[484][7] = 48,
	[484][8] = 49,
	[484][9] = 50,
	[484][10] = 51,
	[484][11] = 52,
	[484][12] = 53,
	[484][13] = 54,
	[484][15] = 55,
	[485][38] = 758,
	[485][39] = 759,
	[487][39] = 760,
	[487][41] = 761,
	[490][39] = 762,
	[490][41] = 763,
	[491][14] = 238,
	[491][20] = 236,
	[491][23] = 237,
	[492][14] = 238,
	[492][20] = 236,
	[492][23] = 237,
	[493][30] = 224,
	[493][31] = 225,
	[494][26] = 243,
	[494][27] = 244,
	[494][28] = 245,
	[494][29] = 246,
	[495][26] = 243,
	[495][27] = 244,
	[495][28] = 245,
	[495][29] = 246,
	[496][16] = 223,
	[500][36] = 764,
	[501][17] = 226,
	[503][18] = 231,
	[504][41] = 765,
	[505][32] = 233,
	[506][22] = 227,
	[507][22] = 227,
	[508][22] = 227,
	[510][35] = 766,
	[512][2] = 41,
	[512][3] = 42,
	[512][4] = 43,
	[512][5] = 45,
	[512][6] = 46,
	[512][7] = 48,
	[512][8] = 49,
	[512][9] = 50,
	[512][10] = 51,
	[512][11] = 52,
	[512][12] = 53,
	[512][13] = 54,
	[512][15] = 55,
	[513][38] = 769,
	[513][39] = 770,
	[514][40] = 771,
	[516][24] = 247,
	[516][25] = 248,
	[517][24] = 247,
	[517][25] = 248,
	[518][24] = 247,
	[518][25] = 248,
	[519][24] = 247,
	[519][25] = 248,
	[520][6] = 221,
	[520][9] = 222,
	[521][6] = 221,
	[521][9] = 222,
	[523][38] = 772,
	[523][39] = 773,
	[525][2] = 41,
	[525][3] = 42,
	[525][4] = 43,
	[525][5] = 45,
	[525][6] = 46,
	[525][7] = 48,
	[525][8] = 49,
	[525][9] = 50,
	[525][10] = 51,
	[525][11] = 52,
	[525][12] = 53,
	[525][13] = 54,
	[525][15] = 55,
	[526][2] = 78,
	[526][3] = 79,
	[526][4] = 80,
	[526][5] = 81,
	[526][6] = 82,
	[526][7] = 84,
	[526][8] = 85,
	[526][9] = 87,
	[526][10] = 88,
	[526][11] = 89,
	[526][12] = 90,
	[526][13] = 91,
	[526][15] = 92,
	[529][39] = 776,
	[529][40] = 777,
	[530][2] = 78,
	[530][3] = 79,
	[530][4] = 80,
	[530][5] = 81,
	[530][6] = 82,
	[530][7] = 84,
	[530][8] = 85,
	[530][9] = 87,
	[530][10] = 88,
	[530][11] = 89,
	[530][12] = 90,
	[530][13] = 91,
	[530][15] = 92,
	[533][2] = 41,
	[533][3] = 42,
	[533][4] = 43,
	[533][5] = 45,
	[533][6] = 46,
	[533][7] = 48,
	[533][8] = 49,
	[533][9] = 50,
	[533][10] = 51,
	[533][11] = 52,
	[533][12] = 53,
	[533][13] = 54,
	[533][15] = 55,
	[534][38] = 781,
	[534][39] = 782,
	[536][39] = 783,
	[536][41] = 784,
	[539][39] = 785,
	[539][41] = 786,
	[540][14] = 282,
	[540][20] = 280,
	[540][23] = 281,
	[541][14] = 282,
	[541][20] = 280,
	[541][23] = 281,
	[542][30] = 268,
	[542][31] = 269,
	[543][26] = 287,
	[543][27] = 288,
	[543][28] = 289,
	[543][29] = 290,
	[544][26] = 287,
	[544][27] = 288,
	[544][28] = 289,
	[544][29] = 290,
	[545][16] = 267,
	[549][36] = 787,
	[550][17] = 270,
	[552][18] = 275,
	[553][41] = 788,
	[554][32] = 277,
	[555][22] = 271,
	[556][22] = 271,
	[557][22] = 271,
	[559][35] = 789,
	[561][2] = 41,
	[561][3] = 42,
	[561][4] = 43,
	[561][5] = 45,
	[561][6] = 46,
	[561][7] = 48,
	[561][8] = 49,
	[561][9] = 50,
	[561][10] = 51,
	[561][11] = 52,
	[561][12] = 53,
	[561][13] = 54,
	[561][15] = 55,
	[562][38] = 792,
	[562][39] = 793,
	[563][40] = 794,
	[565][24] = 291,
	[565][25] = 292,
	[566][24] = 291,
	[566][25] = 292,
	[567][24] = 291,
	[567][25] = 292,
	[568][24] = 291,
	[568][25] = 292,
	[569][6] = 265,
	[569][9] = 266,
	[570][6] = 265,
	[570][9] = 266,
	[571][56] = 795,
	[572][56] = 797,
	[573][56] = 799,
	[574][56] = 800,
	[575][2] = 573,
	[575][3] = 574,
	[575][4] = 575,
	[575][7] = 576,
	[575][8] = 577,
	[575][11] = 578,
	[575][23] = 579,
	[576][56] = 802,
	[577][2] = 585,
	[577][3] = 586,
	[577][4] = 587,
	[577][5] = 588,
	[578][56] = 804,
	[579][2] = 596,
	[579][3] = 597,
	[579][4] = 598,
	[579][7] = 599,
	[579][8] = 600,
	[580][38] = 806,
	[581][9] = 807,
	[581][19] = 808,
	[581][20] = 809,
	[582][18] = 810,
	[583][2] = 573,
	[583][3] = 574,
	[583][4] = 575,
	[583][7] = 576,
	[583][8] = 577,
	[583][11] = 578,
	[583][23] = 579,
	[584][56] = 812,
	[587][2] = 814,
	[587][3] = 815,
	[587][4] = 816,
	[587][5] = 817,
	[588][2] = 585,
	[588][3] = 586,
	[588][4] = 587,
	[589][40] = 825,
	[591][17] = 826,
	[592][6] = 827,
	[593][16] = 828,
	[594][2] = 585,
	[594][3] = 586,
	[594][4] = 587,
	[594][5] = 588,
	[594][18] = 830,
	[594][39] = 829,
	[595][56] = 832,
	[598][2] = 834,
	[598][3] = 835,
	[598][4] = 836,
	[598][7] = 837,
	[598][8] = 838,
	[600][2] = 585,
	[600][3] = 586,
	[600][4] = 587,
	[600][5] = 588,
	[601][23] = 844,
	[602][9] = 845,
	[602][19] = 846,
	[602][20] = 847,
	[603][18] = 848,
	[604][2] = 596,
	[604][3] = 597,
	[604][4] = 598,
	[604][7] = 599,
	[604][8] = 600,
	[609][2] = 293,
	[609][3] = 294,
	[609][4] = 295,
	[609][7] = 296,
	[609][8] = 297,
	[609][11] = 298,
	[609][23] = 299,
	[610][2] = 293,
	[610][3] = 294,
	[610][4] = 295,
	[610][7] = 296,
	[610][8] = 297,
	[610][11] = 298,
	[610][23] = 299,
	[613][38] = 854,
	[613][39] = 855,
	[615][2] = 41,
	[615][3] = 42,
	[615][4] = 43,
	[615][5] = 45,
	[615][6] = 46,
	[615][7] = 48,
	[615][8] = 49,
	[615][9] = 50,
	[615][10] = 51,
	[615][11] = 52,
	[615][12] = 53,
	[615][13] = 54,
	[615][15] = 55,
	[619][2] = 834,
	[619][3] = 835,
	[619][4] = 836,
	[619][7] = 837,
	[619][8] = 838,
	[621][2] = 585,
	[621][3] = 586,
	[621][4] = 587,
	[621][5] = 588,
	[622][37] = 859,
	[623][9] = 860,
	[623][19] = 861,
	[623][20] = 862,
	[624][18] = 863,
	[625][2] = 617,
	[625][3] = 618,
	[625][4] = 619,
	[625][7] = 620,
	[625][8] = 621,
	[626][37] = 865,
	[628][37] = 149,
	[633][4] = 315,
	[633][11] = 318,
	[633][15] = 323,
	[633][50] = 319,
	[633][51] = 320,
	[633][52] = 321,
	[633][53] = 322,
	[634][38] = 869,
	[634][39] = 870,
	[636][38] = 871,
	[636][39] = 872,
	[637][4] = 332,
	[637][11] = 334,
	[637][15] = 340,
	[637][50] = 336,
	[637][51] = 337,
	[637][52] = 338,
	[637][53] = 339,
	[638][4] = 315,
	[638][11] = 318,
	[638][15] = 323,
	[638][50] = 319,
	[638][51] = 320,
	[638][52] = 321,
	[638][53] = 322,
	[639][39] = 877,
	[639][41] = 878,
	[642][4] = 315,
	[642][11] = 318,
	[642][15] = 323,
	[642][50] = 319,
	[642][51] = 320,
	[642][52] = 321,
	[642][53] = 322,
	[643][4] = 124,
	[643][11] = 326,
	[643][15] = 132,
	[643][50] = 128,
	[643][51] = 129,
	[643][52] = 130,
	[643][53] = 131,
	[644][2] = 2,
	[644][3] = 3,
	[644][4] = 4,
	[644][5] = 5,
	[644][6] = 6,
	[644][7] = 7,
	[644][8] = 8,
	[644][9] = 9,
	[644][10] = 10,
	[644][11] = 75,
	[644][12] = 12,
	[644][13] = 13,
	[644][15] = 15,
	[647][4] = 315,
	[647][11] = 318,
	[647][15] = 323,
	[647][50] = 319,
	[647][51] = 320,
	[647][52] = 321,
	[647][53] = 322,
	[648][38] = 884,
	[648][39] = 885,
	[650][39] = 886,
	[650][41] = 887,
	[653][4] = 332,
	[653][11] = 334,
	[653][15] = 340,
	[653][50] = 336,
	[653][51] = 337,
	[653][52] = 338,
	[653][53] = 339,
	[654][4] = 332,
	[654][11] = 334,
	[654][15] = 340,
	[654][50] = 336,
	[654][51] = 337,
	[654][52] = 338,
	[654][53] = 339,
	[655][39] = 892,
	[655][41] = 893,
	[657][4] = 332,
	[657][11] = 334,
	[657][15] = 340,
	[657][50] = 336,
	[657][51] = 337,
	[657][52] = 338,
	[657][53] = 339,
	[658][4] = 124,
	[658][11] = 126,
	[658][15] = 132,
	[658][50] = 128,
	[658][51] = 129,
	[658][52] = 130,
	[658][53] = 131,
	[659][4] = 124,
	[659][11] = 326,
	[659][15] = 132,
	[659][50] = 128,
	[659][51] = 129,
	[659][52] = 130,
	[659][53] = 131,
	[660][2] = 2,
	[660][3] = 3,
	[660][4] = 4,
	[660][5] = 5,
	[660][6] = 6,
	[660][7] = 7,
	[660][8] = 8,
	[660][9] = 9,
	[660][10] = 10,
	[660][11] = 75,
	[660][12] = 12,
	[660][13] = 13,
	[660][15] = 15,
	[661][2] = 2,
	[661][3] = 3,
	[661][4] = 4,
	[661][5] = 5,
	[661][6] = 6,
	[661][7] = 7,
	[661][8] = 8,
	[661][9] = 9,
	[661][10] = 10,
	[661][11] = 75,
	[661][12] = 12,
	[661][13] = 13,
	[661][15] = 15,
	[663][2] = 41,
	[663][3] = 42,
	[663][4] = 43,
	[663][5] = 45,
	[663][6] = 46,
	[663][7] = 48,
	[663][8] = 49,
	[663][9] = 50,
	[663][10] = 51,
	[663][11] = 52,
	[663][12] = 53,
	[663][13] = 54,
	[663][15] = 55,
	[664][38] = 901,
	[664][39] = 902,
	[667][2] = 78,
	[667][3] = 79,
	[667][4] = 80,
	[667][5] = 81,
	[667][6] = 82,
	[667][7] = 84,
	[667][8] = 85,
	[667][9] = 87,
	[667][10] = 88,
	[667][11] = 89,
	[667][12] = 90,
	[667][13] = 91,
	[667][15] = 92,
	[669][39] = 905,
	[669][40] = 906,
	[671][2] = 41,
	[671][3] = 42,
	[671][4] = 43,
	[671][5] = 45,
	[671][6] = 46,
	[671][7] = 48,
	[671][8] = 49,
	[671][9] = 50,
	[671][10] = 51,
	[671][11] = 52,
	[671][12] = 53,
	[671][13] = 54,
	[671][15] = 55,
	[671][38] = 907,
	[671][39] = 908,
	[673][4] = 124,
	[673][11] = 326,
	[673][15] = 132,
	[673][50] = 128,
	[673][51] = 129,
	[673][52] = 130,
	[673][53] = 131,
	[674][2] = 369,
	[674][3] = 370,
	[674][4] = 371,
	[674][5] = 372,
	[674][6] = 373,
	[674][7] = 374,
	[674][8] = 375,
	[674][9] = 376,
	[674][10] = 377,
	[674][11] = 378,
	[674][12] = 379,
	[674][13] = 380,
	[674][15] = 381,
	[675][11] = 914,
	[676][2] = 369,
	[676][3] = 370,
	[676][4] = 371,
	[676][5] = 372,
	[676][6] = 373,
	[676][7] = 374,
	[676][8] = 375,
	[676][9] = 376,
	[676][10] = 377,
	[676][11] = 378,
	[676][12] = 379,
	[676][13] = 380,
	[677][2] = 369,
	[677][3] = 370,
	[677][4] = 371,
	[677][5] = 372,
	[677][6] = 373,
	[677][7] = 374,
	[677][8] = 375,
	[677][9] = 376,
	[677][10] = 377,
	[677][11] = 378,
	[677][12] = 379,
	[677][13] = 380,
	[678][2] = 369,
	[678][3] = 370,
	[678][4] = 371,
	[678][5] = 372,
	[678][6] = 373,
	[678][7] = 374,
	[678][8] = 375,
	[678][9] = 376,
	[678][10] = 377,
	[678][11] = 378,
	[678][12] = 379,
	[678][13] = 380,
	[679][2] = 369,
	[679][3] = 370,
	[679][4] = 371,
	[679][5] = 372,
	[679][6] = 373,
	[679][7] = 374,
	[679][8] = 375,
	[679][9] = 376,
	[679][10] = 377,
	[679][11] = 378,
	[679][12] = 379,
	[679][13] = 380,
	[680][2] = 369,
	[680][3] = 370,
	[680][4] = 371,
	[680][5] = 372,
	[680][6] = 373,
	[680][7] = 374,
	[680][8] = 375,
	[680][9] = 376,
	[680][10] = 377,
	[680][11] = 378,
	[680][12] = 379,
	[680][13] = 380,
	[681][2] = 369,
	[681][3] = 370,
	[681][4] = 371,
	[681][5] = 372,
	[681][6] = 373,
	[681][7] = 374,
	[681][8] = 375,
	[681][9] = 376,
	[681][10] = 377,
	[681][11] = 378,
	[681][12] = 379,
	[681][13] = 380,
	[682][2] = 369,
	[682][3] = 370,
	[682][4] = 371,
	[682][5] = 372,
	[682][6] = 373,
	[682][7] = 374,
	[682][8] = 375,
	[682][9] = 376,
	[682][10] = 377,
	[682][11] = 378,
	[682][12] = 379,
	[682][13] = 380,
	[683][2] = 2,
	[683][3] = 3,
	[683][4] = 4,
	[683][5] = 5,
	[683][6] = 6,
	[683][7] = 7,
	[683][8] = 8,
	[683][9] = 9,
	[683][10] = 10,
	[683][11] = 75,
	[683][12] = 12,
	[683][13] = 13,
	[684][2] = 369,
	[684][3] = 370,
	[684][4] = 371,
	[684][5] = 372,
	[684][6] = 373,
	[684][7] = 374,
	[684][8] = 375,
	[684][9] = 376,
	[684][10] = 377,
	[684][11] = 378,
	[684][12] = 379,
	[684][13] = 380,
	[684][15] = 381,
	[685][2] = 369,
	[685][3] = 370,
	[685][4] = 371,
	[685][5] = 372,
	[685][6] = 373,
	[685][7] = 374,
	[685][8] = 375,
	[685][9] = 376,
	[685][10] = 377,
	[685][11] = 378,
	[685][12] = 379,
	[685][13] = 380,
	[686][11] = 926,
	[687][2] = 369,
	[687][3] = 370,
	[687][4] = 371,
	[687][5] = 372,
	[687][6] = 373,
	[687][7] = 374,
	[687][8] = 375,
	[687][9] = 376,
	[687][10] = 377,
	[687][11] = 378,
	[687][12] = 379,
	[687][13] = 380,
	[688][2] = 369,
	[688][3] = 370,
	[688][4] = 371,
	[688][5] = 372,
	[688][6] = 373,
	[688][7] = 374,
	[688][8] = 375,
	[688][9] = 376,
	[688][10] = 377,
	[688][11] = 378,
	[688][12] = 379,
	[688][13] = 380,
	[688][15] = 381,
	[689][2] = 369,
	[689][3] = 370,
	[689][4] = 371,
	[689][5] = 372,
	[689][6] = 373,
	[689][7] = 374,
	[689][8] = 375,
	[689][9] = 376,
	[689][10] = 377,
	[689][11] = 378,
	[689][12] = 379,
	[689][13] = 380,
	[690][2] = 369,
	[690][3] = 370,
	[690][4] = 371,
	[690][5] = 372,
	[690][6] = 373,
	[690][7] = 374,
	[690][8] = 375,
	[690][9] = 376,
	[690][10] = 377,
	[690][11] = 378,
	[690][12] = 379,
	[690][13] = 380,
	[691][2] = 369,
	[691][3] = 370,
	[691][4] = 371,
	[691][5] = 372,
	[691][6] = 373,
	[691][7] = 374,
	[691][8] = 375,
	[691][9] = 376,
	[691][10] = 377,
	[691][11] = 378,
	[691][12] = 379,
	[691][13] = 380,
	[692][2] = 369,
	[692][3] = 370,
	[692][4] = 371,
	[692][5] = 372,
	[692][6] = 373,
	[692][7] = 374,
	[692][8] = 375,
	[692][9] = 376,
	[692][10] = 377,
	[692][11] = 378,
	[692][12] = 379,
	[692][13] = 380,
	[693][2] = 369,
	[693][3] = 370,
	[693][4] = 371,
	[693][5] = 372,
	[693][6] = 373,
	[693][7] = 374,
	[693][8] = 375,
	[693][9] = 376,
	[693][10] = 377,
	[693][11] = 378,
	[693][12] = 379,
	[693][13] = 380,
	[693][15] = 381,
	[694][2] = 41,
	[694][3] = 42,
	[694][4] = 43,
	[694][5] = 45,
	[694][6] = 46,
	[694][7] = 48,
	[694][8] = 49,
	[694][9] = 50,
	[694][10] = 51,
	[694][11] = 52,
	[694][12] = 53,
	[694][13] = 54,
	[694][15] = 55,
	[694][38] = 935,
	[694][39] = 936,
	[695][2] = 410,
	[695][3] = 411,
	[695][4] = 412,
	[695][5] = 413,
	[695][6] = 414,
	[695][7] = 415,
	[695][8] = 416,
	[695][9] = 417,
	[695][10] = 418,
	[695][11] = 419,
	[695][12] = 420,
	[695][13] = 421,
	[695][15] = 422,
	[696][11] = 939,
	[697][2] = 369,
	[697][3] = 370,
	[697][4] = 371,
	[697][5] = 372,
	[697][6] = 373,
	[697][7] = 374,
	[697][8] = 375,
	[697][9] = 376,
	[697][10] = 377,
	[697][11] = 378,
	[697][12] = 379,
	[697][13] = 380,
	[698][2] = 369,
	[698][3] = 370,
	[698][4] = 371,
	[698][5] = 372,
	[698][6] = 373,
	[698][7] = 374,
	[698][8] = 375,
	[698][9] = 376,
	[698][10] = 377,
	[698][11] = 378,
	[698][12] = 379,
	[698][13] = 380,
	[699][2] = 369,
	[699][3] = 370,
	[699][4] = 371,
	[699][5] = 372,
	[699][6] = 373,
	[699][7] = 374,
	[699][8] = 375,
	[699][9] = 376,
	[699][10] = 377,
	[699][11] = 378,
	[699][12] = 379,
	[699][13] = 380,
	[700][2] = 369,
	[700][3] = 370,
	[700][4] = 371,
	[700][5] = 372,
	[700][6] = 373,
	[700][7] = 374,
	[700][8] = 375,
	[700][9] = 376,
	[700][10] = 377,
	[700][11] = 378,
	[700][12] = 379,
	[700][13] = 380,
	[701][2] = 369,
	[701][3] = 370,
	[701][4] = 371,
	[701][5] = 372,
	[701][6] = 373,
	[701][7] = 374,
	[701][8] = 375,
	[701][9] = 376,
	[701][10] = 377,
	[701][11] = 378,
	[701][12] = 379,
	[701][13] = 380,
	[702][2] = 369,
	[702][3] = 370,
	[702][4] = 371,
	[702][5] = 372,
	[702][6] = 373,
	[702][7] = 374,
	[702][8] = 375,
	[702][9] = 376,
	[702][10] = 377,
	[702][11] = 378,
	[702][12] = 379,
	[702][13] = 380,
	[703][2] = 2,
	[703][3] = 3,
	[703][4] = 4,
	[703][5] = 5,
	[703][6] = 6,
	[703][7] = 7,
	[703][8] = 8,
	[703][9] = 9,
	[703][10] = 10,
	[703][11] = 75,
	[703][12] = 12,
	[703][13] = 13,
	[703][15] = 15,
	[705][38] = 947,
	[705][39] = 948,
	[707][2] = 41,
	[707][3] = 42,
	[707][4] = 43,
	[707][5] = 45,
	[707][6] = 46,
	[707][7] = 48,
	[707][8] = 49,
	[707][9] = 50,
	[707][10] = 51,
	[707][11] = 52,
	[707][12] = 53,
	[707][13] = 54,
	[707][15] = 55,
	[709][2] = 41,
	[709][3] = 42,
	[709][4] = 43,
	[709][5] = 45,
	[709][6] = 46,
	[709][7] = 48,
	[709][8] = 49,
	[709][9] = 50,
	[709][10] = 51,
	[709][11] = 52,
	[709][12] = 53,
	[709][13] = 54,
	[709][15] = 55,
	[710][38] = 952,
	[710][39] = 953,
	[713][2] = 78,
	[713][3] = 79,
	[713][4] = 80,
	[713][5] = 81,
	[713][6] = 82,
	[713][7] = 84,
	[713][8] = 85,
	[713][9] = 87,
	[713][10] = 88,
	[713][11] = 89,
	[713][12] = 90,
	[713][13] = 91,
	[713][15] = 92,
	[715][39] = 956,
	[715][40] = 957,
	[717][2] = 41,
	[717][3] = 42,
	[717][4] = 43,
	[717][5] = 45,
	[717][6] = 46,
	[717][7] = 48,
	[717][8] = 49,
	[717][9] = 50,
	[717][10] = 51,
	[717][11] = 52,
	[717][12] = 53,
	[717][13] = 54,
	[717][15] = 55,
	[717][38] = 958,
	[717][39] = 959,
	[719][4] = 124,
	[719][11] = 326,
	[719][15] = 132,
	[719][50] = 128,
	[719][51] = 129,
	[719][52] = 130,
	[719][53] = 131,
	[720][2] = 410,
	[720][3] = 411,
	[720][4] = 412,
	[720][5] = 413,
	[720][6] = 414,
	[720][7] = 415,
	[720][8] = 416,
	[720][9] = 417,
	[720][10] = 418,
	[720][11] = 419,
	[720][12] = 420,
	[720][13] = 421,
	[720][15] = 422,
	[721][11] = 965,
	[722][2] = 410,
	[722][3] = 411,
	[722][4] = 412,
	[722][5] = 413,
	[722][6] = 414,
	[722][7] = 415,
	[722][8] = 416,
	[722][9] = 417,
	[722][10] = 418,
	[722][11] = 419,
	[722][12] = 420,
	[722][13] = 421,
	[723][2] = 410,
	[723][3] = 411,
	[723][4] = 412,
	[723][5] = 413,
	[723][6] = 414,
	[723][7] = 415,
	[723][8] = 416,
	[723][9] = 417,
	[723][10] = 418,
	[723][11] = 419,
	[723][12] = 420,
	[723][13] = 421,
	[724][2] = 410,
	[724][3] = 411,
	[724][4] = 412,
	[724][5] = 413,
	[724][6] = 414,
	[724][7] = 415,
	[724][8] = 416,
	[724][9] = 417,
	[724][10] = 418,
	[724][11] = 419,
	[724][12] = 420,
	[724][13] = 421,
	[725][2] = 410,
	[725][3] = 411,
	[725][4] = 412,
	[725][5] = 413,
	[725][6] = 414,
	[725][7] = 415,
	[725][8] = 416,
	[725][9] = 417,
	[725][10] = 418,
	[725][11] = 419,
	[725][12] = 420,
	[725][13] = 421,
	[726][2] = 410,
	[726][3] = 411,
	[726][4] = 412,
	[726][5] = 413,
	[726][6] = 414,
	[726][7] = 415,
	[726][8] = 416,
	[726][9] = 417,
	[726][10] = 418,
	[726][11] = 419,
	[726][12] = 420,
	[726][13] = 421,
	[727][2] = 410,
	[727][3] = 411,
	[727][4] = 412,
	[727][5] = 413,
	[727][6] = 414,
	[727][7] = 415,
	[727][8] = 416,
	[727][9] = 417,
	[727][10] = 418,
	[727][11] = 419,
	[727][12] = 420,
	[727][13] = 421,
	[728][2] = 410,
	[728][3] = 411,
	[728][4] = 412,
	[728][5] = 413,
	[728][6] = 414,
	[728][7] = 415,
	[728][8] = 416,
	[728][9] = 417,
	[728][10] = 418,
	[728][11] = 419,
	[728][12] = 420,
	[728][13] = 421,
	[730][2] = 410,
	[730][3] = 411,
	[730][4] = 412,
	[730][5] = 413,
	[730][6] = 414,
	[730][7] = 415,
	[730][8] = 416,
	[730][9] = 417,
	[730][10] = 418,
	[730][11] = 419,
	[730][12] = 420,
	[730][13] = 421,
	[730][15] = 422,
	[731][2] = 410,
	[731][3] = 411,
	[731][4] = 412,
	[731][5] = 413,
	[731][6] = 414,
	[731][7] = 415,
	[731][8] = 416,
	[731][9] = 417,
	[731][10] = 418,
	[731][11] = 419,
	[731][12] = 420,
	[731][13] = 421,
	[732][11] = 976,
	[733][2] = 410,
	[733][3] = 411,
	[733][4] = 412,
	[733][5] = 413,
	[733][6] = 414,
	[733][7] = 415,
	[733][8] = 416,
	[733][9] = 417,
	[733][10] = 418,
	[733][11] = 419,
	[733][12] = 420,
	[733][13] = 421,
	[734][2] = 369,
	[734][3] = 370,
	[734][4] = 371,
	[734][5] = 372,
	[734][6] = 373,
	[734][7] = 374,
	[734][8] = 375,
	[734][9] = 376,
	[734][10] = 377,
	[734][11] = 378,
	[734][12] = 379,
	[734][13] = 380,
	[734][15] = 381,
	[735][2] = 410,
	[735][3] = 411,
	[735][4] = 412,
	[735][5] = 413,
	[735][6] = 414,
	[735][7] = 415,
	[735][8] = 416,
	[735][9] = 417,
	[735][10] = 418,
	[735][11] = 419,
	[735][12] = 420,
	[735][13] = 421,
	[736][2] = 410,
	[736][3] = 411,
	[736][4] = 412,
	[736][5] = 413,
	[736][6] = 414,
	[736][7] = 415,
	[736][8] = 416,
	[736][9] = 417,
	[736][10] = 418,
	[736][11] = 419,
	[736][12] = 420,
	[736][13] = 421,
	[737][2] = 410,
	[737][3] = 411,
	[737][4] = 412,
	[737][5] = 413,
	[737][6] = 414,
	[737][7] = 415,
	[737][8] = 416,
	[737][9] = 417,
	[737][10] = 418,
	[737][11] = 419,
	[737][12] = 420,
	[737][13] = 421,
	[738][2] = 410,
	[738][3] = 411,
	[738][4] = 412,
	[738][5] = 413,
	[738][6] = 414,
	[738][7] = 415,
	[738][8] = 416,
	[738][9] = 417,
	[738][10] = 418,
	[738][11] = 419,
	[738][12] = 420,
	[738][13] = 421,
	[739][2] = 410,
	[739][3] = 411,
	[739][4] = 412,
	[739][5] = 413,
	[739][6] = 414,
	[739][7] = 415,
	[739][8] = 416,
	[739][9] = 417,
	[739][10] = 418,
	[739][11] = 419,
	[739][12] = 420,
	[739][13] = 421,
	[739][15] = 422,
	[740][2] = 41,
	[740][3] = 42,
	[740][4] = 43,
	[740][5] = 45,
	[740][6] = 46,
	[740][7] = 48,
	[740][8] = 49,
	[740][9] = 50,
	[740][10] = 51,
	[740][11] = 52,
	[740][12] = 53,
	[740][13] = 54,
	[740][15] = 55,
	[740][38] = 985,
	[740][39] = 986,
	[741][2] = 410,
	[741][3] = 411,
	[741][4] = 412,
	[741][5] = 413,
	[741][6] = 414,
	[741][7] = 415,
	[741][8] = 416,
	[741][9] = 417,
	[741][10] = 418,
	[741][11] = 419,
	[741][12] = 420,
	[741][13] = 421,
	[741][15] = 422,
	[742][11] = 989,
	[743][2] = 410,
	[743][3] = 411,
	[743][4] = 412,
	[743][5] = 413,
	[743][6] = 414,
	[743][7] = 415,
	[743][8] = 416,
	[743][9] = 417,
	[743][10] = 418,
	[743][11] = 419,
	[743][12] = 420,
	[743][13] = 421,
	[744][2] = 410,
	[744][3] = 411,
	[744][4] = 412,
	[744][5] = 413,
	[744][6] = 414,
	[744][7] = 415,
	[744][8] = 416,
	[744][9] = 417,
	[744][10] = 418,
	[744][11] = 419,
	[744][12] = 420,
	[744][13] = 421,
	[745][2] = 410,
	[745][3] = 411,
	[745][4] = 412,
	[745][5] = 413,
	[745][6] = 414,
	[745][7] = 415,
	[745][8] = 416,
	[745][9] = 417,
	[745][10] = 418,
	[745][11] = 419,
	[745][12] = 420,
	[745][13] = 421,
	[746][2] = 410,
	[746][3] = 411,
	[746][4] = 412,
	[746][5] = 413,
	[746][6] = 414,
	[746][7] = 415,
	[746][8] = 416,
	[746][9] = 417,
	[746][10] = 418,
	[746][11] = 419,
	[746][12] = 420,
	[746][13] = 421,
	[747][2] = 410,
	[747][3] = 411,
	[747][4] = 412,
	[747][5] = 413,
	[747][6] = 414,
	[747][7] = 415,
	[747][8] = 416,
	[747][9] = 417,
	[747][10] = 418,
	[747][11] = 419,
	[747][12] = 420,
	[747][13] = 421,
	[748][2] = 410,
	[748][3] = 411,
	[748][4] = 412,
	[748][5] = 413,
	[748][6] = 414,
	[748][7] = 415,
	[748][8] = 416,
	[748][9] = 417,
	[748][10] = 418,
	[748][11] = 419,
	[748][12] = 420,
	[748][13] = 421,
	[750][2] = 41,
	[750][3] = 42,
	[750][4] = 43,
	[750][5] = 45,
	[750][6] = 46,
	[750][7] = 48,
	[750][8] = 49,
	[750][9] = 50,
	[750][10] = 51,
	[750][11] = 52,
	[750][12] = 53,
	[750][13] = 54,
	[750][15] = 55,
	[753][2] = 78,
	[753][3] = 79,
	[753][4] = 80,
	[753][5] = 81,
	[753][6] = 82,
	[753][7] = 84,
	[753][8] = 85,
	[753][9] = 87,
	[753][10] = 88,
	[753][11] = 89,
	[753][12] = 90,
	[753][13] = 91,
	[753][15] = 92,
	[757][38] = 998,
	[757][39] = 999,
	[759][2] = 41,
	[759][3] = 42,
	[759][4] = 43,
	[759][5] = 45,
	[759][6] = 46,
	[759][7] = 48,
	[759][8] = 49,
	[759][9] = 50,
	[759][10] = 51,
	[759][11] = 52,
	[759][12] = 53,
	[759][13] = 54,
	[759][15] = 55,
	[760][4] = 124,
	[760][11] = 326,
	[760][15] = 132,
	[760][50] = 128,
	[760][51] = 129,
	[760][52] = 130,
	[760][53] = 131,
	[761][2] = 41,
	[761][3] = 42,
	[761][4] = 43,
	[761][5] = 45,
	[761][6] = 46,
	[761][7] = 48,
	[761][8] = 49,
	[761][9] = 50,
	[761][10] = 51,
	[761][11] = 52,
	[761][12] = 53,
	[761][13] = 54,
	[761][15] = 55,
	[762][4] = 124,
	[762][11] = 326,
	[762][15] = 132,
	[762][50] = 128,
	[762][51] = 129,
	[762][52] = 130,
	[762][53] = 131,
	[763][2] = 41,
	[763][3] = 42,
	[763][4] = 43,
	[763][5] = 45,
	[763][6] = 46,
	[763][7] = 48,
	[763][8] = 49,
	[763][9] = 50,
	[763][10] = 51,
	[763][11] = 52,
	[763][12] = 53,
	[763][13] = 54,
	[763][15] = 55,
	[764][2] = 41,
	[764][3] = 42,
	[764][4] = 43,
	[764][5] = 45,
	[764][6] = 46,
	[764][7] = 48,
	[764][8] = 49,
	[764][9] = 50,
	[764][10] = 51,
	[764][11] = 52,
	[764][12] = 53,
	[764][13] = 54,
	[764][15] = 55,
	[765][2] = 41,
	[765][3] = 42,
	[765][4] = 43,
	[765][5] = 45,
	[765][6] = 46,
	[765][7] = 48,
	[765][8] = 49,
	[765][9] = 50,
	[765][10] = 51,
	[765][11] = 52,
	[765][12] = 53,
	[765][13] = 54,
	[766][2] = 41,
	[766][3] = 42,
	[766][4] = 43,
	[766][5] = 45,
	[766][6] = 46,
	[766][7] = 48,
	[766][8] = 49,
	[766][9] = 50,
	[766][10] = 51,
	[766][11] = 52,
	[766][12] = 53,
	[766][13] = 54,
	[766][15] = 55,
	[768][38] = 1008,
	[768][39] = 1009,
	[770][2] = 41,
	[770][3] = 42,
	[770][4] = 43,
	[770][5] = 45,
	[770][6] = 46,
	[770][7] = 48,
	[770][8] = 49,
	[770][9] = 50,
	[770][10] = 51,
	[770][11] = 52,
	[770][12] = 53,
	[770][13] = 54,
	[770][15] = 55,
	[773][2] = 41,
	[773][3] = 42,
	[773][4] = 43,
	[773][5] = 45,
	[773][6] = 46,
	[773][7] = 48,
	[773][8] = 49,
	[773][9] = 50,
	[773][10] = 51,
	[773][11] = 52,
	[773][12] = 53,
	[773][13] = 54,
	[773][15] = 55,
	[776][2] = 78,
	[776][3] = 79,
	[776][4] = 80,
	[776][5] = 81,
	[776][6] = 82,
	[776][7] = 84,
	[776][8] = 85,
	[776][9] = 87,
	[776][10] = 88,
	[776][11] = 89,
	[776][12] = 90,
	[776][13] = 91,
	[776][15] = 92,
	[780][38] = 1013,
	[780][39] = 1014,
	[782][2] = 41,
	[782][3] = 42,
	[782][4] = 43,
	[782][5] = 45,
	[782][6] = 46,
	[782][7] = 48,
	[782][8] = 49,
	[782][9] = 50,
	[782][10] = 51,
	[782][11] = 52,
	[782][12] = 53,
	[782][13] = 54,
	[782][15] = 55,
	[783][4] = 124,
	[783][11] = 326,
	[783][15] = 132,
	[783][50] = 128,
	[783][51] = 129,
	[783][52] = 130,
	[783][53] = 131,
	[784][2] = 78,
	[784][3] = 79,
	[784][4] = 80,
	[784][5] = 81,
	[784][6] = 82,
	[784][7] = 84,
	[784][8] = 85,
	[784][9] = 87,
	[784][10] = 88,
	[784][11] = 89,
	[784][12] = 90,
	[784][13] = 91,
	[784][15] = 92,
	[785][4] = 124,
	[785][11] = 326,
	[785][15] = 132,
	[785][50] = 128,
	[785][51] = 129,
	[785][52] = 130,
	[785][53] = 131,
	[786][2] = 78,
	[786][3] = 79,
	[786][4] = 80,
	[786][5] = 81,
	[786][6] = 82,
	[786][7] = 84,
	[786][8] = 85,
	[786][9] = 87,
	[786][10] = 88,
	[786][11] = 89,
	[786][12] = 90,
	[786][13] = 91,
	[786][15] = 92,
	[787][2] = 78,
	[787][3] = 79,
	[787][4] = 80,
	[787][5] = 81,
	[787][6] = 82,
	[787][7] = 84,
	[787][8] = 85,
	[787][9] = 87,
	[787][10] = 88,
	[787][11] = 89,
	[787][12] = 90,
	[787][13] = 91,
	[787][15] = 92,
	[788][2] = 78,
	[788][3] = 79,
	[788][4] = 80,
	[788][5] = 81,
	[788][6] = 82,
	[788][7] = 84,
	[788][8] = 85,
	[788][9] = 87,
	[788][10] = 88,
	[788][11] = 89,
	[788][12] = 90,
	[788][13] = 91,
	[789][2] = 78,
	[789][3] = 79,
	[789][4] = 80,
	[789][5] = 81,
	[789][6] = 82,
	[789][7] = 84,
	[789][8] = 85,
	[789][9] = 87,
	[789][10] = 88,
	[789][11] = 89,
	[789][12] = 90,
	[789][13] = 91,
	[789][15] = 92,
	[791][38] = 1023,
	[791][39] = 1024,
	[793][2] = 41,
	[793][3] = 42,
	[793][4] = 43,
	[793][5] = 45,
	[793][6] = 46,
	[793][7] = 48,
	[793][8] = 49,
	[793][9] = 50,
	[793][10] = 51,
	[793][11] = 52,
	[793][12] = 53,
	[793][13] = 54,
	[793][15] = 55,
	[795][56] = 795,
	[797][56] = 797,
	[799][56] = 1028,
	[800][56] = 1030,
	[801][38] = 1032,
	[802][56] = 1033,
	[803][40] = 1035,
	[804][56] = 1036,
	[805][23] = 1038,
	[806][56] = 1039,
	[810][2] = 573,
	[810][3] = 574,
	[810][4] = 575,
	[810][7] = 576,
	[810][8] = 577,
	[810][11] = 578,
	[810][23] = 579,
	[811][2] = 573,
	[811][3] = 574,
	[811][4] = 575,
	[811][7] = 576,
	[811][8] = 577,
	[811][11] = 578,
	[811][23] = 579,
	[812][56] = 812,
	[816][2] = 814,
	[816][3] = 815,
	[816][4] = 816,
	[816][5] = 817,
	[817][2] = 814,
	[817][3] = 815,
	[817][4] = 816,
	[818][38] = 1047,
	[820][17] = 1048,
	[821][6] = 1049,
	[822][16] = 1050,
	[823][2] = 814,
	[823][3] = 815,
	[823][4] = 816,
	[823][5] = 817,
	[823][18] = 1052,
	[823][39] = 1051,
	[825][56] = 1054,
	[826][2] = 585,
	[826][3] = 586,
	[826][4] = 587,
	[826][5] = 588,
	[827][2] = 1057,
	[827][3] = 1058,
	[827][4] = 1059,
	[827][5] = 1060,
	[828][2] = 585,
	[828][3] = 586,
	[828][4] = 587,
	[828][5] = 588,
	[829][2] = 585,
	[829][3] = 586,
	[829][4] = 587,
	[829][5] = 588,
	[830][2] = 585,
	[830][3] = 586,
	[830][4] = 587,
	[830][5] = 588,
	[831][2] = 585,
	[831][3] = 586,
	[831][4] = 587,
	[831][5] = 588,
	[831][18] = 1070,
	[831][39] = 1069,
	[832][56] = 832,
	[836][2] = 834,
	[836][3] = 835,
	[836][4] = 836,
	[836][7] = 837,
	[836][8] = 838,
	[838][2] = 585,
	[838][3] = 586,
	[838][4] = 587,
	[838][5] = 588,
	[839][38] = 1076,
	[840][9] = 1077,
	[840][19] = 1078,
	[840][20] = 1079,
	[841][18] = 1080,
	[842][2] = 834,
	[842][3] = 835,
	[842][4] = 836,
	[842][7] = 837,
	[842][8] = 838,
	[843][40] = 1082,
	[844][56] = 1083,
	[848][2] = 596,
	[848][3] = 597,
	[848][4] = 598,
	[848][7] = 599,
	[848][8] = 600,
	[849][2] = 596,
	[849][3] = 597,
	[849][4] = 598,
	[849][7] = 599,
	[849][8] = 600,
	[851][18] = 1088,
	[853][2] = 293,
	[853][3] = 294,
	[853][4] = 295,
	[853][7] = 296,
	[853][8] = 297,
	[853][11] = 298,
	[853][23] = 299,
	[855][2] = 41,
	[855][3] = 42,
	[855][4] = 43,
	[855][5] = 45,
	[855][6] = 46,
	[855][7] = 48,
	[855][8] = 49,
	[855][9] = 50,
	[855][10] = 51,
	[855][11] = 52,
	[855][12] = 53,
	[855][13] = 54,
	[855][15] = 55,
	[857][38] = 1091,
	[858][40] = 1092,
	[863][2] = 617,
	[863][3] = 618,
	[863][4] = 619,
	[863][7] = 620,
	[863][8] = 621,
	[864][2] = 617,
	[864][3] = 618,
	[864][4] = 619,
	[864][7] = 620,
	[864][8] = 621,
	[868][38] = 1097,
	[868][39] = 1098,
	[870][4] = 315,
	[870][11] = 318,
	[870][15] = 323,
	[870][50] = 319,
	[870][51] = 320,
	[870][52] = 321,
	[870][53] = 322,
	[872][4] = 315,
	[872][11] = 318,
	[872][15] = 323,
	[872][50] = 319,
	[872][51] = 320,
	[872][52] = 321,
	[872][53] = 322,
	[874][39] = 1101,
	[874][41] = 1102,
	[877][4] = 332,
	[877][11] = 334,
	[877][15] = 340,
	[877][50] = 336,
	[877][51] = 337,
	[877][52] = 338,
	[877][53] = 339,
	[878][4] = 315,
	[878][11] = 318,
	[878][15] = 323,
	[878][50] = 319,
	[878][51] = 320,
	[878][52] = 321,
	[878][53] = 322,
	[883][38] = 1105,
	[883][39] = 1106,
	[885][4] = 315,
	[885][11] = 318,
	[885][15] = 323,
	[885][50] = 319,
	[885][51] = 320,
	[885][52] = 321,
	[885][53] = 322,
	[886][4] = 332,
	[886][11] = 334,
	[886][15] = 340,
	[886][50] = 336,
	[886][51] = 337,
	[886][52] = 338,
	[886][53] = 339,
	[887][4] = 124,
	[887][11] = 126,
	[887][15] = 132,
	[887][50] = 128,
	[887][51] = 129,
	[887][52] = 130,
	[887][53] = 131,
	[889][39] = 1110,
	[889][41] = 1111,
	[892][4] = 332,
	[892][11] = 334,
	[892][15] = 340,
	[892][50] = 336,
	[892][51] = 337,
	[892][52] = 338,
	[892][53] = 339,
	[893][4] = 332,
	[893][11] = 334,
	[893][15] = 340,
	[893][50] = 336,
	[893][51] = 337,
	[893][52] = 338,
	[893][53] = 339,
	[900][38] = 1114,
	[900][39] = 1115,
	[902][2] = 41,
	[902][3] = 42,
	[902][4] = 43,
	[902][5] = 45,
	[902][6] = 46,
	[902][7] = 48,
	[902][8] = 49,
	[902][9] = 50,
	[902][10] = 51,
	[902][11] = 52,
	[902][12] = 53,
	[902][13] = 54,
	[902][15] = 55,
	[904][39] = 1117,
	[904][40] = 1118,
	[905][2] = 78,
	[905][3] = 79,
	[905][4] = 80,
	[905][5] = 81,
	[905][6] = 82,
	[905][7] = 84,
	[905][8] = 85,
	[905][9] = 87,
	[905][10] = 88,
	[905][11] = 89,
	[905][12] = 90,
	[905][13] = 91,
	[905][15] = 92,
	[908][2] = 41,
	[908][3] = 42,
	[908][4] = 43,
	[908][5] = 45,
	[908][6] = 46,
	[908][7] = 48,
	[908][8] = 49,
	[908][9] = 50,
	[908][10] = 51,
	[908][11] = 52,
	[908][12] = 53,
	[908][13] = 54,
	[908][15] = 55,
	[909][38] = 1122,
	[909][39] = 1123,
	[911][39] = 1124,
	[911][41] = 1125,
	[914][39] = 1126,
	[914][41] = 1127,
	[915][14] = 692,
	[915][20] = 690,
	[915][23] = 691,
	[916][14] = 692,
	[916][20] = 690,
	[916][23] = 691,
	[917][30] = 679,
	[917][31] = 680,
	[918][26] = 697,
	[918][27] = 698,
	[918][28] = 699,
	[918][29] = 700,
	[919][26] = 697,
	[919][27] = 698,
	[919][28] = 699,
	[919][29] = 700,
	[920][16] = 678,
	[924][36] = 1128,
	[925][17] = 681,
	[927][18] = 685,
	[928][41] = 1129,
	[929][32] = 687,
	[930][22] = 682,
	[931][22] = 682,
	[932][22] = 682,
	[934][35] = 1130,
	[936][2] = 41,
	[936][3] = 42,
	[936][4] = 43,
	[936][5] = 45,
	[936][6] = 46,
	[936][7] = 48,
	[936][8] = 49,
	[936][9] = 50,
	[936][10] = 51,
	[936][11] = 52,
	[936][12] = 53,
	[936][13] = 54,
	[936][15] = 55,
	[937][38] = 1133,
	[937][39] = 1134,
	[938][40] = 1135,
	[940][24] = 701,
	[940][25] = 702,
	[941][24] = 701,
	[941][25] = 702,
	[942][24] = 701,
	[942][25] = 702,
	[943][24] = 701,
	[943][25] = 702,
	[944][6] = 676,
	[944][9] = 677,
	[945][6] = 676,
	[945][9] = 677,
	[948][2] = 41,
	[948][3] = 42,
	[948][4] = 43,
	[948][5] = 45,
	[948][6] = 46,
	[948][7] = 48,
	[948][8] = 49,
	[948][9] = 50,
	[948][10] = 51,
	[948][11] = 52,
	[948][12] = 53,
	[948][13] = 54,
	[948][15] = 55,
	[951][38] = 1137,
	[951][39] = 1138,
	[953][2] = 41,
	[953][3] = 42,
	[953][4] = 43,
	[953][5] = 45,
	[953][6] = 46,
	[953][7] = 48,
	[953][8] = 49,
	[953][9] = 50,
	[953][10] = 51,
	[953][11] = 52,
	[953][12] = 53,
	[953][13] = 54,
	[953][15] = 55,
	[955][39] = 1140,
	[955][40] = 1141,
	[956][2] = 78,
	[956][3] = 79,
	[956][4] = 80,
	[956][5] = 81,
	[956][6] = 82,
	[956][7] = 84,
	[956][8] = 85,
	[956][9] = 87,
	[956][10] = 88,
	[956][11] = 89,
	[956][12] = 90,
	[956][13] = 91,
	[956][15] = 92,
	[959][2] = 41,
	[959][3] = 42,
	[959][4] = 43,
	[959][5] = 45,
	[959][6] = 46,
	[959][7] = 48,
	[959][8] = 49,
	[959][9] = 50,
	[959][10] = 51,
	[959][11] = 52,
	[959][12] = 53,
	[959][13] = 54,
	[959][15] = 55,
	[960][38] = 1145,
	[960][39] = 1146,
	[962][39] = 1147,
	[962][41] = 1148,
	[965][39] = 1149,
	[965][41] = 1150,
	[966][14] = 738,
	[966][20] = 736,
	[966][23] = 737,
	[967][14] = 738,
	[967][20] = 736,
	[967][23] = 737,
	[968][30] = 725,
	[968][31] = 726,
	[969][26] = 743,
	[969][27] = 744,
	[969][28] = 745,
	[969][29] = 746,
	[970][26] = 743,
	[970][27] = 744,
	[970][28] = 745,
	[970][29] = 746,
	[971][16] = 724,
	[974][36] = 1151,
	[975][17] = 727,
	[977][18] = 731,
	[978][41] = 1152,
	[979][32] = 733,
	[980][22] = 728,
	[981][22] = 728,
	[982][22] = 728,
	[984][35] = 1153,
	[986][2] = 41,
	[986][3] = 42,
	[986][4] = 43,
	[986][5] = 45,
	[986][6] = 46,
	[986][7] = 48,
	[986][8] = 49,
	[986][9] = 50,
	[986][10] = 51,
	[986][11] = 52,
	[986][12] = 53,
	[986][13] = 54,
	[986][15] = 55,
	[987][38] = 1156,
	[987][39] = 1157,
	[988][40] = 1158,
	[990][24] = 747,
	[990][25] = 748,
	[991][24] = 747,
	[991][25] = 748,
	[992][24] = 747,
	[992][25] = 748,
	[993][24] = 747,
	[993][25] = 748,
	[994][6] = 722,
	[994][9] = 723,
	[995][6] = 722,
	[995][9] = 723,
	[999][2] = 41,
	[999][3] = 42,
	[999][4] = 43,
	[999][5] = 45,
	[999][6] = 46,
	[999][7] = 48,
	[999][8] = 49,
	[999][9] = 50,
	[999][10] = 51,
	[999][11] = 52,
	[999][12] = 53,
	[999][13] = 54,
	[999][15] = 55,
	[1009][2] = 41,
	[1009][3] = 42,
	[1009][4] = 43,
	[1009][5] = 45,
	[1009][6] = 46,
	[1009][7] = 48,
	[1009][8] = 49,
	[1009][9] = 50,
	[1009][10] = 51,
	[1009][11] = 52,
	[1009][12] = 53,
	[1009][13] = 54,
	[1009][15] = 55,
	[1014][2] = 41,
	[1014][3] = 42,
	[1014][4] = 43,
	[1014][5] = 45,
	[1014][6] = 46,
	[1014][7] = 48,
	[1014][8] = 49,
	[1014][9] = 50,
	[1014][10] = 51,
	[1014][11] = 52,
	[1014][12] = 53,
	[1014][13] = 54,
	[1014][15] = 55,
	[1024][2] = 41,
	[1024][3] = 42,
	[1024][4] = 43,
	[1024][5] = 45,
	[1024][6] = 46,
	[1024][7] = 48,
	[1024][8] = 49,
	[1024][9] = 50,
	[1024][10] = 51,
	[1024][11] = 52,
	[1024][12] = 53,
	[1024][13] = 54,
	[1024][15] = 55,
	[1028][56] = 1028,
	[1030][56] = 1030,
	[1032][56] = 1165,
	[1033][56] = 1033,
	[1035][56] = 1167,
	[1036][56] = 1036,
	[1038][56] = 1169,
	[1039][56] = 795,
	[1041][18] = 1171,
	[1043][2] = 573,
	[1043][3] = 574,
	[1043][4] = 575,
	[1043][7] = 576,
	[1043][8] = 577,
	[1043][11] = 578,
	[1043][23] = 579,
	[1045][38] = 1173,
	[1048][2] = 814,
	[1048][3] = 815,
	[1048][4] = 816,
	[1048][5] = 817,
	[1049][2] = 1176,
	[1049][3] = 1177,
	[1049][4] = 1178,
	[1049][5] = 1179,
	[1050][2] = 814,
	[1050][3] = 815,
	[1050][4] = 816,
	[1050][5] = 817,
	[1051][2] = 814,
	[1051][3] = 815,
	[1051][4] = 816,
	[1051][5] = 817,
	[1052][2] = 814,
	[1052][3] = 815,
	[1052][4] = 816,
	[1052][5] = 817,
	[1053][2] = 814,
	[1053][3] = 815,
	[1053][4] = 816,
	[1053][5] = 817,
	[1053][18] = 1189,
	[1053][39] = 1188,
	[1054][56] = 1192,
	[1056][17] = 1194,
	[1059][2] = 814,
	[1059][3] = 815,
	[1059][4] = 816,
	[1059][5] = 817,
	[1060][2] = 1057,
	[1060][3] = 1058,
	[1060][4] = 1059,
	[1064][16] = 1197,
	[1066][2] = 585,
	[1066][3] = 586,
	[1066][4] = 587,
	[1066][5] = 588,
	[1066][18] = 1070,
	[1066][39] = 1069,
	[1068][2] = 585,
	[1068][3] = 586,
	[1068][4] = 587,
	[1068][5] = 588,
	[1068][18] = 1070,
	[1068][39] = 1069,
	[1069][2] = 585,
	[1069][3] = 586,
	[1069][4] = 587,
	[1069][5] = 588,
	[1070][2] = 585,
	[1070][3] = 586,
	[1070][4] = 587,
	[1070][5] = 588,
	[1072][2] = 585,
	[1072][3] = 586,
	[1072][4] = 587,
	[1072][5] = 588,
	[1072][18] = 1070,
	[1072][39] = 1069,
	[1074][38] = 1203,
	[1075][40] = 1204,
	[1080][2] = 834,
	[1080][3] = 835,
	[1080][4] = 836,
	[1080][7] = 837,
	[1080][8] = 838,
	[1081][2] = 834,
	[1081][3] = 835,
	[1081][4] = 836,
	[1081][7] = 837,
	[1081][8] = 838,
	[1083][56] = 1209,
	[1085][18] = 1211,
	[1087][2] = 596,
	[1087][3] = 597,
	[1087][4] = 598,
	[1087][7] = 599,
	[1087][8] = 600,
	[1088][2] = 293,
	[1088][3] = 294,
	[1088][4] = 295,
	[1088][7] = 296,
	[1088][8] = 297,
	[1088][11] = 298,
	[1088][23] = 299,
	[1094][18] = 1214,
	[1096][2] = 617,
	[1096][3] = 618,
	[1096][4] = 619,
	[1096][7] = 620,
	[1096][8] = 621,
	[1098][4] = 315,
	[1098][11] = 318,
	[1098][15] = 323,
	[1098][50] = 319,
	[1098][51] = 320,
	[1098][52] = 321,
	[1098][53] = 322,
	[1101][4] = 332,
	[1101][11] = 334,
	[1101][15] = 340,
	[1101][50] = 336,
	[1101][51] = 337,
	[1101][52] = 338,
	[1101][53] = 339,
	[1102][4] = 315,
	[1102][11] = 318,
	[1102][15] = 323,
	[1102][50] = 319,
	[1102][51] = 320,
	[1102][52] = 321,
	[1102][53] = 322,
	[1106][4] = 315,
	[1106][11] = 318,
	[1106][15] = 323,
	[1106][50] = 319,
	[1106][51] = 320,
	[1106][52] = 321,
	[1106][53] = 322,
	[1110][4] = 332,
	[1110][11] = 334,
	[1110][15] = 340,
	[1110][50] = 336,
	[1110][51] = 337,
	[1110][52] = 338,
	[1110][53] = 339,
	[1111][4] = 332,
	[1111][11] = 334,
	[1111][15] = 340,
	[1111][50] = 336,
	[1111][51] = 337,
	[1111][52] = 338,
	[1111][53] = 339,
	[1115][2] = 41,
	[1115][3] = 42,
	[1115][4] = 43,
	[1115][5] = 45,
	[1115][6] = 46,
	[1115][7] = 48,
	[1115][8] = 49,
	[1115][9] = 50,
	[1115][10] = 51,
	[1115][11] = 52,
	[1115][12] = 53,
	[1115][13] = 54,
	[1115][15] = 55,
	[1117][2] = 78,
	[1117][3] = 79,
	[1117][4] = 80,
	[1117][5] = 81,
	[1117][6] = 82,
	[1117][7] = 84,
	[1117][8] = 85,
	[1117][9] = 87,
	[1117][10] = 88,
	[1117][11] = 89,
	[1117][12] = 90,
	[1117][13] = 91,
	[1117][15] = 92,
	[1121][38] = 1224,
	[1121][39] = 1225,
	[1123][2] = 41,
	[1123][3] = 42,
	[1123][4] = 43,
	[1123][5] = 45,
	[1123][6] = 46,
	[1123][7] = 48,
	[1123][8] = 49,
	[1123][9] = 50,
	[1123][10] = 51,
	[1123][11] = 52,
	[1123][12] = 53,
	[1123][13] = 54,
	[1123][15] = 55,
	[1124][4] = 124,
	[1124][11] = 326,
	[1124][15] = 132,
	[1124][50] = 128,
	[1124][51] = 129,
	[1124][52] = 130,
	[1124][53] = 131,
	[1125][2] = 369,
	[1125][3] = 370,
	[1125][4] = 371,
	[1125][5] = 372,
	[1125][6] = 373,
	[1125][7] = 374,
	[1125][8] = 375,
	[1125][9] = 376,
	[1125][10] = 377,
	[1125][11] = 378,
	[1125][12] = 379,
	[1125][13] = 380,
	[1125][15] = 381,
	[1126][4] = 124,
	[1126][11] = 326,
	[1126][15] = 132,
	[1126][50] = 128,
	[1126][51] = 129,
	[1126][52] = 130,
	[1126][53] = 131,
	[1127][2] = 369,
	[1127][3] = 370,
	[1127][4] = 371,
	[1127][5] = 372,
	[1127][6] = 373,
	[1127][7] = 374,
	[1127][8] = 375,
	[1127][9] = 376,
	[1127][10] = 377,
	[1127][11] = 378,
	[1127][12] = 379,
	[1127][13] = 380,
	[1127][15] = 381,
	[1128][2] = 369,
	[1128][3] = 370,
	[1128][4] = 371,
	[1128][5] = 372,
	[1128][6] = 373,
	[1128][7] = 374,
	[1128][8] = 375,
	[1128][9] = 376,
	[1128][10] = 377,
	[1128][11] = 378,
	[1128][12] = 379,
	[1128][13] = 380,
	[1128][15] = 381,
	[1129][2] = 369,
	[1129][3] = 370,
	[1129][4] = 371,
	[1129][5] = 372,
	[1129][6] = 373,
	[1129][7] = 374,
	[1129][8] = 375,
	[1129][9] = 376,
	[1129][10] = 377,
	[1129][11] = 378,
	[1129][12] = 379,
	[1129][13] = 380,
	[1130][2] = 369,
	[1130][3] = 370,
	[1130][4] = 371,
	[1130][5] = 372,
	[1130][6] = 373,
	[1130][7] = 374,
	[1130][8] = 375,
	[1130][9] = 376,
	[1130][10] = 377,
	[1130][11] = 378,
	[1130][12] = 379,
	[1130][13] = 380,
	[1130][15] = 381,
	[1132][38] = 1234,
	[1132][39] = 1235,
	[1134][2] = 41,
	[1134][3] = 42,
	[1134][4] = 43,
	[1134][5] = 45,
	[1134][6] = 46,
	[1134][7] = 48,
	[1134][8] = 49,
	[1134][9] = 50,
	[1134][10] = 51,
	[1134][11] = 52,
	[1134][12] = 53,
	[1134][13] = 54,
	[1134][15] = 55,
	[1138][2] = 41,
	[1138][3] = 42,
	[1138][4] = 43,
	[1138][5] = 45,
	[1138][6] = 46,
	[1138][7] = 48,
	[1138][8] = 49,
	[1138][9] = 50,
	[1138][10] = 51,
	[1138][11] = 52,
	[1138][12] = 53,
	[1138][13] = 54,
	[1138][15] = 55,
	[1140][2] = 78,
	[1140][3] = 79,
	[1140][4] = 80,
	[1140][5] = 81,
	[1140][6] = 82,
	[1140][7] = 84,
	[1140][8] = 85,
	[1140][9] = 87,
	[1140][10] = 88,
	[1140][11] = 89,
	[1140][12] = 90,
	[1140][13] = 91,
	[1140][15] = 92,
	[1144][38] = 1239,
	[1144][39] = 1240,
	[1146][2] = 41,
	[1146][3] = 42,
	[1146][4] = 43,
	[1146][5] = 45,
	[1146][6] = 46,
	[1146][7] = 48,
	[1146][8] = 49,
	[1146][9] = 50,
	[1146][10] = 51,
	[1146][11] = 52,
	[1146][12] = 53,
	[1146][13] = 54,
	[1146][15] = 55,
	[1147][4] = 124,
	[1147][11] = 326,
	[1147][15] = 132,
	[1147][50] = 128,
	[1147][51] = 129,
	[1147][52] = 130,
	[1147][53] = 131,
	[1148][2] = 410,
	[1148][3] = 411,
	[1148][4] = 412,
	[1148][5] = 413,
	[1148][6] = 414,
	[1148][7] = 415,
	[1148][8] = 416,
	[1148][9] = 417,
	[1148][10] = 418,
	[1148][11] = 419,
	[1148][12] = 420,
	[1148][13] = 421,
	[1148][15] = 422,
	[1149][4] = 124,
	[1149][11] = 326,
	[1149][15] = 132,
	[1149][50] = 128,
	[1149][51] = 129,
	[1149][52] = 130,
	[1149][53] = 131,
	[1150][2] = 410,
	[1150][3] = 411,
	[1150][4] = 412,
	[1150][5] = 413,
	[1150][6] = 414,
	[1150][7] = 415,
	[1150][8] = 416,
	[1150][9] = 417,
	[1150][10] = 418,
	[1150][11] = 419,
	[1150][12] = 420,
	[1150][13] = 421,
	[1150][15] = 422,
	[1151][2] = 410,
	[1151][3] = 411,
	[1151][4] = 412,
	[1151][5] = 413,
	[1151][6] = 414,
	[1151][7] = 415,
	[1151][8] = 416,
	[1151][9] = 417,
	[1151][10] = 418,
	[1151][11] = 419,
	[1151][12] = 420,
	[1151][13] = 421,
	[1151][15] = 422,
	[1152][2] = 410,
	[1152][3] = 411,
	[1152][4] = 412,
	[1152][5] = 413,
	[1152][6] = 414,
	[1152][7] = 415,
	[1152][8] = 416,
	[1152][9] = 417,
	[1152][10] = 418,
	[1152][11] = 419,
	[1152][12] = 420,
	[1152][13] = 421,
	[1153][2] = 410,
	[1153][3] = 411,
	[1153][4] = 412,
	[1153][5] = 413,
	[1153][6] = 414,
	[1153][7] = 415,
	[1153][8] = 416,
	[1153][9] = 417,
	[1153][10] = 418,
	[1153][11] = 419,
	[1153][12] = 420,
	[1153][13] = 421,
	[1153][15] = 422,
	[1155][38] = 1249,
	[1155][39] = 1250,
	[1157][2] = 41,
	[1157][3] = 42,
	[1157][4] = 43,
	[1157][5] = 45,
	[1157][6] = 46,
	[1157][7] = 48,
	[1157][8] = 49,
	[1157][9] = 50,
	[1157][10] = 51,
	[1157][11] = 52,
	[1157][12] = 53,
	[1157][13] = 54,
	[1157][15] = 55,
	[1165][56] = 1028,
	[1167][56] = 1253,
	[1169][56] = 1255,
	[1171][2] = 573,
	[1171][3] = 574,
	[1171][4] = 575,
	[1171][7] = 576,
	[1171][8] = 577,
	[1171][11] = 578,
	[1171][23] = 579,
	[1175][17] = 1258,
	[1178][2] = 814,
	[1178][3] = 815,
	[1178][4] = 816,
	[1178][5] = 817,
	[1179][2] = 1176,
	[1179][3] = 1177,
	[1179][4] = 1178,
	[1183][16] = 1261,
	[1185][2] = 814,
	[1185][3] = 815,
	[1185][4] = 816,
	[1185][5] = 817,
	[1185][18] = 1189,
	[1185][39] = 1188,
	[1187][2] = 814,
	[1187][3] = 815,
	[1187][4] = 816,
	[1187][5] = 817,
	[1187][18] = 1189,
	[1187][39] = 1188,
	[1188][2] = 814,
	[1188][3] = 815,
	[1188][4] = 816,
	[1188][5] = 817,
	[1189][2] = 814,
	[1189][3] = 815,
	[1189][4] = 816,
	[1189][5] = 817,
	[1191][2] = 814,
	[1191][3] = 815,
	[1191][4] = 816,
	[1191][5] = 817,
	[1191][18] = 1189,
	[1191][39] = 1188,
	[1192][56] = 1192,
	[1194][2] = 585,
	[1194][3] = 586,
	[1194][4] = 587,
	[1194][5] = 588,
	[1195][38] = 1269,
	[1197][2] = 585,
	[1197][3] = 586,
	[1197][4] = 587,
	[1197][5] = 588,
	[1206][18] = 1271,
	[1208][2] = 834,
	[1208][3] = 835,
	[1208][4] = 836,
	[1208][7] = 837,
	[1208][8] = 838,
	[1209][56] = 1209,
	[1211][2] = 596,
	[1211][3] = 597,
	[1211][4] = 598,
	[1211][7] = 599,
	[1211][8] = 600,
	[1214][2] = 617,
	[1214][3] = 618,
	[1214][4] = 619,
	[1214][7] = 620,
	[1214][8] = 621,
	[1225][2] = 41,
	[1225][3] = 42,
	[1225][4] = 43,
	[1225][5] = 45,
	[1225][6] = 46,
	[1225][7] = 48,
	[1225][8] = 49,
	[1225][9] = 50,
	[1225][10] = 51,
	[1225][11] = 52,
	[1225][12] = 53,
	[1225][13] = 54,
	[1225][15] = 55,
	[1235][2] = 41,
	[1235][3] = 42,
	[1235][4] = 43,
	[1235][5] = 45,
	[1235][6] = 46,
	[1235][7] = 48,
	[1235][8] = 49,
	[1235][9] = 50,
	[1235][10] = 51,
	[1235][11] = 52,
	[1235][12] = 53,
	[1235][13] = 54,
	[1235][15] = 55,
	[1240][2] = 41,
	[1240][3] = 42,
	[1240][4] = 43,
	[1240][5] = 45,
	[1240][6] = 46,
	[1240][7] = 48,
	[1240][8] = 49,
	[1240][9] = 50,
	[1240][10] = 51,
	[1240][11] = 52,
	[1240][12] = 53,
	[1240][13] = 54,
	[1240][15] = 55,
	[1250][2] = 41,
	[1250][3] = 42,
	[1250][4] = 43,
	[1250][5] = 45,
	[1250][6] = 46,
	[1250][7] = 48,
	[1250][8] = 49,
	[1250][9] = 50,
	[1250][10] = 51,
	[1250][11] = 52,
	[1250][12] = 53,
	[1250][13] = 54,
	[1250][15] = 55,
	[1253][56] = 1253,
	[1255][56] = 1255,
	[1258][2] = 814,
	[1258][3] = 815,
	[1258][4] = 816,
	[1258][5] = 817,
	[1259][38] = 1283,
	[1261][2] = 814,
	[1261][3] = 815,
	[1261][4] = 816,
	[1261][5] = 817,
	[1271][2] = 834,
	[1271][3] = 835,
	[1271][4] = 836,
	[1271][7] = 837,
	[1271][8] = 838,
};


const unsigned zebu_reduces[1286][56] = {
	[2][4] = 1,
	[2][6] = 1,
	[2][8] = 1,
	[2][9] = 1,
	[2][14] = 1,
	[2][16] = 1,
	[2][17] = 1,
	[2][18] = 1,
	[2][19] = 1,
	[2][20] = 1,
	[2][21] = 1,
	[2][22] = 1,
	[2][23] = 1,
	[2][24] = 1,
	[2][25] = 1,
	[2][26] = 1,
	[2][27] = 1,
	[2][28] = 1,
	[2][29] = 1,
	[2][30] = 1,
	[2][31] = 1,
	[2][32] = 1,
	[2][33] = 1,
	[2][34] = 1,
	[2][35] = 1,
	[2][36] = 1,
	[2][37] = 1,
	[3][4] = 2,
	[3][6] = 2,
	[3][8] = 2,
	[3][9] = 2,
	[3][14] = 2,
	[3][16] = 2,
	[3][17] = 2,
	[3][18] = 2,
	[3][19] = 2,
	[3][20] = 2,
	[3][21] = 2,
	[3][22] = 2,
	[3][23] = 2,
	[3][24] = 2,
	[3][25] = 2,
	[3][26] = 2,
	[3][27] = 2,
	[3][28] = 2,
	[3][29] = 2,
	[3][30] = 2,
	[3][31] = 2,
	[3][32] = 2,
	[3][33] = 2,
	[3][34] = 2,
	[3][35] = 2,
	[3][36] = 2,
	[3][37] = 2,
	[7][4] = 3,
	[7][6] = 3,
	[7][8] = 3,
	[7][9] = 3,
	[7][14] = 3,
	[7][16] = 3,
	[7][17] = 3,
	[7][18] = 3,
	[7][19] = 3,
	[7][20] = 3,
	[7][21] = 3,
	[7][22] = 3,
	[7][23] = 3,
	[7][24] = 3,
	[7][25] = 3,
	[7][26] = 3,
	[7][27] = 3,
	[7][28] = 3,
	[7][29] = 3,
	[7][30] = 3,
	[7][31] = 3,
	[7][32] = 3,
	[7][33] = 3,
	[7][34] = 3,
	[7][35] = 3,
	[7][36] = 3,
	[7][37] = 3,
	[10][4] = 4,
	[10][6] = 4,
	[10][8] = 4,
	[10][9] = 4,
	[10][14] = 4,
	[10][16] = 4,
	[10][17] = 4,
	[10][18] = 4,
	[10][19] = 4,
	[10][20] = 4,
	[10][21] = 4,
	[10][22] = 4,
	[10][23] = 4,
	[10][24] = 4,
	[10][25] = 4,
	[10][26] = 4,
	[10][27] = 4,
	[10][28] = 4,
	[10][29] = 4,
	[10][30] = 4,
	[10][31] = 4,
	[10][32] = 4,
	[10][33] = 4,
	[10][34] = 4,
	[10][35] = 4,
	[10][36] = 4,
	[10][37] = 4,
	[11][4] = 5,
	[11][6] = 5,
	[11][8] = 5,
	[11][9] = 5,
	[11][14] = 5,
	[11][16] = 5,
	[11][17] = 5,
	[11][18] = 5,
	[11][19] = 5,
	[11][20] = 5,
	[11][21] = 5,
	[11][22] = 5,
	[11][23] = 5,
	[11][24] = 5,
	[11][25] = 5,
	[11][26] = 5,
	[11][27] = 5,
	[11][28] = 5,
	[11][29] = 5,
	[11][30] = 5,
	[11][31] = 5,
	[11][32] = 5,
	[11][33] = 5,
	[11][34] = 5,
	[11][35] = 5,
	[11][36] = 5,
	[11][37] = 5,
	[16][16] = 6,
	[16][17] = 6,
	[16][18] = 6,
	[16][19] = 6,
	[16][24] = 6,
	[16][25] = 6,
	[16][26] = 6,
	[16][27] = 6,
	[16][28] = 6,
	[16][29] = 6,
	[16][30] = 6,
	[16][31] = 6,
	[16][32] = 6,
	[16][33] = 6,
	[16][34] = 6,
	[16][35] = 6,
	[16][36] = 6,
	[16][37] = 6,
	[17][17] = 7,
	[17][18] = 7,
	[17][19] = 7,
	[17][32] = 7,
	[17][33] = 7,
	[17][34] = 7,
	[17][35] = 7,
	[17][36] = 7,
	[17][37] = 7,
	[18][54] = 8,
	[19][34] = 9,
	[19][35] = 9,
	[19][36] = 9,
	[19][37] = 9,
	[20][16] = 10,
	[20][17] = 10,
	[20][18] = 10,
	[20][19] = 10,
	[20][32] = 10,
	[20][33] = 10,
	[20][34] = 10,
	[20][35] = 10,
	[20][36] = 10,
	[20][37] = 10,
	[21][18] = 11,
	[21][19] = 11,
	[21][32] = 11,
	[21][33] = 11,
	[21][34] = 11,
	[21][35] = 11,
	[21][36] = 11,
	[21][37] = 11,
	[22][6] = 12,
	[22][9] = 12,
	[22][14] = 12,
	[22][16] = 12,
	[22][17] = 12,
	[22][18] = 12,
	[22][19] = 12,
	[22][20] = 12,
	[22][23] = 12,
	[22][24] = 12,
	[22][25] = 12,
	[22][26] = 12,
	[22][27] = 12,
	[22][28] = 12,
	[22][29] = 12,
	[22][30] = 12,
	[22][31] = 12,
	[22][32] = 12,
	[22][33] = 12,
	[22][34] = 12,
	[22][35] = 12,
	[22][36] = 12,
	[22][37] = 12,
	[24][54] = 13,
	[25][37] = 14,
	[26][19] = 15,
	[26][32] = 15,
	[26][33] = 15,
	[26][34] = 15,
	[26][35] = 15,
	[26][36] = 15,
	[26][37] = 15,
	[27][35] = 16,
	[27][36] = 16,
	[27][37] = 16,
	[28][19] = 17,
	[28][33] = 17,
	[28][34] = 17,
	[28][35] = 17,
	[28][36] = 17,
	[28][37] = 17,
	[29][34] = 18,
	[29][35] = 18,
	[29][36] = 18,
	[29][37] = 18,
	[30][6] = 19,
	[30][9] = 19,
	[30][16] = 19,
	[30][17] = 19,
	[30][18] = 19,
	[30][19] = 19,
	[30][24] = 19,
	[30][25] = 19,
	[30][26] = 19,
	[30][27] = 19,
	[30][28] = 19,
	[30][29] = 19,
	[30][30] = 19,
	[30][31] = 19,
	[30][32] = 19,
	[30][33] = 19,
	[30][34] = 19,
	[30][35] = 19,
	[30][36] = 19,
	[30][37] = 19,
	[31][36] = 20,
	[31][37] = 20,
	[32][6] = 21,
	[32][9] = 21,
	[32][14] = 21,
	[32][16] = 21,
	[32][17] = 21,
	[32][18] = 21,
	[32][19] = 21,
	[32][20] = 21,
	[32][22] = 21,
	[32][23] = 21,
	[32][24] = 21,
	[32][25] = 21,
	[32][26] = 21,
	[32][27] = 21,
	[32][28] = 21,
	[32][29] = 21,
	[32][30] = 21,
	[32][31] = 21,
	[32][32] = 21,
	[32][33] = 21,
	[32][34] = 21,
	[32][35] = 21,
	[32][36] = 21,
	[32][37] = 21,
	[33][4] = 22,
	[33][6] = 22,
	[33][8] = 22,
	[33][9] = 22,
	[33][14] = 22,
	[33][16] = 22,
	[33][17] = 22,
	[33][18] = 22,
	[33][19] = 22,
	[33][20] = 22,
	[33][21] = 22,
	[33][22] = 22,
	[33][23] = 22,
	[33][24] = 22,
	[33][25] = 22,
	[33][26] = 22,
	[33][27] = 22,
	[33][28] = 22,
	[33][29] = 22,
	[33][30] = 22,
	[33][31] = 22,
	[33][32] = 22,
	[33][33] = 22,
	[33][34] = 22,
	[33][35] = 22,
	[33][36] = 22,
	[33][37] = 22,
	[34][16] = 23,
	[34][17] = 23,
	[34][18] = 23,
	[34][19] = 23,
	[34][30] = 23,
	[34][31] = 23,
	[34][32] = 23,
	[34][33] = 23,
	[34][34] = 23,
	[34][35] = 23,
	[34][36] = 23,
	[34][37] = 23,
	[35][16] = 24,
	[35][17] = 24,
	[35][18] = 24,
	[35][19] = 24,
	[35][26] = 24,
	[35][27] = 24,
	[35][28] = 24,
	[35][29] = 24,
	[35][30] = 24,
	[35][31] = 24,
	[35][32] = 24,
	[35][33] = 24,
	[35][34] = 24,
	[35][35] = 24,
	[35][36] = 24,
	[35][37] = 24,
	[36][54] = 25,
	[37][54] = 26,
	[38][6] = 27,
	[38][9] = 27,
	[38][14] = 27,
	[38][16] = 27,
	[38][17] = 27,
	[38][18] = 27,
	[38][19] = 27,
	[38][20] = 27,
	[38][22] = 27,
	[38][23] = 27,
	[38][24] = 27,
	[38][25] = 27,
	[38][26] = 27,
	[38][27] = 27,
	[38][28] = 27,
	[38][29] = 27,
	[38][30] = 27,
	[38][31] = 27,
	[38][32] = 27,
	[38][33] = 27,
	[38][34] = 27,
	[38][35] = 27,
	[38][36] = 27,
	[38][37] = 27,
	[39][54] = 28,
	[40][54] = 29,
	[41][4] = 1,
	[41][6] = 1,
	[41][8] = 1,
	[41][9] = 1,
	[41][14] = 1,
	[41][16] = 1,
	[41][17] = 1,
	[41][18] = 1,
	[41][19] = 1,
	[41][20] = 1,
	[41][21] = 1,
	[41][22] = 1,
	[41][23] = 1,
	[41][24] = 1,
	[41][25] = 1,
	[41][26] = 1,
	[41][27] = 1,
	[41][28] = 1,
	[41][29] = 1,
	[41][30] = 1,
	[41][31] = 1,
	[41][32] = 1,
	[41][33] = 1,
	[41][34] = 1,
	[41][35] = 1,
	[41][36] = 1,
	[41][38] = 1,
	[41][39] = 1,
	[42][4] = 2,
	[42][6] = 2,
	[42][8] = 2,
	[42][9] = 2,
	[42][14] = 2,
	[42][16] = 2,
	[42][17] = 2,
	[42][18] = 2,
	[42][19] = 2,
	[42][20] = 2,
	[42][21] = 2,
	[42][22] = 2,
	[42][23] = 2,
	[42][24] = 2,
	[42][25] = 2,
	[42][26] = 2,
	[42][27] = 2,
	[42][28] = 2,
	[42][29] = 2,
	[42][30] = 2,
	[42][31] = 2,
	[42][32] = 2,
	[42][33] = 2,
	[42][34] = 2,
	[42][35] = 2,
	[42][36] = 2,
	[42][38] = 2,
	[42][39] = 2,
	[44][4] = 30,
	[44][6] = 30,
	[44][8] = 30,
	[44][9] = 30,
	[44][14] = 30,
	[44][16] = 30,
	[44][17] = 30,
	[44][18] = 30,
	[44][19] = 30,
	[44][20] = 30,
	[44][21] = 30,
	[44][22] = 30,
	[44][23] = 30,
	[44][24] = 30,
	[44][25] = 30,
	[44][26] = 30,
	[44][27] = 30,
	[44][28] = 30,
	[44][29] = 30,
	[44][30] = 30,
	[44][31] = 30,
	[44][32] = 30,
	[44][33] = 30,
	[44][34] = 30,
	[44][35] = 30,
	[44][36] = 30,
	[44][37] = 30,
	[48][4] = 3,
	[48][6] = 3,
	[48][8] = 3,
	[48][9] = 3,
	[48][14] = 3,
	[48][16] = 3,
	[48][17] = 3,
	[48][18] = 3,
	[48][19] = 3,
	[48][20] = 3,
	[48][21] = 3,
	[48][22] = 3,
	[48][23] = 3,
	[48][24] = 3,
	[48][25] = 3,
	[48][26] = 3,
	[48][27] = 3,
	[48][28] = 3,
	[48][29] = 3,
	[48][30] = 3,
	[48][31] = 3,
	[48][32] = 3,
	[48][33] = 3,
	[48][34] = 3,
	[48][35] = 3,
	[48][36] = 3,
	[48][38] = 3,
	[48][39] = 3,
	[51][4] = 4,
	[51][6] = 4,
	[51][8] = 4,
	[51][9] = 4,
	[51][14] = 4,
	[51][16] = 4,
	[51][17] = 4,
	[51][18] = 4,
	[51][19] = 4,
	[51][20] = 4,
	[51][21] = 4,
	[51][22] = 4,
	[51][23] = 4,
	[51][24] = 4,
	[51][25] = 4,
	[51][26] = 4,
	[51][27] = 4,
	[51][28] = 4,
	[51][29] = 4,
	[51][30] = 4,
	[51][31] = 4,
	[51][32] = 4,
	[51][33] = 4,
	[51][34] = 4,
	[51][35] = 4,
	[51][36] = 4,
	[51][38] = 4,
	[51][39] = 4,
	[52][4] = 5,
	[52][6] = 5,
	[52][8] = 5,
	[52][9] = 5,
	[52][14] = 5,
	[52][16] = 5,
	[52][17] = 5,
	[52][18] = 5,
	[52][19] = 5,
	[52][20] = 5,
	[52][21] = 5,
	[52][22] = 5,
	[52][23] = 5,
	[52][24] = 5,
	[52][25] = 5,
	[52][26] = 5,
	[52][27] = 5,
	[52][28] = 5,
	[52][29] = 5,
	[52][30] = 5,
	[52][31] = 5,
	[52][32] = 5,
	[52][33] = 5,
	[52][34] = 5,
	[52][35] = 5,
	[52][36] = 5,
	[52][38] = 5,
	[52][39] = 5,
	[56][16] = 6,
	[56][17] = 6,
	[56][18] = 6,
	[56][19] = 6,
	[56][24] = 6,
	[56][25] = 6,
	[56][26] = 6,
	[56][27] = 6,
	[56][28] = 6,
	[56][29] = 6,
	[56][30] = 6,
	[56][31] = 6,
	[56][32] = 6,
	[56][33] = 6,
	[56][34] = 6,
	[56][35] = 6,
	[56][36] = 6,
	[56][38] = 6,
	[56][39] = 6,
	[57][17] = 7,
	[57][18] = 7,
	[57][19] = 7,
	[57][32] = 7,
	[57][33] = 7,
	[57][34] = 7,
	[57][35] = 7,
	[57][36] = 7,
	[57][38] = 7,
	[57][39] = 7,
	[58][34] = 9,
	[58][35] = 9,
	[58][36] = 9,
	[58][38] = 9,
	[58][39] = 9,
	[59][16] = 10,
	[59][17] = 10,
	[59][18] = 10,
	[59][19] = 10,
	[59][32] = 10,
	[59][33] = 10,
	[59][34] = 10,
	[59][35] = 10,
	[59][36] = 10,
	[59][38] = 10,
	[59][39] = 10,
	[60][18] = 11,
	[60][19] = 11,
	[60][32] = 11,
	[60][33] = 11,
	[60][34] = 11,
	[60][35] = 11,
	[60][36] = 11,
	[60][38] = 11,
	[60][39] = 11,
	[61][6] = 12,
	[61][9] = 12,
	[61][14] = 12,
	[61][16] = 12,
	[61][17] = 12,
	[61][18] = 12,
	[61][19] = 12,
	[61][20] = 12,
	[61][23] = 12,
	[61][24] = 12,
	[61][25] = 12,
	[61][26] = 12,
	[61][27] = 12,
	[61][28] = 12,
	[61][29] = 12,
	[61][30] = 12,
	[61][31] = 12,
	[61][32] = 12,
	[61][33] = 12,
	[61][34] = 12,
	[61][35] = 12,
	[61][36] = 12,
	[61][38] = 12,
	[61][39] = 12,
	[63][38] = 14,
	[63][39] = 14,
	[64][19] = 15,
	[64][32] = 15,
	[64][33] = 15,
	[64][34] = 15,
	[64][35] = 15,
	[64][36] = 15,
	[64][38] = 15,
	[64][39] = 15,
	[65][35] = 16,
	[65][36] = 16,
	[65][38] = 16,
	[65][39] = 16,
	[66][19] = 17,
	[66][33] = 17,
	[66][34] = 17,
	[66][35] = 17,
	[66][36] = 17,
	[66][38] = 17,
	[66][39] = 17,
	[67][34] = 18,
	[67][35] = 18,
	[67][36] = 18,
	[67][38] = 18,
	[67][39] = 18,
	[68][6] = 19,
	[68][9] = 19,
	[68][16] = 19,
	[68][17] = 19,
	[68][18] = 19,
	[68][19] = 19,
	[68][24] = 19,
	[68][25] = 19,
	[68][26] = 19,
	[68][27] = 19,
	[68][28] = 19,
	[68][29] = 19,
	[68][30] = 19,
	[68][31] = 19,
	[68][32] = 19,
	[68][33] = 19,
	[68][34] = 19,
	[68][35] = 19,
	[68][36] = 19,
	[68][38] = 19,
	[68][39] = 19,
	[69][36] = 20,
	[69][38] = 20,
	[69][39] = 20,
	[70][6] = 21,
	[70][9] = 21,
	[70][14] = 21,
	[70][16] = 21,
	[70][17] = 21,
	[70][18] = 21,
	[70][19] = 21,
	[70][20] = 21,
	[70][22] = 21,
	[70][23] = 21,
	[70][24] = 21,
	[70][25] = 21,
	[70][26] = 21,
	[70][27] = 21,
	[70][28] = 21,
	[70][29] = 21,
	[70][30] = 21,
	[70][31] = 21,
	[70][32] = 21,
	[70][33] = 21,
	[70][34] = 21,
	[70][35] = 21,
	[70][36] = 21,
	[70][38] = 21,
	[70][39] = 21,
	[71][4] = 22,
	[71][6] = 22,
	[71][8] = 22,
	[71][9] = 22,
	[71][14] = 22,
	[71][16] = 22,
	[71][17] = 22,
	[71][18] = 22,
	[71][19] = 22,
	[71][20] = 22,
	[71][21] = 22,
	[71][22] = 22,
	[71][23] = 22,
	[71][24] = 22,
	[71][25] = 22,
	[71][26] = 22,
	[71][27] = 22,
	[71][28] = 22,
	[71][29] = 22,
	[71][30] = 22,
	[71][31] = 22,
	[71][32] = 22,
	[71][33] = 22,
	[71][34] = 22,
	[71][35] = 22,
	[71][36] = 22,
	[71][38] = 22,
	[71][39] = 22,
	[72][16] = 23,
	[72][17] = 23,
	[72][18] = 23,
	[72][19] = 23,
	[72][30] = 23,
	[72][31] = 23,
	[72][32] = 23,
	[72][33] = 23,
	[72][34] = 23,
	[72][35] = 23,
	[72][36] = 23,
	[72][38] = 23,
	[72][39] = 23,
	[73][16] = 24,
	[73][17] = 24,
	[73][18] = 24,
	[73][19] = 24,
	[73][26] = 24,
	[73][27] = 24,
	[73][28] = 24,
	[73][29] = 24,
	[73][30] = 24,
	[73][31] = 24,
	[73][32] = 24,
	[73][33] = 24,
	[73][34] = 24,
	[73][35] = 24,
	[73][36] = 24,
	[73][38] = 24,
	[73][39] = 24,
	[74][6] = 27,
	[74][9] = 27,
	[74][14] = 27,
	[74][16] = 27,
	[74][17] = 27,
	[74][18] = 27,
	[74][19] = 27,
	[74][20] = 27,
	[74][22] = 27,
	[74][23] = 27,
	[74][24] = 27,
	[74][25] = 27,
	[74][26] = 27,
	[74][27] = 27,
	[74][28] = 27,
	[74][29] = 27,
	[74][30] = 27,
	[74][31] = 27,
	[74][32] = 27,
	[74][33] = 27,
	[74][34] = 27,
	[74][35] = 27,
	[74][36] = 27,
	[74][38] = 27,
	[74][39] = 27,
	[75][4] = 5,
	[75][6] = 5,
	[75][8] = 5,
	[75][9] = 5,
	[75][14] = 5,
	[75][16] = 5,
	[75][17] = 5,
	[75][18] = 5,
	[75][19] = 5,
	[75][20] = 5,
	[75][21] = 5,
	[75][22] = 5,
	[75][23] = 5,
	[75][24] = 5,
	[75][25] = 5,
	[75][26] = 5,
	[75][27] = 5,
	[75][28] = 5,
	[75][29] = 5,
	[75][30] = 5,
	[75][31] = 5,
	[75][32] = 5,
	[75][33] = 5,
	[75][34] = 5,
	[75][35] = 5,
	[75][36] = 5,
	[75][37] = 5,
	[76][6] = 31,
	[76][9] = 31,
	[76][14] = 31,
	[76][16] = 31,
	[76][17] = 31,
	[76][18] = 31,
	[76][19] = 31,
	[76][20] = 31,
	[76][22] = 31,
	[76][23] = 31,
	[76][24] = 31,
	[76][25] = 31,
	[76][26] = 31,
	[76][27] = 31,
	[76][28] = 31,
	[76][29] = 31,
	[76][30] = 31,
	[76][31] = 31,
	[76][32] = 31,
	[76][33] = 31,
	[76][34] = 31,
	[76][35] = 31,
	[76][36] = 31,
	[76][37] = 31,
	[77][6] = 32,
	[77][9] = 32,
	[77][14] = 32,
	[77][16] = 32,
	[77][17] = 32,
	[77][18] = 32,
	[77][19] = 32,
	[77][20] = 32,
	[77][22] = 32,
	[77][23] = 32,
	[77][24] = 32,
	[77][25] = 32,
	[77][26] = 32,
	[77][27] = 32,
	[77][28] = 32,
	[77][29] = 32,
	[77][30] = 32,
	[77][31] = 32,
	[77][32] = 32,
	[77][33] = 32,
	[77][34] = 32,
	[77][35] = 32,
	[77][36] = 32,
	[77][37] = 32,
	[78][4] = 1,
	[78][6] = 1,
	[78][8] = 1,
	[78][9] = 1,
	[78][14] = 1,
	[78][16] = 1,
	[78][17] = 1,
	[78][18] = 1,
	[78][19] = 1,
	[78][20] = 1,
	[78][21] = 1,
	[78][22] = 1,
	[78][23] = 1,
	[78][24] = 1,
	[78][25] = 1,
	[78][26] = 1,
	[78][27] = 1,
	[78][28] = 1,
	[78][29] = 1,
	[78][30] = 1,
	[78][31] = 1,
	[78][32] = 1,
	[78][33] = 1,
	[78][34] = 1,
	[78][35] = 1,
	[78][36] = 1,
	[78][39] = 1,
	[78][40] = 1,
	[79][4] = 2,
	[79][6] = 2,
	[79][8] = 2,
	[79][9] = 2,
	[79][14] = 2,
	[79][16] = 2,
	[79][17] = 2,
	[79][18] = 2,
	[79][19] = 2,
	[79][20] = 2,
	[79][21] = 2,
	[79][22] = 2,
	[79][23] = 2,
	[79][24] = 2,
	[79][25] = 2,
	[79][26] = 2,
	[79][27] = 2,
	[79][28] = 2,
	[79][29] = 2,
	[79][30] = 2,
	[79][31] = 2,
	[79][32] = 2,
	[79][33] = 2,
	[79][34] = 2,
	[79][35] = 2,
	[79][36] = 2,
	[79][39] = 2,
	[79][40] = 2,
	[84][4] = 3,
	[84][6] = 3,
	[84][8] = 3,
	[84][9] = 3,
	[84][14] = 3,
	[84][16] = 3,
	[84][17] = 3,
	[84][18] = 3,
	[84][19] = 3,
	[84][20] = 3,
	[84][21] = 3,
	[84][22] = 3,
	[84][23] = 3,
	[84][24] = 3,
	[84][25] = 3,
	[84][26] = 3,
	[84][27] = 3,
	[84][28] = 3,
	[84][29] = 3,
	[84][30] = 3,
	[84][31] = 3,
	[84][32] = 3,
	[84][33] = 3,
	[84][34] = 3,
	[84][35] = 3,
	[84][36] = 3,
	[84][39] = 3,
	[84][40] = 3,
	[86][4] = 33,
	[86][6] = 33,
	[86][8] = 33,
	[86][9] = 33,
	[86][14] = 33,
	[86][16] = 33,
	[86][17] = 33,
	[86][18] = 33,
	[86][19] = 33,
	[86][20] = 33,
	[86][21] = 33,
	[86][22] = 33,
	[86][23] = 33,
	[86][24] = 33,
	[86][25] = 33,
	[86][26] = 33,
	[86][27] = 33,
	[86][28] = 33,
	[86][29] = 33,
	[86][30] = 33,
	[86][31] = 33,
	[86][32] = 33,
	[86][33] = 33,
	[86][34] = 33,
	[86][35] = 33,
	[86][36] = 33,
	[86][37] = 33,
	[88][4] = 4,
	[88][6] = 4,
	[88][8] = 4,
	[88][9] = 4,
	[88][14] = 4,
	[88][16] = 4,
	[88][17] = 4,
	[88][18] = 4,
	[88][19] = 4,
	[88][20] = 4,
	[88][21] = 4,
	[88][22] = 4,
	[88][23] = 4,
	[88][24] = 4,
	[88][25] = 4,
	[88][26] = 4,
	[88][27] = 4,
	[88][28] = 4,
	[88][29] = 4,
	[88][30] = 4,
	[88][31] = 4,
	[88][32] = 4,
	[88][33] = 4,
	[88][34] = 4,
	[88][35] = 4,
	[88][36] = 4,
	[88][39] = 4,
	[88][40] = 4,
	[89][4] = 5,
	[89][6] = 5,
	[89][8] = 5,
	[89][9] = 5,
	[89][14] = 5,
	[89][16] = 5,
	[89][17] = 5,
	[89][18] = 5,
	[89][19] = 5,
	[89][20] = 5,
	[89][21] = 5,
	[89][22] = 5,
	[89][23] = 5,
	[89][24] = 5,
	[89][25] = 5,
	[89][26] = 5,
	[89][27] = 5,
	[89][28] = 5,
	[89][29] = 5,
	[89][30] = 5,
	[89][31] = 5,
	[89][32] = 5,
	[89][33] = 5,
	[89][34] = 5,
	[89][35] = 5,
	[89][36] = 5,
	[89][39] = 5,
	[89][40] = 5,
	[93][16] = 6,
	[93][17] = 6,
	[93][18] = 6,
	[93][19] = 6,
	[93][24] = 6,
	[93][25] = 6,
	[93][26] = 6,
	[93][27] = 6,
	[93][28] = 6,
	[93][29] = 6,
	[93][30] = 6,
	[93][31] = 6,
	[93][32] = 6,
	[93][33] = 6,
	[93][34] = 6,
	[93][35] = 6,
	[93][36] = 6,
	[93][39] = 6,
	[93][40] = 6,
	[94][17] = 7,
	[94][18] = 7,
	[94][19] = 7,
	[94][32] = 7,
	[94][33] = 7,
	[94][34] = 7,
	[94][35] = 7,
	[94][36] = 7,
	[94][39] = 7,
	[94][40] = 7,
	[95][34] = 9,
	[95][35] = 9,
	[95][36] = 9,
	[95][39] = 9,
	[95][40] = 9,
	[96][16] = 10,
	[96][17] = 10,
	[96][18] = 10,
	[96][19] = 10,
	[96][32] = 10,
	[96][33] = 10,
	[96][34] = 10,
	[96][35] = 10,
	[96][36] = 10,
	[96][39] = 10,
	[96][40] = 10,
	[97][18] = 11,
	[97][19] = 11,
	[97][32] = 11,
	[97][33] = 11,
	[97][34] = 11,
	[97][35] = 11,
	[97][36] = 11,
	[97][39] = 11,
	[97][40] = 11,
	[98][6] = 12,
	[98][9] = 12,
	[98][14] = 12,
	[98][16] = 12,
	[98][17] = 12,
	[98][18] = 12,
	[98][19] = 12,
	[98][20] = 12,
	[98][23] = 12,
	[98][24] = 12,
	[98][25] = 12,
	[98][26] = 12,
	[98][27] = 12,
	[98][28] = 12,
	[98][29] = 12,
	[98][30] = 12,
	[98][31] = 12,
	[98][32] = 12,
	[98][33] = 12,
	[98][34] = 12,
	[98][35] = 12,
	[98][36] = 12,
	[98][39] = 12,
	[98][40] = 12,
	[100][39] = 14,
	[100][40] = 14,
	[101][19] = 15,
	[101][32] = 15,
	[101][33] = 15,
	[101][34] = 15,
	[101][35] = 15,
	[101][36] = 15,
	[101][39] = 15,
	[101][40] = 15,
	[102][35] = 16,
	[102][36] = 16,
	[102][39] = 16,
	[102][40] = 16,
	[103][19] = 17,
	[103][33] = 17,
	[103][34] = 17,
	[103][35] = 17,
	[103][36] = 17,
	[103][39] = 17,
	[103][40] = 17,
	[104][34] = 18,
	[104][35] = 18,
	[104][36] = 18,
	[104][39] = 18,
	[104][40] = 18,
	[105][6] = 19,
	[105][9] = 19,
	[105][16] = 19,
	[105][17] = 19,
	[105][18] = 19,
	[105][19] = 19,
	[105][24] = 19,
	[105][25] = 19,
	[105][26] = 19,
	[105][27] = 19,
	[105][28] = 19,
	[105][29] = 19,
	[105][30] = 19,
	[105][31] = 19,
	[105][32] = 19,
	[105][33] = 19,
	[105][34] = 19,
	[105][35] = 19,
	[105][36] = 19,
	[105][39] = 19,
	[105][40] = 19,
	[106][36] = 20,
	[106][39] = 20,
	[106][40] = 20,
	[107][6] = 21,
	[107][9] = 21,
	[107][14] = 21,
	[107][16] = 21,
	[107][17] = 21,
	[107][18] = 21,
	[107][19] = 21,
	[107][20] = 21,
	[107][22] = 21,
	[107][23] = 21,
	[107][24] = 21,
	[107][25] = 21,
	[107][26] = 21,
	[107][27] = 21,
	[107][28] = 21,
	[107][29] = 21,
	[107][30] = 21,
	[107][31] = 21,
	[107][32] = 21,
	[107][33] = 21,
	[107][34] = 21,
	[107][35] = 21,
	[107][36] = 21,
	[107][39] = 21,
	[107][40] = 21,
	[108][4] = 22,
	[108][6] = 22,
	[108][8] = 22,
	[108][9] = 22,
	[108][14] = 22,
	[108][16] = 22,
	[108][17] = 22,
	[108][18] = 22,
	[108][19] = 22,
	[108][20] = 22,
	[108][21] = 22,
	[108][22] = 22,
	[108][23] = 22,
	[108][24] = 22,
	[108][25] = 22,
	[108][26] = 22,
	[108][27] = 22,
	[108][28] = 22,
	[108][29] = 22,
	[108][30] = 22,
	[108][31] = 22,
	[108][32] = 22,
	[108][33] = 22,
	[108][34] = 22,
	[108][35] = 22,
	[108][36] = 22,
	[108][39] = 22,
	[108][40] = 22,
	[109][16] = 23,
	[109][17] = 23,
	[109][18] = 23,
	[109][19] = 23,
	[109][30] = 23,
	[109][31] = 23,
	[109][32] = 23,
	[109][33] = 23,
	[109][34] = 23,
	[109][35] = 23,
	[109][36] = 23,
	[109][39] = 23,
	[109][40] = 23,
	[110][16] = 24,
	[110][17] = 24,
	[110][18] = 24,
	[110][19] = 24,
	[110][26] = 24,
	[110][27] = 24,
	[110][28] = 24,
	[110][29] = 24,
	[110][30] = 24,
	[110][31] = 24,
	[110][32] = 24,
	[110][33] = 24,
	[110][34] = 24,
	[110][35] = 24,
	[110][36] = 24,
	[110][39] = 24,
	[110][40] = 24,
	[111][6] = 27,
	[111][9] = 27,
	[111][14] = 27,
	[111][16] = 27,
	[111][17] = 27,
	[111][18] = 27,
	[111][19] = 27,
	[111][20] = 27,
	[111][22] = 27,
	[111][23] = 27,
	[111][24] = 27,
	[111][25] = 27,
	[111][26] = 27,
	[111][27] = 27,
	[111][28] = 27,
	[111][29] = 27,
	[111][30] = 27,
	[111][31] = 27,
	[111][32] = 27,
	[111][33] = 27,
	[111][34] = 27,
	[111][35] = 27,
	[111][36] = 27,
	[111][39] = 27,
	[111][40] = 27,
	[112][6] = 34,
	[112][9] = 34,
	[112][14] = 34,
	[112][16] = 34,
	[112][17] = 34,
	[112][18] = 34,
	[112][19] = 34,
	[112][20] = 34,
	[112][22] = 34,
	[112][23] = 34,
	[112][24] = 34,
	[112][25] = 34,
	[112][26] = 34,
	[112][27] = 34,
	[112][28] = 34,
	[112][29] = 34,
	[112][30] = 34,
	[112][31] = 34,
	[112][32] = 34,
	[112][33] = 34,
	[112][34] = 34,
	[112][35] = 34,
	[112][36] = 34,
	[112][37] = 34,
	[116][6] = 35,
	[116][9] = 35,
	[116][14] = 35,
	[116][16] = 35,
	[116][17] = 35,
	[116][18] = 35,
	[116][19] = 35,
	[116][20] = 35,
	[116][22] = 35,
	[116][23] = 35,
	[116][24] = 35,
	[116][25] = 35,
	[116][26] = 35,
	[116][27] = 35,
	[116][28] = 35,
	[116][29] = 35,
	[116][30] = 35,
	[116][31] = 35,
	[116][32] = 35,
	[116][33] = 35,
	[116][34] = 35,
	[116][35] = 35,
	[116][36] = 35,
	[116][37] = 35,
	[126][11] = 36,
	[126][55] = 36,
	[128][11] = 37,
	[128][55] = 37,
	[129][11] = 38,
	[129][55] = 38,
	[130][11] = 39,
	[130][55] = 39,
	[131][11] = 40,
	[131][55] = 40,
	[133][11] = 41,
	[138][54] = 42,
	[139][54] = 43,
	[140][54] = 44,
	[141][54] = 45,
	[142][54] = 46,
	[143][54] = 47,
	[144][54] = 48,
	[149][2] = 49,
	[149][3] = 49,
	[149][4] = 49,
	[149][5] = 49,
	[149][6] = 49,
	[149][7] = 49,
	[149][8] = 49,
	[149][9] = 49,
	[149][10] = 49,
	[149][11] = 49,
	[149][12] = 49,
	[149][13] = 49,
	[149][14] = 49,
	[149][15] = 49,
	[149][54] = 49,
	[150][2] = 50,
	[150][3] = 50,
	[150][4] = 50,
	[150][5] = 50,
	[150][6] = 50,
	[150][7] = 50,
	[150][8] = 50,
	[150][9] = 50,
	[150][10] = 50,
	[150][11] = 50,
	[150][12] = 50,
	[150][13] = 50,
	[150][14] = 50,
	[150][15] = 50,
	[150][54] = 50,
	[151][54] = 51,
	[152][54] = 52,
	[153][54] = 53,
	[154][54] = 54,
	[155][54] = 55,
	[156][54] = 56,
	[157][54] = 57,
	[177][54] = 58,
	[178][54] = 59,
	[179][54] = 60,
	[180][54] = 61,
	[181][54] = 62,
	[182][54] = 63,
	[183][54] = 64,
	[184][54] = 65,
	[185][54] = 66,
	[186][54] = 67,
	[187][54] = 68,
	[188][54] = 69,
	[189][54] = 70,
	[190][54] = 71,
	[191][54] = 72,
	[192][54] = 73,
	[193][54] = 74,
	[194][54] = 75,
	[195][54] = 76,
	[196][54] = 77,
	[197][54] = 78,
	[198][54] = 79,
	[199][54] = 80,
	[200][54] = 81,
	[201][54] = 82,
	[202][54] = 83,
	[203][54] = 84,
	[204][54] = 85,
	[205][4] = 30,
	[205][6] = 30,
	[205][8] = 30,
	[205][9] = 30,
	[205][14] = 30,
	[205][16] = 30,
	[205][17] = 30,
	[205][18] = 30,
	[205][19] = 30,
	[205][20] = 30,
	[205][21] = 30,
	[205][22] = 30,
	[205][23] = 30,
	[205][24] = 30,
	[205][25] = 30,
	[205][26] = 30,
	[205][27] = 30,
	[205][28] = 30,
	[205][29] = 30,
	[205][30] = 30,
	[205][31] = 30,
	[205][32] = 30,
	[205][33] = 30,
	[205][34] = 30,
	[205][35] = 30,
	[205][36] = 30,
	[205][38] = 30,
	[205][39] = 30,
	[208][6] = 31,
	[208][9] = 31,
	[208][14] = 31,
	[208][16] = 31,
	[208][17] = 31,
	[208][18] = 31,
	[208][19] = 31,
	[208][20] = 31,
	[208][22] = 31,
	[208][23] = 31,
	[208][24] = 31,
	[208][25] = 31,
	[208][26] = 31,
	[208][27] = 31,
	[208][28] = 31,
	[208][29] = 31,
	[208][30] = 31,
	[208][31] = 31,
	[208][32] = 31,
	[208][33] = 31,
	[208][34] = 31,
	[208][35] = 31,
	[208][36] = 31,
	[208][38] = 31,
	[208][39] = 31,
	[209][6] = 32,
	[209][9] = 32,
	[209][14] = 32,
	[209][16] = 32,
	[209][17] = 32,
	[209][18] = 32,
	[209][19] = 32,
	[209][20] = 32,
	[209][22] = 32,
	[209][23] = 32,
	[209][24] = 32,
	[209][25] = 32,
	[209][26] = 32,
	[209][27] = 32,
	[209][28] = 32,
	[209][29] = 32,
	[209][30] = 32,
	[209][31] = 32,
	[209][32] = 32,
	[209][33] = 32,
	[209][34] = 32,
	[209][35] = 32,
	[209][36] = 32,
	[209][38] = 32,
	[209][39] = 32,
	[210][4] = 86,
	[210][6] = 86,
	[210][8] = 86,
	[210][9] = 86,
	[210][14] = 86,
	[210][16] = 86,
	[210][17] = 86,
	[210][18] = 86,
	[210][19] = 86,
	[210][20] = 86,
	[210][21] = 86,
	[210][22] = 86,
	[210][23] = 86,
	[210][24] = 86,
	[210][25] = 86,
	[210][26] = 86,
	[210][27] = 86,
	[210][28] = 86,
	[210][29] = 86,
	[210][30] = 86,
	[210][31] = 86,
	[210][32] = 86,
	[210][33] = 86,
	[210][34] = 86,
	[210][35] = 86,
	[210][36] = 86,
	[210][37] = 86,
	[213][4] = 33,
	[213][6] = 33,
	[213][8] = 33,
	[213][9] = 33,
	[213][14] = 33,
	[213][16] = 33,
	[213][17] = 33,
	[213][18] = 33,
	[213][19] = 33,
	[213][20] = 33,
	[213][21] = 33,
	[213][22] = 33,
	[213][23] = 33,
	[213][24] = 33,
	[213][25] = 33,
	[213][26] = 33,
	[213][27] = 33,
	[213][28] = 33,
	[213][29] = 33,
	[213][30] = 33,
	[213][31] = 33,
	[213][32] = 33,
	[213][33] = 33,
	[213][34] = 33,
	[213][35] = 33,
	[213][36] = 33,
	[213][38] = 33,
	[213][39] = 33,
	[215][6] = 34,
	[215][9] = 34,
	[215][14] = 34,
	[215][16] = 34,
	[215][17] = 34,
	[215][18] = 34,
	[215][19] = 34,
	[215][20] = 34,
	[215][22] = 34,
	[215][23] = 34,
	[215][24] = 34,
	[215][25] = 34,
	[215][26] = 34,
	[215][27] = 34,
	[215][28] = 34,
	[215][29] = 34,
	[215][30] = 34,
	[215][31] = 34,
	[215][32] = 34,
	[215][33] = 34,
	[215][34] = 34,
	[215][35] = 34,
	[215][36] = 34,
	[215][38] = 34,
	[215][39] = 34,
	[217][6] = 35,
	[217][9] = 35,
	[217][14] = 35,
	[217][16] = 35,
	[217][17] = 35,
	[217][18] = 35,
	[217][19] = 35,
	[217][20] = 35,
	[217][22] = 35,
	[217][23] = 35,
	[217][24] = 35,
	[217][25] = 35,
	[217][26] = 35,
	[217][27] = 35,
	[217][28] = 35,
	[217][29] = 35,
	[217][30] = 35,
	[217][31] = 35,
	[217][32] = 35,
	[217][33] = 35,
	[217][34] = 35,
	[217][35] = 35,
	[217][36] = 35,
	[217][38] = 35,
	[217][39] = 35,
	[228][4] = 87,
	[228][6] = 87,
	[228][8] = 87,
	[228][9] = 87,
	[228][14] = 87,
	[228][16] = 87,
	[228][17] = 87,
	[228][18] = 87,
	[228][19] = 87,
	[228][20] = 87,
	[228][21] = 87,
	[228][22] = 87,
	[228][23] = 87,
	[228][24] = 87,
	[228][25] = 87,
	[228][26] = 87,
	[228][27] = 87,
	[228][28] = 87,
	[228][29] = 87,
	[228][30] = 87,
	[228][31] = 87,
	[228][32] = 87,
	[228][33] = 87,
	[228][34] = 87,
	[228][35] = 87,
	[228][36] = 87,
	[228][37] = 87,
	[249][4] = 30,
	[249][6] = 30,
	[249][8] = 30,
	[249][9] = 30,
	[249][14] = 30,
	[249][16] = 30,
	[249][17] = 30,
	[249][18] = 30,
	[249][19] = 30,
	[249][20] = 30,
	[249][21] = 30,
	[249][22] = 30,
	[249][23] = 30,
	[249][24] = 30,
	[249][25] = 30,
	[249][26] = 30,
	[249][27] = 30,
	[249][28] = 30,
	[249][29] = 30,
	[249][30] = 30,
	[249][31] = 30,
	[249][32] = 30,
	[249][33] = 30,
	[249][34] = 30,
	[249][35] = 30,
	[249][36] = 30,
	[249][39] = 30,
	[249][40] = 30,
	[252][6] = 31,
	[252][9] = 31,
	[252][14] = 31,
	[252][16] = 31,
	[252][17] = 31,
	[252][18] = 31,
	[252][19] = 31,
	[252][20] = 31,
	[252][22] = 31,
	[252][23] = 31,
	[252][24] = 31,
	[252][25] = 31,
	[252][26] = 31,
	[252][27] = 31,
	[252][28] = 31,
	[252][29] = 31,
	[252][30] = 31,
	[252][31] = 31,
	[252][32] = 31,
	[252][33] = 31,
	[252][34] = 31,
	[252][35] = 31,
	[252][36] = 31,
	[252][39] = 31,
	[252][40] = 31,
	[253][6] = 32,
	[253][9] = 32,
	[253][14] = 32,
	[253][16] = 32,
	[253][17] = 32,
	[253][18] = 32,
	[253][19] = 32,
	[253][20] = 32,
	[253][22] = 32,
	[253][23] = 32,
	[253][24] = 32,
	[253][25] = 32,
	[253][26] = 32,
	[253][27] = 32,
	[253][28] = 32,
	[253][29] = 32,
	[253][30] = 32,
	[253][31] = 32,
	[253][32] = 32,
	[253][33] = 32,
	[253][34] = 32,
	[253][35] = 32,
	[253][36] = 32,
	[253][39] = 32,
	[253][40] = 32,
	[254][4] = 88,
	[254][6] = 88,
	[254][8] = 88,
	[254][9] = 88,
	[254][14] = 88,
	[254][16] = 88,
	[254][17] = 88,
	[254][18] = 88,
	[254][19] = 88,
	[254][20] = 88,
	[254][21] = 88,
	[254][22] = 88,
	[254][23] = 88,
	[254][24] = 88,
	[254][25] = 88,
	[254][26] = 88,
	[254][27] = 88,
	[254][28] = 88,
	[254][29] = 88,
	[254][30] = 88,
	[254][31] = 88,
	[254][32] = 88,
	[254][33] = 88,
	[254][34] = 88,
	[254][35] = 88,
	[254][36] = 88,
	[254][37] = 88,
	[257][4] = 33,
	[257][6] = 33,
	[257][8] = 33,
	[257][9] = 33,
	[257][14] = 33,
	[257][16] = 33,
	[257][17] = 33,
	[257][18] = 33,
	[257][19] = 33,
	[257][20] = 33,
	[257][21] = 33,
	[257][22] = 33,
	[257][23] = 33,
	[257][24] = 33,
	[257][25] = 33,
	[257][26] = 33,
	[257][27] = 33,
	[257][28] = 33,
	[257][29] = 33,
	[257][30] = 33,
	[257][31] = 33,
	[257][32] = 33,
	[257][33] = 33,
	[257][34] = 33,
	[257][35] = 33,
	[257][36] = 33,
	[257][39] = 33,
	[257][40] = 33,
	[259][6] = 34,
	[259][9] = 34,
	[259][14] = 34,
	[259][16] = 34,
	[259][17] = 34,
	[259][18] = 34,
	[259][19] = 34,
	[259][20] = 34,
	[259][22] = 34,
	[259][23] = 34,
	[259][24] = 34,
	[259][25] = 34,
	[259][26] = 34,
	[259][27] = 34,
	[259][28] = 34,
	[259][29] = 34,
	[259][30] = 34,
	[259][31] = 34,
	[259][32] = 34,
	[259][33] = 34,
	[259][34] = 34,
	[259][35] = 34,
	[259][36] = 34,
	[259][39] = 34,
	[259][40] = 34,
	[261][6] = 35,
	[261][9] = 35,
	[261][14] = 35,
	[261][16] = 35,
	[261][17] = 35,
	[261][18] = 35,
	[261][19] = 35,
	[261][20] = 35,
	[261][22] = 35,
	[261][23] = 35,
	[261][24] = 35,
	[261][25] = 35,
	[261][26] = 35,
	[261][27] = 35,
	[261][28] = 35,
	[261][29] = 35,
	[261][30] = 35,
	[261][31] = 35,
	[261][32] = 35,
	[261][33] = 35,
	[261][34] = 35,
	[261][35] = 35,
	[261][36] = 35,
	[261][39] = 35,
	[261][40] = 35,
	[273][4] = 89,
	[273][6] = 89,
	[273][8] = 89,
	[273][9] = 89,
	[273][14] = 89,
	[273][16] = 89,
	[273][17] = 89,
	[273][18] = 89,
	[273][19] = 89,
	[273][20] = 89,
	[273][21] = 89,
	[273][22] = 89,
	[273][23] = 89,
	[273][24] = 89,
	[273][25] = 89,
	[273][26] = 89,
	[273][27] = 89,
	[273][28] = 89,
	[273][29] = 89,
	[273][30] = 89,
	[273][31] = 89,
	[273][32] = 89,
	[273][33] = 89,
	[273][34] = 89,
	[273][35] = 89,
	[273][36] = 89,
	[273][37] = 89,
	[293][2] = 90,
	[293][3] = 90,
	[293][4] = 90,
	[293][7] = 90,
	[293][8] = 90,
	[293][9] = 90,
	[293][11] = 90,
	[293][18] = 90,
	[293][19] = 90,
	[293][20] = 90,
	[293][23] = 90,
	[293][37] = 90,
	[294][2] = 91,
	[294][3] = 91,
	[294][4] = 91,
	[294][7] = 91,
	[294][8] = 91,
	[294][9] = 91,
	[294][11] = 91,
	[294][18] = 91,
	[294][19] = 91,
	[294][20] = 91,
	[294][23] = 91,
	[294][37] = 91,
	[296][2] = 92,
	[296][3] = 92,
	[296][4] = 92,
	[296][7] = 92,
	[296][8] = 92,
	[296][9] = 92,
	[296][11] = 92,
	[296][18] = 92,
	[296][19] = 92,
	[296][20] = 92,
	[296][23] = 92,
	[296][37] = 92,
	[298][2] = 93,
	[298][3] = 93,
	[298][4] = 93,
	[298][7] = 93,
	[298][8] = 93,
	[298][9] = 93,
	[298][11] = 93,
	[298][18] = 93,
	[298][19] = 93,
	[298][20] = 93,
	[298][23] = 93,
	[298][37] = 93,
	[301][2] = 94,
	[301][3] = 94,
	[301][4] = 94,
	[301][7] = 94,
	[301][8] = 94,
	[301][11] = 94,
	[301][18] = 94,
	[301][23] = 94,
	[301][37] = 94,
	[302][37] = 95,
	[303][18] = 96,
	[303][37] = 96,
	[305][4] = 97,
	[305][6] = 97,
	[305][8] = 97,
	[305][9] = 97,
	[305][14] = 97,
	[305][16] = 97,
	[305][17] = 97,
	[305][18] = 97,
	[305][19] = 97,
	[305][20] = 97,
	[305][21] = 97,
	[305][22] = 97,
	[305][23] = 97,
	[305][24] = 97,
	[305][25] = 97,
	[305][26] = 97,
	[305][27] = 97,
	[305][28] = 97,
	[305][29] = 97,
	[305][30] = 97,
	[305][31] = 97,
	[305][32] = 97,
	[305][33] = 97,
	[305][34] = 97,
	[305][35] = 97,
	[305][36] = 97,
	[305][37] = 97,
	[316][11] = 98,
	[316][55] = 98,
	[318][38] = 36,
	[318][39] = 36,
	[318][55] = 36,
	[319][38] = 37,
	[319][39] = 37,
	[319][55] = 37,
	[320][38] = 38,
	[320][39] = 38,
	[320][55] = 38,
	[321][38] = 39,
	[321][39] = 39,
	[321][55] = 39,
	[322][38] = 40,
	[322][39] = 40,
	[322][55] = 40,
	[324][38] = 41,
	[324][39] = 41,
	[326][11] = 36,
	[326][39] = 99,
	[326][41] = 99,
	[326][55] = 36,
	[327][34] = 100,
	[327][35] = 100,
	[327][36] = 100,
	[327][37] = 100,
	[330][34] = 101,
	[330][35] = 101,
	[330][36] = 101,
	[330][37] = 101,
	[331][34] = 102,
	[331][35] = 102,
	[331][36] = 102,
	[331][37] = 102,
	[334][39] = 36,
	[334][41] = 36,
	[334][55] = 36,
	[336][39] = 37,
	[336][41] = 37,
	[336][55] = 37,
	[337][39] = 38,
	[337][41] = 38,
	[337][55] = 38,
	[338][39] = 39,
	[338][41] = 39,
	[338][55] = 39,
	[339][39] = 40,
	[339][41] = 40,
	[339][55] = 40,
	[341][39] = 41,
	[341][41] = 41,
	[343][11] = 103,
	[343][55] = 103,
	[345][6] = 104,
	[345][9] = 104,
	[345][16] = 104,
	[345][17] = 104,
	[345][18] = 104,
	[345][19] = 104,
	[345][24] = 104,
	[345][25] = 104,
	[345][26] = 104,
	[345][27] = 104,
	[345][28] = 104,
	[345][29] = 104,
	[345][30] = 104,
	[345][31] = 104,
	[345][32] = 104,
	[345][33] = 104,
	[345][34] = 104,
	[345][35] = 104,
	[345][36] = 104,
	[345][37] = 104,
	[346][6] = 105,
	[346][9] = 105,
	[346][16] = 105,
	[346][17] = 105,
	[346][18] = 105,
	[346][19] = 105,
	[346][24] = 105,
	[346][25] = 105,
	[346][26] = 105,
	[346][27] = 105,
	[346][28] = 105,
	[346][29] = 105,
	[346][30] = 105,
	[346][31] = 105,
	[346][32] = 105,
	[346][33] = 105,
	[346][34] = 105,
	[346][35] = 105,
	[346][36] = 105,
	[346][37] = 105,
	[347][16] = 106,
	[347][17] = 106,
	[347][18] = 106,
	[347][19] = 106,
	[347][32] = 106,
	[347][33] = 106,
	[347][34] = 106,
	[347][35] = 106,
	[347][36] = 106,
	[347][37] = 106,
	[348][54] = 107,
	[349][54] = 108,
	[350][54] = 109,
	[351][54] = 110,
	[352][54] = 111,
	[353][54] = 112,
	[354][16] = 113,
	[354][17] = 113,
	[354][18] = 113,
	[354][19] = 113,
	[354][30] = 113,
	[354][31] = 113,
	[354][32] = 113,
	[354][33] = 113,
	[354][34] = 113,
	[354][35] = 113,
	[354][36] = 113,
	[354][37] = 113,
	[355][16] = 114,
	[355][17] = 114,
	[355][18] = 114,
	[355][19] = 114,
	[355][30] = 114,
	[355][31] = 114,
	[355][32] = 114,
	[355][33] = 114,
	[355][34] = 114,
	[355][35] = 114,
	[355][36] = 114,
	[355][37] = 114,
	[356][17] = 115,
	[356][18] = 115,
	[356][19] = 115,
	[356][32] = 115,
	[356][33] = 115,
	[356][34] = 115,
	[356][35] = 115,
	[356][36] = 115,
	[356][37] = 115,
	[357][6] = 116,
	[357][9] = 116,
	[357][14] = 116,
	[357][16] = 116,
	[357][17] = 116,
	[357][18] = 116,
	[357][19] = 116,
	[357][20] = 116,
	[357][22] = 116,
	[357][23] = 116,
	[357][24] = 116,
	[357][25] = 116,
	[357][26] = 116,
	[357][27] = 116,
	[357][28] = 116,
	[357][29] = 116,
	[357][30] = 116,
	[357][31] = 116,
	[357][32] = 116,
	[357][33] = 116,
	[357][34] = 116,
	[357][35] = 116,
	[357][36] = 116,
	[357][37] = 116,
	[358][54] = 117,
	[359][54] = 118,
	[360][54] = 119,
	[361][54] = 120,
	[362][54] = 121,
	[363][54] = 122,
	[364][37] = 123,
	[365][37] = 124,
	[366][18] = 125,
	[366][19] = 125,
	[366][32] = 125,
	[366][33] = 125,
	[366][34] = 125,
	[366][35] = 125,
	[366][36] = 125,
	[366][37] = 125,
	[367][35] = 126,
	[367][36] = 126,
	[367][37] = 126,
	[368][19] = 127,
	[368][32] = 127,
	[368][33] = 127,
	[368][34] = 127,
	[368][35] = 127,
	[368][36] = 127,
	[368][37] = 127,
	[369][4] = 1,
	[369][6] = 1,
	[369][8] = 1,
	[369][9] = 1,
	[369][14] = 1,
	[369][16] = 1,
	[369][17] = 1,
	[369][18] = 1,
	[369][19] = 1,
	[369][20] = 1,
	[369][21] = 1,
	[369][22] = 1,
	[369][23] = 1,
	[369][24] = 1,
	[369][25] = 1,
	[369][26] = 1,
	[369][27] = 1,
	[369][28] = 1,
	[369][29] = 1,
	[369][30] = 1,
	[369][31] = 1,
	[369][32] = 1,
	[369][33] = 1,
	[369][34] = 1,
	[369][35] = 1,
	[369][36] = 1,
	[369][41] = 1,
	[370][4] = 2,
	[370][6] = 2,
	[370][8] = 2,
	[370][9] = 2,
	[370][14] = 2,
	[370][16] = 2,
	[370][17] = 2,
	[370][18] = 2,
	[370][19] = 2,
	[370][20] = 2,
	[370][21] = 2,
	[370][22] = 2,
	[370][23] = 2,
	[370][24] = 2,
	[370][25] = 2,
	[370][26] = 2,
	[370][27] = 2,
	[370][28] = 2,
	[370][29] = 2,
	[370][30] = 2,
	[370][31] = 2,
	[370][32] = 2,
	[370][33] = 2,
	[370][34] = 2,
	[370][35] = 2,
	[370][36] = 2,
	[370][41] = 2,
	[374][4] = 3,
	[374][6] = 3,
	[374][8] = 3,
	[374][9] = 3,
	[374][14] = 3,
	[374][16] = 3,
	[374][17] = 3,
	[374][18] = 3,
	[374][19] = 3,
	[374][20] = 3,
	[374][21] = 3,
	[374][22] = 3,
	[374][23] = 3,
	[374][24] = 3,
	[374][25] = 3,
	[374][26] = 3,
	[374][27] = 3,
	[374][28] = 3,
	[374][29] = 3,
	[374][30] = 3,
	[374][31] = 3,
	[374][32] = 3,
	[374][33] = 3,
	[374][34] = 3,
	[374][35] = 3,
	[374][36] = 3,
	[374][41] = 3,
	[377][4] = 4,
	[377][6] = 4,
	[377][8] = 4,
	[377][9] = 4,
	[377][14] = 4,
	[377][16] = 4,
	[377][17] = 4,
	[377][18] = 4,
	[377][19] = 4,
	[377][20] = 4,
	[377][21] = 4,
	[377][22] = 4,
	[377][23] = 4,
	[377][24] = 4,
	[377][25] = 4,
	[377][26] = 4,
	[377][27] = 4,
	[377][28] = 4,
	[377][29] = 4,
	[377][30] = 4,
	[377][31] = 4,
	[377][32] = 4,
	[377][33] = 4,
	[377][34] = 4,
	[377][35] = 4,
	[377][36] = 4,
	[377][41] = 4,
	[378][4] = 5,
	[378][6] = 5,
	[378][8] = 5,
	[378][9] = 5,
	[378][14] = 5,
	[378][16] = 5,
	[378][17] = 5,
	[378][18] = 5,
	[378][19] = 5,
	[378][20] = 5,
	[378][21] = 5,
	[378][22] = 5,
	[378][23] = 5,
	[378][24] = 5,
	[378][25] = 5,
	[378][26] = 5,
	[378][27] = 5,
	[378][28] = 5,
	[378][29] = 5,
	[378][30] = 5,
	[378][31] = 5,
	[378][32] = 5,
	[378][33] = 5,
	[378][34] = 5,
	[378][35] = 5,
	[378][36] = 5,
	[378][41] = 5,
	[382][16] = 6,
	[382][17] = 6,
	[382][18] = 6,
	[382][19] = 6,
	[382][24] = 6,
	[382][25] = 6,
	[382][26] = 6,
	[382][27] = 6,
	[382][28] = 6,
	[382][29] = 6,
	[382][30] = 6,
	[382][31] = 6,
	[382][32] = 6,
	[382][33] = 6,
	[382][34] = 6,
	[382][35] = 6,
	[382][36] = 6,
	[382][41] = 6,
	[383][17] = 7,
	[383][18] = 7,
	[383][19] = 7,
	[383][32] = 7,
	[383][33] = 7,
	[383][34] = 7,
	[383][35] = 7,
	[383][36] = 7,
	[383][41] = 7,
	[384][34] = 9,
	[384][35] = 9,
	[384][36] = 9,
	[384][41] = 9,
	[385][16] = 10,
	[385][17] = 10,
	[385][18] = 10,
	[385][19] = 10,
	[385][32] = 10,
	[385][33] = 10,
	[385][34] = 10,
	[385][35] = 10,
	[385][36] = 10,
	[385][41] = 10,
	[386][18] = 11,
	[386][19] = 11,
	[386][32] = 11,
	[386][33] = 11,
	[386][34] = 11,
	[386][35] = 11,
	[386][36] = 11,
	[386][41] = 11,
	[387][6] = 12,
	[387][9] = 12,
	[387][14] = 12,
	[387][16] = 12,
	[387][17] = 12,
	[387][18] = 12,
	[387][19] = 12,
	[387][20] = 12,
	[387][23] = 12,
	[387][24] = 12,
	[387][25] = 12,
	[387][26] = 12,
	[387][27] = 12,
	[387][28] = 12,
	[387][29] = 12,
	[387][30] = 12,
	[387][31] = 12,
	[387][32] = 12,
	[387][33] = 12,
	[387][34] = 12,
	[387][35] = 12,
	[387][36] = 12,
	[387][41] = 12,
	[389][41] = 14,
	[390][19] = 15,
	[390][32] = 15,
	[390][33] = 15,
	[390][34] = 15,
	[390][35] = 15,
	[390][36] = 15,
	[390][41] = 15,
	[391][35] = 16,
	[391][36] = 16,
	[391][41] = 16,
	[392][19] = 17,
	[392][33] = 17,
	[392][34] = 17,
	[392][35] = 17,
	[392][36] = 17,
	[392][41] = 17,
	[393][34] = 18,
	[393][35] = 18,
	[393][36] = 18,
	[393][41] = 18,
	[394][6] = 19,
	[394][9] = 19,
	[394][16] = 19,
	[394][17] = 19,
	[394][18] = 19,
	[394][19] = 19,
	[394][24] = 19,
	[394][25] = 19,
	[394][26] = 19,
	[394][27] = 19,
	[394][28] = 19,
	[394][29] = 19,
	[394][30] = 19,
	[394][31] = 19,
	[394][32] = 19,
	[394][33] = 19,
	[394][34] = 19,
	[394][35] = 19,
	[394][36] = 19,
	[394][41] = 19,
	[395][36] = 20,
	[395][41] = 20,
	[396][6] = 21,
	[396][9] = 21,
	[396][14] = 21,
	[396][16] = 21,
	[396][17] = 21,
	[396][18] = 21,
	[396][19] = 21,
	[396][20] = 21,
	[396][22] = 21,
	[396][23] = 21,
	[396][24] = 21,
	[396][25] = 21,
	[396][26] = 21,
	[396][27] = 21,
	[396][28] = 21,
	[396][29] = 21,
	[396][30] = 21,
	[396][31] = 21,
	[396][32] = 21,
	[396][33] = 21,
	[396][34] = 21,
	[396][35] = 21,
	[396][36] = 21,
	[396][41] = 21,
	[397][4] = 22,
	[397][6] = 22,
	[397][8] = 22,
	[397][9] = 22,
	[397][14] = 22,
	[397][16] = 22,
	[397][17] = 22,
	[397][18] = 22,
	[397][19] = 22,
	[397][20] = 22,
	[397][21] = 22,
	[397][22] = 22,
	[397][23] = 22,
	[397][24] = 22,
	[397][25] = 22,
	[397][26] = 22,
	[397][27] = 22,
	[397][28] = 22,
	[397][29] = 22,
	[397][30] = 22,
	[397][31] = 22,
	[397][32] = 22,
	[397][33] = 22,
	[397][34] = 22,
	[397][35] = 22,
	[397][36] = 22,
	[397][41] = 22,
	[398][16] = 23,
	[398][17] = 23,
	[398][18] = 23,
	[398][19] = 23,
	[398][30] = 23,
	[398][31] = 23,
	[398][32] = 23,
	[398][33] = 23,
	[398][34] = 23,
	[398][35] = 23,
	[398][36] = 23,
	[398][41] = 23,
	[399][16] = 24,
	[399][17] = 24,
	[399][18] = 24,
	[399][19] = 24,
	[399][26] = 24,
	[399][27] = 24,
	[399][28] = 24,
	[399][29] = 24,
	[399][30] = 24,
	[399][31] = 24,
	[399][32] = 24,
	[399][33] = 24,
	[399][34] = 24,
	[399][35] = 24,
	[399][36] = 24,
	[399][41] = 24,
	[400][6] = 27,
	[400][9] = 27,
	[400][14] = 27,
	[400][16] = 27,
	[400][17] = 27,
	[400][18] = 27,
	[400][19] = 27,
	[400][20] = 27,
	[400][22] = 27,
	[400][23] = 27,
	[400][24] = 27,
	[400][25] = 27,
	[400][26] = 27,
	[400][27] = 27,
	[400][28] = 27,
	[400][29] = 27,
	[400][30] = 27,
	[400][31] = 27,
	[400][32] = 27,
	[400][33] = 27,
	[400][34] = 27,
	[400][35] = 27,
	[400][36] = 27,
	[400][41] = 27,
	[401][19] = 128,
	[401][33] = 128,
	[401][34] = 128,
	[401][35] = 128,
	[401][36] = 128,
	[401][37] = 128,
	[402][6] = 129,
	[402][9] = 129,
	[402][14] = 129,
	[402][16] = 129,
	[402][17] = 129,
	[402][18] = 129,
	[402][19] = 129,
	[402][20] = 129,
	[402][23] = 129,
	[402][24] = 129,
	[402][25] = 129,
	[402][26] = 129,
	[402][27] = 129,
	[402][28] = 129,
	[402][29] = 129,
	[402][30] = 129,
	[402][31] = 129,
	[402][32] = 129,
	[402][33] = 129,
	[402][34] = 129,
	[402][35] = 129,
	[402][36] = 129,
	[402][37] = 129,
	[403][6] = 130,
	[403][9] = 130,
	[403][14] = 130,
	[403][16] = 130,
	[403][17] = 130,
	[403][18] = 130,
	[403][19] = 130,
	[403][20] = 130,
	[403][23] = 130,
	[403][24] = 130,
	[403][25] = 130,
	[403][26] = 130,
	[403][27] = 130,
	[403][28] = 130,
	[403][29] = 130,
	[403][30] = 130,
	[403][31] = 130,
	[403][32] = 130,
	[403][33] = 130,
	[403][34] = 130,
	[403][35] = 130,
	[403][36] = 130,
	[403][37] = 130,
	[404][6] = 131,
	[404][9] = 131,
	[404][14] = 131,
	[404][16] = 131,
	[404][17] = 131,
	[404][18] = 131,
	[404][19] = 131,
	[404][20] = 131,
	[404][23] = 131,
	[404][24] = 131,
	[404][25] = 131,
	[404][26] = 131,
	[404][27] = 131,
	[404][28] = 131,
	[404][29] = 131,
	[404][30] = 131,
	[404][31] = 131,
	[404][32] = 131,
	[404][33] = 131,
	[404][34] = 131,
	[404][35] = 131,
	[404][36] = 131,
	[404][37] = 131,
	[405][36] = 132,
	[405][37] = 132,
	[406][36] = 133,
	[406][37] = 133,
	[407][4] = 134,
	[407][6] = 134,
	[407][8] = 134,
	[407][9] = 134,
	[407][14] = 134,
	[407][16] = 134,
	[407][17] = 134,
	[407][18] = 134,
	[407][19] = 134,
	[407][20] = 134,
	[407][21] = 134,
	[407][22] = 134,
	[407][23] = 134,
	[407][24] = 134,
	[407][25] = 134,
	[407][26] = 134,
	[407][27] = 134,
	[407][28] = 134,
	[407][29] = 134,
	[407][30] = 134,
	[407][31] = 134,
	[407][32] = 134,
	[407][33] = 134,
	[407][34] = 134,
	[407][35] = 134,
	[407][36] = 134,
	[407][37] = 134,
	[410][4] = 1,
	[410][6] = 1,
	[410][8] = 1,
	[410][9] = 1,
	[410][14] = 1,
	[410][16] = 1,
	[410][17] = 1,
	[410][18] = 1,
	[410][19] = 1,
	[410][20] = 1,
	[410][21] = 1,
	[410][22] = 1,
	[410][23] = 1,
	[410][24] = 1,
	[410][25] = 1,
	[410][26] = 1,
	[410][27] = 1,
	[410][28] = 1,
	[410][29] = 1,
	[410][30] = 1,
	[410][31] = 1,
	[410][32] = 1,
	[410][33] = 1,
	[410][34] = 1,
	[410][35] = 1,
	[410][36] = 1,
	[410][40] = 1,
	[411][4] = 2,
	[411][6] = 2,
	[411][8] = 2,
	[411][9] = 2,
	[411][14] = 2,
	[411][16] = 2,
	[411][17] = 2,
	[411][18] = 2,
	[411][19] = 2,
	[411][20] = 2,
	[411][21] = 2,
	[411][22] = 2,
	[411][23] = 2,
	[411][24] = 2,
	[411][25] = 2,
	[411][26] = 2,
	[411][27] = 2,
	[411][28] = 2,
	[411][29] = 2,
	[411][30] = 2,
	[411][31] = 2,
	[411][32] = 2,
	[411][33] = 2,
	[411][34] = 2,
	[411][35] = 2,
	[411][36] = 2,
	[411][40] = 2,
	[415][4] = 3,
	[415][6] = 3,
	[415][8] = 3,
	[415][9] = 3,
	[415][14] = 3,
	[415][16] = 3,
	[415][17] = 3,
	[415][18] = 3,
	[415][19] = 3,
	[415][20] = 3,
	[415][21] = 3,
	[415][22] = 3,
	[415][23] = 3,
	[415][24] = 3,
	[415][25] = 3,
	[415][26] = 3,
	[415][27] = 3,
	[415][28] = 3,
	[415][29] = 3,
	[415][30] = 3,
	[415][31] = 3,
	[415][32] = 3,
	[415][33] = 3,
	[415][34] = 3,
	[415][35] = 3,
	[415][36] = 3,
	[415][40] = 3,
	[418][4] = 4,
	[418][6] = 4,
	[418][8] = 4,
	[418][9] = 4,
	[418][14] = 4,
	[418][16] = 4,
	[418][17] = 4,
	[418][18] = 4,
	[418][19] = 4,
	[418][20] = 4,
	[418][21] = 4,
	[418][22] = 4,
	[418][23] = 4,
	[418][24] = 4,
	[418][25] = 4,
	[418][26] = 4,
	[418][27] = 4,
	[418][28] = 4,
	[418][29] = 4,
	[418][30] = 4,
	[418][31] = 4,
	[418][32] = 4,
	[418][33] = 4,
	[418][34] = 4,
	[418][35] = 4,
	[418][36] = 4,
	[418][40] = 4,
	[419][4] = 5,
	[419][6] = 5,
	[419][8] = 5,
	[419][9] = 5,
	[419][14] = 5,
	[419][16] = 5,
	[419][17] = 5,
	[419][18] = 5,
	[419][19] = 5,
	[419][20] = 5,
	[419][21] = 5,
	[419][22] = 5,
	[419][23] = 5,
	[419][24] = 5,
	[419][25] = 5,
	[419][26] = 5,
	[419][27] = 5,
	[419][28] = 5,
	[419][29] = 5,
	[419][30] = 5,
	[419][31] = 5,
	[419][32] = 5,
	[419][33] = 5,
	[419][34] = 5,
	[419][35] = 5,
	[419][36] = 5,
	[419][40] = 5,
	[423][16] = 6,
	[423][17] = 6,
	[423][18] = 6,
	[423][19] = 6,
	[423][24] = 6,
	[423][25] = 6,
	[423][26] = 6,
	[423][27] = 6,
	[423][28] = 6,
	[423][29] = 6,
	[423][30] = 6,
	[423][31] = 6,
	[423][32] = 6,
	[423][33] = 6,
	[423][34] = 6,
	[423][35] = 6,
	[423][36] = 6,
	[423][40] = 6,
	[424][17] = 7,
	[424][18] = 7,
	[424][19] = 7,
	[424][32] = 7,
	[424][33] = 7,
	[424][34] = 7,
	[424][35] = 7,
	[424][36] = 7,
	[424][40] = 7,
	[425][34] = 9,
	[425][35] = 9,
	[425][36] = 9,
	[425][40] = 9,
	[426][16] = 10,
	[426][17] = 10,
	[426][18] = 10,
	[426][19] = 10,
	[426][32] = 10,
	[426][33] = 10,
	[426][34] = 10,
	[426][35] = 10,
	[426][36] = 10,
	[426][40] = 10,
	[427][18] = 11,
	[427][19] = 11,
	[427][32] = 11,
	[427][33] = 11,
	[427][34] = 11,
	[427][35] = 11,
	[427][36] = 11,
	[427][40] = 11,
	[428][6] = 12,
	[428][9] = 12,
	[428][14] = 12,
	[428][16] = 12,
	[428][17] = 12,
	[428][18] = 12,
	[428][19] = 12,
	[428][20] = 12,
	[428][23] = 12,
	[428][24] = 12,
	[428][25] = 12,
	[428][26] = 12,
	[428][27] = 12,
	[428][28] = 12,
	[428][29] = 12,
	[428][30] = 12,
	[428][31] = 12,
	[428][32] = 12,
	[428][33] = 12,
	[428][34] = 12,
	[428][35] = 12,
	[428][36] = 12,
	[428][40] = 12,
	[430][40] = 14,
	[431][19] = 15,
	[431][32] = 15,
	[431][33] = 15,
	[431][34] = 15,
	[431][35] = 15,
	[431][36] = 15,
	[431][40] = 15,
	[432][35] = 16,
	[432][36] = 16,
	[432][40] = 16,
	[433][19] = 17,
	[433][33] = 17,
	[433][34] = 17,
	[433][35] = 17,
	[433][36] = 17,
	[433][40] = 17,
	[434][34] = 18,
	[434][35] = 18,
	[434][36] = 18,
	[434][40] = 18,
	[435][6] = 19,
	[435][9] = 19,
	[435][16] = 19,
	[435][17] = 19,
	[435][18] = 19,
	[435][19] = 19,
	[435][24] = 19,
	[435][25] = 19,
	[435][26] = 19,
	[435][27] = 19,
	[435][28] = 19,
	[435][29] = 19,
	[435][30] = 19,
	[435][31] = 19,
	[435][32] = 19,
	[435][33] = 19,
	[435][34] = 19,
	[435][35] = 19,
	[435][36] = 19,
	[435][40] = 19,
	[436][36] = 20,
	[436][40] = 20,
	[437][6] = 21,
	[437][9] = 21,
	[437][14] = 21,
	[437][16] = 21,
	[437][17] = 21,
	[437][18] = 21,
	[437][19] = 21,
	[437][20] = 21,
	[437][22] = 21,
	[437][23] = 21,
	[437][24] = 21,
	[437][25] = 21,
	[437][26] = 21,
	[437][27] = 21,
	[437][28] = 21,
	[437][29] = 21,
	[437][30] = 21,
	[437][31] = 21,
	[437][32] = 21,
	[437][33] = 21,
	[437][34] = 21,
	[437][35] = 21,
	[437][36] = 21,
	[437][40] = 21,
	[438][4] = 22,
	[438][6] = 22,
	[438][8] = 22,
	[438][9] = 22,
	[438][14] = 22,
	[438][16] = 22,
	[438][17] = 22,
	[438][18] = 22,
	[438][19] = 22,
	[438][20] = 22,
	[438][21] = 22,
	[438][22] = 22,
	[438][23] = 22,
	[438][24] = 22,
	[438][25] = 22,
	[438][26] = 22,
	[438][27] = 22,
	[438][28] = 22,
	[438][29] = 22,
	[438][30] = 22,
	[438][31] = 22,
	[438][32] = 22,
	[438][33] = 22,
	[438][34] = 22,
	[438][35] = 22,
	[438][36] = 22,
	[438][40] = 22,
	[439][16] = 23,
	[439][17] = 23,
	[439][18] = 23,
	[439][19] = 23,
	[439][30] = 23,
	[439][31] = 23,
	[439][32] = 23,
	[439][33] = 23,
	[439][34] = 23,
	[439][35] = 23,
	[439][36] = 23,
	[439][40] = 23,
	[440][16] = 24,
	[440][17] = 24,
	[440][18] = 24,
	[440][19] = 24,
	[440][26] = 24,
	[440][27] = 24,
	[440][28] = 24,
	[440][29] = 24,
	[440][30] = 24,
	[440][31] = 24,
	[440][32] = 24,
	[440][33] = 24,
	[440][34] = 24,
	[440][35] = 24,
	[440][36] = 24,
	[440][40] = 24,
	[441][6] = 27,
	[441][9] = 27,
	[441][14] = 27,
	[441][16] = 27,
	[441][17] = 27,
	[441][18] = 27,
	[441][19] = 27,
	[441][20] = 27,
	[441][22] = 27,
	[441][23] = 27,
	[441][24] = 27,
	[441][25] = 27,
	[441][26] = 27,
	[441][27] = 27,
	[441][28] = 27,
	[441][29] = 27,
	[441][30] = 27,
	[441][31] = 27,
	[441][32] = 27,
	[441][33] = 27,
	[441][34] = 27,
	[441][35] = 27,
	[441][36] = 27,
	[441][40] = 27,
	[442][4] = 135,
	[442][6] = 135,
	[442][8] = 135,
	[442][9] = 135,
	[442][14] = 135,
	[442][16] = 135,
	[442][17] = 135,
	[442][18] = 135,
	[442][19] = 135,
	[442][20] = 135,
	[442][21] = 135,
	[442][22] = 135,
	[442][23] = 135,
	[442][24] = 135,
	[442][25] = 135,
	[442][26] = 135,
	[442][27] = 135,
	[442][28] = 135,
	[442][29] = 135,
	[442][30] = 135,
	[442][31] = 135,
	[442][32] = 135,
	[442][33] = 135,
	[442][34] = 135,
	[442][35] = 135,
	[442][36] = 135,
	[442][37] = 135,
	[443][16] = 136,
	[443][17] = 136,
	[443][18] = 136,
	[443][19] = 136,
	[443][26] = 136,
	[443][27] = 136,
	[443][28] = 136,
	[443][29] = 136,
	[443][30] = 136,
	[443][31] = 136,
	[443][32] = 136,
	[443][33] = 136,
	[443][34] = 136,
	[443][35] = 136,
	[443][36] = 136,
	[443][37] = 136,
	[444][16] = 137,
	[444][17] = 137,
	[444][18] = 137,
	[444][19] = 137,
	[444][26] = 137,
	[444][27] = 137,
	[444][28] = 137,
	[444][29] = 137,
	[444][30] = 137,
	[444][31] = 137,
	[444][32] = 137,
	[444][33] = 137,
	[444][34] = 137,
	[444][35] = 137,
	[444][36] = 137,
	[444][37] = 137,
	[445][16] = 138,
	[445][17] = 138,
	[445][18] = 138,
	[445][19] = 138,
	[445][26] = 138,
	[445][27] = 138,
	[445][28] = 138,
	[445][29] = 138,
	[445][30] = 138,
	[445][31] = 138,
	[445][32] = 138,
	[445][33] = 138,
	[445][34] = 138,
	[445][35] = 138,
	[445][36] = 138,
	[445][37] = 138,
	[446][16] = 139,
	[446][17] = 139,
	[446][18] = 139,
	[446][19] = 139,
	[446][26] = 139,
	[446][27] = 139,
	[446][28] = 139,
	[446][29] = 139,
	[446][30] = 139,
	[446][31] = 139,
	[446][32] = 139,
	[446][33] = 139,
	[446][34] = 139,
	[446][35] = 139,
	[446][36] = 139,
	[446][37] = 139,
	[447][16] = 140,
	[447][17] = 140,
	[447][18] = 140,
	[447][19] = 140,
	[447][24] = 140,
	[447][25] = 140,
	[447][26] = 140,
	[447][27] = 140,
	[447][28] = 140,
	[447][29] = 140,
	[447][30] = 140,
	[447][31] = 140,
	[447][32] = 140,
	[447][33] = 140,
	[447][34] = 140,
	[447][35] = 140,
	[447][36] = 140,
	[447][37] = 140,
	[448][16] = 141,
	[448][17] = 141,
	[448][18] = 141,
	[448][19] = 141,
	[448][24] = 141,
	[448][25] = 141,
	[448][26] = 141,
	[448][27] = 141,
	[448][28] = 141,
	[448][29] = 141,
	[448][30] = 141,
	[448][31] = 141,
	[448][32] = 141,
	[448][33] = 141,
	[448][34] = 141,
	[448][35] = 141,
	[448][36] = 141,
	[448][37] = 141,
	[449][54] = 142,
	[450][54] = 143,
	[451][54] = 144,
	[452][54] = 145,
	[453][54] = 146,
	[454][54] = 147,
	[455][54] = 148,
	[456][54] = 149,
	[457][54] = 150,
	[458][54] = 151,
	[459][54] = 152,
	[460][54] = 153,
	[461][54] = 154,
	[462][54] = 155,
	[463][54] = 156,
	[464][54] = 157,
	[465][54] = 158,
	[466][54] = 159,
	[467][54] = 160,
	[468][54] = 161,
	[469][54] = 162,
	[470][54] = 163,
	[471][54] = 164,
	[472][54] = 165,
	[473][4] = 86,
	[473][6] = 86,
	[473][8] = 86,
	[473][9] = 86,
	[473][14] = 86,
	[473][16] = 86,
	[473][17] = 86,
	[473][18] = 86,
	[473][19] = 86,
	[473][20] = 86,
	[473][21] = 86,
	[473][22] = 86,
	[473][23] = 86,
	[473][24] = 86,
	[473][25] = 86,
	[473][26] = 86,
	[473][27] = 86,
	[473][28] = 86,
	[473][29] = 86,
	[473][30] = 86,
	[473][31] = 86,
	[473][32] = 86,
	[473][33] = 86,
	[473][34] = 86,
	[473][35] = 86,
	[473][36] = 86,
	[473][38] = 86,
	[473][39] = 86,
	[475][4] = 87,
	[475][6] = 87,
	[475][8] = 87,
	[475][9] = 87,
	[475][14] = 87,
	[475][16] = 87,
	[475][17] = 87,
	[475][18] = 87,
	[475][19] = 87,
	[475][20] = 87,
	[475][21] = 87,
	[475][22] = 87,
	[475][23] = 87,
	[475][24] = 87,
	[475][25] = 87,
	[475][26] = 87,
	[475][27] = 87,
	[475][28] = 87,
	[475][29] = 87,
	[475][30] = 87,
	[475][31] = 87,
	[475][32] = 87,
	[475][33] = 87,
	[475][34] = 87,
	[475][35] = 87,
	[475][36] = 87,
	[475][38] = 87,
	[475][39] = 87,
	[477][4] = 166,
	[477][6] = 166,
	[477][8] = 166,
	[477][9] = 166,
	[477][14] = 166,
	[477][16] = 166,
	[477][17] = 166,
	[477][18] = 166,
	[477][19] = 166,
	[477][20] = 166,
	[477][21] = 166,
	[477][22] = 166,
	[477][23] = 166,
	[477][24] = 166,
	[477][25] = 166,
	[477][26] = 166,
	[477][27] = 166,
	[477][28] = 166,
	[477][29] = 166,
	[477][30] = 166,
	[477][31] = 166,
	[477][32] = 166,
	[477][33] = 166,
	[477][34] = 166,
	[477][35] = 166,
	[477][36] = 166,
	[477][37] = 166,
	[479][4] = 88,
	[479][6] = 88,
	[479][8] = 88,
	[479][9] = 88,
	[479][14] = 88,
	[479][16] = 88,
	[479][17] = 88,
	[479][18] = 88,
	[479][19] = 88,
	[479][20] = 88,
	[479][21] = 88,
	[479][22] = 88,
	[479][23] = 88,
	[479][24] = 88,
	[479][25] = 88,
	[479][26] = 88,
	[479][27] = 88,
	[479][28] = 88,
	[479][29] = 88,
	[479][30] = 88,
	[479][31] = 88,
	[479][32] = 88,
	[479][33] = 88,
	[479][34] = 88,
	[479][35] = 88,
	[479][36] = 88,
	[479][38] = 88,
	[479][39] = 88,
	[482][4] = 89,
	[482][6] = 89,
	[482][8] = 89,
	[482][9] = 89,
	[482][14] = 89,
	[482][16] = 89,
	[482][17] = 89,
	[482][18] = 89,
	[482][19] = 89,
	[482][20] = 89,
	[482][21] = 89,
	[482][22] = 89,
	[482][23] = 89,
	[482][24] = 89,
	[482][25] = 89,
	[482][26] = 89,
	[482][27] = 89,
	[482][28] = 89,
	[482][29] = 89,
	[482][30] = 89,
	[482][31] = 89,
	[482][32] = 89,
	[482][33] = 89,
	[482][34] = 89,
	[482][35] = 89,
	[482][36] = 89,
	[482][38] = 89,
	[482][39] = 89,
	[483][4] = 97,
	[483][6] = 97,
	[483][8] = 97,
	[483][9] = 97,
	[483][14] = 97,
	[483][16] = 97,
	[483][17] = 97,
	[483][18] = 97,
	[483][19] = 97,
	[483][20] = 97,
	[483][21] = 97,
	[483][22] = 97,
	[483][23] = 97,
	[483][24] = 97,
	[483][25] = 97,
	[483][26] = 97,
	[483][27] = 97,
	[483][28] = 97,
	[483][29] = 97,
	[483][30] = 97,
	[483][31] = 97,
	[483][32] = 97,
	[483][33] = 97,
	[483][34] = 97,
	[483][35] = 97,
	[483][36] = 97,
	[483][38] = 97,
	[483][39] = 97,
	[486][34] = 100,
	[486][35] = 100,
	[486][36] = 100,
	[486][38] = 100,
	[486][39] = 100,
	[488][34] = 101,
	[488][35] = 101,
	[488][36] = 101,
	[488][38] = 101,
	[488][39] = 101,
	[489][34] = 102,
	[489][35] = 102,
	[489][36] = 102,
	[489][38] = 102,
	[489][39] = 102,
	[491][6] = 104,
	[491][9] = 104,
	[491][16] = 104,
	[491][17] = 104,
	[491][18] = 104,
	[491][19] = 104,
	[491][24] = 104,
	[491][25] = 104,
	[491][26] = 104,
	[491][27] = 104,
	[491][28] = 104,
	[491][29] = 104,
	[491][30] = 104,
	[491][31] = 104,
	[491][32] = 104,
	[491][33] = 104,
	[491][34] = 104,
	[491][35] = 104,
	[491][36] = 104,
	[491][38] = 104,
	[491][39] = 104,
	[492][6] = 105,
	[492][9] = 105,
	[492][16] = 105,
	[492][17] = 105,
	[492][18] = 105,
	[492][19] = 105,
	[492][24] = 105,
	[492][25] = 105,
	[492][26] = 105,
	[492][27] = 105,
	[492][28] = 105,
	[492][29] = 105,
	[492][30] = 105,
	[492][31] = 105,
	[492][32] = 105,
	[492][33] = 105,
	[492][34] = 105,
	[492][35] = 105,
	[492][36] = 105,
	[492][38] = 105,
	[492][39] = 105,
	[493][16] = 106,
	[493][17] = 106,
	[493][18] = 106,
	[493][19] = 106,
	[493][32] = 106,
	[493][33] = 106,
	[493][34] = 106,
	[493][35] = 106,
	[493][36] = 106,
	[493][38] = 106,
	[493][39] = 106,
	[494][16] = 113,
	[494][17] = 113,
	[494][18] = 113,
	[494][19] = 113,
	[494][30] = 113,
	[494][31] = 113,
	[494][32] = 113,
	[494][33] = 113,
	[494][34] = 113,
	[494][35] = 113,
	[494][36] = 113,
	[494][38] = 113,
	[494][39] = 113,
	[495][16] = 114,
	[495][17] = 114,
	[495][18] = 114,
	[495][19] = 114,
	[495][30] = 114,
	[495][31] = 114,
	[495][32] = 114,
	[495][33] = 114,
	[495][34] = 114,
	[495][35] = 114,
	[495][36] = 114,
	[495][38] = 114,
	[495][39] = 114,
	[496][17] = 115,
	[496][18] = 115,
	[496][19] = 115,
	[496][32] = 115,
	[496][33] = 115,
	[496][34] = 115,
	[496][35] = 115,
	[496][36] = 115,
	[496][38] = 115,
	[496][39] = 115,
	[497][6] = 116,
	[497][9] = 116,
	[497][14] = 116,
	[497][16] = 116,
	[497][17] = 116,
	[497][18] = 116,
	[497][19] = 116,
	[497][20] = 116,
	[497][22] = 116,
	[497][23] = 116,
	[497][24] = 116,
	[497][25] = 116,
	[497][26] = 116,
	[497][27] = 116,
	[497][28] = 116,
	[497][29] = 116,
	[497][30] = 116,
	[497][31] = 116,
	[497][32] = 116,
	[497][33] = 116,
	[497][34] = 116,
	[497][35] = 116,
	[497][36] = 116,
	[497][38] = 116,
	[497][39] = 116,
	[498][4] = 167,
	[498][6] = 167,
	[498][8] = 167,
	[498][9] = 167,
	[498][14] = 167,
	[498][16] = 167,
	[498][17] = 167,
	[498][18] = 167,
	[498][19] = 167,
	[498][20] = 167,
	[498][21] = 167,
	[498][22] = 167,
	[498][23] = 167,
	[498][24] = 167,
	[498][25] = 167,
	[498][26] = 167,
	[498][27] = 167,
	[498][28] = 167,
	[498][29] = 167,
	[498][30] = 167,
	[498][31] = 167,
	[498][32] = 167,
	[498][33] = 167,
	[498][34] = 167,
	[498][35] = 167,
	[498][36] = 167,
	[498][37] = 167,
	[499][38] = 123,
	[499][39] = 123,
	[500][38] = 124,
	[500][39] = 124,
	[501][18] = 125,
	[501][19] = 125,
	[501][32] = 125,
	[501][33] = 125,
	[501][34] = 125,
	[501][35] = 125,
	[501][36] = 125,
	[501][38] = 125,
	[501][39] = 125,
	[502][35] = 126,
	[502][36] = 126,
	[502][38] = 126,
	[502][39] = 126,
	[503][19] = 127,
	[503][32] = 127,
	[503][33] = 127,
	[503][34] = 127,
	[503][35] = 127,
	[503][36] = 127,
	[503][38] = 127,
	[503][39] = 127,
	[505][19] = 128,
	[505][33] = 128,
	[505][34] = 128,
	[505][35] = 128,
	[505][36] = 128,
	[505][38] = 128,
	[505][39] = 128,
	[506][6] = 129,
	[506][9] = 129,
	[506][14] = 129,
	[506][16] = 129,
	[506][17] = 129,
	[506][18] = 129,
	[506][19] = 129,
	[506][20] = 129,
	[506][23] = 129,
	[506][24] = 129,
	[506][25] = 129,
	[506][26] = 129,
	[506][27] = 129,
	[506][28] = 129,
	[506][29] = 129,
	[506][30] = 129,
	[506][31] = 129,
	[506][32] = 129,
	[506][33] = 129,
	[506][34] = 129,
	[506][35] = 129,
	[506][36] = 129,
	[506][38] = 129,
	[506][39] = 129,
	[507][6] = 130,
	[507][9] = 130,
	[507][14] = 130,
	[507][16] = 130,
	[507][17] = 130,
	[507][18] = 130,
	[507][19] = 130,
	[507][20] = 130,
	[507][23] = 130,
	[507][24] = 130,
	[507][25] = 130,
	[507][26] = 130,
	[507][27] = 130,
	[507][28] = 130,
	[507][29] = 130,
	[507][30] = 130,
	[507][31] = 130,
	[507][32] = 130,
	[507][33] = 130,
	[507][34] = 130,
	[507][35] = 130,
	[507][36] = 130,
	[507][38] = 130,
	[507][39] = 130,
	[508][6] = 131,
	[508][9] = 131,
	[508][14] = 131,
	[508][16] = 131,
	[508][17] = 131,
	[508][18] = 131,
	[508][19] = 131,
	[508][20] = 131,
	[508][23] = 131,
	[508][24] = 131,
	[508][25] = 131,
	[508][26] = 131,
	[508][27] = 131,
	[508][28] = 131,
	[508][29] = 131,
	[508][30] = 131,
	[508][31] = 131,
	[508][32] = 131,
	[508][33] = 131,
	[508][34] = 131,
	[508][35] = 131,
	[508][36] = 131,
	[508][38] = 131,
	[508][39] = 131,
	[509][36] = 132,
	[509][38] = 132,
	[509][39] = 132,
	[510][36] = 133,
	[510][38] = 133,
	[510][39] = 133,
	[511][4] = 134,
	[511][6] = 134,
	[511][8] = 134,
	[511][9] = 134,
	[511][14] = 134,
	[511][16] = 134,
	[511][17] = 134,
	[511][18] = 134,
	[511][19] = 134,
	[511][20] = 134,
	[511][21] = 134,
	[511][22] = 134,
	[511][23] = 134,
	[511][24] = 134,
	[511][25] = 134,
	[511][26] = 134,
	[511][27] = 134,
	[511][28] = 134,
	[511][29] = 134,
	[511][30] = 134,
	[511][31] = 134,
	[511][32] = 134,
	[511][33] = 134,
	[511][34] = 134,
	[511][35] = 134,
	[511][36] = 134,
	[511][38] = 134,
	[511][39] = 134,
	[515][4] = 135,
	[515][6] = 135,
	[515][8] = 135,
	[515][9] = 135,
	[515][14] = 135,
	[515][16] = 135,
	[515][17] = 135,
	[515][18] = 135,
	[515][19] = 135,
	[515][20] = 135,
	[515][21] = 135,
	[515][22] = 135,
	[515][23] = 135,
	[515][24] = 135,
	[515][25] = 135,
	[515][26] = 135,
	[515][27] = 135,
	[515][28] = 135,
	[515][29] = 135,
	[515][30] = 135,
	[515][31] = 135,
	[515][32] = 135,
	[515][33] = 135,
	[515][34] = 135,
	[515][35] = 135,
	[515][36] = 135,
	[515][38] = 135,
	[515][39] = 135,
	[516][16] = 136,
	[516][17] = 136,
	[516][18] = 136,
	[516][19] = 136,
	[516][26] = 136,
	[516][27] = 136,
	[516][28] = 136,
	[516][29] = 136,
	[516][30] = 136,
	[516][31] = 136,
	[516][32] = 136,
	[516][33] = 136,
	[516][34] = 136,
	[516][35] = 136,
	[516][36] = 136,
	[516][38] = 136,
	[516][39] = 136,
	[517][16] = 137,
	[517][17] = 137,
	[517][18] = 137,
	[517][19] = 137,
	[517][26] = 137,
	[517][27] = 137,
	[517][28] = 137,
	[517][29] = 137,
	[517][30] = 137,
	[517][31] = 137,
	[517][32] = 137,
	[517][33] = 137,
	[517][34] = 137,
	[517][35] = 137,
	[517][36] = 137,
	[517][38] = 137,
	[517][39] = 137,
	[518][16] = 138,
	[518][17] = 138,
	[518][18] = 138,
	[518][19] = 138,
	[518][26] = 138,
	[518][27] = 138,
	[518][28] = 138,
	[518][29] = 138,
	[518][30] = 138,
	[518][31] = 138,
	[518][32] = 138,
	[518][33] = 138,
	[518][34] = 138,
	[518][35] = 138,
	[518][36] = 138,
	[518][38] = 138,
	[518][39] = 138,
	[519][16] = 139,
	[519][17] = 139,
	[519][18] = 139,
	[519][19] = 139,
	[519][26] = 139,
	[519][27] = 139,
	[519][28] = 139,
	[519][29] = 139,
	[519][30] = 139,
	[519][31] = 139,
	[519][32] = 139,
	[519][33] = 139,
	[519][34] = 139,
	[519][35] = 139,
	[519][36] = 139,
	[519][38] = 139,
	[519][39] = 139,
	[520][16] = 140,
	[520][17] = 140,
	[520][18] = 140,
	[520][19] = 140,
	[520][24] = 140,
	[520][25] = 140,
	[520][26] = 140,
	[520][27] = 140,
	[520][28] = 140,
	[520][29] = 140,
	[520][30] = 140,
	[520][31] = 140,
	[520][32] = 140,
	[520][33] = 140,
	[520][34] = 140,
	[520][35] = 140,
	[520][36] = 140,
	[520][38] = 140,
	[520][39] = 140,
	[521][16] = 141,
	[521][17] = 141,
	[521][18] = 141,
	[521][19] = 141,
	[521][24] = 141,
	[521][25] = 141,
	[521][26] = 141,
	[521][27] = 141,
	[521][28] = 141,
	[521][29] = 141,
	[521][30] = 141,
	[521][31] = 141,
	[521][32] = 141,
	[521][33] = 141,
	[521][34] = 141,
	[521][35] = 141,
	[521][36] = 141,
	[521][38] = 141,
	[521][39] = 141,
	[522][4] = 86,
	[522][6] = 86,
	[522][8] = 86,
	[522][9] = 86,
	[522][14] = 86,
	[522][16] = 86,
	[522][17] = 86,
	[522][18] = 86,
	[522][19] = 86,
	[522][20] = 86,
	[522][21] = 86,
	[522][22] = 86,
	[522][23] = 86,
	[522][24] = 86,
	[522][25] = 86,
	[522][26] = 86,
	[522][27] = 86,
	[522][28] = 86,
	[522][29] = 86,
	[522][30] = 86,
	[522][31] = 86,
	[522][32] = 86,
	[522][33] = 86,
	[522][34] = 86,
	[522][35] = 86,
	[522][36] = 86,
	[522][39] = 86,
	[522][40] = 86,
	[524][4] = 87,
	[524][6] = 87,
	[524][8] = 87,
	[524][9] = 87,
	[524][14] = 87,
	[524][16] = 87,
	[524][17] = 87,
	[524][18] = 87,
	[524][19] = 87,
	[524][20] = 87,
	[524][21] = 87,
	[524][22] = 87,
	[524][23] = 87,
	[524][24] = 87,
	[524][25] = 87,
	[524][26] = 87,
	[524][27] = 87,
	[524][28] = 87,
	[524][29] = 87,
	[524][30] = 87,
	[524][31] = 87,
	[524][32] = 87,
	[524][33] = 87,
	[524][34] = 87,
	[524][35] = 87,
	[524][36] = 87,
	[524][39] = 87,
	[524][40] = 87,
	[527][4] = 168,
	[527][6] = 168,
	[527][8] = 168,
	[527][9] = 168,
	[527][14] = 168,
	[527][16] = 168,
	[527][17] = 168,
	[527][18] = 168,
	[527][19] = 168,
	[527][20] = 168,
	[527][21] = 168,
	[527][22] = 168,
	[527][23] = 168,
	[527][24] = 168,
	[527][25] = 168,
	[527][26] = 168,
	[527][27] = 168,
	[527][28] = 168,
	[527][29] = 168,
	[527][30] = 168,
	[527][31] = 168,
	[527][32] = 168,
	[527][33] = 168,
	[527][34] = 168,
	[527][35] = 168,
	[527][36] = 168,
	[527][37] = 168,
	[528][4] = 88,
	[528][6] = 88,
	[528][8] = 88,
	[528][9] = 88,
	[528][14] = 88,
	[528][16] = 88,
	[528][17] = 88,
	[528][18] = 88,
	[528][19] = 88,
	[528][20] = 88,
	[528][21] = 88,
	[528][22] = 88,
	[528][23] = 88,
	[528][24] = 88,
	[528][25] = 88,
	[528][26] = 88,
	[528][27] = 88,
	[528][28] = 88,
	[528][29] = 88,
	[528][30] = 88,
	[528][31] = 88,
	[528][32] = 88,
	[528][33] = 88,
	[528][34] = 88,
	[528][35] = 88,
	[528][36] = 88,
	[528][39] = 88,
	[528][40] = 88,
	[531][4] = 89,
	[531][6] = 89,
	[531][8] = 89,
	[531][9] = 89,
	[531][14] = 89,
	[531][16] = 89,
	[531][17] = 89,
	[531][18] = 89,
	[531][19] = 89,
	[531][20] = 89,
	[531][21] = 89,
	[531][22] = 89,
	[531][23] = 89,
	[531][24] = 89,
	[531][25] = 89,
	[531][26] = 89,
	[531][27] = 89,
	[531][28] = 89,
	[531][29] = 89,
	[531][30] = 89,
	[531][31] = 89,
	[531][32] = 89,
	[531][33] = 89,
	[531][34] = 89,
	[531][35] = 89,
	[531][36] = 89,
	[531][39] = 89,
	[531][40] = 89,
	[532][4] = 97,
	[532][6] = 97,
	[532][8] = 97,
	[532][9] = 97,
	[532][14] = 97,
	[532][16] = 97,
	[532][17] = 97,
	[532][18] = 97,
	[532][19] = 97,
	[532][20] = 97,
	[532][21] = 97,
	[532][22] = 97,
	[532][23] = 97,
	[532][24] = 97,
	[532][25] = 97,
	[532][26] = 97,
	[532][27] = 97,
	[532][28] = 97,
	[532][29] = 97,
	[532][30] = 97,
	[532][31] = 97,
	[532][32] = 97,
	[532][33] = 97,
	[532][34] = 97,
	[532][35] = 97,
	[532][36] = 97,
	[532][39] = 97,
	[532][40] = 97,
	[535][34] = 100,
	[535][35] = 100,
	[535][36] = 100,
	[535][39] = 100,
	[535][40] = 100,
	[537][34] = 101,
	[537][35] = 101,
	[537][36] = 101,
	[537][39] = 101,
	[537][40] = 101,
	[538][34] = 102,
	[538][35] = 102,
	[538][36] = 102,
	[538][39] = 102,
	[538][40] = 102,
	[540][6] = 104,
	[540][9] = 104,
	[540][16] = 104,
	[540][17] = 104,
	[540][18] = 104,
	[540][19] = 104,
	[540][24] = 104,
	[540][25] = 104,
	[540][26] = 104,
	[540][27] = 104,
	[540][28] = 104,
	[540][29] = 104,
	[540][30] = 104,
	[540][31] = 104,
	[540][32] = 104,
	[540][33] = 104,
	[540][34] = 104,
	[540][35] = 104,
	[540][36] = 104,
	[540][39] = 104,
	[540][40] = 104,
	[541][6] = 105,
	[541][9] = 105,
	[541][16] = 105,
	[541][17] = 105,
	[541][18] = 105,
	[541][19] = 105,
	[541][24] = 105,
	[541][25] = 105,
	[541][26] = 105,
	[541][27] = 105,
	[541][28] = 105,
	[541][29] = 105,
	[541][30] = 105,
	[541][31] = 105,
	[541][32] = 105,
	[541][33] = 105,
	[541][34] = 105,
	[541][35] = 105,
	[541][36] = 105,
	[541][39] = 105,
	[541][40] = 105,
	[542][16] = 106,
	[542][17] = 106,
	[542][18] = 106,
	[542][19] = 106,
	[542][32] = 106,
	[542][33] = 106,
	[542][34] = 106,
	[542][35] = 106,
	[542][36] = 106,
	[542][39] = 106,
	[542][40] = 106,
	[543][16] = 113,
	[543][17] = 113,
	[543][18] = 113,
	[543][19] = 113,
	[543][30] = 113,
	[543][31] = 113,
	[543][32] = 113,
	[543][33] = 113,
	[543][34] = 113,
	[543][35] = 113,
	[543][36] = 113,
	[543][39] = 113,
	[543][40] = 113,
	[544][16] = 114,
	[544][17] = 114,
	[544][18] = 114,
	[544][19] = 114,
	[544][30] = 114,
	[544][31] = 114,
	[544][32] = 114,
	[544][33] = 114,
	[544][34] = 114,
	[544][35] = 114,
	[544][36] = 114,
	[544][39] = 114,
	[544][40] = 114,
	[545][17] = 115,
	[545][18] = 115,
	[545][19] = 115,
	[545][32] = 115,
	[545][33] = 115,
	[545][34] = 115,
	[545][35] = 115,
	[545][36] = 115,
	[545][39] = 115,
	[545][40] = 115,
	[546][6] = 116,
	[546][9] = 116,
	[546][14] = 116,
	[546][16] = 116,
	[546][17] = 116,
	[546][18] = 116,
	[546][19] = 116,
	[546][20] = 116,
	[546][22] = 116,
	[546][23] = 116,
	[546][24] = 116,
	[546][25] = 116,
	[546][26] = 116,
	[546][27] = 116,
	[546][28] = 116,
	[546][29] = 116,
	[546][30] = 116,
	[546][31] = 116,
	[546][32] = 116,
	[546][33] = 116,
	[546][34] = 116,
	[546][35] = 116,
	[546][36] = 116,
	[546][39] = 116,
	[546][40] = 116,
	[547][4] = 169,
	[547][6] = 169,
	[547][8] = 169,
	[547][9] = 169,
	[547][14] = 169,
	[547][16] = 169,
	[547][17] = 169,
	[547][18] = 169,
	[547][19] = 169,
	[547][20] = 169,
	[547][21] = 169,
	[547][22] = 169,
	[547][23] = 169,
	[547][24] = 169,
	[547][25] = 169,
	[547][26] = 169,
	[547][27] = 169,
	[547][28] = 169,
	[547][29] = 169,
	[547][30] = 169,
	[547][31] = 169,
	[547][32] = 169,
	[547][33] = 169,
	[547][34] = 169,
	[547][35] = 169,
	[547][36] = 169,
	[547][37] = 169,
	[548][39] = 123,
	[548][40] = 123,
	[549][39] = 124,
	[549][40] = 124,
	[550][18] = 125,
	[550][19] = 125,
	[550][32] = 125,
	[550][33] = 125,
	[550][34] = 125,
	[550][35] = 125,
	[550][36] = 125,
	[550][39] = 125,
	[550][40] = 125,
	[551][35] = 126,
	[551][36] = 126,
	[551][39] = 126,
	[551][40] = 126,
	[552][19] = 127,
	[552][32] = 127,
	[552][33] = 127,
	[552][34] = 127,
	[552][35] = 127,
	[552][36] = 127,
	[552][39] = 127,
	[552][40] = 127,
	[554][19] = 128,
	[554][33] = 128,
	[554][34] = 128,
	[554][35] = 128,
	[554][36] = 128,
	[554][39] = 128,
	[554][40] = 128,
	[555][6] = 129,
	[555][9] = 129,
	[555][14] = 129,
	[555][16] = 129,
	[555][17] = 129,
	[555][18] = 129,
	[555][19] = 129,
	[555][20] = 129,
	[555][23] = 129,
	[555][24] = 129,
	[555][25] = 129,
	[555][26] = 129,
	[555][27] = 129,
	[555][28] = 129,
	[555][29] = 129,
	[555][30] = 129,
	[555][31] = 129,
	[555][32] = 129,
	[555][33] = 129,
	[555][34] = 129,
	[555][35] = 129,
	[555][36] = 129,
	[555][39] = 129,
	[555][40] = 129,
	[556][6] = 130,
	[556][9] = 130,
	[556][14] = 130,
	[556][16] = 130,
	[556][17] = 130,
	[556][18] = 130,
	[556][19] = 130,
	[556][20] = 130,
	[556][23] = 130,
	[556][24] = 130,
	[556][25] = 130,
	[556][26] = 130,
	[556][27] = 130,
	[556][28] = 130,
	[556][29] = 130,
	[556][30] = 130,
	[556][31] = 130,
	[556][32] = 130,
	[556][33] = 130,
	[556][34] = 130,
	[556][35] = 130,
	[556][36] = 130,
	[556][39] = 130,
	[556][40] = 130,
	[557][6] = 131,
	[557][9] = 131,
	[557][14] = 131,
	[557][16] = 131,
	[557][17] = 131,
	[557][18] = 131,
	[557][19] = 131,
	[557][20] = 131,
	[557][23] = 131,
	[557][24] = 131,
	[557][25] = 131,
	[557][26] = 131,
	[557][27] = 131,
	[557][28] = 131,
	[557][29] = 131,
	[557][30] = 131,
	[557][31] = 131,
	[557][32] = 131,
	[557][33] = 131,
	[557][34] = 131,
	[557][35] = 131,
	[557][36] = 131,
	[557][39] = 131,
	[557][40] = 131,
	[558][36] = 132,
	[558][39] = 132,
	[558][40] = 132,
	[559][36] = 133,
	[559][39] = 133,
	[559][40] = 133,
	[560][4] = 134,
	[560][6] = 134,
	[560][8] = 134,
	[560][9] = 134,
	[560][14] = 134,
	[560][16] = 134,
	[560][17] = 134,
	[560][18] = 134,
	[560][19] = 134,
	[560][20] = 134,
	[560][21] = 134,
	[560][22] = 134,
	[560][23] = 134,
	[560][24] = 134,
	[560][25] = 134,
	[560][26] = 134,
	[560][27] = 134,
	[560][28] = 134,
	[560][29] = 134,
	[560][30] = 134,
	[560][31] = 134,
	[560][32] = 134,
	[560][33] = 134,
	[560][34] = 134,
	[560][35] = 134,
	[560][36] = 134,
	[560][39] = 134,
	[560][40] = 134,
	[564][4] = 135,
	[564][6] = 135,
	[564][8] = 135,
	[564][9] = 135,
	[564][14] = 135,
	[564][16] = 135,
	[564][17] = 135,
	[564][18] = 135,
	[564][19] = 135,
	[564][20] = 135,
	[564][21] = 135,
	[564][22] = 135,
	[564][23] = 135,
	[564][24] = 135,
	[564][25] = 135,
	[564][26] = 135,
	[564][27] = 135,
	[564][28] = 135,
	[564][29] = 135,
	[564][30] = 135,
	[564][31] = 135,
	[564][32] = 135,
	[564][33] = 135,
	[564][34] = 135,
	[564][35] = 135,
	[564][36] = 135,
	[564][39] = 135,
	[564][40] = 135,
	[565][16] = 136,
	[565][17] = 136,
	[565][18] = 136,
	[565][19] = 136,
	[565][26] = 136,
	[565][27] = 136,
	[565][28] = 136,
	[565][29] = 136,
	[565][30] = 136,
	[565][31] = 136,
	[565][32] = 136,
	[565][33] = 136,
	[565][34] = 136,
	[565][35] = 136,
	[565][36] = 136,
	[565][39] = 136,
	[565][40] = 136,
	[566][16] = 137,
	[566][17] = 137,
	[566][18] = 137,
	[566][19] = 137,
	[566][26] = 137,
	[566][27] = 137,
	[566][28] = 137,
	[566][29] = 137,
	[566][30] = 137,
	[566][31] = 137,
	[566][32] = 137,
	[566][33] = 137,
	[566][34] = 137,
	[566][35] = 137,
	[566][36] = 137,
	[566][39] = 137,
	[566][40] = 137,
	[567][16] = 138,
	[567][17] = 138,
	[567][18] = 138,
	[567][19] = 138,
	[567][26] = 138,
	[567][27] = 138,
	[567][28] = 138,
	[567][29] = 138,
	[567][30] = 138,
	[567][31] = 138,
	[567][32] = 138,
	[567][33] = 138,
	[567][34] = 138,
	[567][35] = 138,
	[567][36] = 138,
	[567][39] = 138,
	[567][40] = 138,
	[568][16] = 139,
	[568][17] = 139,
	[568][18] = 139,
	[568][19] = 139,
	[568][26] = 139,
	[568][27] = 139,
	[568][28] = 139,
	[568][29] = 139,
	[568][30] = 139,
	[568][31] = 139,
	[568][32] = 139,
	[568][33] = 139,
	[568][34] = 139,
	[568][35] = 139,
	[568][36] = 139,
	[568][39] = 139,
	[568][40] = 139,
	[569][16] = 140,
	[569][17] = 140,
	[569][18] = 140,
	[569][19] = 140,
	[569][24] = 140,
	[569][25] = 140,
	[569][26] = 140,
	[569][27] = 140,
	[569][28] = 140,
	[569][29] = 140,
	[569][30] = 140,
	[569][31] = 140,
	[569][32] = 140,
	[569][33] = 140,
	[569][34] = 140,
	[569][35] = 140,
	[569][36] = 140,
	[569][39] = 140,
	[569][40] = 140,
	[570][16] = 141,
	[570][17] = 141,
	[570][18] = 141,
	[570][19] = 141,
	[570][24] = 141,
	[570][25] = 141,
	[570][26] = 141,
	[570][27] = 141,
	[570][28] = 141,
	[570][29] = 141,
	[570][30] = 141,
	[570][31] = 141,
	[570][32] = 141,
	[570][33] = 141,
	[570][34] = 141,
	[570][35] = 141,
	[570][36] = 141,
	[570][39] = 141,
	[570][40] = 141,
	[571][2] = 170,
	[571][3] = 170,
	[571][4] = 170,
	[571][7] = 170,
	[571][8] = 170,
	[571][9] = 170,
	[571][11] = 170,
	[571][18] = 170,
	[571][19] = 170,
	[571][20] = 170,
	[571][23] = 170,
	[571][37] = 170,
	[572][2] = 171,
	[572][3] = 171,
	[572][4] = 171,
	[572][7] = 171,
	[572][8] = 171,
	[572][9] = 171,
	[572][11] = 171,
	[572][18] = 171,
	[572][19] = 171,
	[572][20] = 171,
	[572][23] = 171,
	[572][37] = 171,
	[573][2] = 90,
	[573][3] = 90,
	[573][4] = 90,
	[573][7] = 90,
	[573][8] = 90,
	[573][9] = 90,
	[573][11] = 90,
	[573][18] = 90,
	[573][19] = 90,
	[573][20] = 90,
	[573][23] = 90,
	[573][38] = 90,
	[574][2] = 91,
	[574][3] = 91,
	[574][4] = 91,
	[574][7] = 91,
	[574][8] = 91,
	[574][9] = 91,
	[574][11] = 91,
	[574][18] = 91,
	[574][19] = 91,
	[574][20] = 91,
	[574][23] = 91,
	[574][38] = 91,
	[576][2] = 92,
	[576][3] = 92,
	[576][4] = 92,
	[576][7] = 92,
	[576][8] = 92,
	[576][9] = 92,
	[576][11] = 92,
	[576][18] = 92,
	[576][19] = 92,
	[576][20] = 92,
	[576][23] = 92,
	[576][38] = 92,
	[578][2] = 93,
	[578][3] = 93,
	[578][4] = 93,
	[578][7] = 93,
	[578][8] = 93,
	[578][9] = 93,
	[578][11] = 93,
	[578][18] = 93,
	[578][19] = 93,
	[578][20] = 93,
	[578][23] = 93,
	[578][38] = 93,
	[581][2] = 94,
	[581][3] = 94,
	[581][4] = 94,
	[581][7] = 94,
	[581][8] = 94,
	[581][11] = 94,
	[581][18] = 94,
	[581][23] = 94,
	[581][38] = 94,
	[582][38] = 95,
	[583][18] = 96,
	[583][38] = 96,
	[584][2] = 172,
	[584][3] = 172,
	[584][4] = 172,
	[584][7] = 172,
	[584][8] = 172,
	[584][9] = 172,
	[584][11] = 172,
	[584][18] = 172,
	[584][19] = 172,
	[584][20] = 172,
	[584][23] = 172,
	[584][37] = 172,
	[585][2] = 173,
	[585][3] = 173,
	[585][4] = 173,
	[585][5] = 173,
	[585][6] = 173,
	[585][16] = 173,
	[585][17] = 173,
	[585][18] = 173,
	[585][39] = 173,
	[585][40] = 173,
	[586][2] = 174,
	[586][3] = 174,
	[586][4] = 174,
	[586][5] = 174,
	[586][6] = 174,
	[586][16] = 174,
	[586][17] = 174,
	[586][18] = 174,
	[586][39] = 174,
	[586][40] = 174,
	[590][2] = 175,
	[590][3] = 175,
	[590][4] = 175,
	[590][5] = 175,
	[590][6] = 175,
	[590][16] = 175,
	[590][17] = 175,
	[590][18] = 175,
	[590][39] = 175,
	[590][40] = 175,
	[591][2] = 176,
	[591][3] = 176,
	[591][4] = 176,
	[591][5] = 176,
	[591][18] = 176,
	[591][39] = 176,
	[591][40] = 176,
	[592][2] = 177,
	[592][3] = 177,
	[592][4] = 177,
	[592][5] = 177,
	[592][16] = 177,
	[592][17] = 177,
	[592][18] = 177,
	[592][39] = 177,
	[592][40] = 177,
	[593][2] = 178,
	[593][3] = 178,
	[593][4] = 178,
	[593][5] = 178,
	[593][17] = 178,
	[593][18] = 178,
	[593][39] = 178,
	[593][40] = 178,
	[594][40] = 179,
	[595][2] = 180,
	[595][3] = 180,
	[595][4] = 180,
	[595][7] = 180,
	[595][8] = 180,
	[595][9] = 180,
	[595][11] = 180,
	[595][18] = 180,
	[595][19] = 180,
	[595][20] = 180,
	[595][23] = 180,
	[595][37] = 180,
	[596][2] = 181,
	[596][3] = 181,
	[596][4] = 181,
	[596][7] = 181,
	[596][8] = 181,
	[596][9] = 181,
	[596][18] = 181,
	[596][19] = 181,
	[596][20] = 181,
	[596][23] = 181,
	[597][2] = 182,
	[597][3] = 182,
	[597][4] = 182,
	[597][7] = 182,
	[597][8] = 182,
	[597][9] = 182,
	[597][18] = 182,
	[597][19] = 182,
	[597][20] = 182,
	[597][23] = 182,
	[599][2] = 183,
	[599][3] = 183,
	[599][4] = 183,
	[599][7] = 183,
	[599][8] = 183,
	[599][9] = 183,
	[599][18] = 183,
	[599][19] = 183,
	[599][20] = 183,
	[599][23] = 183,
	[602][2] = 184,
	[602][3] = 184,
	[602][4] = 184,
	[602][7] = 184,
	[602][8] = 184,
	[602][18] = 184,
	[602][23] = 184,
	[603][23] = 185,
	[604][18] = 186,
	[604][23] = 186,
	[605][2] = 187,
	[605][3] = 187,
	[605][4] = 187,
	[605][5] = 187,
	[605][6] = 187,
	[605][7] = 187,
	[605][8] = 187,
	[605][9] = 187,
	[605][10] = 187,
	[605][11] = 187,
	[605][12] = 187,
	[605][13] = 187,
	[605][14] = 187,
	[605][15] = 187,
	[605][54] = 187,
	[606][2] = 188,
	[606][3] = 188,
	[606][4] = 188,
	[606][7] = 188,
	[606][8] = 188,
	[606][11] = 188,
	[606][18] = 188,
	[606][23] = 188,
	[606][37] = 188,
	[607][2] = 189,
	[607][3] = 189,
	[607][4] = 189,
	[607][7] = 189,
	[607][8] = 189,
	[607][11] = 189,
	[607][18] = 189,
	[607][23] = 189,
	[607][37] = 189,
	[608][2] = 190,
	[608][3] = 190,
	[608][4] = 190,
	[608][7] = 190,
	[608][8] = 190,
	[608][11] = 190,
	[608][18] = 190,
	[608][23] = 190,
	[608][37] = 190,
	[610][18] = 191,
	[610][37] = 191,
	[611][2] = 192,
	[611][3] = 192,
	[611][4] = 192,
	[611][5] = 192,
	[611][6] = 192,
	[611][7] = 192,
	[611][8] = 192,
	[611][9] = 192,
	[611][10] = 192,
	[611][11] = 192,
	[611][12] = 192,
	[611][13] = 192,
	[611][14] = 192,
	[611][15] = 192,
	[611][54] = 192,
	[612][4] = 193,
	[612][6] = 193,
	[612][8] = 193,
	[612][9] = 193,
	[612][14] = 193,
	[612][16] = 193,
	[612][17] = 193,
	[612][18] = 193,
	[612][19] = 193,
	[612][20] = 193,
	[612][21] = 193,
	[612][22] = 193,
	[612][23] = 193,
	[612][24] = 193,
	[612][25] = 193,
	[612][26] = 193,
	[612][27] = 193,
	[612][28] = 193,
	[612][29] = 193,
	[612][30] = 193,
	[612][31] = 193,
	[612][32] = 193,
	[612][33] = 193,
	[612][34] = 193,
	[612][35] = 193,
	[612][36] = 193,
	[612][37] = 193,
	[614][4] = 194,
	[614][6] = 194,
	[614][8] = 194,
	[614][9] = 194,
	[614][14] = 194,
	[614][16] = 194,
	[614][17] = 194,
	[614][18] = 194,
	[614][19] = 194,
	[614][20] = 194,
	[614][21] = 194,
	[614][22] = 194,
	[614][23] = 194,
	[614][24] = 194,
	[614][25] = 194,
	[614][26] = 194,
	[614][27] = 194,
	[614][28] = 194,
	[614][29] = 194,
	[614][30] = 194,
	[614][31] = 194,
	[614][32] = 194,
	[614][33] = 194,
	[614][34] = 194,
	[614][35] = 194,
	[614][36] = 194,
	[614][37] = 194,
	[616][2] = 195,
	[616][3] = 195,
	[616][4] = 195,
	[616][5] = 195,
	[616][6] = 195,
	[616][7] = 195,
	[616][8] = 195,
	[616][9] = 195,
	[616][10] = 195,
	[616][11] = 195,
	[616][12] = 195,
	[616][13] = 195,
	[616][14] = 195,
	[616][15] = 195,
	[616][54] = 195,
	[617][2] = 181,
	[617][3] = 181,
	[617][4] = 181,
	[617][7] = 181,
	[617][8] = 181,
	[617][9] = 181,
	[617][18] = 181,
	[617][19] = 181,
	[617][20] = 181,
	[617][37] = 181,
	[618][2] = 182,
	[618][3] = 182,
	[618][4] = 182,
	[618][7] = 182,
	[618][8] = 182,
	[618][9] = 182,
	[618][18] = 182,
	[618][19] = 182,
	[618][20] = 182,
	[618][37] = 182,
	[620][2] = 183,
	[620][3] = 183,
	[620][4] = 183,
	[620][7] = 183,
	[620][8] = 183,
	[620][9] = 183,
	[620][18] = 183,
	[620][19] = 183,
	[620][20] = 183,
	[620][37] = 183,
	[623][2] = 184,
	[623][3] = 184,
	[623][4] = 184,
	[623][7] = 184,
	[623][8] = 184,
	[623][18] = 184,
	[623][37] = 184,
	[624][37] = 185,
	[625][18] = 186,
	[625][37] = 186,
	[627][2] = 196,
	[627][3] = 196,
	[627][4] = 196,
	[627][5] = 196,
	[627][6] = 196,
	[627][7] = 196,
	[627][8] = 196,
	[627][9] = 196,
	[627][10] = 196,
	[627][11] = 196,
	[627][12] = 196,
	[627][13] = 196,
	[627][14] = 196,
	[627][15] = 196,
	[627][54] = 196,
	[629][2] = 197,
	[629][3] = 197,
	[629][4] = 197,
	[629][5] = 197,
	[629][6] = 197,
	[629][7] = 197,
	[629][8] = 197,
	[629][9] = 197,
	[629][10] = 197,
	[629][11] = 197,
	[629][12] = 197,
	[629][13] = 197,
	[629][14] = 197,
	[629][15] = 197,
	[629][54] = 197,
	[630][2] = 198,
	[630][3] = 198,
	[630][4] = 198,
	[630][5] = 198,
	[630][6] = 198,
	[630][7] = 198,
	[630][8] = 198,
	[630][9] = 198,
	[630][10] = 198,
	[630][11] = 198,
	[630][12] = 198,
	[630][13] = 198,
	[630][14] = 198,
	[630][15] = 198,
	[630][54] = 198,
	[631][2] = 199,
	[631][3] = 199,
	[631][4] = 199,
	[631][5] = 199,
	[631][6] = 199,
	[631][7] = 199,
	[631][8] = 199,
	[631][9] = 199,
	[631][10] = 199,
	[631][11] = 199,
	[631][12] = 199,
	[631][13] = 199,
	[631][14] = 199,
	[631][15] = 199,
	[631][54] = 199,
	[632][38] = 98,
	[632][39] = 98,
	[632][55] = 98,
	[635][11] = 200,
	[635][55] = 200,
	[640][38] = 103,
	[640][39] = 103,
	[640][55] = 103,
	[641][11] = 201,
	[641][55] = 201,
	[645][39] = 202,
	[645][41] = 202,
	[646][39] = 98,
	[646][41] = 98,
	[646][55] = 98,
	[649][11] = 203,
	[651][11] = 204,
	[652][11] = 205,
	[656][39] = 103,
	[656][41] = 103,
	[656][55] = 103,
	[662][4] = 30,
	[662][6] = 30,
	[662][8] = 30,
	[662][9] = 30,
	[662][14] = 30,
	[662][16] = 30,
	[662][17] = 30,
	[662][18] = 30,
	[662][19] = 30,
	[662][20] = 30,
	[662][21] = 30,
	[662][22] = 30,
	[662][23] = 30,
	[662][24] = 30,
	[662][25] = 30,
	[662][26] = 30,
	[662][27] = 30,
	[662][28] = 30,
	[662][29] = 30,
	[662][30] = 30,
	[662][31] = 30,
	[662][32] = 30,
	[662][33] = 30,
	[662][34] = 30,
	[662][35] = 30,
	[662][36] = 30,
	[662][41] = 30,
	[665][6] = 31,
	[665][9] = 31,
	[665][14] = 31,
	[665][16] = 31,
	[665][17] = 31,
	[665][18] = 31,
	[665][19] = 31,
	[665][20] = 31,
	[665][22] = 31,
	[665][23] = 31,
	[665][24] = 31,
	[665][25] = 31,
	[665][26] = 31,
	[665][27] = 31,
	[665][28] = 31,
	[665][29] = 31,
	[665][30] = 31,
	[665][31] = 31,
	[665][32] = 31,
	[665][33] = 31,
	[665][34] = 31,
	[665][35] = 31,
	[665][36] = 31,
	[665][41] = 31,
	[666][6] = 32,
	[666][9] = 32,
	[666][14] = 32,
	[666][16] = 32,
	[666][17] = 32,
	[666][18] = 32,
	[666][19] = 32,
	[666][20] = 32,
	[666][22] = 32,
	[666][23] = 32,
	[666][24] = 32,
	[666][25] = 32,
	[666][26] = 32,
	[666][27] = 32,
	[666][28] = 32,
	[666][29] = 32,
	[666][30] = 32,
	[666][31] = 32,
	[666][32] = 32,
	[666][33] = 32,
	[666][34] = 32,
	[666][35] = 32,
	[666][36] = 32,
	[666][41] = 32,
	[668][4] = 33,
	[668][6] = 33,
	[668][8] = 33,
	[668][9] = 33,
	[668][14] = 33,
	[668][16] = 33,
	[668][17] = 33,
	[668][18] = 33,
	[668][19] = 33,
	[668][20] = 33,
	[668][21] = 33,
	[668][22] = 33,
	[668][23] = 33,
	[668][24] = 33,
	[668][25] = 33,
	[668][26] = 33,
	[668][27] = 33,
	[668][28] = 33,
	[668][29] = 33,
	[668][30] = 33,
	[668][31] = 33,
	[668][32] = 33,
	[668][33] = 33,
	[668][34] = 33,
	[668][35] = 33,
	[668][36] = 33,
	[668][41] = 33,
	[670][6] = 34,
	[670][9] = 34,
	[670][14] = 34,
	[670][16] = 34,
	[670][17] = 34,
	[670][18] = 34,
	[670][19] = 34,
	[670][20] = 34,
	[670][22] = 34,
	[670][23] = 34,
	[670][24] = 34,
	[670][25] = 34,
	[670][26] = 34,
	[670][27] = 34,
	[670][28] = 34,
	[670][29] = 34,
	[670][30] = 34,
	[670][31] = 34,
	[670][32] = 34,
	[670][33] = 34,
	[670][34] = 34,
	[670][35] = 34,
	[670][36] = 34,
	[670][41] = 34,
	[672][6] = 35,
	[672][9] = 35,
	[672][14] = 35,
	[672][16] = 35,
	[672][17] = 35,
	[672][18] = 35,
	[672][19] = 35,
	[672][20] = 35,
	[672][22] = 35,
	[672][23] = 35,
	[672][24] = 35,
	[672][25] = 35,
	[672][26] = 35,
	[672][27] = 35,
	[672][28] = 35,
	[672][29] = 35,
	[672][30] = 35,
	[672][31] = 35,
	[672][32] = 35,
	[672][33] = 35,
	[672][34] = 35,
	[672][35] = 35,
	[672][36] = 35,
	[672][41] = 35,
	[704][4] = 206,
	[704][6] = 206,
	[704][8] = 206,
	[704][9] = 206,
	[704][14] = 206,
	[704][16] = 206,
	[704][17] = 206,
	[704][18] = 206,
	[704][19] = 206,
	[704][20] = 206,
	[704][21] = 206,
	[704][22] = 206,
	[704][23] = 206,
	[704][24] = 206,
	[704][25] = 206,
	[704][26] = 206,
	[704][27] = 206,
	[704][28] = 206,
	[704][29] = 206,
	[704][30] = 206,
	[704][31] = 206,
	[704][32] = 206,
	[704][33] = 206,
	[704][34] = 206,
	[704][35] = 206,
	[704][36] = 206,
	[704][37] = 206,
	[706][4] = 207,
	[706][6] = 207,
	[706][8] = 207,
	[706][9] = 207,
	[706][14] = 207,
	[706][16] = 207,
	[706][17] = 207,
	[706][18] = 207,
	[706][19] = 207,
	[706][20] = 207,
	[706][21] = 207,
	[706][22] = 207,
	[706][23] = 207,
	[706][24] = 207,
	[706][25] = 207,
	[706][26] = 207,
	[706][27] = 207,
	[706][28] = 207,
	[706][29] = 207,
	[706][30] = 207,
	[706][31] = 207,
	[706][32] = 207,
	[706][33] = 207,
	[706][34] = 207,
	[706][35] = 207,
	[706][36] = 207,
	[706][37] = 207,
	[708][4] = 30,
	[708][6] = 30,
	[708][8] = 30,
	[708][9] = 30,
	[708][14] = 30,
	[708][16] = 30,
	[708][17] = 30,
	[708][18] = 30,
	[708][19] = 30,
	[708][20] = 30,
	[708][21] = 30,
	[708][22] = 30,
	[708][23] = 30,
	[708][24] = 30,
	[708][25] = 30,
	[708][26] = 30,
	[708][27] = 30,
	[708][28] = 30,
	[708][29] = 30,
	[708][30] = 30,
	[708][31] = 30,
	[708][32] = 30,
	[708][33] = 30,
	[708][34] = 30,
	[708][35] = 30,
	[708][36] = 30,
	[708][40] = 30,
	[711][6] = 31,
	[711][9] = 31,
	[711][14] = 31,
	[711][16] = 31,
	[711][17] = 31,
	[711][18] = 31,
	[711][19] = 31,
	[711][20] = 31,
	[711][22] = 31,
	[711][23] = 31,
	[711][24] = 31,
	[711][25] = 31,
	[711][26] = 31,
	[711][27] = 31,
	[711][28] = 31,
	[711][29] = 31,
	[711][30] = 31,
	[711][31] = 31,
	[711][32] = 31,
	[711][33] = 31,
	[711][34] = 31,
	[711][35] = 31,
	[711][36] = 31,
	[711][40] = 31,
	[712][6] = 32,
	[712][9] = 32,
	[712][14] = 32,
	[712][16] = 32,
	[712][17] = 32,
	[712][18] = 32,
	[712][19] = 32,
	[712][20] = 32,
	[712][22] = 32,
	[712][23] = 32,
	[712][24] = 32,
	[712][25] = 32,
	[712][26] = 32,
	[712][27] = 32,
	[712][28] = 32,
	[712][29] = 32,
	[712][30] = 32,
	[712][31] = 32,
	[712][32] = 32,
	[712][33] = 32,
	[712][34] = 32,
	[712][35] = 32,
	[712][36] = 32,
	[712][40] = 32,
	[714][4] = 33,
	[714][6] = 33,
	[714][8] = 33,
	[714][9] = 33,
	[714][14] = 33,
	[714][16] = 33,
	[714][17] = 33,
	[714][18] = 33,
	[714][19] = 33,
	[714][20] = 33,
	[714][21] = 33,
	[714][22] = 33,
	[714][23] = 33,
	[714][24] = 33,
	[714][25] = 33,
	[714][26] = 33,
	[714][27] = 33,
	[714][28] = 33,
	[714][29] = 33,
	[714][30] = 33,
	[714][31] = 33,
	[714][32] = 33,
	[714][33] = 33,
	[714][34] = 33,
	[714][35] = 33,
	[714][36] = 33,
	[714][40] = 33,
	[716][6] = 34,
	[716][9] = 34,
	[716][14] = 34,
	[716][16] = 34,
	[716][17] = 34,
	[716][18] = 34,
	[716][19] = 34,
	[716][20] = 34,
	[716][22] = 34,
	[716][23] = 34,
	[716][24] = 34,
	[716][25] = 34,
	[716][26] = 34,
	[716][27] = 34,
	[716][28] = 34,
	[716][29] = 34,
	[716][30] = 34,
	[716][31] = 34,
	[716][32] = 34,
	[716][33] = 34,
	[716][34] = 34,
	[716][35] = 34,
	[716][36] = 34,
	[716][40] = 34,
	[718][6] = 35,
	[718][9] = 35,
	[718][14] = 35,
	[718][16] = 35,
	[718][17] = 35,
	[718][18] = 35,
	[718][19] = 35,
	[718][20] = 35,
	[718][22] = 35,
	[718][23] = 35,
	[718][24] = 35,
	[718][25] = 35,
	[718][26] = 35,
	[718][27] = 35,
	[718][28] = 35,
	[718][29] = 35,
	[718][30] = 35,
	[718][31] = 35,
	[718][32] = 35,
	[718][33] = 35,
	[718][34] = 35,
	[718][35] = 35,
	[718][36] = 35,
	[718][40] = 35,
	[729][4] = 208,
	[729][6] = 208,
	[729][8] = 208,
	[729][9] = 208,
	[729][14] = 208,
	[729][16] = 208,
	[729][17] = 208,
	[729][18] = 208,
	[729][19] = 208,
	[729][20] = 208,
	[729][21] = 208,
	[729][22] = 208,
	[729][23] = 208,
	[729][24] = 208,
	[729][25] = 208,
	[729][26] = 208,
	[729][27] = 208,
	[729][28] = 208,
	[729][29] = 208,
	[729][30] = 208,
	[729][31] = 208,
	[729][32] = 208,
	[729][33] = 208,
	[729][34] = 208,
	[729][35] = 208,
	[729][36] = 208,
	[729][37] = 208,
	[749][4] = 166,
	[749][6] = 166,
	[749][8] = 166,
	[749][9] = 166,
	[749][14] = 166,
	[749][16] = 166,
	[749][17] = 166,
	[749][18] = 166,
	[749][19] = 166,
	[749][20] = 166,
	[749][21] = 166,
	[749][22] = 166,
	[749][23] = 166,
	[749][24] = 166,
	[749][25] = 166,
	[749][26] = 166,
	[749][27] = 166,
	[749][28] = 166,
	[749][29] = 166,
	[749][30] = 166,
	[749][31] = 166,
	[749][32] = 166,
	[749][33] = 166,
	[749][34] = 166,
	[749][35] = 166,
	[749][36] = 166,
	[749][38] = 166,
	[749][39] = 166,
	[751][4] = 167,
	[751][6] = 167,
	[751][8] = 167,
	[751][9] = 167,
	[751][14] = 167,
	[751][16] = 167,
	[751][17] = 167,
	[751][18] = 167,
	[751][19] = 167,
	[751][20] = 167,
	[751][21] = 167,
	[751][22] = 167,
	[751][23] = 167,
	[751][24] = 167,
	[751][25] = 167,
	[751][26] = 167,
	[751][27] = 167,
	[751][28] = 167,
	[751][29] = 167,
	[751][30] = 167,
	[751][31] = 167,
	[751][32] = 167,
	[751][33] = 167,
	[751][34] = 167,
	[751][35] = 167,
	[751][36] = 167,
	[751][38] = 167,
	[751][39] = 167,
	[752][4] = 209,
	[752][6] = 209,
	[752][8] = 209,
	[752][9] = 209,
	[752][14] = 209,
	[752][16] = 209,
	[752][17] = 209,
	[752][18] = 209,
	[752][19] = 209,
	[752][20] = 209,
	[752][21] = 209,
	[752][22] = 209,
	[752][23] = 209,
	[752][24] = 209,
	[752][25] = 209,
	[752][26] = 209,
	[752][27] = 209,
	[752][28] = 209,
	[752][29] = 209,
	[752][30] = 209,
	[752][31] = 209,
	[752][32] = 209,
	[752][33] = 209,
	[752][34] = 209,
	[752][35] = 209,
	[752][36] = 209,
	[752][37] = 209,
	[754][4] = 168,
	[754][6] = 168,
	[754][8] = 168,
	[754][9] = 168,
	[754][14] = 168,
	[754][16] = 168,
	[754][17] = 168,
	[754][18] = 168,
	[754][19] = 168,
	[754][20] = 168,
	[754][21] = 168,
	[754][22] = 168,
	[754][23] = 168,
	[754][24] = 168,
	[754][25] = 168,
	[754][26] = 168,
	[754][27] = 168,
	[754][28] = 168,
	[754][29] = 168,
	[754][30] = 168,
	[754][31] = 168,
	[754][32] = 168,
	[754][33] = 168,
	[754][34] = 168,
	[754][35] = 168,
	[754][36] = 168,
	[754][38] = 168,
	[754][39] = 168,
	[755][4] = 169,
	[755][6] = 169,
	[755][8] = 169,
	[755][9] = 169,
	[755][14] = 169,
	[755][16] = 169,
	[755][17] = 169,
	[755][18] = 169,
	[755][19] = 169,
	[755][20] = 169,
	[755][21] = 169,
	[755][22] = 169,
	[755][23] = 169,
	[755][24] = 169,
	[755][25] = 169,
	[755][26] = 169,
	[755][27] = 169,
	[755][28] = 169,
	[755][29] = 169,
	[755][30] = 169,
	[755][31] = 169,
	[755][32] = 169,
	[755][33] = 169,
	[755][34] = 169,
	[755][35] = 169,
	[755][36] = 169,
	[755][38] = 169,
	[755][39] = 169,
	[756][4] = 193,
	[756][6] = 193,
	[756][8] = 193,
	[756][9] = 193,
	[756][14] = 193,
	[756][16] = 193,
	[756][17] = 193,
	[756][18] = 193,
	[756][19] = 193,
	[756][20] = 193,
	[756][21] = 193,
	[756][22] = 193,
	[756][23] = 193,
	[756][24] = 193,
	[756][25] = 193,
	[756][26] = 193,
	[756][27] = 193,
	[756][28] = 193,
	[756][29] = 193,
	[756][30] = 193,
	[756][31] = 193,
	[756][32] = 193,
	[756][33] = 193,
	[756][34] = 193,
	[756][35] = 193,
	[756][36] = 193,
	[756][38] = 193,
	[756][39] = 193,
	[758][4] = 194,
	[758][6] = 194,
	[758][8] = 194,
	[758][9] = 194,
	[758][14] = 194,
	[758][16] = 194,
	[758][17] = 194,
	[758][18] = 194,
	[758][19] = 194,
	[758][20] = 194,
	[758][21] = 194,
	[758][22] = 194,
	[758][23] = 194,
	[758][24] = 194,
	[758][25] = 194,
	[758][26] = 194,
	[758][27] = 194,
	[758][28] = 194,
	[758][29] = 194,
	[758][30] = 194,
	[758][31] = 194,
	[758][32] = 194,
	[758][33] = 194,
	[758][34] = 194,
	[758][35] = 194,
	[758][36] = 194,
	[758][38] = 194,
	[758][39] = 194,
	[767][4] = 206,
	[767][6] = 206,
	[767][8] = 206,
	[767][9] = 206,
	[767][14] = 206,
	[767][16] = 206,
	[767][17] = 206,
	[767][18] = 206,
	[767][19] = 206,
	[767][20] = 206,
	[767][21] = 206,
	[767][22] = 206,
	[767][23] = 206,
	[767][24] = 206,
	[767][25] = 206,
	[767][26] = 206,
	[767][27] = 206,
	[767][28] = 206,
	[767][29] = 206,
	[767][30] = 206,
	[767][31] = 206,
	[767][32] = 206,
	[767][33] = 206,
	[767][34] = 206,
	[767][35] = 206,
	[767][36] = 206,
	[767][38] = 206,
	[767][39] = 206,
	[769][4] = 207,
	[769][6] = 207,
	[769][8] = 207,
	[769][9] = 207,
	[769][14] = 207,
	[769][16] = 207,
	[769][17] = 207,
	[769][18] = 207,
	[769][19] = 207,
	[769][20] = 207,
	[769][21] = 207,
	[769][22] = 207,
	[769][23] = 207,
	[769][24] = 207,
	[769][25] = 207,
	[769][26] = 207,
	[769][27] = 207,
	[769][28] = 207,
	[769][29] = 207,
	[769][30] = 207,
	[769][31] = 207,
	[769][32] = 207,
	[769][33] = 207,
	[769][34] = 207,
	[769][35] = 207,
	[769][36] = 207,
	[769][38] = 207,
	[769][39] = 207,
	[771][4] = 208,
	[771][6] = 208,
	[771][8] = 208,
	[771][9] = 208,
	[771][14] = 208,
	[771][16] = 208,
	[771][17] = 208,
	[771][18] = 208,
	[771][19] = 208,
	[771][20] = 208,
	[771][21] = 208,
	[771][22] = 208,
	[771][23] = 208,
	[771][24] = 208,
	[771][25] = 208,
	[771][26] = 208,
	[771][27] = 208,
	[771][28] = 208,
	[771][29] = 208,
	[771][30] = 208,
	[771][31] = 208,
	[771][32] = 208,
	[771][33] = 208,
	[771][34] = 208,
	[771][35] = 208,
	[771][36] = 208,
	[771][38] = 208,
	[771][39] = 208,
	[772][4] = 166,
	[772][6] = 166,
	[772][8] = 166,
	[772][9] = 166,
	[772][14] = 166,
	[772][16] = 166,
	[772][17] = 166,
	[772][18] = 166,
	[772][19] = 166,
	[772][20] = 166,
	[772][21] = 166,
	[772][22] = 166,
	[772][23] = 166,
	[772][24] = 166,
	[772][25] = 166,
	[772][26] = 166,
	[772][27] = 166,
	[772][28] = 166,
	[772][29] = 166,
	[772][30] = 166,
	[772][31] = 166,
	[772][32] = 166,
	[772][33] = 166,
	[772][34] = 166,
	[772][35] = 166,
	[772][36] = 166,
	[772][39] = 166,
	[772][40] = 166,
	[774][4] = 167,
	[774][6] = 167,
	[774][8] = 167,
	[774][9] = 167,
	[774][14] = 167,
	[774][16] = 167,
	[774][17] = 167,
	[774][18] = 167,
	[774][19] = 167,
	[774][20] = 167,
	[774][21] = 167,
	[774][22] = 167,
	[774][23] = 167,
	[774][24] = 167,
	[774][25] = 167,
	[774][26] = 167,
	[774][27] = 167,
	[774][28] = 167,
	[774][29] = 167,
	[774][30] = 167,
	[774][31] = 167,
	[774][32] = 167,
	[774][33] = 167,
	[774][34] = 167,
	[774][35] = 167,
	[774][36] = 167,
	[774][39] = 167,
	[774][40] = 167,
	[775][4] = 210,
	[775][6] = 210,
	[775][8] = 210,
	[775][9] = 210,
	[775][14] = 210,
	[775][16] = 210,
	[775][17] = 210,
	[775][18] = 210,
	[775][19] = 210,
	[775][20] = 210,
	[775][21] = 210,
	[775][22] = 210,
	[775][23] = 210,
	[775][24] = 210,
	[775][25] = 210,
	[775][26] = 210,
	[775][27] = 210,
	[775][28] = 210,
	[775][29] = 210,
	[775][30] = 210,
	[775][31] = 210,
	[775][32] = 210,
	[775][33] = 210,
	[775][34] = 210,
	[775][35] = 210,
	[775][36] = 210,
	[775][37] = 210,
	[777][4] = 168,
	[777][6] = 168,
	[777][8] = 168,
	[777][9] = 168,
	[777][14] = 168,
	[777][16] = 168,
	[777][17] = 168,
	[777][18] = 168,
	[777][19] = 168,
	[777][20] = 168,
	[777][21] = 168,
	[777][22] = 168,
	[777][23] = 168,
	[777][24] = 168,
	[777][25] = 168,
	[777][26] = 168,
	[777][27] = 168,
	[777][28] = 168,
	[777][29] = 168,
	[777][30] = 168,
	[777][31] = 168,
	[777][32] = 168,
	[777][33] = 168,
	[777][34] = 168,
	[777][35] = 168,
	[777][36] = 168,
	[777][39] = 168,
	[777][40] = 168,
	[778][4] = 169,
	[778][6] = 169,
	[778][8] = 169,
	[778][9] = 169,
	[778][14] = 169,
	[778][16] = 169,
	[778][17] = 169,
	[778][18] = 169,
	[778][19] = 169,
	[778][20] = 169,
	[778][21] = 169,
	[778][22] = 169,
	[778][23] = 169,
	[778][24] = 169,
	[778][25] = 169,
	[778][26] = 169,
	[778][27] = 169,
	[778][28] = 169,
	[778][29] = 169,
	[778][30] = 169,
	[778][31] = 169,
	[778][32] = 169,
	[778][33] = 169,
	[778][34] = 169,
	[778][35] = 169,
	[778][36] = 169,
	[778][39] = 169,
	[778][40] = 169,
	[779][4] = 193,
	[779][6] = 193,
	[779][8] = 193,
	[779][9] = 193,
	[779][14] = 193,
	[779][16] = 193,
	[779][17] = 193,
	[779][18] = 193,
	[779][19] = 193,
	[779][20] = 193,
	[779][21] = 193,
	[779][22] = 193,
	[779][23] = 193,
	[779][24] = 193,
	[779][25] = 193,
	[779][26] = 193,
	[779][27] = 193,
	[779][28] = 193,
	[779][29] = 193,
	[779][30] = 193,
	[779][31] = 193,
	[779][32] = 193,
	[779][33] = 193,
	[779][34] = 193,
	[779][35] = 193,
	[779][36] = 193,
	[779][39] = 193,
	[779][40] = 193,
	[781][4] = 194,
	[781][6] = 194,
	[781][8] = 194,
	[781][9] = 194,
	[781][14] = 194,
	[781][16] = 194,
	[781][17] = 194,
	[781][18] = 194,
	[781][19] = 194,
	[781][20] = 194,
	[781][21] = 194,
	[781][22] = 194,
	[781][23] = 194,
	[781][24] = 194,
	[781][25] = 194,
	[781][26] = 194,
	[781][27] = 194,
	[781][28] = 194,
	[781][29] = 194,
	[781][30] = 194,
	[781][31] = 194,
	[781][32] = 194,
	[781][33] = 194,
	[781][34] = 194,
	[781][35] = 194,
	[781][36] = 194,
	[781][39] = 194,
	[781][40] = 194,
	[790][4] = 206,
	[790][6] = 206,
	[790][8] = 206,
	[790][9] = 206,
	[790][14] = 206,
	[790][16] = 206,
	[790][17] = 206,
	[790][18] = 206,
	[790][19] = 206,
	[790][20] = 206,
	[790][21] = 206,
	[790][22] = 206,
	[790][23] = 206,
	[790][24] = 206,
	[790][25] = 206,
	[790][26] = 206,
	[790][27] = 206,
	[790][28] = 206,
	[790][29] = 206,
	[790][30] = 206,
	[790][31] = 206,
	[790][32] = 206,
	[790][33] = 206,
	[790][34] = 206,
	[790][35] = 206,
	[790][36] = 206,
	[790][39] = 206,
	[790][40] = 206,
	[792][4] = 207,
	[792][6] = 207,
	[792][8] = 207,
	[792][9] = 207,
	[792][14] = 207,
	[792][16] = 207,
	[792][17] = 207,
	[792][18] = 207,
	[792][19] = 207,
	[792][20] = 207,
	[792][21] = 207,
	[792][22] = 207,
	[792][23] = 207,
	[792][24] = 207,
	[792][25] = 207,
	[792][26] = 207,
	[792][27] = 207,
	[792][28] = 207,
	[792][29] = 207,
	[792][30] = 207,
	[792][31] = 207,
	[792][32] = 207,
	[792][33] = 207,
	[792][34] = 207,
	[792][35] = 207,
	[792][36] = 207,
	[792][39] = 207,
	[792][40] = 207,
	[794][4] = 208,
	[794][6] = 208,
	[794][8] = 208,
	[794][9] = 208,
	[794][14] = 208,
	[794][16] = 208,
	[794][17] = 208,
	[794][18] = 208,
	[794][19] = 208,
	[794][20] = 208,
	[794][21] = 208,
	[794][22] = 208,
	[794][23] = 208,
	[794][24] = 208,
	[794][25] = 208,
	[794][26] = 208,
	[794][27] = 208,
	[794][28] = 208,
	[794][29] = 208,
	[794][30] = 208,
	[794][31] = 208,
	[794][32] = 208,
	[794][33] = 208,
	[794][34] = 208,
	[794][35] = 208,
	[794][36] = 208,
	[794][39] = 208,
	[794][40] = 208,
	[795][2] = 211,
	[795][3] = 211,
	[795][4] = 211,
	[795][7] = 211,
	[795][8] = 211,
	[795][9] = 211,
	[795][11] = 211,
	[795][18] = 211,
	[795][19] = 211,
	[795][20] = 211,
	[795][23] = 211,
	[795][37] = 211,
	[796][2] = 212,
	[796][3] = 212,
	[796][4] = 212,
	[796][7] = 212,
	[796][8] = 212,
	[796][9] = 212,
	[796][11] = 212,
	[796][18] = 212,
	[796][19] = 212,
	[796][20] = 212,
	[796][23] = 212,
	[796][37] = 212,
	[797][2] = 213,
	[797][3] = 213,
	[797][4] = 213,
	[797][7] = 213,
	[797][8] = 213,
	[797][9] = 213,
	[797][11] = 213,
	[797][18] = 213,
	[797][19] = 213,
	[797][20] = 213,
	[797][23] = 213,
	[797][37] = 213,
	[798][2] = 214,
	[798][3] = 214,
	[798][4] = 214,
	[798][7] = 214,
	[798][8] = 214,
	[798][9] = 214,
	[798][11] = 214,
	[798][18] = 214,
	[798][19] = 214,
	[798][20] = 214,
	[798][23] = 214,
	[798][37] = 214,
	[799][2] = 170,
	[799][3] = 170,
	[799][4] = 170,
	[799][7] = 170,
	[799][8] = 170,
	[799][9] = 170,
	[799][11] = 170,
	[799][18] = 170,
	[799][19] = 170,
	[799][20] = 170,
	[799][23] = 170,
	[799][38] = 170,
	[800][2] = 171,
	[800][3] = 171,
	[800][4] = 171,
	[800][7] = 171,
	[800][8] = 171,
	[800][9] = 171,
	[800][11] = 171,
	[800][18] = 171,
	[800][19] = 171,
	[800][20] = 171,
	[800][23] = 171,
	[800][38] = 171,
	[802][2] = 172,
	[802][3] = 172,
	[802][4] = 172,
	[802][7] = 172,
	[802][8] = 172,
	[802][9] = 172,
	[802][11] = 172,
	[802][18] = 172,
	[802][19] = 172,
	[802][20] = 172,
	[802][23] = 172,
	[802][38] = 172,
	[804][2] = 180,
	[804][3] = 180,
	[804][4] = 180,
	[804][7] = 180,
	[804][8] = 180,
	[804][9] = 180,
	[804][11] = 180,
	[804][18] = 180,
	[804][19] = 180,
	[804][20] = 180,
	[804][23] = 180,
	[804][38] = 180,
	[806][2] = 215,
	[806][3] = 215,
	[806][4] = 215,
	[806][7] = 215,
	[806][8] = 215,
	[806][9] = 215,
	[806][11] = 215,
	[806][18] = 215,
	[806][19] = 215,
	[806][20] = 215,
	[806][23] = 215,
	[806][37] = 215,
	[807][2] = 188,
	[807][3] = 188,
	[807][4] = 188,
	[807][7] = 188,
	[807][8] = 188,
	[807][11] = 188,
	[807][18] = 188,
	[807][23] = 188,
	[807][38] = 188,
	[808][2] = 189,
	[808][3] = 189,
	[808][4] = 189,
	[808][7] = 189,
	[808][8] = 189,
	[808][11] = 189,
	[808][18] = 189,
	[808][23] = 189,
	[808][38] = 189,
	[809][2] = 190,
	[809][3] = 190,
	[809][4] = 190,
	[809][7] = 190,
	[809][8] = 190,
	[809][11] = 190,
	[809][18] = 190,
	[809][23] = 190,
	[809][38] = 190,
	[811][18] = 191,
	[811][38] = 191,
	[812][2] = 216,
	[812][3] = 216,
	[812][4] = 216,
	[812][7] = 216,
	[812][8] = 216,
	[812][9] = 216,
	[812][11] = 216,
	[812][18] = 216,
	[812][19] = 216,
	[812][20] = 216,
	[812][23] = 216,
	[812][37] = 216,
	[813][2] = 217,
	[813][3] = 217,
	[813][4] = 217,
	[813][7] = 217,
	[813][8] = 217,
	[813][9] = 217,
	[813][11] = 217,
	[813][18] = 217,
	[813][19] = 217,
	[813][20] = 217,
	[813][23] = 217,
	[813][37] = 217,
	[814][2] = 173,
	[814][3] = 173,
	[814][4] = 173,
	[814][5] = 173,
	[814][6] = 173,
	[814][16] = 173,
	[814][17] = 173,
	[814][18] = 173,
	[814][38] = 173,
	[814][39] = 173,
	[815][2] = 174,
	[815][3] = 174,
	[815][4] = 174,
	[815][5] = 174,
	[815][6] = 174,
	[815][16] = 174,
	[815][17] = 174,
	[815][18] = 174,
	[815][38] = 174,
	[815][39] = 174,
	[819][2] = 175,
	[819][3] = 175,
	[819][4] = 175,
	[819][5] = 175,
	[819][6] = 175,
	[819][16] = 175,
	[819][17] = 175,
	[819][18] = 175,
	[819][38] = 175,
	[819][39] = 175,
	[820][2] = 176,
	[820][3] = 176,
	[820][4] = 176,
	[820][5] = 176,
	[820][18] = 176,
	[820][38] = 176,
	[820][39] = 176,
	[821][2] = 177,
	[821][3] = 177,
	[821][4] = 177,
	[821][5] = 177,
	[821][16] = 177,
	[821][17] = 177,
	[821][18] = 177,
	[821][38] = 177,
	[821][39] = 177,
	[822][2] = 178,
	[822][3] = 178,
	[822][4] = 178,
	[822][5] = 178,
	[822][17] = 178,
	[822][18] = 178,
	[822][38] = 178,
	[822][39] = 178,
	[823][38] = 179,
	[824][2] = 218,
	[824][3] = 218,
	[824][4] = 218,
	[824][5] = 218,
	[824][6] = 218,
	[824][16] = 218,
	[824][17] = 218,
	[824][18] = 218,
	[824][39] = 218,
	[824][40] = 218,
	[825][2] = 219,
	[825][3] = 219,
	[825][4] = 219,
	[825][7] = 219,
	[825][8] = 219,
	[825][9] = 219,
	[825][11] = 219,
	[825][18] = 219,
	[825][19] = 219,
	[825][20] = 219,
	[825][23] = 219,
	[825][37] = 219,
	[831][40] = 220,
	[832][2] = 221,
	[832][3] = 221,
	[832][4] = 221,
	[832][7] = 221,
	[832][8] = 221,
	[832][9] = 221,
	[832][11] = 221,
	[832][18] = 221,
	[832][19] = 221,
	[832][20] = 221,
	[832][23] = 221,
	[832][37] = 221,
	[833][2] = 222,
	[833][3] = 222,
	[833][4] = 222,
	[833][7] = 222,
	[833][8] = 222,
	[833][9] = 222,
	[833][11] = 222,
	[833][18] = 222,
	[833][19] = 222,
	[833][20] = 222,
	[833][23] = 222,
	[833][37] = 222,
	[834][2] = 181,
	[834][3] = 181,
	[834][4] = 181,
	[834][7] = 181,
	[834][8] = 181,
	[834][9] = 181,
	[834][18] = 181,
	[834][19] = 181,
	[834][20] = 181,
	[834][38] = 181,
	[835][2] = 182,
	[835][3] = 182,
	[835][4] = 182,
	[835][7] = 182,
	[835][8] = 182,
	[835][9] = 182,
	[835][18] = 182,
	[835][19] = 182,
	[835][20] = 182,
	[835][38] = 182,
	[837][2] = 183,
	[837][3] = 183,
	[837][4] = 183,
	[837][7] = 183,
	[837][8] = 183,
	[837][9] = 183,
	[837][18] = 183,
	[837][19] = 183,
	[837][20] = 183,
	[837][38] = 183,
	[840][2] = 184,
	[840][3] = 184,
	[840][4] = 184,
	[840][7] = 184,
	[840][8] = 184,
	[840][18] = 184,
	[840][38] = 184,
	[841][38] = 185,
	[842][18] = 186,
	[842][38] = 186,
	[844][2] = 223,
	[844][3] = 223,
	[844][4] = 223,
	[844][7] = 223,
	[844][8] = 223,
	[844][9] = 223,
	[844][11] = 223,
	[844][18] = 223,
	[844][19] = 223,
	[844][20] = 223,
	[844][23] = 223,
	[844][37] = 223,
	[845][2] = 224,
	[845][3] = 224,
	[845][4] = 224,
	[845][7] = 224,
	[845][8] = 224,
	[845][18] = 224,
	[845][23] = 224,
	[846][2] = 225,
	[846][3] = 225,
	[846][4] = 225,
	[846][7] = 225,
	[846][8] = 225,
	[846][18] = 225,
	[846][23] = 225,
	[847][2] = 226,
	[847][3] = 226,
	[847][4] = 226,
	[847][7] = 226,
	[847][8] = 226,
	[847][18] = 226,
	[847][23] = 226,
	[849][18] = 227,
	[849][23] = 227,
	[850][37] = 228,
	[851][37] = 229,
	[852][18] = 230,
	[852][37] = 230,
	[853][18] = 231,
	[853][37] = 231,
	[854][4] = 232,
	[854][6] = 232,
	[854][8] = 232,
	[854][9] = 232,
	[854][14] = 232,
	[854][16] = 232,
	[854][17] = 232,
	[854][18] = 232,
	[854][19] = 232,
	[854][20] = 232,
	[854][21] = 232,
	[854][22] = 232,
	[854][23] = 232,
	[854][24] = 232,
	[854][25] = 232,
	[854][26] = 232,
	[854][27] = 232,
	[854][28] = 232,
	[854][29] = 232,
	[854][30] = 232,
	[854][31] = 232,
	[854][32] = 232,
	[854][33] = 232,
	[854][34] = 232,
	[854][35] = 232,
	[854][36] = 232,
	[854][37] = 232,
	[856][4] = 233,
	[856][6] = 233,
	[856][8] = 233,
	[856][9] = 233,
	[856][14] = 233,
	[856][16] = 233,
	[856][17] = 233,
	[856][18] = 233,
	[856][19] = 233,
	[856][20] = 233,
	[856][21] = 233,
	[856][22] = 233,
	[856][23] = 233,
	[856][24] = 233,
	[856][25] = 233,
	[856][26] = 233,
	[856][27] = 233,
	[856][28] = 233,
	[856][29] = 233,
	[856][30] = 233,
	[856][31] = 233,
	[856][32] = 233,
	[856][33] = 233,
	[856][34] = 233,
	[856][35] = 233,
	[856][36] = 233,
	[856][37] = 233,
	[859][2] = 234,
	[859][3] = 234,
	[859][4] = 234,
	[859][5] = 234,
	[859][6] = 234,
	[859][7] = 234,
	[859][8] = 234,
	[859][9] = 234,
	[859][10] = 234,
	[859][11] = 234,
	[859][12] = 234,
	[859][13] = 234,
	[859][14] = 234,
	[859][15] = 234,
	[859][54] = 234,
	[860][2] = 224,
	[860][3] = 224,
	[860][4] = 224,
	[860][7] = 224,
	[860][8] = 224,
	[860][18] = 224,
	[860][37] = 224,
	[861][2] = 225,
	[861][3] = 225,
	[861][4] = 225,
	[861][7] = 225,
	[861][8] = 225,
	[861][18] = 225,
	[861][37] = 225,
	[862][2] = 226,
	[862][3] = 226,
	[862][4] = 226,
	[862][7] = 226,
	[862][8] = 226,
	[862][18] = 226,
	[862][37] = 226,
	[864][18] = 227,
	[864][37] = 227,
	[865][2] = 235,
	[865][3] = 235,
	[865][4] = 235,
	[865][5] = 235,
	[865][6] = 235,
	[865][7] = 235,
	[865][8] = 235,
	[865][9] = 235,
	[865][10] = 235,
	[865][11] = 235,
	[865][12] = 235,
	[865][13] = 235,
	[865][14] = 235,
	[865][15] = 235,
	[865][54] = 235,
	[866][2] = 236,
	[866][3] = 236,
	[866][4] = 236,
	[866][5] = 236,
	[866][6] = 236,
	[866][7] = 236,
	[866][8] = 236,
	[866][9] = 236,
	[866][10] = 236,
	[866][11] = 236,
	[866][12] = 236,
	[866][13] = 236,
	[866][14] = 236,
	[866][15] = 236,
	[866][54] = 236,
	[867][38] = 200,
	[867][39] = 200,
	[867][55] = 200,
	[869][38] = 201,
	[869][39] = 201,
	[869][55] = 201,
	[871][11] = 237,
	[871][55] = 237,
	[873][38] = 203,
	[873][39] = 203,
	[875][38] = 204,
	[875][39] = 204,
	[876][38] = 205,
	[876][39] = 205,
	[879][11] = 238,
	[879][55] = 238,
	[880][34] = 239,
	[880][35] = 239,
	[880][36] = 239,
	[880][37] = 239,
	[881][34] = 240,
	[881][35] = 240,
	[881][36] = 240,
	[881][37] = 240,
	[882][39] = 200,
	[882][41] = 200,
	[882][55] = 200,
	[884][39] = 201,
	[884][41] = 201,
	[884][55] = 201,
	[888][39] = 203,
	[888][41] = 203,
	[890][39] = 204,
	[890][41] = 204,
	[891][39] = 205,
	[891][41] = 205,
	[894][11] = 241,
	[895][11] = 242,
	[896][34] = 243,
	[896][35] = 243,
	[896][36] = 243,
	[896][37] = 243,
	[897][34] = 244,
	[897][35] = 244,
	[897][36] = 244,
	[897][37] = 244,
	[898][37] = 245,
	[899][4] = 86,
	[899][6] = 86,
	[899][8] = 86,
	[899][9] = 86,
	[899][14] = 86,
	[899][16] = 86,
	[899][17] = 86,
	[899][18] = 86,
	[899][19] = 86,
	[899][20] = 86,
	[899][21] = 86,
	[899][22] = 86,
	[899][23] = 86,
	[899][24] = 86,
	[899][25] = 86,
	[899][26] = 86,
	[899][27] = 86,
	[899][28] = 86,
	[899][29] = 86,
	[899][30] = 86,
	[899][31] = 86,
	[899][32] = 86,
	[899][33] = 86,
	[899][34] = 86,
	[899][35] = 86,
	[899][36] = 86,
	[899][41] = 86,
	[901][4] = 87,
	[901][6] = 87,
	[901][8] = 87,
	[901][9] = 87,
	[901][14] = 87,
	[901][16] = 87,
	[901][17] = 87,
	[901][18] = 87,
	[901][19] = 87,
	[901][20] = 87,
	[901][21] = 87,
	[901][22] = 87,
	[901][23] = 87,
	[901][24] = 87,
	[901][25] = 87,
	[901][26] = 87,
	[901][27] = 87,
	[901][28] = 87,
	[901][29] = 87,
	[901][30] = 87,
	[901][31] = 87,
	[901][32] = 87,
	[901][33] = 87,
	[901][34] = 87,
	[901][35] = 87,
	[901][36] = 87,
	[901][41] = 87,
	[903][4] = 88,
	[903][6] = 88,
	[903][8] = 88,
	[903][9] = 88,
	[903][14] = 88,
	[903][16] = 88,
	[903][17] = 88,
	[903][18] = 88,
	[903][19] = 88,
	[903][20] = 88,
	[903][21] = 88,
	[903][22] = 88,
	[903][23] = 88,
	[903][24] = 88,
	[903][25] = 88,
	[903][26] = 88,
	[903][27] = 88,
	[903][28] = 88,
	[903][29] = 88,
	[903][30] = 88,
	[903][31] = 88,
	[903][32] = 88,
	[903][33] = 88,
	[903][34] = 88,
	[903][35] = 88,
	[903][36] = 88,
	[903][41] = 88,
	[906][4] = 89,
	[906][6] = 89,
	[906][8] = 89,
	[906][9] = 89,
	[906][14] = 89,
	[906][16] = 89,
	[906][17] = 89,
	[906][18] = 89,
	[906][19] = 89,
	[906][20] = 89,
	[906][21] = 89,
	[906][22] = 89,
	[906][23] = 89,
	[906][24] = 89,
	[906][25] = 89,
	[906][26] = 89,
	[906][27] = 89,
	[906][28] = 89,
	[906][29] = 89,
	[906][30] = 89,
	[906][31] = 89,
	[906][32] = 89,
	[906][33] = 89,
	[906][34] = 89,
	[906][35] = 89,
	[906][36] = 89,
	[906][41] = 89,
	[907][4] = 97,
	[907][6] = 97,
	[907][8] = 97,
	[907][9] = 97,
	[907][14] = 97,
	[907][16] = 97,
	[907][17] = 97,
	[907][18] = 97,
	[907][19] = 97,
	[907][20] = 97,
	[907][21] = 97,
	[907][22] = 97,
	[907][23] = 97,
	[907][24] = 97,
	[907][25] = 97,
	[907][26] = 97,
	[907][27] = 97,
	[907][28] = 97,
	[907][29] = 97,
	[907][30] = 97,
	[907][31] = 97,
	[907][32] = 97,
	[907][33] = 97,
	[907][34] = 97,
	[907][35] = 97,
	[907][36] = 97,
	[907][41] = 97,
	[910][34] = 100,
	[910][35] = 100,
	[910][36] = 100,
	[910][41] = 100,
	[912][34] = 101,
	[912][35] = 101,
	[912][36] = 101,
	[912][41] = 101,
	[913][34] = 102,
	[913][35] = 102,
	[913][36] = 102,
	[913][41] = 102,
	[915][6] = 104,
	[915][9] = 104,
	[915][16] = 104,
	[915][17] = 104,
	[915][18] = 104,
	[915][19] = 104,
	[915][24] = 104,
	[915][25] = 104,
	[915][26] = 104,
	[915][27] = 104,
	[915][28] = 104,
	[915][29] = 104,
	[915][30] = 104,
	[915][31] = 104,
	[915][32] = 104,
	[915][33] = 104,
	[915][34] = 104,
	[915][35] = 104,
	[915][36] = 104,
	[915][41] = 104,
	[916][6] = 105,
	[916][9] = 105,
	[916][16] = 105,
	[916][17] = 105,
	[916][18] = 105,
	[916][19] = 105,
	[916][24] = 105,
	[916][25] = 105,
	[916][26] = 105,
	[916][27] = 105,
	[916][28] = 105,
	[916][29] = 105,
	[916][30] = 105,
	[916][31] = 105,
	[916][32] = 105,
	[916][33] = 105,
	[916][34] = 105,
	[916][35] = 105,
	[916][36] = 105,
	[916][41] = 105,
	[917][16] = 106,
	[917][17] = 106,
	[917][18] = 106,
	[917][19] = 106,
	[917][32] = 106,
	[917][33] = 106,
	[917][34] = 106,
	[917][35] = 106,
	[917][36] = 106,
	[917][41] = 106,
	[918][16] = 113,
	[918][17] = 113,
	[918][18] = 113,
	[918][19] = 113,
	[918][30] = 113,
	[918][31] = 113,
	[918][32] = 113,
	[918][33] = 113,
	[918][34] = 113,
	[918][35] = 113,
	[918][36] = 113,
	[918][41] = 113,
	[919][16] = 114,
	[919][17] = 114,
	[919][18] = 114,
	[919][19] = 114,
	[919][30] = 114,
	[919][31] = 114,
	[919][32] = 114,
	[919][33] = 114,
	[919][34] = 114,
	[919][35] = 114,
	[919][36] = 114,
	[919][41] = 114,
	[920][17] = 115,
	[920][18] = 115,
	[920][19] = 115,
	[920][32] = 115,
	[920][33] = 115,
	[920][34] = 115,
	[920][35] = 115,
	[920][36] = 115,
	[920][41] = 115,
	[921][6] = 116,
	[921][9] = 116,
	[921][14] = 116,
	[921][16] = 116,
	[921][17] = 116,
	[921][18] = 116,
	[921][19] = 116,
	[921][20] = 116,
	[921][22] = 116,
	[921][23] = 116,
	[921][24] = 116,
	[921][25] = 116,
	[921][26] = 116,
	[921][27] = 116,
	[921][28] = 116,
	[921][29] = 116,
	[921][30] = 116,
	[921][31] = 116,
	[921][32] = 116,
	[921][33] = 116,
	[921][34] = 116,
	[921][35] = 116,
	[921][36] = 116,
	[921][41] = 116,
	[922][34] = 246,
	[922][35] = 246,
	[922][36] = 246,
	[922][37] = 246,
	[923][41] = 123,
	[924][41] = 124,
	[925][18] = 125,
	[925][19] = 125,
	[925][32] = 125,
	[925][33] = 125,
	[925][34] = 125,
	[925][35] = 125,
	[925][36] = 125,
	[925][41] = 125,
	[926][35] = 126,
	[926][36] = 126,
	[926][41] = 126,
	[927][19] = 127,
	[927][32] = 127,
	[927][33] = 127,
	[927][34] = 127,
	[927][35] = 127,
	[927][36] = 127,
	[927][41] = 127,
	[929][19] = 128,
	[929][33] = 128,
	[929][34] = 128,
	[929][35] = 128,
	[929][36] = 128,
	[929][41] = 128,
	[930][6] = 129,
	[930][9] = 129,
	[930][14] = 129,
	[930][16] = 129,
	[930][17] = 129,
	[930][18] = 129,
	[930][19] = 129,
	[930][20] = 129,
	[930][23] = 129,
	[930][24] = 129,
	[930][25] = 129,
	[930][26] = 129,
	[930][27] = 129,
	[930][28] = 129,
	[930][29] = 129,
	[930][30] = 129,
	[930][31] = 129,
	[930][32] = 129,
	[930][33] = 129,
	[930][34] = 129,
	[930][35] = 129,
	[930][36] = 129,
	[930][41] = 129,
	[931][6] = 130,
	[931][9] = 130,
	[931][14] = 130,
	[931][16] = 130,
	[931][17] = 130,
	[931][18] = 130,
	[931][19] = 130,
	[931][20] = 130,
	[931][23] = 130,
	[931][24] = 130,
	[931][25] = 130,
	[931][26] = 130,
	[931][27] = 130,
	[931][28] = 130,
	[931][29] = 130,
	[931][30] = 130,
	[931][31] = 130,
	[931][32] = 130,
	[931][33] = 130,
	[931][34] = 130,
	[931][35] = 130,
	[931][36] = 130,
	[931][41] = 130,
	[932][6] = 131,
	[932][9] = 131,
	[932][14] = 131,
	[932][16] = 131,
	[932][17] = 131,
	[932][18] = 131,
	[932][19] = 131,
	[932][20] = 131,
	[932][23] = 131,
	[932][24] = 131,
	[932][25] = 131,
	[932][26] = 131,
	[932][27] = 131,
	[932][28] = 131,
	[932][29] = 131,
	[932][30] = 131,
	[932][31] = 131,
	[932][32] = 131,
	[932][33] = 131,
	[932][34] = 131,
	[932][35] = 131,
	[932][36] = 131,
	[932][41] = 131,
	[933][36] = 132,
	[933][41] = 132,
	[934][36] = 133,
	[934][41] = 133,
	[935][4] = 134,
	[935][6] = 134,
	[935][8] = 134,
	[935][9] = 134,
	[935][14] = 134,
	[935][16] = 134,
	[935][17] = 134,
	[935][18] = 134,
	[935][19] = 134,
	[935][20] = 134,
	[935][21] = 134,
	[935][22] = 134,
	[935][23] = 134,
	[935][24] = 134,
	[935][25] = 134,
	[935][26] = 134,
	[935][27] = 134,
	[935][28] = 134,
	[935][29] = 134,
	[935][30] = 134,
	[935][31] = 134,
	[935][32] = 134,
	[935][33] = 134,
	[935][34] = 134,
	[935][35] = 134,
	[935][36] = 134,
	[935][41] = 134,
	[939][4] = 135,
	[939][6] = 135,
	[939][8] = 135,
	[939][9] = 135,
	[939][14] = 135,
	[939][16] = 135,
	[939][17] = 135,
	[939][18] = 135,
	[939][19] = 135,
	[939][20] = 135,
	[939][21] = 135,
	[939][22] = 135,
	[939][23] = 135,
	[939][24] = 135,
	[939][25] = 135,
	[939][26] = 135,
	[939][27] = 135,
	[939][28] = 135,
	[939][29] = 135,
	[939][30] = 135,
	[939][31] = 135,
	[939][32] = 135,
	[939][33] = 135,
	[939][34] = 135,
	[939][35] = 135,
	[939][36] = 135,
	[939][41] = 135,
	[940][16] = 136,
	[940][17] = 136,
	[940][18] = 136,
	[940][19] = 136,
	[940][26] = 136,
	[940][27] = 136,
	[940][28] = 136,
	[940][29] = 136,
	[940][30] = 136,
	[940][31] = 136,
	[940][32] = 136,
	[940][33] = 136,
	[940][34] = 136,
	[940][35] = 136,
	[940][36] = 136,
	[940][41] = 136,
	[941][16] = 137,
	[941][17] = 137,
	[941][18] = 137,
	[941][19] = 137,
	[941][26] = 137,
	[941][27] = 137,
	[941][28] = 137,
	[941][29] = 137,
	[941][30] = 137,
	[941][31] = 137,
	[941][32] = 137,
	[941][33] = 137,
	[941][34] = 137,
	[941][35] = 137,
	[941][36] = 137,
	[941][41] = 137,
	[942][16] = 138,
	[942][17] = 138,
	[942][18] = 138,
	[942][19] = 138,
	[942][26] = 138,
	[942][27] = 138,
	[942][28] = 138,
	[942][29] = 138,
	[942][30] = 138,
	[942][31] = 138,
	[942][32] = 138,
	[942][33] = 138,
	[942][34] = 138,
	[942][35] = 138,
	[942][36] = 138,
	[942][41] = 138,
	[943][16] = 139,
	[943][17] = 139,
	[943][18] = 139,
	[943][19] = 139,
	[943][26] = 139,
	[943][27] = 139,
	[943][28] = 139,
	[943][29] = 139,
	[943][30] = 139,
	[943][31] = 139,
	[943][32] = 139,
	[943][33] = 139,
	[943][34] = 139,
	[943][35] = 139,
	[943][36] = 139,
	[943][41] = 139,
	[944][16] = 140,
	[944][17] = 140,
	[944][18] = 140,
	[944][19] = 140,
	[944][24] = 140,
	[944][25] = 140,
	[944][26] = 140,
	[944][27] = 140,
	[944][28] = 140,
	[944][29] = 140,
	[944][30] = 140,
	[944][31] = 140,
	[944][32] = 140,
	[944][33] = 140,
	[944][34] = 140,
	[944][35] = 140,
	[944][36] = 140,
	[944][41] = 140,
	[945][16] = 141,
	[945][17] = 141,
	[945][18] = 141,
	[945][19] = 141,
	[945][24] = 141,
	[945][25] = 141,
	[945][26] = 141,
	[945][27] = 141,
	[945][28] = 141,
	[945][29] = 141,
	[945][30] = 141,
	[945][31] = 141,
	[945][32] = 141,
	[945][33] = 141,
	[945][34] = 141,
	[945][35] = 141,
	[945][36] = 141,
	[945][41] = 141,
	[946][36] = 247,
	[946][37] = 247,
	[947][4] = 248,
	[947][6] = 248,
	[947][8] = 248,
	[947][9] = 248,
	[947][14] = 248,
	[947][16] = 248,
	[947][17] = 248,
	[947][18] = 248,
	[947][19] = 248,
	[947][20] = 248,
	[947][21] = 248,
	[947][22] = 248,
	[947][23] = 248,
	[947][24] = 248,
	[947][25] = 248,
	[947][26] = 248,
	[947][27] = 248,
	[947][28] = 248,
	[947][29] = 248,
	[947][30] = 248,
	[947][31] = 248,
	[947][32] = 248,
	[947][33] = 248,
	[947][34] = 248,
	[947][35] = 248,
	[947][36] = 248,
	[947][37] = 248,
	[949][4] = 249,
	[949][6] = 249,
	[949][8] = 249,
	[949][9] = 249,
	[949][14] = 249,
	[949][16] = 249,
	[949][17] = 249,
	[949][18] = 249,
	[949][19] = 249,
	[949][20] = 249,
	[949][21] = 249,
	[949][22] = 249,
	[949][23] = 249,
	[949][24] = 249,
	[949][25] = 249,
	[949][26] = 249,
	[949][27] = 249,
	[949][28] = 249,
	[949][29] = 249,
	[949][30] = 249,
	[949][31] = 249,
	[949][32] = 249,
	[949][33] = 249,
	[949][34] = 249,
	[949][35] = 249,
	[949][36] = 249,
	[949][37] = 249,
	[950][4] = 86,
	[950][6] = 86,
	[950][8] = 86,
	[950][9] = 86,
	[950][14] = 86,
	[950][16] = 86,
	[950][17] = 86,
	[950][18] = 86,
	[950][19] = 86,
	[950][20] = 86,
	[950][21] = 86,
	[950][22] = 86,
	[950][23] = 86,
	[950][24] = 86,
	[950][25] = 86,
	[950][26] = 86,
	[950][27] = 86,
	[950][28] = 86,
	[950][29] = 86,
	[950][30] = 86,
	[950][31] = 86,
	[950][32] = 86,
	[950][33] = 86,
	[950][34] = 86,
	[950][35] = 86,
	[950][36] = 86,
	[950][40] = 86,
	[952][4] = 87,
	[952][6] = 87,
	[952][8] = 87,
	[952][9] = 87,
	[952][14] = 87,
	[952][16] = 87,
	[952][17] = 87,
	[952][18] = 87,
	[952][19] = 87,
	[952][20] = 87,
	[952][21] = 87,
	[952][22] = 87,
	[952][23] = 87,
	[952][24] = 87,
	[952][25] = 87,
	[952][26] = 87,
	[952][27] = 87,
	[952][28] = 87,
	[952][29] = 87,
	[952][30] = 87,
	[952][31] = 87,
	[952][32] = 87,
	[952][33] = 87,
	[952][34] = 87,
	[952][35] = 87,
	[952][36] = 87,
	[952][40] = 87,
	[954][4] = 88,
	[954][6] = 88,
	[954][8] = 88,
	[954][9] = 88,
	[954][14] = 88,
	[954][16] = 88,
	[954][17] = 88,
	[954][18] = 88,
	[954][19] = 88,
	[954][20] = 88,
	[954][21] = 88,
	[954][22] = 88,
	[954][23] = 88,
	[954][24] = 88,
	[954][25] = 88,
	[954][26] = 88,
	[954][27] = 88,
	[954][28] = 88,
	[954][29] = 88,
	[954][30] = 88,
	[954][31] = 88,
	[954][32] = 88,
	[954][33] = 88,
	[954][34] = 88,
	[954][35] = 88,
	[954][36] = 88,
	[954][40] = 88,
	[957][4] = 89,
	[957][6] = 89,
	[957][8] = 89,
	[957][9] = 89,
	[957][14] = 89,
	[957][16] = 89,
	[957][17] = 89,
	[957][18] = 89,
	[957][19] = 89,
	[957][20] = 89,
	[957][21] = 89,
	[957][22] = 89,
	[957][23] = 89,
	[957][24] = 89,
	[957][25] = 89,
	[957][26] = 89,
	[957][27] = 89,
	[957][28] = 89,
	[957][29] = 89,
	[957][30] = 89,
	[957][31] = 89,
	[957][32] = 89,
	[957][33] = 89,
	[957][34] = 89,
	[957][35] = 89,
	[957][36] = 89,
	[957][40] = 89,
	[958][4] = 97,
	[958][6] = 97,
	[958][8] = 97,
	[958][9] = 97,
	[958][14] = 97,
	[958][16] = 97,
	[958][17] = 97,
	[958][18] = 97,
	[958][19] = 97,
	[958][20] = 97,
	[958][21] = 97,
	[958][22] = 97,
	[958][23] = 97,
	[958][24] = 97,
	[958][25] = 97,
	[958][26] = 97,
	[958][27] = 97,
	[958][28] = 97,
	[958][29] = 97,
	[958][30] = 97,
	[958][31] = 97,
	[958][32] = 97,
	[958][33] = 97,
	[958][34] = 97,
	[958][35] = 97,
	[958][36] = 97,
	[958][40] = 97,
	[961][34] = 100,
	[961][35] = 100,
	[961][36] = 100,
	[961][40] = 100,
	[963][34] = 101,
	[963][35] = 101,
	[963][36] = 101,
	[963][40] = 101,
	[964][34] = 102,
	[964][35] = 102,
	[964][36] = 102,
	[964][40] = 102,
	[966][6] = 104,
	[966][9] = 104,
	[966][16] = 104,
	[966][17] = 104,
	[966][18] = 104,
	[966][19] = 104,
	[966][24] = 104,
	[966][25] = 104,
	[966][26] = 104,
	[966][27] = 104,
	[966][28] = 104,
	[966][29] = 104,
	[966][30] = 104,
	[966][31] = 104,
	[966][32] = 104,
	[966][33] = 104,
	[966][34] = 104,
	[966][35] = 104,
	[966][36] = 104,
	[966][40] = 104,
	[967][6] = 105,
	[967][9] = 105,
	[967][16] = 105,
	[967][17] = 105,
	[967][18] = 105,
	[967][19] = 105,
	[967][24] = 105,
	[967][25] = 105,
	[967][26] = 105,
	[967][27] = 105,
	[967][28] = 105,
	[967][29] = 105,
	[967][30] = 105,
	[967][31] = 105,
	[967][32] = 105,
	[967][33] = 105,
	[967][34] = 105,
	[967][35] = 105,
	[967][36] = 105,
	[967][40] = 105,
	[968][16] = 106,
	[968][17] = 106,
	[968][18] = 106,
	[968][19] = 106,
	[968][32] = 106,
	[968][33] = 106,
	[968][34] = 106,
	[968][35] = 106,
	[968][36] = 106,
	[968][40] = 106,
	[969][16] = 113,
	[969][17] = 113,
	[969][18] = 113,
	[969][19] = 113,
	[969][30] = 113,
	[969][31] = 113,
	[969][32] = 113,
	[969][33] = 113,
	[969][34] = 113,
	[969][35] = 113,
	[969][36] = 113,
	[969][40] = 113,
	[970][16] = 114,
	[970][17] = 114,
	[970][18] = 114,
	[970][19] = 114,
	[970][30] = 114,
	[970][31] = 114,
	[970][32] = 114,
	[970][33] = 114,
	[970][34] = 114,
	[970][35] = 114,
	[970][36] = 114,
	[970][40] = 114,
	[971][17] = 115,
	[971][18] = 115,
	[971][19] = 115,
	[971][32] = 115,
	[971][33] = 115,
	[971][34] = 115,
	[971][35] = 115,
	[971][36] = 115,
	[971][40] = 115,
	[972][6] = 116,
	[972][9] = 116,
	[972][14] = 116,
	[972][16] = 116,
	[972][17] = 116,
	[972][18] = 116,
	[972][19] = 116,
	[972][20] = 116,
	[972][22] = 116,
	[972][23] = 116,
	[972][24] = 116,
	[972][25] = 116,
	[972][26] = 116,
	[972][27] = 116,
	[972][28] = 116,
	[972][29] = 116,
	[972][30] = 116,
	[972][31] = 116,
	[972][32] = 116,
	[972][33] = 116,
	[972][34] = 116,
	[972][35] = 116,
	[972][36] = 116,
	[972][40] = 116,
	[973][40] = 123,
	[974][40] = 124,
	[975][18] = 125,
	[975][19] = 125,
	[975][32] = 125,
	[975][33] = 125,
	[975][34] = 125,
	[975][35] = 125,
	[975][36] = 125,
	[975][40] = 125,
	[976][35] = 126,
	[976][36] = 126,
	[976][40] = 126,
	[977][19] = 127,
	[977][32] = 127,
	[977][33] = 127,
	[977][34] = 127,
	[977][35] = 127,
	[977][36] = 127,
	[977][40] = 127,
	[979][19] = 128,
	[979][33] = 128,
	[979][34] = 128,
	[979][35] = 128,
	[979][36] = 128,
	[979][40] = 128,
	[980][6] = 129,
	[980][9] = 129,
	[980][14] = 129,
	[980][16] = 129,
	[980][17] = 129,
	[980][18] = 129,
	[980][19] = 129,
	[980][20] = 129,
	[980][23] = 129,
	[980][24] = 129,
	[980][25] = 129,
	[980][26] = 129,
	[980][27] = 129,
	[980][28] = 129,
	[980][29] = 129,
	[980][30] = 129,
	[980][31] = 129,
	[980][32] = 129,
	[980][33] = 129,
	[980][34] = 129,
	[980][35] = 129,
	[980][36] = 129,
	[980][40] = 129,
	[981][6] = 130,
	[981][9] = 130,
	[981][14] = 130,
	[981][16] = 130,
	[981][17] = 130,
	[981][18] = 130,
	[981][19] = 130,
	[981][20] = 130,
	[981][23] = 130,
	[981][24] = 130,
	[981][25] = 130,
	[981][26] = 130,
	[981][27] = 130,
	[981][28] = 130,
	[981][29] = 130,
	[981][30] = 130,
	[981][31] = 130,
	[981][32] = 130,
	[981][33] = 130,
	[981][34] = 130,
	[981][35] = 130,
	[981][36] = 130,
	[981][40] = 130,
	[982][6] = 131,
	[982][9] = 131,
	[982][14] = 131,
	[982][16] = 131,
	[982][17] = 131,
	[982][18] = 131,
	[982][19] = 131,
	[982][20] = 131,
	[982][23] = 131,
	[982][24] = 131,
	[982][25] = 131,
	[982][26] = 131,
	[982][27] = 131,
	[982][28] = 131,
	[982][29] = 131,
	[982][30] = 131,
	[982][31] = 131,
	[982][32] = 131,
	[982][33] = 131,
	[982][34] = 131,
	[982][35] = 131,
	[982][36] = 131,
	[982][40] = 131,
	[983][36] = 132,
	[983][40] = 132,
	[984][36] = 133,
	[984][40] = 133,
	[985][4] = 134,
	[985][6] = 134,
	[985][8] = 134,
	[985][9] = 134,
	[985][14] = 134,
	[985][16] = 134,
	[985][17] = 134,
	[985][18] = 134,
	[985][19] = 134,
	[985][20] = 134,
	[985][21] = 134,
	[985][22] = 134,
	[985][23] = 134,
	[985][24] = 134,
	[985][25] = 134,
	[985][26] = 134,
	[985][27] = 134,
	[985][28] = 134,
	[985][29] = 134,
	[985][30] = 134,
	[985][31] = 134,
	[985][32] = 134,
	[985][33] = 134,
	[985][34] = 134,
	[985][35] = 134,
	[985][36] = 134,
	[985][40] = 134,
	[989][4] = 135,
	[989][6] = 135,
	[989][8] = 135,
	[989][9] = 135,
	[989][14] = 135,
	[989][16] = 135,
	[989][17] = 135,
	[989][18] = 135,
	[989][19] = 135,
	[989][20] = 135,
	[989][21] = 135,
	[989][22] = 135,
	[989][23] = 135,
	[989][24] = 135,
	[989][25] = 135,
	[989][26] = 135,
	[989][27] = 135,
	[989][28] = 135,
	[989][29] = 135,
	[989][30] = 135,
	[989][31] = 135,
	[989][32] = 135,
	[989][33] = 135,
	[989][34] = 135,
	[989][35] = 135,
	[989][36] = 135,
	[989][40] = 135,
	[990][16] = 136,
	[990][17] = 136,
	[990][18] = 136,
	[990][19] = 136,
	[990][26] = 136,
	[990][27] = 136,
	[990][28] = 136,
	[990][29] = 136,
	[990][30] = 136,
	[990][31] = 136,
	[990][32] = 136,
	[990][33] = 136,
	[990][34] = 136,
	[990][35] = 136,
	[990][36] = 136,
	[990][40] = 136,
	[991][16] = 137,
	[991][17] = 137,
	[991][18] = 137,
	[991][19] = 137,
	[991][26] = 137,
	[991][27] = 137,
	[991][28] = 137,
	[991][29] = 137,
	[991][30] = 137,
	[991][31] = 137,
	[991][32] = 137,
	[991][33] = 137,
	[991][34] = 137,
	[991][35] = 137,
	[991][36] = 137,
	[991][40] = 137,
	[992][16] = 138,
	[992][17] = 138,
	[992][18] = 138,
	[992][19] = 138,
	[992][26] = 138,
	[992][27] = 138,
	[992][28] = 138,
	[992][29] = 138,
	[992][30] = 138,
	[992][31] = 138,
	[992][32] = 138,
	[992][33] = 138,
	[992][34] = 138,
	[992][35] = 138,
	[992][36] = 138,
	[992][40] = 138,
	[993][16] = 139,
	[993][17] = 139,
	[993][18] = 139,
	[993][19] = 139,
	[993][26] = 139,
	[993][27] = 139,
	[993][28] = 139,
	[993][29] = 139,
	[993][30] = 139,
	[993][31] = 139,
	[993][32] = 139,
	[993][33] = 139,
	[993][34] = 139,
	[993][35] = 139,
	[993][36] = 139,
	[993][40] = 139,
	[994][16] = 140,
	[994][17] = 140,
	[994][18] = 140,
	[994][19] = 140,
	[994][24] = 140,
	[994][25] = 140,
	[994][26] = 140,
	[994][27] = 140,
	[994][28] = 140,
	[994][29] = 140,
	[994][30] = 140,
	[994][31] = 140,
	[994][32] = 140,
	[994][33] = 140,
	[994][34] = 140,
	[994][35] = 140,
	[994][36] = 140,
	[994][40] = 140,
	[995][16] = 141,
	[995][17] = 141,
	[995][18] = 141,
	[995][19] = 141,
	[995][24] = 141,
	[995][25] = 141,
	[995][26] = 141,
	[995][27] = 141,
	[995][28] = 141,
	[995][29] = 141,
	[995][30] = 141,
	[995][31] = 141,
	[995][32] = 141,
	[995][33] = 141,
	[995][34] = 141,
	[995][35] = 141,
	[995][36] = 141,
	[995][40] = 141,
	[996][4] = 209,
	[996][6] = 209,
	[996][8] = 209,
	[996][9] = 209,
	[996][14] = 209,
	[996][16] = 209,
	[996][17] = 209,
	[996][18] = 209,
	[996][19] = 209,
	[996][20] = 209,
	[996][21] = 209,
	[996][22] = 209,
	[996][23] = 209,
	[996][24] = 209,
	[996][25] = 209,
	[996][26] = 209,
	[996][27] = 209,
	[996][28] = 209,
	[996][29] = 209,
	[996][30] = 209,
	[996][31] = 209,
	[996][32] = 209,
	[996][33] = 209,
	[996][34] = 209,
	[996][35] = 209,
	[996][36] = 209,
	[996][38] = 209,
	[996][39] = 209,
	[997][4] = 210,
	[997][6] = 210,
	[997][8] = 210,
	[997][9] = 210,
	[997][14] = 210,
	[997][16] = 210,
	[997][17] = 210,
	[997][18] = 210,
	[997][19] = 210,
	[997][20] = 210,
	[997][21] = 210,
	[997][22] = 210,
	[997][23] = 210,
	[997][24] = 210,
	[997][25] = 210,
	[997][26] = 210,
	[997][27] = 210,
	[997][28] = 210,
	[997][29] = 210,
	[997][30] = 210,
	[997][31] = 210,
	[997][32] = 210,
	[997][33] = 210,
	[997][34] = 210,
	[997][35] = 210,
	[997][36] = 210,
	[997][38] = 210,
	[997][39] = 210,
	[998][4] = 232,
	[998][6] = 232,
	[998][8] = 232,
	[998][9] = 232,
	[998][14] = 232,
	[998][16] = 232,
	[998][17] = 232,
	[998][18] = 232,
	[998][19] = 232,
	[998][20] = 232,
	[998][21] = 232,
	[998][22] = 232,
	[998][23] = 232,
	[998][24] = 232,
	[998][25] = 232,
	[998][26] = 232,
	[998][27] = 232,
	[998][28] = 232,
	[998][29] = 232,
	[998][30] = 232,
	[998][31] = 232,
	[998][32] = 232,
	[998][33] = 232,
	[998][34] = 232,
	[998][35] = 232,
	[998][36] = 232,
	[998][38] = 232,
	[998][39] = 232,
	[1000][4] = 233,
	[1000][6] = 233,
	[1000][8] = 233,
	[1000][9] = 233,
	[1000][14] = 233,
	[1000][16] = 233,
	[1000][17] = 233,
	[1000][18] = 233,
	[1000][19] = 233,
	[1000][20] = 233,
	[1000][21] = 233,
	[1000][22] = 233,
	[1000][23] = 233,
	[1000][24] = 233,
	[1000][25] = 233,
	[1000][26] = 233,
	[1000][27] = 233,
	[1000][28] = 233,
	[1000][29] = 233,
	[1000][30] = 233,
	[1000][31] = 233,
	[1000][32] = 233,
	[1000][33] = 233,
	[1000][34] = 233,
	[1000][35] = 233,
	[1000][36] = 233,
	[1000][38] = 233,
	[1000][39] = 233,
	[1001][34] = 239,
	[1001][35] = 239,
	[1001][36] = 239,
	[1001][38] = 239,
	[1001][39] = 239,
	[1002][34] = 240,
	[1002][35] = 240,
	[1002][36] = 240,
	[1002][38] = 240,
	[1002][39] = 240,
	[1003][34] = 243,
	[1003][35] = 243,
	[1003][36] = 243,
	[1003][38] = 243,
	[1003][39] = 243,
	[1004][34] = 244,
	[1004][35] = 244,
	[1004][36] = 244,
	[1004][38] = 244,
	[1004][39] = 244,
	[1005][38] = 245,
	[1005][39] = 245,
	[1006][34] = 246,
	[1006][35] = 246,
	[1006][36] = 246,
	[1006][38] = 246,
	[1006][39] = 246,
	[1007][36] = 247,
	[1007][38] = 247,
	[1007][39] = 247,
	[1008][4] = 248,
	[1008][6] = 248,
	[1008][8] = 248,
	[1008][9] = 248,
	[1008][14] = 248,
	[1008][16] = 248,
	[1008][17] = 248,
	[1008][18] = 248,
	[1008][19] = 248,
	[1008][20] = 248,
	[1008][21] = 248,
	[1008][22] = 248,
	[1008][23] = 248,
	[1008][24] = 248,
	[1008][25] = 248,
	[1008][26] = 248,
	[1008][27] = 248,
	[1008][28] = 248,
	[1008][29] = 248,
	[1008][30] = 248,
	[1008][31] = 248,
	[1008][32] = 248,
	[1008][33] = 248,
	[1008][34] = 248,
	[1008][35] = 248,
	[1008][36] = 248,
	[1008][38] = 248,
	[1008][39] = 248,
	[1010][4] = 249,
	[1010][6] = 249,
	[1010][8] = 249,
	[1010][9] = 249,
	[1010][14] = 249,
	[1010][16] = 249,
	[1010][17] = 249,
	[1010][18] = 249,
	[1010][19] = 249,
	[1010][20] = 249,
	[1010][21] = 249,
	[1010][22] = 249,
	[1010][23] = 249,
	[1010][24] = 249,
	[1010][25] = 249,
	[1010][26] = 249,
	[1010][27] = 249,
	[1010][28] = 249,
	[1010][29] = 249,
	[1010][30] = 249,
	[1010][31] = 249,
	[1010][32] = 249,
	[1010][33] = 249,
	[1010][34] = 249,
	[1010][35] = 249,
	[1010][36] = 249,
	[1010][38] = 249,
	[1010][39] = 249,
	[1011][4] = 209,
	[1011][6] = 209,
	[1011][8] = 209,
	[1011][9] = 209,
	[1011][14] = 209,
	[1011][16] = 209,
	[1011][17] = 209,
	[1011][18] = 209,
	[1011][19] = 209,
	[1011][20] = 209,
	[1011][21] = 209,
	[1011][22] = 209,
	[1011][23] = 209,
	[1011][24] = 209,
	[1011][25] = 209,
	[1011][26] = 209,
	[1011][27] = 209,
	[1011][28] = 209,
	[1011][29] = 209,
	[1011][30] = 209,
	[1011][31] = 209,
	[1011][32] = 209,
	[1011][33] = 209,
	[1011][34] = 209,
	[1011][35] = 209,
	[1011][36] = 209,
	[1011][39] = 209,
	[1011][40] = 209,
	[1012][4] = 210,
	[1012][6] = 210,
	[1012][8] = 210,
	[1012][9] = 210,
	[1012][14] = 210,
	[1012][16] = 210,
	[1012][17] = 210,
	[1012][18] = 210,
	[1012][19] = 210,
	[1012][20] = 210,
	[1012][21] = 210,
	[1012][22] = 210,
	[1012][23] = 210,
	[1012][24] = 210,
	[1012][25] = 210,
	[1012][26] = 210,
	[1012][27] = 210,
	[1012][28] = 210,
	[1012][29] = 210,
	[1012][30] = 210,
	[1012][31] = 210,
	[1012][32] = 210,
	[1012][33] = 210,
	[1012][34] = 210,
	[1012][35] = 210,
	[1012][36] = 210,
	[1012][39] = 210,
	[1012][40] = 210,
	[1013][4] = 232,
	[1013][6] = 232,
	[1013][8] = 232,
	[1013][9] = 232,
	[1013][14] = 232,
	[1013][16] = 232,
	[1013][17] = 232,
	[1013][18] = 232,
	[1013][19] = 232,
	[1013][20] = 232,
	[1013][21] = 232,
	[1013][22] = 232,
	[1013][23] = 232,
	[1013][24] = 232,
	[1013][25] = 232,
	[1013][26] = 232,
	[1013][27] = 232,
	[1013][28] = 232,
	[1013][29] = 232,
	[1013][30] = 232,
	[1013][31] = 232,
	[1013][32] = 232,
	[1013][33] = 232,
	[1013][34] = 232,
	[1013][35] = 232,
	[1013][36] = 232,
	[1013][39] = 232,
	[1013][40] = 232,
	[1015][4] = 233,
	[1015][6] = 233,
	[1015][8] = 233,
	[1015][9] = 233,
	[1015][14] = 233,
	[1015][16] = 233,
	[1015][17] = 233,
	[1015][18] = 233,
	[1015][19] = 233,
	[1015][20] = 233,
	[1015][21] = 233,
	[1015][22] = 233,
	[1015][23] = 233,
	[1015][24] = 233,
	[1015][25] = 233,
	[1015][26] = 233,
	[1015][27] = 233,
	[1015][28] = 233,
	[1015][29] = 233,
	[1015][30] = 233,
	[1015][31] = 233,
	[1015][32] = 233,
	[1015][33] = 233,
	[1015][34] = 233,
	[1015][35] = 233,
	[1015][36] = 233,
	[1015][39] = 233,
	[1015][40] = 233,
	[1016][34] = 239,
	[1016][35] = 239,
	[1016][36] = 239,
	[1016][39] = 239,
	[1016][40] = 239,
	[1017][34] = 240,
	[1017][35] = 240,
	[1017][36] = 240,
	[1017][39] = 240,
	[1017][40] = 240,
	[1018][34] = 243,
	[1018][35] = 243,
	[1018][36] = 243,
	[1018][39] = 243,
	[1018][40] = 243,
	[1019][34] = 244,
	[1019][35] = 244,
	[1019][36] = 244,
	[1019][39] = 244,
	[1019][40] = 244,
	[1020][39] = 245,
	[1020][40] = 245,
	[1021][34] = 246,
	[1021][35] = 246,
	[1021][36] = 246,
	[1021][39] = 246,
	[1021][40] = 246,
	[1022][36] = 247,
	[1022][39] = 247,
	[1022][40] = 247,
	[1023][4] = 248,
	[1023][6] = 248,
	[1023][8] = 248,
	[1023][9] = 248,
	[1023][14] = 248,
	[1023][16] = 248,
	[1023][17] = 248,
	[1023][18] = 248,
	[1023][19] = 248,
	[1023][20] = 248,
	[1023][21] = 248,
	[1023][22] = 248,
	[1023][23] = 248,
	[1023][24] = 248,
	[1023][25] = 248,
	[1023][26] = 248,
	[1023][27] = 248,
	[1023][28] = 248,
	[1023][29] = 248,
	[1023][30] = 248,
	[1023][31] = 248,
	[1023][32] = 248,
	[1023][33] = 248,
	[1023][34] = 248,
	[1023][35] = 248,
	[1023][36] = 248,
	[1023][39] = 248,
	[1023][40] = 248,
	[1025][4] = 249,
	[1025][6] = 249,
	[1025][8] = 249,
	[1025][9] = 249,
	[1025][14] = 249,
	[1025][16] = 249,
	[1025][17] = 249,
	[1025][18] = 249,
	[1025][19] = 249,
	[1025][20] = 249,
	[1025][21] = 249,
	[1025][22] = 249,
	[1025][23] = 249,
	[1025][24] = 249,
	[1025][25] = 249,
	[1025][26] = 249,
	[1025][27] = 249,
	[1025][28] = 249,
	[1025][29] = 249,
	[1025][30] = 249,
	[1025][31] = 249,
	[1025][32] = 249,
	[1025][33] = 249,
	[1025][34] = 249,
	[1025][35] = 249,
	[1025][36] = 249,
	[1025][39] = 249,
	[1025][40] = 249,
	[1026][2] = 250,
	[1026][3] = 250,
	[1026][4] = 250,
	[1026][7] = 250,
	[1026][8] = 250,
	[1026][9] = 250,
	[1026][11] = 250,
	[1026][18] = 250,
	[1026][19] = 250,
	[1026][20] = 250,
	[1026][23] = 250,
	[1026][37] = 250,
	[1027][2] = 251,
	[1027][3] = 251,
	[1027][4] = 251,
	[1027][7] = 251,
	[1027][8] = 251,
	[1027][9] = 251,
	[1027][11] = 251,
	[1027][18] = 251,
	[1027][19] = 251,
	[1027][20] = 251,
	[1027][23] = 251,
	[1027][37] = 251,
	[1028][2] = 211,
	[1028][3] = 211,
	[1028][4] = 211,
	[1028][7] = 211,
	[1028][8] = 211,
	[1028][9] = 211,
	[1028][11] = 211,
	[1028][18] = 211,
	[1028][19] = 211,
	[1028][20] = 211,
	[1028][23] = 211,
	[1028][38] = 211,
	[1029][2] = 212,
	[1029][3] = 212,
	[1029][4] = 212,
	[1029][7] = 212,
	[1029][8] = 212,
	[1029][9] = 212,
	[1029][11] = 212,
	[1029][18] = 212,
	[1029][19] = 212,
	[1029][20] = 212,
	[1029][23] = 212,
	[1029][38] = 212,
	[1030][2] = 213,
	[1030][3] = 213,
	[1030][4] = 213,
	[1030][7] = 213,
	[1030][8] = 213,
	[1030][9] = 213,
	[1030][11] = 213,
	[1030][18] = 213,
	[1030][19] = 213,
	[1030][20] = 213,
	[1030][23] = 213,
	[1030][38] = 213,
	[1031][2] = 214,
	[1031][3] = 214,
	[1031][4] = 214,
	[1031][7] = 214,
	[1031][8] = 214,
	[1031][9] = 214,
	[1031][11] = 214,
	[1031][18] = 214,
	[1031][19] = 214,
	[1031][20] = 214,
	[1031][23] = 214,
	[1031][38] = 214,
	[1032][2] = 215,
	[1032][3] = 215,
	[1032][4] = 215,
	[1032][7] = 215,
	[1032][8] = 215,
	[1032][9] = 215,
	[1032][11] = 215,
	[1032][18] = 215,
	[1032][19] = 215,
	[1032][20] = 215,
	[1032][23] = 215,
	[1032][38] = 215,
	[1033][2] = 216,
	[1033][3] = 216,
	[1033][4] = 216,
	[1033][7] = 216,
	[1033][8] = 216,
	[1033][9] = 216,
	[1033][11] = 216,
	[1033][18] = 216,
	[1033][19] = 216,
	[1033][20] = 216,
	[1033][23] = 216,
	[1033][38] = 216,
	[1034][2] = 217,
	[1034][3] = 217,
	[1034][4] = 217,
	[1034][7] = 217,
	[1034][8] = 217,
	[1034][9] = 217,
	[1034][11] = 217,
	[1034][18] = 217,
	[1034][19] = 217,
	[1034][20] = 217,
	[1034][23] = 217,
	[1034][38] = 217,
	[1035][2] = 219,
	[1035][3] = 219,
	[1035][4] = 219,
	[1035][7] = 219,
	[1035][8] = 219,
	[1035][9] = 219,
	[1035][11] = 219,
	[1035][18] = 219,
	[1035][19] = 219,
	[1035][20] = 219,
	[1035][23] = 219,
	[1035][38] = 219,
	[1036][2] = 221,
	[1036][3] = 221,
	[1036][4] = 221,
	[1036][7] = 221,
	[1036][8] = 221,
	[1036][9] = 221,
	[1036][11] = 221,
	[1036][18] = 221,
	[1036][19] = 221,
	[1036][20] = 221,
	[1036][23] = 221,
	[1036][38] = 221,
	[1037][2] = 222,
	[1037][3] = 222,
	[1037][4] = 222,
	[1037][7] = 222,
	[1037][8] = 222,
	[1037][9] = 222,
	[1037][11] = 222,
	[1037][18] = 222,
	[1037][19] = 222,
	[1037][20] = 222,
	[1037][23] = 222,
	[1037][38] = 222,
	[1038][2] = 223,
	[1038][3] = 223,
	[1038][4] = 223,
	[1038][7] = 223,
	[1038][8] = 223,
	[1038][9] = 223,
	[1038][11] = 223,
	[1038][18] = 223,
	[1038][19] = 223,
	[1038][20] = 223,
	[1038][23] = 223,
	[1038][38] = 223,
	[1039][2] = 252,
	[1039][3] = 252,
	[1039][4] = 252,
	[1039][7] = 252,
	[1039][8] = 252,
	[1039][9] = 252,
	[1039][11] = 252,
	[1039][18] = 252,
	[1039][19] = 252,
	[1039][20] = 252,
	[1039][23] = 252,
	[1039][37] = 252,
	[1040][38] = 228,
	[1041][38] = 229,
	[1042][18] = 230,
	[1042][38] = 230,
	[1043][18] = 231,
	[1043][38] = 231,
	[1044][2] = 253,
	[1044][3] = 253,
	[1044][4] = 253,
	[1044][7] = 253,
	[1044][8] = 253,
	[1044][9] = 253,
	[1044][11] = 253,
	[1044][18] = 253,
	[1044][19] = 253,
	[1044][20] = 253,
	[1044][23] = 253,
	[1044][37] = 253,
	[1046][2] = 218,
	[1046][3] = 218,
	[1046][4] = 218,
	[1046][5] = 218,
	[1046][6] = 218,
	[1046][16] = 218,
	[1046][17] = 218,
	[1046][18] = 218,
	[1046][38] = 218,
	[1046][39] = 218,
	[1047][2] = 254,
	[1047][3] = 254,
	[1047][4] = 254,
	[1047][5] = 254,
	[1047][6] = 254,
	[1047][16] = 254,
	[1047][17] = 254,
	[1047][18] = 254,
	[1047][39] = 254,
	[1047][40] = 254,
	[1053][38] = 220,
	[1054][2] = 255,
	[1054][3] = 255,
	[1054][4] = 255,
	[1054][7] = 255,
	[1054][8] = 255,
	[1054][9] = 255,
	[1054][11] = 255,
	[1054][18] = 255,
	[1054][19] = 255,
	[1054][20] = 255,
	[1054][23] = 255,
	[1054][37] = 255,
	[1055][2] = 256,
	[1055][3] = 256,
	[1055][4] = 256,
	[1055][5] = 256,
	[1055][18] = 256,
	[1055][39] = 256,
	[1055][40] = 256,
	[1056][2] = 257,
	[1056][3] = 257,
	[1056][4] = 257,
	[1056][5] = 257,
	[1056][18] = 257,
	[1056][39] = 257,
	[1056][40] = 257,
	[1057][2] = 173,
	[1057][3] = 173,
	[1057][4] = 173,
	[1057][5] = 173,
	[1057][16] = 173,
	[1057][17] = 173,
	[1057][18] = 173,
	[1057][39] = 173,
	[1057][40] = 173,
	[1058][2] = 174,
	[1058][3] = 174,
	[1058][4] = 174,
	[1058][5] = 174,
	[1058][16] = 174,
	[1058][17] = 174,
	[1058][18] = 174,
	[1058][39] = 174,
	[1058][40] = 174,
	[1061][2] = 175,
	[1061][3] = 175,
	[1061][4] = 175,
	[1061][5] = 175,
	[1061][16] = 175,
	[1061][17] = 175,
	[1061][18] = 175,
	[1061][39] = 175,
	[1061][40] = 175,
	[1062][2] = 258,
	[1062][3] = 258,
	[1062][4] = 258,
	[1062][5] = 258,
	[1062][16] = 258,
	[1062][17] = 258,
	[1062][18] = 258,
	[1062][39] = 258,
	[1062][40] = 258,
	[1063][2] = 259,
	[1063][3] = 259,
	[1063][4] = 259,
	[1063][5] = 259,
	[1063][17] = 259,
	[1063][18] = 259,
	[1063][39] = 259,
	[1063][40] = 259,
	[1064][2] = 260,
	[1064][3] = 260,
	[1064][4] = 260,
	[1064][5] = 260,
	[1064][17] = 260,
	[1064][18] = 260,
	[1064][39] = 260,
	[1064][40] = 260,
	[1065][40] = 261,
	[1066][40] = 262,
	[1067][40] = 263,
	[1068][40] = 264,
	[1071][40] = 265,
	[1072][40] = 266,
	[1073][2] = 267,
	[1073][3] = 267,
	[1073][4] = 267,
	[1073][7] = 267,
	[1073][8] = 267,
	[1073][9] = 267,
	[1073][11] = 267,
	[1073][18] = 267,
	[1073][19] = 267,
	[1073][20] = 267,
	[1073][23] = 267,
	[1073][37] = 267,
	[1076][2] = 268,
	[1076][3] = 268,
	[1076][4] = 268,
	[1076][7] = 268,
	[1076][8] = 268,
	[1076][9] = 268,
	[1076][18] = 268,
	[1076][19] = 268,
	[1076][20] = 268,
	[1076][23] = 268,
	[1077][2] = 224,
	[1077][3] = 224,
	[1077][4] = 224,
	[1077][7] = 224,
	[1077][8] = 224,
	[1077][18] = 224,
	[1077][38] = 224,
	[1078][2] = 225,
	[1078][3] = 225,
	[1078][4] = 225,
	[1078][7] = 225,
	[1078][8] = 225,
	[1078][18] = 225,
	[1078][38] = 225,
	[1079][2] = 226,
	[1079][3] = 226,
	[1079][4] = 226,
	[1079][7] = 226,
	[1079][8] = 226,
	[1079][18] = 226,
	[1079][38] = 226,
	[1081][18] = 227,
	[1081][38] = 227,
	[1082][2] = 269,
	[1082][3] = 269,
	[1082][4] = 269,
	[1082][7] = 269,
	[1082][8] = 269,
	[1082][9] = 269,
	[1082][18] = 269,
	[1082][19] = 269,
	[1082][20] = 269,
	[1082][23] = 269,
	[1083][2] = 270,
	[1083][3] = 270,
	[1083][4] = 270,
	[1083][7] = 270,
	[1083][8] = 270,
	[1083][9] = 270,
	[1083][11] = 270,
	[1083][18] = 270,
	[1083][19] = 270,
	[1083][20] = 270,
	[1083][23] = 270,
	[1083][37] = 270,
	[1084][23] = 271,
	[1085][23] = 272,
	[1086][18] = 273,
	[1086][23] = 273,
	[1087][18] = 274,
	[1087][23] = 274,
	[1089][18] = 275,
	[1089][37] = 275,
	[1090][4] = 276,
	[1090][6] = 276,
	[1090][8] = 276,
	[1090][9] = 276,
	[1090][14] = 276,
	[1090][16] = 276,
	[1090][17] = 276,
	[1090][18] = 276,
	[1090][19] = 276,
	[1090][20] = 276,
	[1090][21] = 276,
	[1090][22] = 276,
	[1090][23] = 276,
	[1090][24] = 276,
	[1090][25] = 276,
	[1090][26] = 276,
	[1090][27] = 276,
	[1090][28] = 276,
	[1090][29] = 276,
	[1090][30] = 276,
	[1090][31] = 276,
	[1090][32] = 276,
	[1090][33] = 276,
	[1090][34] = 276,
	[1090][35] = 276,
	[1090][36] = 276,
	[1090][37] = 276,
	[1091][2] = 268,
	[1091][3] = 268,
	[1091][4] = 268,
	[1091][7] = 268,
	[1091][8] = 268,
	[1091][9] = 268,
	[1091][18] = 268,
	[1091][19] = 268,
	[1091][20] = 268,
	[1091][37] = 268,
	[1092][2] = 269,
	[1092][3] = 269,
	[1092][4] = 269,
	[1092][7] = 269,
	[1092][8] = 269,
	[1092][9] = 269,
	[1092][18] = 269,
	[1092][19] = 269,
	[1092][20] = 269,
	[1092][37] = 269,
	[1093][37] = 271,
	[1094][37] = 272,
	[1095][18] = 273,
	[1095][37] = 273,
	[1096][18] = 274,
	[1096][37] = 274,
	[1097][38] = 237,
	[1097][39] = 237,
	[1097][55] = 237,
	[1099][38] = 238,
	[1099][39] = 238,
	[1099][55] = 238,
	[1100][11] = 277,
	[1100][55] = 277,
	[1103][38] = 241,
	[1103][39] = 241,
	[1104][38] = 242,
	[1104][39] = 242,
	[1105][39] = 237,
	[1105][41] = 237,
	[1105][55] = 237,
	[1107][39] = 238,
	[1107][41] = 238,
	[1107][55] = 238,
	[1108][11] = 278,
	[1109][11] = 279,
	[1112][39] = 241,
	[1112][41] = 241,
	[1113][39] = 242,
	[1113][41] = 242,
	[1114][4] = 166,
	[1114][6] = 166,
	[1114][8] = 166,
	[1114][9] = 166,
	[1114][14] = 166,
	[1114][16] = 166,
	[1114][17] = 166,
	[1114][18] = 166,
	[1114][19] = 166,
	[1114][20] = 166,
	[1114][21] = 166,
	[1114][22] = 166,
	[1114][23] = 166,
	[1114][24] = 166,
	[1114][25] = 166,
	[1114][26] = 166,
	[1114][27] = 166,
	[1114][28] = 166,
	[1114][29] = 166,
	[1114][30] = 166,
	[1114][31] = 166,
	[1114][32] = 166,
	[1114][33] = 166,
	[1114][34] = 166,
	[1114][35] = 166,
	[1114][36] = 166,
	[1114][41] = 166,
	[1116][4] = 167,
	[1116][6] = 167,
	[1116][8] = 167,
	[1116][9] = 167,
	[1116][14] = 167,
	[1116][16] = 167,
	[1116][17] = 167,
	[1116][18] = 167,
	[1116][19] = 167,
	[1116][20] = 167,
	[1116][21] = 167,
	[1116][22] = 167,
	[1116][23] = 167,
	[1116][24] = 167,
	[1116][25] = 167,
	[1116][26] = 167,
	[1116][27] = 167,
	[1116][28] = 167,
	[1116][29] = 167,
	[1116][30] = 167,
	[1116][31] = 167,
	[1116][32] = 167,
	[1116][33] = 167,
	[1116][34] = 167,
	[1116][35] = 167,
	[1116][36] = 167,
	[1116][41] = 167,
	[1118][4] = 168,
	[1118][6] = 168,
	[1118][8] = 168,
	[1118][9] = 168,
	[1118][14] = 168,
	[1118][16] = 168,
	[1118][17] = 168,
	[1118][18] = 168,
	[1118][19] = 168,
	[1118][20] = 168,
	[1118][21] = 168,
	[1118][22] = 168,
	[1118][23] = 168,
	[1118][24] = 168,
	[1118][25] = 168,
	[1118][26] = 168,
	[1118][27] = 168,
	[1118][28] = 168,
	[1118][29] = 168,
	[1118][30] = 168,
	[1118][31] = 168,
	[1118][32] = 168,
	[1118][33] = 168,
	[1118][34] = 168,
	[1118][35] = 168,
	[1118][36] = 168,
	[1118][41] = 168,
	[1119][4] = 169,
	[1119][6] = 169,
	[1119][8] = 169,
	[1119][9] = 169,
	[1119][14] = 169,
	[1119][16] = 169,
	[1119][17] = 169,
	[1119][18] = 169,
	[1119][19] = 169,
	[1119][20] = 169,
	[1119][21] = 169,
	[1119][22] = 169,
	[1119][23] = 169,
	[1119][24] = 169,
	[1119][25] = 169,
	[1119][26] = 169,
	[1119][27] = 169,
	[1119][28] = 169,
	[1119][29] = 169,
	[1119][30] = 169,
	[1119][31] = 169,
	[1119][32] = 169,
	[1119][33] = 169,
	[1119][34] = 169,
	[1119][35] = 169,
	[1119][36] = 169,
	[1119][41] = 169,
	[1120][4] = 193,
	[1120][6] = 193,
	[1120][8] = 193,
	[1120][9] = 193,
	[1120][14] = 193,
	[1120][16] = 193,
	[1120][17] = 193,
	[1120][18] = 193,
	[1120][19] = 193,
	[1120][20] = 193,
	[1120][21] = 193,
	[1120][22] = 193,
	[1120][23] = 193,
	[1120][24] = 193,
	[1120][25] = 193,
	[1120][26] = 193,
	[1120][27] = 193,
	[1120][28] = 193,
	[1120][29] = 193,
	[1120][30] = 193,
	[1120][31] = 193,
	[1120][32] = 193,
	[1120][33] = 193,
	[1120][34] = 193,
	[1120][35] = 193,
	[1120][36] = 193,
	[1120][41] = 193,
	[1122][4] = 194,
	[1122][6] = 194,
	[1122][8] = 194,
	[1122][9] = 194,
	[1122][14] = 194,
	[1122][16] = 194,
	[1122][17] = 194,
	[1122][18] = 194,
	[1122][19] = 194,
	[1122][20] = 194,
	[1122][21] = 194,
	[1122][22] = 194,
	[1122][23] = 194,
	[1122][24] = 194,
	[1122][25] = 194,
	[1122][26] = 194,
	[1122][27] = 194,
	[1122][28] = 194,
	[1122][29] = 194,
	[1122][30] = 194,
	[1122][31] = 194,
	[1122][32] = 194,
	[1122][33] = 194,
	[1122][34] = 194,
	[1122][35] = 194,
	[1122][36] = 194,
	[1122][41] = 194,
	[1131][4] = 206,
	[1131][6] = 206,
	[1131][8] = 206,
	[1131][9] = 206,
	[1131][14] = 206,
	[1131][16] = 206,
	[1131][17] = 206,
	[1131][18] = 206,
	[1131][19] = 206,
	[1131][20] = 206,
	[1131][21] = 206,
	[1131][22] = 206,
	[1131][23] = 206,
	[1131][24] = 206,
	[1131][25] = 206,
	[1131][26] = 206,
	[1131][27] = 206,
	[1131][28] = 206,
	[1131][29] = 206,
	[1131][30] = 206,
	[1131][31] = 206,
	[1131][32] = 206,
	[1131][33] = 206,
	[1131][34] = 206,
	[1131][35] = 206,
	[1131][36] = 206,
	[1131][41] = 206,
	[1133][4] = 207,
	[1133][6] = 207,
	[1133][8] = 207,
	[1133][9] = 207,
	[1133][14] = 207,
	[1133][16] = 207,
	[1133][17] = 207,
	[1133][18] = 207,
	[1133][19] = 207,
	[1133][20] = 207,
	[1133][21] = 207,
	[1133][22] = 207,
	[1133][23] = 207,
	[1133][24] = 207,
	[1133][25] = 207,
	[1133][26] = 207,
	[1133][27] = 207,
	[1133][28] = 207,
	[1133][29] = 207,
	[1133][30] = 207,
	[1133][31] = 207,
	[1133][32] = 207,
	[1133][33] = 207,
	[1133][34] = 207,
	[1133][35] = 207,
	[1133][36] = 207,
	[1133][41] = 207,
	[1135][4] = 208,
	[1135][6] = 208,
	[1135][8] = 208,
	[1135][9] = 208,
	[1135][14] = 208,
	[1135][16] = 208,
	[1135][17] = 208,
	[1135][18] = 208,
	[1135][19] = 208,
	[1135][20] = 208,
	[1135][21] = 208,
	[1135][22] = 208,
	[1135][23] = 208,
	[1135][24] = 208,
	[1135][25] = 208,
	[1135][26] = 208,
	[1135][27] = 208,
	[1135][28] = 208,
	[1135][29] = 208,
	[1135][30] = 208,
	[1135][31] = 208,
	[1135][32] = 208,
	[1135][33] = 208,
	[1135][34] = 208,
	[1135][35] = 208,
	[1135][36] = 208,
	[1135][41] = 208,
	[1136][4] = 280,
	[1136][6] = 280,
	[1136][8] = 280,
	[1136][9] = 280,
	[1136][14] = 280,
	[1136][16] = 280,
	[1136][17] = 280,
	[1136][18] = 280,
	[1136][19] = 280,
	[1136][20] = 280,
	[1136][21] = 280,
	[1136][22] = 280,
	[1136][23] = 280,
	[1136][24] = 280,
	[1136][25] = 280,
	[1136][26] = 280,
	[1136][27] = 280,
	[1136][28] = 280,
	[1136][29] = 280,
	[1136][30] = 280,
	[1136][31] = 280,
	[1136][32] = 280,
	[1136][33] = 280,
	[1136][34] = 280,
	[1136][35] = 280,
	[1136][36] = 280,
	[1136][37] = 280,
	[1137][4] = 166,
	[1137][6] = 166,
	[1137][8] = 166,
	[1137][9] = 166,
	[1137][14] = 166,
	[1137][16] = 166,
	[1137][17] = 166,
	[1137][18] = 166,
	[1137][19] = 166,
	[1137][20] = 166,
	[1137][21] = 166,
	[1137][22] = 166,
	[1137][23] = 166,
	[1137][24] = 166,
	[1137][25] = 166,
	[1137][26] = 166,
	[1137][27] = 166,
	[1137][28] = 166,
	[1137][29] = 166,
	[1137][30] = 166,
	[1137][31] = 166,
	[1137][32] = 166,
	[1137][33] = 166,
	[1137][34] = 166,
	[1137][35] = 166,
	[1137][36] = 166,
	[1137][40] = 166,
	[1139][4] = 167,
	[1139][6] = 167,
	[1139][8] = 167,
	[1139][9] = 167,
	[1139][14] = 167,
	[1139][16] = 167,
	[1139][17] = 167,
	[1139][18] = 167,
	[1139][19] = 167,
	[1139][20] = 167,
	[1139][21] = 167,
	[1139][22] = 167,
	[1139][23] = 167,
	[1139][24] = 167,
	[1139][25] = 167,
	[1139][26] = 167,
	[1139][27] = 167,
	[1139][28] = 167,
	[1139][29] = 167,
	[1139][30] = 167,
	[1139][31] = 167,
	[1139][32] = 167,
	[1139][33] = 167,
	[1139][34] = 167,
	[1139][35] = 167,
	[1139][36] = 167,
	[1139][40] = 167,
	[1141][4] = 168,
	[1141][6] = 168,
	[1141][8] = 168,
	[1141][9] = 168,
	[1141][14] = 168,
	[1141][16] = 168,
	[1141][17] = 168,
	[1141][18] = 168,
	[1141][19] = 168,
	[1141][20] = 168,
	[1141][21] = 168,
	[1141][22] = 168,
	[1141][23] = 168,
	[1141][24] = 168,
	[1141][25] = 168,
	[1141][26] = 168,
	[1141][27] = 168,
	[1141][28] = 168,
	[1141][29] = 168,
	[1141][30] = 168,
	[1141][31] = 168,
	[1141][32] = 168,
	[1141][33] = 168,
	[1141][34] = 168,
	[1141][35] = 168,
	[1141][36] = 168,
	[1141][40] = 168,
	[1142][4] = 169,
	[1142][6] = 169,
	[1142][8] = 169,
	[1142][9] = 169,
	[1142][14] = 169,
	[1142][16] = 169,
	[1142][17] = 169,
	[1142][18] = 169,
	[1142][19] = 169,
	[1142][20] = 169,
	[1142][21] = 169,
	[1142][22] = 169,
	[1142][23] = 169,
	[1142][24] = 169,
	[1142][25] = 169,
	[1142][26] = 169,
	[1142][27] = 169,
	[1142][28] = 169,
	[1142][29] = 169,
	[1142][30] = 169,
	[1142][31] = 169,
	[1142][32] = 169,
	[1142][33] = 169,
	[1142][34] = 169,
	[1142][35] = 169,
	[1142][36] = 169,
	[1142][40] = 169,
	[1143][4] = 193,
	[1143][6] = 193,
	[1143][8] = 193,
	[1143][9] = 193,
	[1143][14] = 193,
	[1143][16] = 193,
	[1143][17] = 193,
	[1143][18] = 193,
	[1143][19] = 193,
	[1143][20] = 193,
	[1143][21] = 193,
	[1143][22] = 193,
	[1143][23] = 193,
	[1143][24] = 193,
	[1143][25] = 193,
	[1143][26] = 193,
	[1143][27] = 193,
	[1143][28] = 193,
	[1143][29] = 193,
	[1143][30] = 193,
	[1143][31] = 193,
	[1143][32] = 193,
	[1143][33] = 193,
	[1143][34] = 193,
	[1143][35] = 193,
	[1143][36] = 193,
	[1143][40] = 193,
	[1145][4] = 194,
	[1145][6] = 194,
	[1145][8] = 194,
	[1145][9] = 194,
	[1145][14] = 194,
	[1145][16] = 194,
	[1145][17] = 194,
	[1145][18] = 194,
	[1145][19] = 194,
	[1145][20] = 194,
	[1145][21] = 194,
	[1145][22] = 194,
	[1145][23] = 194,
	[1145][24] = 194,
	[1145][25] = 194,
	[1145][26] = 194,
	[1145][27] = 194,
	[1145][28] = 194,
	[1145][29] = 194,
	[1145][30] = 194,
	[1145][31] = 194,
	[1145][32] = 194,
	[1145][33] = 194,
	[1145][34] = 194,
	[1145][35] = 194,
	[1145][36] = 194,
	[1145][40] = 194,
	[1154][4] = 206,
	[1154][6] = 206,
	[1154][8] = 206,
	[1154][9] = 206,
	[1154][14] = 206,
	[1154][16] = 206,
	[1154][17] = 206,
	[1154][18] = 206,
	[1154][19] = 206,
	[1154][20] = 206,
	[1154][21] = 206,
	[1154][22] = 206,
	[1154][23] = 206,
	[1154][24] = 206,
	[1154][25] = 206,
	[1154][26] = 206,
	[1154][27] = 206,
	[1154][28] = 206,
	[1154][29] = 206,
	[1154][30] = 206,
	[1154][31] = 206,
	[1154][32] = 206,
	[1154][33] = 206,
	[1154][34] = 206,
	[1154][35] = 206,
	[1154][36] = 206,
	[1154][40] = 206,
	[1156][4] = 207,
	[1156][6] = 207,
	[1156][8] = 207,
	[1156][9] = 207,
	[1156][14] = 207,
	[1156][16] = 207,
	[1156][17] = 207,
	[1156][18] = 207,
	[1156][19] = 207,
	[1156][20] = 207,
	[1156][21] = 207,
	[1156][22] = 207,
	[1156][23] = 207,
	[1156][24] = 207,
	[1156][25] = 207,
	[1156][26] = 207,
	[1156][27] = 207,
	[1156][28] = 207,
	[1156][29] = 207,
	[1156][30] = 207,
	[1156][31] = 207,
	[1156][32] = 207,
	[1156][33] = 207,
	[1156][34] = 207,
	[1156][35] = 207,
	[1156][36] = 207,
	[1156][40] = 207,
	[1158][4] = 208,
	[1158][6] = 208,
	[1158][8] = 208,
	[1158][9] = 208,
	[1158][14] = 208,
	[1158][16] = 208,
	[1158][17] = 208,
	[1158][18] = 208,
	[1158][19] = 208,
	[1158][20] = 208,
	[1158][21] = 208,
	[1158][22] = 208,
	[1158][23] = 208,
	[1158][24] = 208,
	[1158][25] = 208,
	[1158][26] = 208,
	[1158][27] = 208,
	[1158][28] = 208,
	[1158][29] = 208,
	[1158][30] = 208,
	[1158][31] = 208,
	[1158][32] = 208,
	[1158][33] = 208,
	[1158][34] = 208,
	[1158][35] = 208,
	[1158][36] = 208,
	[1158][40] = 208,
	[1159][4] = 276,
	[1159][6] = 276,
	[1159][8] = 276,
	[1159][9] = 276,
	[1159][14] = 276,
	[1159][16] = 276,
	[1159][17] = 276,
	[1159][18] = 276,
	[1159][19] = 276,
	[1159][20] = 276,
	[1159][21] = 276,
	[1159][22] = 276,
	[1159][23] = 276,
	[1159][24] = 276,
	[1159][25] = 276,
	[1159][26] = 276,
	[1159][27] = 276,
	[1159][28] = 276,
	[1159][29] = 276,
	[1159][30] = 276,
	[1159][31] = 276,
	[1159][32] = 276,
	[1159][33] = 276,
	[1159][34] = 276,
	[1159][35] = 276,
	[1159][36] = 276,
	[1159][38] = 276,
	[1159][39] = 276,
	[1160][4] = 280,
	[1160][6] = 280,
	[1160][8] = 280,
	[1160][9] = 280,
	[1160][14] = 280,
	[1160][16] = 280,
	[1160][17] = 280,
	[1160][18] = 280,
	[1160][19] = 280,
	[1160][20] = 280,
	[1160][21] = 280,
	[1160][22] = 280,
	[1160][23] = 280,
	[1160][24] = 280,
	[1160][25] = 280,
	[1160][26] = 280,
	[1160][27] = 280,
	[1160][28] = 280,
	[1160][29] = 280,
	[1160][30] = 280,
	[1160][31] = 280,
	[1160][32] = 280,
	[1160][33] = 280,
	[1160][34] = 280,
	[1160][35] = 280,
	[1160][36] = 280,
	[1160][38] = 280,
	[1160][39] = 280,
	[1161][4] = 276,
	[1161][6] = 276,
	[1161][8] = 276,
	[1161][9] = 276,
	[1161][14] = 276,
	[1161][16] = 276,
	[1161][17] = 276,
	[1161][18] = 276,
	[1161][19] = 276,
	[1161][20] = 276,
	[1161][21] = 276,
	[1161][22] = 276,
	[1161][23] = 276,
	[1161][24] = 276,
	[1161][25] = 276,
	[1161][26] = 276,
	[1161][27] = 276,
	[1161][28] = 276,
	[1161][29] = 276,
	[1161][30] = 276,
	[1161][31] = 276,
	[1161][32] = 276,
	[1161][33] = 276,
	[1161][34] = 276,
	[1161][35] = 276,
	[1161][36] = 276,
	[1161][39] = 276,
	[1161][40] = 276,
	[1162][4] = 280,
	[1162][6] = 280,
	[1162][8] = 280,
	[1162][9] = 280,
	[1162][14] = 280,
	[1162][16] = 280,
	[1162][17] = 280,
	[1162][18] = 280,
	[1162][19] = 280,
	[1162][20] = 280,
	[1162][21] = 280,
	[1162][22] = 280,
	[1162][23] = 280,
	[1162][24] = 280,
	[1162][25] = 280,
	[1162][26] = 280,
	[1162][27] = 280,
	[1162][28] = 280,
	[1162][29] = 280,
	[1162][30] = 280,
	[1162][31] = 280,
	[1162][32] = 280,
	[1162][33] = 280,
	[1162][34] = 280,
	[1162][35] = 280,
	[1162][36] = 280,
	[1162][39] = 280,
	[1162][40] = 280,
	[1163][2] = 250,
	[1163][3] = 250,
	[1163][4] = 250,
	[1163][7] = 250,
	[1163][8] = 250,
	[1163][9] = 250,
	[1163][11] = 250,
	[1163][18] = 250,
	[1163][19] = 250,
	[1163][20] = 250,
	[1163][23] = 250,
	[1163][38] = 250,
	[1164][2] = 251,
	[1164][3] = 251,
	[1164][4] = 251,
	[1164][7] = 251,
	[1164][8] = 251,
	[1164][9] = 251,
	[1164][11] = 251,
	[1164][18] = 251,
	[1164][19] = 251,
	[1164][20] = 251,
	[1164][23] = 251,
	[1164][38] = 251,
	[1165][2] = 252,
	[1165][3] = 252,
	[1165][4] = 252,
	[1165][7] = 252,
	[1165][8] = 252,
	[1165][9] = 252,
	[1165][11] = 252,
	[1165][18] = 252,
	[1165][19] = 252,
	[1165][20] = 252,
	[1165][23] = 252,
	[1165][38] = 252,
	[1166][2] = 253,
	[1166][3] = 253,
	[1166][4] = 253,
	[1166][7] = 253,
	[1166][8] = 253,
	[1166][9] = 253,
	[1166][11] = 253,
	[1166][18] = 253,
	[1166][19] = 253,
	[1166][20] = 253,
	[1166][23] = 253,
	[1166][38] = 253,
	[1167][2] = 255,
	[1167][3] = 255,
	[1167][4] = 255,
	[1167][7] = 255,
	[1167][8] = 255,
	[1167][9] = 255,
	[1167][11] = 255,
	[1167][18] = 255,
	[1167][19] = 255,
	[1167][20] = 255,
	[1167][23] = 255,
	[1167][38] = 255,
	[1168][2] = 267,
	[1168][3] = 267,
	[1168][4] = 267,
	[1168][7] = 267,
	[1168][8] = 267,
	[1168][9] = 267,
	[1168][11] = 267,
	[1168][18] = 267,
	[1168][19] = 267,
	[1168][20] = 267,
	[1168][23] = 267,
	[1168][38] = 267,
	[1169][2] = 270,
	[1169][3] = 270,
	[1169][4] = 270,
	[1169][7] = 270,
	[1169][8] = 270,
	[1169][9] = 270,
	[1169][11] = 270,
	[1169][18] = 270,
	[1169][19] = 270,
	[1169][20] = 270,
	[1169][23] = 270,
	[1169][38] = 270,
	[1170][2] = 281,
	[1170][3] = 281,
	[1170][4] = 281,
	[1170][7] = 281,
	[1170][8] = 281,
	[1170][9] = 281,
	[1170][11] = 281,
	[1170][18] = 281,
	[1170][19] = 281,
	[1170][20] = 281,
	[1170][23] = 281,
	[1170][37] = 281,
	[1172][18] = 275,
	[1172][38] = 275,
	[1173][2] = 254,
	[1173][3] = 254,
	[1173][4] = 254,
	[1173][5] = 254,
	[1173][6] = 254,
	[1173][16] = 254,
	[1173][17] = 254,
	[1173][18] = 254,
	[1173][38] = 254,
	[1173][39] = 254,
	[1174][2] = 256,
	[1174][3] = 256,
	[1174][4] = 256,
	[1174][5] = 256,
	[1174][18] = 256,
	[1174][38] = 256,
	[1174][39] = 256,
	[1175][2] = 257,
	[1175][3] = 257,
	[1175][4] = 257,
	[1175][5] = 257,
	[1175][18] = 257,
	[1175][38] = 257,
	[1175][39] = 257,
	[1176][2] = 173,
	[1176][3] = 173,
	[1176][4] = 173,
	[1176][5] = 173,
	[1176][16] = 173,
	[1176][17] = 173,
	[1176][18] = 173,
	[1176][38] = 173,
	[1176][39] = 173,
	[1177][2] = 174,
	[1177][3] = 174,
	[1177][4] = 174,
	[1177][5] = 174,
	[1177][16] = 174,
	[1177][17] = 174,
	[1177][18] = 174,
	[1177][38] = 174,
	[1177][39] = 174,
	[1180][2] = 175,
	[1180][3] = 175,
	[1180][4] = 175,
	[1180][5] = 175,
	[1180][16] = 175,
	[1180][17] = 175,
	[1180][18] = 175,
	[1180][38] = 175,
	[1180][39] = 175,
	[1181][2] = 258,
	[1181][3] = 258,
	[1181][4] = 258,
	[1181][5] = 258,
	[1181][16] = 258,
	[1181][17] = 258,
	[1181][18] = 258,
	[1181][38] = 258,
	[1181][39] = 258,
	[1182][2] = 259,
	[1182][3] = 259,
	[1182][4] = 259,
	[1182][5] = 259,
	[1182][17] = 259,
	[1182][18] = 259,
	[1182][38] = 259,
	[1182][39] = 259,
	[1183][2] = 260,
	[1183][3] = 260,
	[1183][4] = 260,
	[1183][5] = 260,
	[1183][17] = 260,
	[1183][18] = 260,
	[1183][38] = 260,
	[1183][39] = 260,
	[1184][38] = 261,
	[1185][38] = 262,
	[1186][38] = 263,
	[1187][38] = 264,
	[1190][38] = 265,
	[1191][38] = 266,
	[1192][2] = 282,
	[1192][3] = 282,
	[1192][4] = 282,
	[1192][7] = 282,
	[1192][8] = 282,
	[1192][9] = 282,
	[1192][11] = 282,
	[1192][18] = 282,
	[1192][19] = 282,
	[1192][20] = 282,
	[1192][23] = 282,
	[1192][37] = 282,
	[1193][2] = 283,
	[1193][3] = 283,
	[1193][4] = 283,
	[1193][7] = 283,
	[1193][8] = 283,
	[1193][9] = 283,
	[1193][11] = 283,
	[1193][18] = 283,
	[1193][19] = 283,
	[1193][20] = 283,
	[1193][23] = 283,
	[1193][37] = 283,
	[1196][2] = 218,
	[1196][3] = 218,
	[1196][4] = 218,
	[1196][5] = 218,
	[1196][16] = 218,
	[1196][17] = 218,
	[1196][18] = 218,
	[1196][39] = 218,
	[1196][40] = 218,
	[1198][40] = 284,
	[1199][40] = 285,
	[1200][40] = 286,
	[1201][40] = 287,
	[1202][40] = 288,
	[1203][2] = 268,
	[1203][3] = 268,
	[1203][4] = 268,
	[1203][7] = 268,
	[1203][8] = 268,
	[1203][9] = 268,
	[1203][18] = 268,
	[1203][19] = 268,
	[1203][20] = 268,
	[1203][38] = 268,
	[1204][2] = 269,
	[1204][3] = 269,
	[1204][4] = 269,
	[1204][7] = 269,
	[1204][8] = 269,
	[1204][9] = 269,
	[1204][18] = 269,
	[1204][19] = 269,
	[1204][20] = 269,
	[1204][38] = 269,
	[1205][38] = 271,
	[1206][38] = 272,
	[1207][18] = 273,
	[1207][38] = 273,
	[1208][18] = 274,
	[1208][38] = 274,
	[1209][2] = 289,
	[1209][3] = 289,
	[1209][4] = 289,
	[1209][7] = 289,
	[1209][8] = 289,
	[1209][9] = 289,
	[1209][11] = 289,
	[1209][18] = 289,
	[1209][19] = 289,
	[1209][20] = 289,
	[1209][23] = 289,
	[1209][37] = 289,
	[1210][2] = 290,
	[1210][3] = 290,
	[1210][4] = 290,
	[1210][7] = 290,
	[1210][8] = 290,
	[1210][9] = 290,
	[1210][11] = 290,
	[1210][18] = 290,
	[1210][19] = 290,
	[1210][20] = 290,
	[1210][23] = 290,
	[1210][37] = 290,
	[1212][18] = 291,
	[1212][23] = 291,
	[1213][37] = 292,
	[1215][18] = 291,
	[1215][37] = 291,
	[1216][38] = 277,
	[1216][39] = 277,
	[1216][55] = 277,
	[1217][38] = 278,
	[1217][39] = 278,
	[1218][38] = 279,
	[1218][39] = 279,
	[1219][39] = 277,
	[1219][41] = 277,
	[1219][55] = 277,
	[1220][39] = 278,
	[1220][41] = 278,
	[1221][39] = 279,
	[1221][41] = 279,
	[1222][4] = 209,
	[1222][6] = 209,
	[1222][8] = 209,
	[1222][9] = 209,
	[1222][14] = 209,
	[1222][16] = 209,
	[1222][17] = 209,
	[1222][18] = 209,
	[1222][19] = 209,
	[1222][20] = 209,
	[1222][21] = 209,
	[1222][22] = 209,
	[1222][23] = 209,
	[1222][24] = 209,
	[1222][25] = 209,
	[1222][26] = 209,
	[1222][27] = 209,
	[1222][28] = 209,
	[1222][29] = 209,
	[1222][30] = 209,
	[1222][31] = 209,
	[1222][32] = 209,
	[1222][33] = 209,
	[1222][34] = 209,
	[1222][35] = 209,
	[1222][36] = 209,
	[1222][41] = 209,
	[1223][4] = 210,
	[1223][6] = 210,
	[1223][8] = 210,
	[1223][9] = 210,
	[1223][14] = 210,
	[1223][16] = 210,
	[1223][17] = 210,
	[1223][18] = 210,
	[1223][19] = 210,
	[1223][20] = 210,
	[1223][21] = 210,
	[1223][22] = 210,
	[1223][23] = 210,
	[1223][24] = 210,
	[1223][25] = 210,
	[1223][26] = 210,
	[1223][27] = 210,
	[1223][28] = 210,
	[1223][29] = 210,
	[1223][30] = 210,
	[1223][31] = 210,
	[1223][32] = 210,
	[1223][33] = 210,
	[1223][34] = 210,
	[1223][35] = 210,
	[1223][36] = 210,
	[1223][41] = 210,
	[1224][4] = 232,
	[1224][6] = 232,
	[1224][8] = 232,
	[1224][9] = 232,
	[1224][14] = 232,
	[1224][16] = 232,
	[1224][17] = 232,
	[1224][18] = 232,
	[1224][19] = 232,
	[1224][20] = 232,
	[1224][21] = 232,
	[1224][22] = 232,
	[1224][23] = 232,
	[1224][24] = 232,
	[1224][25] = 232,
	[1224][26] = 232,
	[1224][27] = 232,
	[1224][28] = 232,
	[1224][29] = 232,
	[1224][30] = 232,
	[1224][31] = 232,
	[1224][32] = 232,
	[1224][33] = 232,
	[1224][34] = 232,
	[1224][35] = 232,
	[1224][36] = 232,
	[1224][41] = 232,
	[1226][4] = 233,
	[1226][6] = 233,
	[1226][8] = 233,
	[1226][9] = 233,
	[1226][14] = 233,
	[1226][16] = 233,
	[1226][17] = 233,
	[1226][18] = 233,
	[1226][19] = 233,
	[1226][20] = 233,
	[1226][21] = 233,
	[1226][22] = 233,
	[1226][23] = 233,
	[1226][24] = 233,
	[1226][25] = 233,
	[1226][26] = 233,
	[1226][27] = 233,
	[1226][28] = 233,
	[1226][29] = 233,
	[1226][30] = 233,
	[1226][31] = 233,
	[1226][32] = 233,
	[1226][33] = 233,
	[1226][34] = 233,
	[1226][35] = 233,
	[1226][36] = 233,
	[1226][41] = 233,
	[1227][34] = 239,
	[1227][35] = 239,
	[1227][36] = 239,
	[1227][41] = 239,
	[1228][34] = 240,
	[1228][35] = 240,
	[1228][36] = 240,
	[1228][41] = 240,
	[1229][34] = 243,
	[1229][35] = 243,
	[1229][36] = 243,
	[1229][41] = 243,
	[1230][34] = 244,
	[1230][35] = 244,
	[1230][36] = 244,
	[1230][41] = 244,
	[1231][41] = 245,
	[1232][34] = 246,
	[1232][35] = 246,
	[1232][36] = 246,
	[1232][41] = 246,
	[1233][36] = 247,
	[1233][41] = 247,
	[1234][4] = 248,
	[1234][6] = 248,
	[1234][8] = 248,
	[1234][9] = 248,
	[1234][14] = 248,
	[1234][16] = 248,
	[1234][17] = 248,
	[1234][18] = 248,
	[1234][19] = 248,
	[1234][20] = 248,
	[1234][21] = 248,
	[1234][22] = 248,
	[1234][23] = 248,
	[1234][24] = 248,
	[1234][25] = 248,
	[1234][26] = 248,
	[1234][27] = 248,
	[1234][28] = 248,
	[1234][29] = 248,
	[1234][30] = 248,
	[1234][31] = 248,
	[1234][32] = 248,
	[1234][33] = 248,
	[1234][34] = 248,
	[1234][35] = 248,
	[1234][36] = 248,
	[1234][41] = 248,
	[1236][4] = 249,
	[1236][6] = 249,
	[1236][8] = 249,
	[1236][9] = 249,
	[1236][14] = 249,
	[1236][16] = 249,
	[1236][17] = 249,
	[1236][18] = 249,
	[1236][19] = 249,
	[1236][20] = 249,
	[1236][21] = 249,
	[1236][22] = 249,
	[1236][23] = 249,
	[1236][24] = 249,
	[1236][25] = 249,
	[1236][26] = 249,
	[1236][27] = 249,
	[1236][28] = 249,
	[1236][29] = 249,
	[1236][30] = 249,
	[1236][31] = 249,
	[1236][32] = 249,
	[1236][33] = 249,
	[1236][34] = 249,
	[1236][35] = 249,
	[1236][36] = 249,
	[1236][41] = 249,
	[1237][4] = 209,
	[1237][6] = 209,
	[1237][8] = 209,
	[1237][9] = 209,
	[1237][14] = 209,
	[1237][16] = 209,
	[1237][17] = 209,
	[1237][18] = 209,
	[1237][19] = 209,
	[1237][20] = 209,
	[1237][21] = 209,
	[1237][22] = 209,
	[1237][23] = 209,
	[1237][24] = 209,
	[1237][25] = 209,
	[1237][26] = 209,
	[1237][27] = 209,
	[1237][28] = 209,
	[1237][29] = 209,
	[1237][30] = 209,
	[1237][31] = 209,
	[1237][32] = 209,
	[1237][33] = 209,
	[1237][34] = 209,
	[1237][35] = 209,
	[1237][36] = 209,
	[1237][40] = 209,
	[1238][4] = 210,
	[1238][6] = 210,
	[1238][8] = 210,
	[1238][9] = 210,
	[1238][14] = 210,
	[1238][16] = 210,
	[1238][17] = 210,
	[1238][18] = 210,
	[1238][19] = 210,
	[1238][20] = 210,
	[1238][21] = 210,
	[1238][22] = 210,
	[1238][23] = 210,
	[1238][24] = 210,
	[1238][25] = 210,
	[1238][26] = 210,
	[1238][27] = 210,
	[1238][28] = 210,
	[1238][29] = 210,
	[1238][30] = 210,
	[1238][31] = 210,
	[1238][32] = 210,
	[1238][33] = 210,
	[1238][34] = 210,
	[1238][35] = 210,
	[1238][36] = 210,
	[1238][40] = 210,
	[1239][4] = 232,
	[1239][6] = 232,
	[1239][8] = 232,
	[1239][9] = 232,
	[1239][14] = 232,
	[1239][16] = 232,
	[1239][17] = 232,
	[1239][18] = 232,
	[1239][19] = 232,
	[1239][20] = 232,
	[1239][21] = 232,
	[1239][22] = 232,
	[1239][23] = 232,
	[1239][24] = 232,
	[1239][25] = 232,
	[1239][26] = 232,
	[1239][27] = 232,
	[1239][28] = 232,
	[1239][29] = 232,
	[1239][30] = 232,
	[1239][31] = 232,
	[1239][32] = 232,
	[1239][33] = 232,
	[1239][34] = 232,
	[1239][35] = 232,
	[1239][36] = 232,
	[1239][40] = 232,
	[1241][4] = 233,
	[1241][6] = 233,
	[1241][8] = 233,
	[1241][9] = 233,
	[1241][14] = 233,
	[1241][16] = 233,
	[1241][17] = 233,
	[1241][18] = 233,
	[1241][19] = 233,
	[1241][20] = 233,
	[1241][21] = 233,
	[1241][22] = 233,
	[1241][23] = 233,
	[1241][24] = 233,
	[1241][25] = 233,
	[1241][26] = 233,
	[1241][27] = 233,
	[1241][28] = 233,
	[1241][29] = 233,
	[1241][30] = 233,
	[1241][31] = 233,
	[1241][32] = 233,
	[1241][33] = 233,
	[1241][34] = 233,
	[1241][35] = 233,
	[1241][36] = 233,
	[1241][40] = 233,
	[1242][34] = 239,
	[1242][35] = 239,
	[1242][36] = 239,
	[1242][40] = 239,
	[1243][34] = 240,
	[1243][35] = 240,
	[1243][36] = 240,
	[1243][40] = 240,
	[1244][34] = 243,
	[1244][35] = 243,
	[1244][36] = 243,
	[1244][40] = 243,
	[1245][34] = 244,
	[1245][35] = 244,
	[1245][36] = 244,
	[1245][40] = 244,
	[1246][40] = 245,
	[1247][34] = 246,
	[1247][35] = 246,
	[1247][36] = 246,
	[1247][40] = 246,
	[1248][36] = 247,
	[1248][40] = 247,
	[1249][4] = 248,
	[1249][6] = 248,
	[1249][8] = 248,
	[1249][9] = 248,
	[1249][14] = 248,
	[1249][16] = 248,
	[1249][17] = 248,
	[1249][18] = 248,
	[1249][19] = 248,
	[1249][20] = 248,
	[1249][21] = 248,
	[1249][22] = 248,
	[1249][23] = 248,
	[1249][24] = 248,
	[1249][25] = 248,
	[1249][26] = 248,
	[1249][27] = 248,
	[1249][28] = 248,
	[1249][29] = 248,
	[1249][30] = 248,
	[1249][31] = 248,
	[1249][32] = 248,
	[1249][33] = 248,
	[1249][34] = 248,
	[1249][35] = 248,
	[1249][36] = 248,
	[1249][40] = 248,
	[1251][4] = 249,
	[1251][6] = 249,
	[1251][8] = 249,
	[1251][9] = 249,
	[1251][14] = 249,
	[1251][16] = 249,
	[1251][17] = 249,
	[1251][18] = 249,
	[1251][19] = 249,
	[1251][20] = 249,
	[1251][21] = 249,
	[1251][22] = 249,
	[1251][23] = 249,
	[1251][24] = 249,
	[1251][25] = 249,
	[1251][26] = 249,
	[1251][27] = 249,
	[1251][28] = 249,
	[1251][29] = 249,
	[1251][30] = 249,
	[1251][31] = 249,
	[1251][32] = 249,
	[1251][33] = 249,
	[1251][34] = 249,
	[1251][35] = 249,
	[1251][36] = 249,
	[1251][40] = 249,
	[1252][2] = 281,
	[1252][3] = 281,
	[1252][4] = 281,
	[1252][7] = 281,
	[1252][8] = 281,
	[1252][9] = 281,
	[1252][11] = 281,
	[1252][18] = 281,
	[1252][19] = 281,
	[1252][20] = 281,
	[1252][23] = 281,
	[1252][38] = 281,
	[1253][2] = 282,
	[1253][3] = 282,
	[1253][4] = 282,
	[1253][7] = 282,
	[1253][8] = 282,
	[1253][9] = 282,
	[1253][11] = 282,
	[1253][18] = 282,
	[1253][19] = 282,
	[1253][20] = 282,
	[1253][23] = 282,
	[1253][38] = 282,
	[1254][2] = 283,
	[1254][3] = 283,
	[1254][4] = 283,
	[1254][7] = 283,
	[1254][8] = 283,
	[1254][9] = 283,
	[1254][11] = 283,
	[1254][18] = 283,
	[1254][19] = 283,
	[1254][20] = 283,
	[1254][23] = 283,
	[1254][38] = 283,
	[1255][2] = 289,
	[1255][3] = 289,
	[1255][4] = 289,
	[1255][7] = 289,
	[1255][8] = 289,
	[1255][9] = 289,
	[1255][11] = 289,
	[1255][18] = 289,
	[1255][19] = 289,
	[1255][20] = 289,
	[1255][23] = 289,
	[1255][38] = 289,
	[1256][2] = 290,
	[1256][3] = 290,
	[1256][4] = 290,
	[1256][7] = 290,
	[1256][8] = 290,
	[1256][9] = 290,
	[1256][11] = 290,
	[1256][18] = 290,
	[1256][19] = 290,
	[1256][20] = 290,
	[1256][23] = 290,
	[1256][38] = 290,
	[1257][38] = 292,
	[1260][2] = 218,
	[1260][3] = 218,
	[1260][4] = 218,
	[1260][5] = 218,
	[1260][16] = 218,
	[1260][17] = 218,
	[1260][18] = 218,
	[1260][38] = 218,
	[1260][39] = 218,
	[1262][38] = 284,
	[1263][38] = 285,
	[1264][38] = 286,
	[1265][38] = 287,
	[1266][38] = 288,
	[1267][2] = 293,
	[1267][3] = 293,
	[1267][4] = 293,
	[1267][7] = 293,
	[1267][8] = 293,
	[1267][9] = 293,
	[1267][11] = 293,
	[1267][18] = 293,
	[1267][19] = 293,
	[1267][20] = 293,
	[1267][23] = 293,
	[1267][37] = 293,
	[1268][2] = 294,
	[1268][3] = 294,
	[1268][4] = 294,
	[1268][5] = 294,
	[1268][18] = 294,
	[1268][39] = 294,
	[1268][40] = 294,
	[1269][2] = 254,
	[1269][3] = 254,
	[1269][4] = 254,
	[1269][5] = 254,
	[1269][16] = 254,
	[1269][17] = 254,
	[1269][18] = 254,
	[1269][39] = 254,
	[1269][40] = 254,
	[1270][2] = 295,
	[1270][3] = 295,
	[1270][4] = 295,
	[1270][5] = 295,
	[1270][17] = 295,
	[1270][18] = 295,
	[1270][39] = 295,
	[1270][40] = 295,
	[1272][18] = 291,
	[1272][38] = 291,
	[1273][2] = 296,
	[1273][3] = 296,
	[1273][4] = 296,
	[1273][7] = 296,
	[1273][8] = 296,
	[1273][9] = 296,
	[1273][11] = 296,
	[1273][18] = 296,
	[1273][19] = 296,
	[1273][20] = 296,
	[1273][23] = 296,
	[1273][37] = 296,
	[1274][23] = 297,
	[1275][37] = 297,
	[1276][4] = 276,
	[1276][6] = 276,
	[1276][8] = 276,
	[1276][9] = 276,
	[1276][14] = 276,
	[1276][16] = 276,
	[1276][17] = 276,
	[1276][18] = 276,
	[1276][19] = 276,
	[1276][20] = 276,
	[1276][21] = 276,
	[1276][22] = 276,
	[1276][23] = 276,
	[1276][24] = 276,
	[1276][25] = 276,
	[1276][26] = 276,
	[1276][27] = 276,
	[1276][28] = 276,
	[1276][29] = 276,
	[1276][30] = 276,
	[1276][31] = 276,
	[1276][32] = 276,
	[1276][33] = 276,
	[1276][34] = 276,
	[1276][35] = 276,
	[1276][36] = 276,
	[1276][41] = 276,
	[1277][4] = 280,
	[1277][6] = 280,
	[1277][8] = 280,
	[1277][9] = 280,
	[1277][14] = 280,
	[1277][16] = 280,
	[1277][17] = 280,
	[1277][18] = 280,
	[1277][19] = 280,
	[1277][20] = 280,
	[1277][21] = 280,
	[1277][22] = 280,
	[1277][23] = 280,
	[1277][24] = 280,
	[1277][25] = 280,
	[1277][26] = 280,
	[1277][27] = 280,
	[1277][28] = 280,
	[1277][29] = 280,
	[1277][30] = 280,
	[1277][31] = 280,
	[1277][32] = 280,
	[1277][33] = 280,
	[1277][34] = 280,
	[1277][35] = 280,
	[1277][36] = 280,
	[1277][41] = 280,
	[1278][4] = 276,
	[1278][6] = 276,
	[1278][8] = 276,
	[1278][9] = 276,
	[1278][14] = 276,
	[1278][16] = 276,
	[1278][17] = 276,
	[1278][18] = 276,
	[1278][19] = 276,
	[1278][20] = 276,
	[1278][21] = 276,
	[1278][22] = 276,
	[1278][23] = 276,
	[1278][24] = 276,
	[1278][25] = 276,
	[1278][26] = 276,
	[1278][27] = 276,
	[1278][28] = 276,
	[1278][29] = 276,
	[1278][30] = 276,
	[1278][31] = 276,
	[1278][32] = 276,
	[1278][33] = 276,
	[1278][34] = 276,
	[1278][35] = 276,
	[1278][36] = 276,
	[1278][40] = 276,
	[1279][4] = 280,
	[1279][6] = 280,
	[1279][8] = 280,
	[1279][9] = 280,
	[1279][14] = 280,
	[1279][16] = 280,
	[1279][17] = 280,
	[1279][18] = 280,
	[1279][19] = 280,
	[1279][20] = 280,
	[1279][21] = 280,
	[1279][22] = 280,
	[1279][23] = 280,
	[1279][24] = 280,
	[1279][25] = 280,
	[1279][26] = 280,
	[1279][27] = 280,
	[1279][28] = 280,
	[1279][29] = 280,
	[1279][30] = 280,
	[1279][31] = 280,
	[1279][32] = 280,
	[1279][33] = 280,
	[1279][34] = 280,
	[1279][35] = 280,
	[1279][36] = 280,
	[1279][40] = 280,
	[1280][2] = 293,
	[1280][3] = 293,
	[1280][4] = 293,
	[1280][7] = 293,
	[1280][8] = 293,
	[1280][9] = 293,
	[1280][11] = 293,
	[1280][18] = 293,
	[1280][19] = 293,
	[1280][20] = 293,
	[1280][23] = 293,
	[1280][38] = 293,
	[1281][2] = 296,
	[1281][3] = 296,
	[1281][4] = 296,
	[1281][7] = 296,
	[1281][8] = 296,
	[1281][9] = 296,
	[1281][11] = 296,
	[1281][18] = 296,
	[1281][19] = 296,
	[1281][20] = 296,
	[1281][23] = 296,
	[1281][38] = 296,
	[1282][2] = 294,
	[1282][3] = 294,
	[1282][4] = 294,
	[1282][5] = 294,
	[1282][18] = 294,
	[1282][38] = 294,
	[1282][39] = 294,
	[1283][2] = 254,
	[1283][3] = 254,
	[1283][4] = 254,
	[1283][5] = 254,
	[1283][16] = 254,
	[1283][17] = 254,
	[1283][18] = 254,
	[1283][38] = 254,
	[1283][39] = 254,
	[1284][2] = 295,
	[1284][3] = 295,
	[1284][4] = 295,
	[1284][5] = 295,
	[1284][17] = 295,
	[1284][18] = 295,
	[1284][38] = 295,
	[1284][39] = 295,
	[1285][38] = 297,
};


const unsigned zebu_gotos[1272][77] = {
	[1][1] = 16,
	[1][2] = 17,
	[1][3] = 18,
	[1][4] = 19,
	[1][5] = 20,
	[1][6] = 21,
	[1][7] = 22,
	[1][8] = 23,
	[1][9] = 24,
	[1][10] = 25,
	[1][11] = 26,
	[1][12] = 27,
	[1][13] = 28,
	[1][14] = 29,
	[1][15] = 30,
	[1][16] = 31,
	[1][17] = 32,
	[1][18] = 33,
	[1][19] = 34,
	[1][20] = 35,
	[1][21] = 36,
	[1][22] = 37,
	[1][23] = 38,
	[1][24] = 39,
	[1][25] = 40,
	[4][1] = 56,
	[4][2] = 57,
	[4][4] = 58,
	[4][5] = 59,
	[4][6] = 60,
	[4][7] = 61,
	[4][8] = 62,
	[4][10] = 63,
	[4][11] = 64,
	[4][12] = 65,
	[4][13] = 66,
	[4][14] = 67,
	[4][15] = 68,
	[4][16] = 69,
	[4][17] = 70,
	[4][18] = 71,
	[4][19] = 72,
	[4][20] = 73,
	[4][23] = 74,
	[5][17] = 32,
	[5][18] = 33,
	[5][23] = 76,
	[6][17] = 32,
	[6][18] = 33,
	[6][23] = 77,
	[8][1] = 93,
	[8][2] = 94,
	[8][4] = 95,
	[8][5] = 96,
	[8][6] = 97,
	[8][7] = 98,
	[8][8] = 99,
	[8][10] = 100,
	[8][11] = 101,
	[8][12] = 102,
	[8][13] = 103,
	[8][14] = 104,
	[8][15] = 105,
	[8][16] = 106,
	[8][17] = 107,
	[8][18] = 108,
	[8][19] = 109,
	[8][20] = 110,
	[8][23] = 111,
	[9][17] = 32,
	[9][18] = 33,
	[9][23] = 112,
	[13][17] = 32,
	[13][18] = 33,
	[13][23] = 116,
	[15][26] = 133,
	[15][27] = 134,
	[18][1] = 16,
	[18][2] = 17,
	[18][3] = 139,
	[18][4] = 19,
	[18][5] = 20,
	[18][6] = 21,
	[18][7] = 22,
	[18][8] = 23,
	[18][9] = 140,
	[18][10] = 25,
	[18][11] = 26,
	[18][12] = 27,
	[18][13] = 28,
	[18][14] = 29,
	[18][15] = 30,
	[18][16] = 31,
	[18][17] = 32,
	[18][18] = 33,
	[18][19] = 34,
	[18][20] = 35,
	[18][21] = 141,
	[18][22] = 142,
	[18][23] = 38,
	[18][24] = 143,
	[18][25] = 144,
	[18][28] = 138,
	[23][29] = 150,
	[24][1] = 16,
	[24][2] = 17,
	[24][3] = 152,
	[24][4] = 19,
	[24][5] = 20,
	[24][6] = 21,
	[24][7] = 22,
	[24][8] = 23,
	[24][9] = 153,
	[24][10] = 25,
	[24][11] = 26,
	[24][12] = 27,
	[24][13] = 28,
	[24][14] = 29,
	[24][15] = 30,
	[24][16] = 31,
	[24][17] = 32,
	[24][18] = 33,
	[24][19] = 34,
	[24][20] = 35,
	[24][21] = 154,
	[24][22] = 155,
	[24][23] = 38,
	[24][24] = 156,
	[24][25] = 157,
	[24][30] = 151,
	[36][1] = 16,
	[36][2] = 17,
	[36][3] = 178,
	[36][4] = 19,
	[36][5] = 20,
	[36][6] = 21,
	[36][7] = 22,
	[36][8] = 23,
	[36][9] = 179,
	[36][10] = 25,
	[36][11] = 26,
	[36][12] = 27,
	[36][13] = 28,
	[36][14] = 29,
	[36][15] = 30,
	[36][16] = 31,
	[36][17] = 32,
	[36][18] = 33,
	[36][19] = 34,
	[36][20] = 35,
	[36][21] = 180,
	[36][22] = 181,
	[36][23] = 38,
	[36][24] = 182,
	[36][25] = 183,
	[36][31] = 177,
	[37][1] = 16,
	[37][2] = 17,
	[37][3] = 185,
	[37][4] = 19,
	[37][5] = 20,
	[37][6] = 21,
	[37][7] = 22,
	[37][8] = 23,
	[37][9] = 186,
	[37][10] = 25,
	[37][11] = 26,
	[37][12] = 27,
	[37][13] = 28,
	[37][14] = 29,
	[37][15] = 30,
	[37][16] = 31,
	[37][17] = 32,
	[37][18] = 33,
	[37][19] = 34,
	[37][20] = 35,
	[37][21] = 187,
	[37][22] = 188,
	[37][23] = 38,
	[37][24] = 189,
	[37][25] = 190,
	[37][32] = 184,
	[39][1] = 16,
	[39][2] = 17,
	[39][3] = 192,
	[39][4] = 19,
	[39][5] = 20,
	[39][6] = 21,
	[39][7] = 22,
	[39][8] = 23,
	[39][9] = 193,
	[39][10] = 25,
	[39][11] = 26,
	[39][12] = 27,
	[39][13] = 28,
	[39][14] = 29,
	[39][15] = 30,
	[39][16] = 31,
	[39][17] = 32,
	[39][18] = 33,
	[39][19] = 34,
	[39][20] = 35,
	[39][21] = 194,
	[39][22] = 195,
	[39][23] = 38,
	[39][24] = 196,
	[39][25] = 197,
	[39][33] = 191,
	[40][1] = 16,
	[40][2] = 17,
	[40][3] = 199,
	[40][4] = 19,
	[40][5] = 20,
	[40][6] = 21,
	[40][7] = 22,
	[40][8] = 23,
	[40][9] = 200,
	[40][10] = 25,
	[40][11] = 26,
	[40][12] = 27,
	[40][13] = 28,
	[40][14] = 29,
	[40][15] = 30,
	[40][16] = 31,
	[40][17] = 32,
	[40][18] = 33,
	[40][19] = 34,
	[40][20] = 35,
	[40][21] = 201,
	[40][22] = 202,
	[40][23] = 38,
	[40][24] = 203,
	[40][25] = 204,
	[40][34] = 198,
	[43][1] = 56,
	[43][2] = 57,
	[43][4] = 58,
	[43][5] = 59,
	[43][6] = 60,
	[43][7] = 61,
	[43][8] = 207,
	[43][10] = 63,
	[43][11] = 64,
	[43][12] = 65,
	[43][13] = 66,
	[43][14] = 67,
	[43][15] = 68,
	[43][16] = 69,
	[43][17] = 70,
	[43][18] = 71,
	[43][19] = 72,
	[43][20] = 73,
	[43][23] = 74,
	[45][17] = 70,
	[45][18] = 71,
	[45][23] = 208,
	[46][17] = 70,
	[46][18] = 71,
	[46][23] = 209,
	[47][1] = 56,
	[47][2] = 57,
	[47][4] = 58,
	[47][5] = 59,
	[47][6] = 60,
	[47][7] = 61,
	[47][8] = 211,
	[47][10] = 63,
	[47][11] = 64,
	[47][12] = 65,
	[47][13] = 66,
	[47][14] = 67,
	[47][15] = 68,
	[47][16] = 69,
	[47][17] = 70,
	[47][18] = 71,
	[47][19] = 72,
	[47][20] = 73,
	[47][23] = 74,
	[47][35] = 210,
	[49][1] = 93,
	[49][2] = 94,
	[49][4] = 95,
	[49][5] = 96,
	[49][6] = 97,
	[49][7] = 98,
	[49][8] = 214,
	[49][10] = 100,
	[49][11] = 101,
	[49][12] = 102,
	[49][13] = 103,
	[49][14] = 104,
	[49][15] = 105,
	[49][16] = 106,
	[49][17] = 107,
	[49][18] = 108,
	[49][19] = 109,
	[49][20] = 110,
	[49][23] = 111,
	[50][17] = 70,
	[50][18] = 71,
	[50][23] = 215,
	[54][17] = 70,
	[54][18] = 71,
	[54][23] = 217,
	[55][26] = 133,
	[55][27] = 220,
	[80][1] = 56,
	[80][2] = 57,
	[80][4] = 58,
	[80][5] = 59,
	[80][6] = 60,
	[80][7] = 61,
	[80][8] = 251,
	[80][10] = 63,
	[80][11] = 64,
	[80][12] = 65,
	[80][13] = 66,
	[80][14] = 67,
	[80][15] = 68,
	[80][16] = 69,
	[80][17] = 70,
	[80][18] = 71,
	[80][19] = 72,
	[80][20] = 73,
	[80][23] = 74,
	[81][17] = 107,
	[81][18] = 108,
	[81][23] = 252,
	[82][17] = 107,
	[82][18] = 108,
	[82][23] = 253,
	[83][1] = 93,
	[83][2] = 94,
	[83][4] = 95,
	[83][5] = 96,
	[83][6] = 97,
	[83][7] = 98,
	[83][8] = 255,
	[83][10] = 100,
	[83][11] = 101,
	[83][12] = 102,
	[83][13] = 103,
	[83][14] = 104,
	[83][15] = 105,
	[83][16] = 106,
	[83][17] = 107,
	[83][18] = 108,
	[83][19] = 109,
	[83][20] = 110,
	[83][23] = 111,
	[83][36] = 254,
	[85][1] = 93,
	[85][2] = 94,
	[85][4] = 95,
	[85][5] = 96,
	[85][6] = 97,
	[85][7] = 98,
	[85][8] = 258,
	[85][10] = 100,
	[85][11] = 101,
	[85][12] = 102,
	[85][13] = 103,
	[85][14] = 104,
	[85][15] = 105,
	[85][16] = 106,
	[85][17] = 107,
	[85][18] = 108,
	[85][19] = 109,
	[85][20] = 110,
	[85][23] = 111,
	[87][17] = 107,
	[87][18] = 108,
	[87][23] = 259,
	[91][17] = 107,
	[91][18] = 108,
	[91][23] = 261,
	[92][26] = 133,
	[92][27] = 264,
	[113][37] = 300,
	[113][38] = 301,
	[113][39] = 302,
	[113][40] = 303,
	[114][1] = 16,
	[114][2] = 17,
	[114][4] = 19,
	[114][5] = 20,
	[114][6] = 21,
	[114][7] = 22,
	[114][8] = 304,
	[114][10] = 25,
	[114][11] = 26,
	[114][12] = 27,
	[114][13] = 28,
	[114][14] = 29,
	[114][15] = 30,
	[114][16] = 31,
	[114][17] = 32,
	[114][18] = 33,
	[114][19] = 34,
	[114][20] = 35,
	[114][23] = 38,
	[115][1] = 56,
	[115][2] = 57,
	[115][4] = 58,
	[115][5] = 59,
	[115][6] = 60,
	[115][7] = 61,
	[115][8] = 307,
	[115][10] = 63,
	[115][11] = 64,
	[115][12] = 65,
	[115][13] = 66,
	[115][14] = 67,
	[115][15] = 68,
	[115][16] = 69,
	[115][17] = 70,
	[115][18] = 71,
	[115][19] = 72,
	[115][20] = 73,
	[115][23] = 74,
	[124][26] = 324,
	[124][27] = 325,
	[125][26] = 133,
	[125][27] = 329,
	[125][41] = 327,
	[125][42] = 328,
	[127][1] = 16,
	[127][2] = 17,
	[127][4] = 19,
	[127][5] = 20,
	[127][6] = 21,
	[127][7] = 22,
	[127][11] = 26,
	[127][12] = 331,
	[127][13] = 28,
	[127][14] = 29,
	[127][15] = 30,
	[127][17] = 32,
	[127][18] = 33,
	[127][19] = 34,
	[127][20] = 35,
	[127][23] = 38,
	[127][43] = 330,
	[132][26] = 341,
	[132][27] = 342,
	[135][7] = 22,
	[135][15] = 345,
	[135][17] = 32,
	[135][18] = 33,
	[135][23] = 38,
	[136][7] = 22,
	[136][15] = 346,
	[136][17] = 32,
	[136][18] = 33,
	[136][23] = 38,
	[137][1] = 16,
	[137][5] = 347,
	[137][7] = 22,
	[137][15] = 30,
	[137][17] = 32,
	[137][18] = 33,
	[137][19] = 34,
	[137][20] = 35,
	[137][23] = 38,
	[139][1] = 16,
	[139][2] = 17,
	[139][3] = 139,
	[139][4] = 19,
	[139][5] = 20,
	[139][6] = 21,
	[139][7] = 22,
	[139][8] = 23,
	[139][9] = 140,
	[139][10] = 25,
	[139][11] = 26,
	[139][12] = 27,
	[139][13] = 28,
	[139][14] = 29,
	[139][15] = 30,
	[139][16] = 31,
	[139][17] = 32,
	[139][18] = 33,
	[139][19] = 34,
	[139][20] = 35,
	[139][21] = 141,
	[139][22] = 142,
	[139][23] = 38,
	[139][24] = 143,
	[139][25] = 144,
	[139][28] = 348,
	[140][1] = 16,
	[140][2] = 17,
	[140][3] = 152,
	[140][4] = 19,
	[140][5] = 20,
	[140][6] = 21,
	[140][7] = 22,
	[140][8] = 23,
	[140][9] = 153,
	[140][10] = 25,
	[140][11] = 26,
	[140][12] = 27,
	[140][13] = 28,
	[140][14] = 29,
	[140][15] = 30,
	[140][16] = 31,
	[140][17] = 32,
	[140][18] = 33,
	[140][19] = 34,
	[140][20] = 35,
	[140][21] = 154,
	[140][22] = 155,
	[140][23] = 38,
	[140][24] = 156,
	[140][25] = 157,
	[140][30] = 349,
	[141][1] = 16,
	[141][2] = 17,
	[141][3] = 178,
	[141][4] = 19,
	[141][5] = 20,
	[141][6] = 21,
	[141][7] = 22,
	[141][8] = 23,
	[141][9] = 179,
	[141][10] = 25,
	[141][11] = 26,
	[141][12] = 27,
	[141][13] = 28,
	[141][14] = 29,
	[141][15] = 30,
	[141][16] = 31,
	[141][17] = 32,
	[141][18] = 33,
	[141][19] = 34,
	[141][20] = 35,
	[141][21] = 180,
	[141][22] = 181,
	[141][23] = 38,
	[141][24] = 182,
	[141][25] = 183,
	[141][31] = 350,
	[142][1] = 16,
	[142][2] = 17,
	[142][3] = 185,
	[142][4] = 19,
	[142][5] = 20,
	[142][6] = 21,
	[142][7] = 22,
	[142][8] = 23,
	[142][9] = 186,
	[142][10] = 25,
	[142][11] = 26,
	[142][12] = 27,
	[142][13] = 28,
	[142][14] = 29,
	[142][15] = 30,
	[142][16] = 31,
	[142][17] = 32,
	[142][18] = 33,
	[142][19] = 34,
	[142][20] = 35,
	[142][21] = 187,
	[142][22] = 188,
	[142][23] = 38,
	[142][24] = 189,
	[142][25] = 190,
	[142][32] = 351,
	[143][1] = 16,
	[143][2] = 17,
	[143][3] = 192,
	[143][4] = 19,
	[143][5] = 20,
	[143][6] = 21,
	[143][7] = 22,
	[143][8] = 23,
	[143][9] = 193,
	[143][10] = 25,
	[143][11] = 26,
	[143][12] = 27,
	[143][13] = 28,
	[143][14] = 29,
	[143][15] = 30,
	[143][16] = 31,
	[143][17] = 32,
	[143][18] = 33,
	[143][19] = 34,
	[143][20] = 35,
	[143][21] = 194,
	[143][22] = 195,
	[143][23] = 38,
	[143][24] = 196,
	[143][25] = 197,
	[143][33] = 352,
	[144][1] = 16,
	[144][2] = 17,
	[144][3] = 199,
	[144][4] = 19,
	[144][5] = 20,
	[144][6] = 21,
	[144][7] = 22,
	[144][8] = 23,
	[144][9] = 200,
	[144][10] = 25,
	[144][11] = 26,
	[144][12] = 27,
	[144][13] = 28,
	[144][14] = 29,
	[144][15] = 30,
	[144][16] = 31,
	[144][17] = 32,
	[144][18] = 33,
	[144][19] = 34,
	[144][20] = 35,
	[144][21] = 201,
	[144][22] = 202,
	[144][23] = 38,
	[144][24] = 203,
	[144][25] = 204,
	[144][34] = 353,
	[145][1] = 16,
	[145][7] = 22,
	[145][15] = 30,
	[145][17] = 32,
	[145][18] = 33,
	[145][19] = 354,
	[145][20] = 35,
	[145][23] = 38,
	[146][1] = 16,
	[146][7] = 22,
	[146][15] = 30,
	[146][17] = 32,
	[146][18] = 33,
	[146][19] = 355,
	[146][20] = 35,
	[146][23] = 38,
	[147][1] = 16,
	[147][2] = 356,
	[147][5] = 20,
	[147][7] = 22,
	[147][15] = 30,
	[147][17] = 32,
	[147][18] = 33,
	[147][19] = 34,
	[147][20] = 35,
	[147][23] = 38,
	[148][17] = 32,
	[148][18] = 33,
	[148][23] = 357,
	[152][1] = 16,
	[152][2] = 17,
	[152][3] = 139,
	[152][4] = 19,
	[152][5] = 20,
	[152][6] = 21,
	[152][7] = 22,
	[152][8] = 23,
	[152][9] = 140,
	[152][10] = 25,
	[152][11] = 26,
	[152][12] = 27,
	[152][13] = 28,
	[152][14] = 29,
	[152][15] = 30,
	[152][16] = 31,
	[152][17] = 32,
	[152][18] = 33,
	[152][19] = 34,
	[152][20] = 35,
	[152][21] = 141,
	[152][22] = 142,
	[152][23] = 38,
	[152][24] = 143,
	[152][25] = 144,
	[152][28] = 358,
	[153][1] = 16,
	[153][2] = 17,
	[153][3] = 152,
	[153][4] = 19,
	[153][5] = 20,
	[153][6] = 21,
	[153][7] = 22,
	[153][8] = 23,
	[153][9] = 153,
	[153][10] = 25,
	[153][11] = 26,
	[153][12] = 27,
	[153][13] = 28,
	[153][14] = 29,
	[153][15] = 30,
	[153][16] = 31,
	[153][17] = 32,
	[153][18] = 33,
	[153][19] = 34,
	[153][20] = 35,
	[153][21] = 154,
	[153][22] = 155,
	[153][23] = 38,
	[153][24] = 156,
	[153][25] = 157,
	[153][30] = 359,
	[154][1] = 16,
	[154][2] = 17,
	[154][3] = 178,
	[154][4] = 19,
	[154][5] = 20,
	[154][6] = 21,
	[154][7] = 22,
	[154][8] = 23,
	[154][9] = 179,
	[154][10] = 25,
	[154][11] = 26,
	[154][12] = 27,
	[154][13] = 28,
	[154][14] = 29,
	[154][15] = 30,
	[154][16] = 31,
	[154][17] = 32,
	[154][18] = 33,
	[154][19] = 34,
	[154][20] = 35,
	[154][21] = 180,
	[154][22] = 181,
	[154][23] = 38,
	[154][24] = 182,
	[154][25] = 183,
	[154][31] = 360,
	[155][1] = 16,
	[155][2] = 17,
	[155][3] = 185,
	[155][4] = 19,
	[155][5] = 20,
	[155][6] = 21,
	[155][7] = 22,
	[155][8] = 23,
	[155][9] = 186,
	[155][10] = 25,
	[155][11] = 26,
	[155][12] = 27,
	[155][13] = 28,
	[155][14] = 29,
	[155][15] = 30,
	[155][16] = 31,
	[155][17] = 32,
	[155][18] = 33,
	[155][19] = 34,
	[155][20] = 35,
	[155][21] = 187,
	[155][22] = 188,
	[155][23] = 38,
	[155][24] = 189,
	[155][25] = 190,
	[155][32] = 361,
	[156][1] = 16,
	[156][2] = 17,
	[156][3] = 192,
	[156][4] = 19,
	[156][5] = 20,
	[156][6] = 21,
	[156][7] = 22,
	[156][8] = 23,
	[156][9] = 193,
	[156][10] = 25,
	[156][11] = 26,
	[156][12] = 27,
	[156][13] = 28,
	[156][14] = 29,
	[156][15] = 30,
	[156][16] = 31,
	[156][17] = 32,
	[156][18] = 33,
	[156][19] = 34,
	[156][20] = 35,
	[156][21] = 194,
	[156][22] = 195,
	[156][23] = 38,
	[156][24] = 196,
	[156][25] = 197,
	[156][33] = 362,
	[157][1] = 16,
	[157][2] = 17,
	[157][3] = 199,
	[157][4] = 19,
	[157][5] = 20,
	[157][6] = 21,
	[157][7] = 22,
	[157][8] = 23,
	[157][9] = 200,
	[157][10] = 25,
	[157][11] = 26,
	[157][12] = 27,
	[157][13] = 28,
	[157][14] = 29,
	[157][15] = 30,
	[157][16] = 31,
	[157][17] = 32,
	[157][18] = 33,
	[157][19] = 34,
	[157][20] = 35,
	[157][21] = 201,
	[157][22] = 202,
	[157][23] = 38,
	[157][24] = 203,
	[157][25] = 204,
	[157][34] = 363,
	[158][1] = 16,
	[158][2] = 17,
	[158][4] = 19,
	[158][5] = 20,
	[158][6] = 21,
	[158][7] = 22,
	[158][10] = 365,
	[158][11] = 26,
	[158][12] = 27,
	[158][13] = 28,
	[158][14] = 29,
	[158][15] = 30,
	[158][16] = 31,
	[158][17] = 32,
	[158][18] = 33,
	[158][19] = 34,
	[158][20] = 35,
	[158][23] = 38,
	[158][44] = 364,
	[159][1] = 16,
	[159][2] = 17,
	[159][5] = 20,
	[159][6] = 366,
	[159][7] = 22,
	[159][15] = 30,
	[159][17] = 32,
	[159][18] = 33,
	[159][19] = 34,
	[159][20] = 35,
	[159][23] = 38,
	[161][1] = 16,
	[161][2] = 17,
	[161][5] = 20,
	[161][6] = 21,
	[161][7] = 22,
	[161][11] = 368,
	[161][15] = 30,
	[161][17] = 32,
	[161][18] = 33,
	[161][19] = 34,
	[161][20] = 35,
	[161][23] = 38,
	[162][1] = 382,
	[162][2] = 383,
	[162][4] = 384,
	[162][5] = 385,
	[162][6] = 386,
	[162][7] = 387,
	[162][8] = 388,
	[162][10] = 389,
	[162][11] = 390,
	[162][12] = 391,
	[162][13] = 392,
	[162][14] = 393,
	[162][15] = 394,
	[162][16] = 395,
	[162][17] = 396,
	[162][18] = 397,
	[162][19] = 398,
	[162][20] = 399,
	[162][23] = 400,
	[163][1] = 16,
	[163][2] = 17,
	[163][5] = 20,
	[163][6] = 21,
	[163][7] = 22,
	[163][11] = 26,
	[163][13] = 401,
	[163][15] = 30,
	[163][17] = 32,
	[163][18] = 33,
	[163][19] = 34,
	[163][20] = 35,
	[163][23] = 38,
	[164][7] = 402,
	[164][17] = 32,
	[164][18] = 33,
	[164][23] = 38,
	[165][7] = 403,
	[165][17] = 32,
	[165][18] = 33,
	[165][23] = 38,
	[166][7] = 404,
	[166][17] = 32,
	[166][18] = 33,
	[166][23] = 38,
	[167][1] = 16,
	[167][2] = 17,
	[167][4] = 19,
	[167][5] = 20,
	[167][6] = 21,
	[167][7] = 22,
	[167][11] = 26,
	[167][12] = 27,
	[167][13] = 28,
	[167][14] = 29,
	[167][15] = 30,
	[167][16] = 406,
	[167][17] = 32,
	[167][18] = 33,
	[167][19] = 34,
	[167][20] = 35,
	[167][23] = 38,
	[167][45] = 405,
	[168][1] = 56,
	[168][2] = 57,
	[168][4] = 58,
	[168][5] = 59,
	[168][6] = 60,
	[168][7] = 61,
	[168][8] = 409,
	[168][10] = 63,
	[168][11] = 64,
	[168][12] = 65,
	[168][13] = 66,
	[168][14] = 67,
	[168][15] = 68,
	[168][16] = 69,
	[168][17] = 70,
	[168][18] = 71,
	[168][19] = 72,
	[168][20] = 73,
	[168][23] = 74,
	[169][1] = 423,
	[169][2] = 424,
	[169][4] = 425,
	[169][5] = 426,
	[169][6] = 427,
	[169][7] = 428,
	[169][8] = 429,
	[169][10] = 430,
	[169][11] = 431,
	[169][12] = 432,
	[169][13] = 433,
	[169][14] = 434,
	[169][15] = 435,
	[169][16] = 436,
	[169][17] = 437,
	[169][18] = 438,
	[169][19] = 439,
	[169][20] = 440,
	[169][23] = 441,
	[171][1] = 16,
	[171][7] = 22,
	[171][15] = 30,
	[171][17] = 32,
	[171][18] = 33,
	[171][20] = 443,
	[171][23] = 38,
	[172][1] = 16,
	[172][7] = 22,
	[172][15] = 30,
	[172][17] = 32,
	[172][18] = 33,
	[172][20] = 444,
	[172][23] = 38,
	[173][1] = 16,
	[173][7] = 22,
	[173][15] = 30,
	[173][17] = 32,
	[173][18] = 33,
	[173][20] = 445,
	[173][23] = 38,
	[174][1] = 16,
	[174][7] = 22,
	[174][15] = 30,
	[174][17] = 32,
	[174][18] = 33,
	[174][20] = 446,
	[174][23] = 38,
	[175][1] = 447,
	[175][7] = 22,
	[175][15] = 30,
	[175][17] = 32,
	[175][18] = 33,
	[175][23] = 38,
	[176][1] = 448,
	[176][7] = 22,
	[176][15] = 30,
	[176][17] = 32,
	[176][18] = 33,
	[176][23] = 38,
	[178][1] = 16,
	[178][2] = 17,
	[178][3] = 139,
	[178][4] = 19,
	[178][5] = 20,
	[178][6] = 21,
	[178][7] = 22,
	[178][8] = 23,
	[178][9] = 140,
	[178][10] = 25,
	[178][11] = 26,
	[178][12] = 27,
	[178][13] = 28,
	[178][14] = 29,
	[178][15] = 30,
	[178][16] = 31,
	[178][17] = 32,
	[178][18] = 33,
	[178][19] = 34,
	[178][20] = 35,
	[178][21] = 141,
	[178][22] = 142,
	[178][23] = 38,
	[178][24] = 143,
	[178][25] = 144,
	[178][28] = 449,
	[179][1] = 16,
	[179][2] = 17,
	[179][3] = 152,
	[179][4] = 19,
	[179][5] = 20,
	[179][6] = 21,
	[179][7] = 22,
	[179][8] = 23,
	[179][9] = 153,
	[179][10] = 25,
	[179][11] = 26,
	[179][12] = 27,
	[179][13] = 28,
	[179][14] = 29,
	[179][15] = 30,
	[179][16] = 31,
	[179][17] = 32,
	[179][18] = 33,
	[179][19] = 34,
	[179][20] = 35,
	[179][21] = 154,
	[179][22] = 155,
	[179][23] = 38,
	[179][24] = 156,
	[179][25] = 157,
	[179][30] = 450,
	[180][1] = 16,
	[180][2] = 17,
	[180][3] = 178,
	[180][4] = 19,
	[180][5] = 20,
	[180][6] = 21,
	[180][7] = 22,
	[180][8] = 23,
	[180][9] = 179,
	[180][10] = 25,
	[180][11] = 26,
	[180][12] = 27,
	[180][13] = 28,
	[180][14] = 29,
	[180][15] = 30,
	[180][16] = 31,
	[180][17] = 32,
	[180][18] = 33,
	[180][19] = 34,
	[180][20] = 35,
	[180][21] = 180,
	[180][22] = 181,
	[180][23] = 38,
	[180][24] = 182,
	[180][25] = 183,
	[180][31] = 451,
	[181][1] = 16,
	[181][2] = 17,
	[181][3] = 185,
	[181][4] = 19,
	[181][5] = 20,
	[181][6] = 21,
	[181][7] = 22,
	[181][8] = 23,
	[181][9] = 186,
	[181][10] = 25,
	[181][11] = 26,
	[181][12] = 27,
	[181][13] = 28,
	[181][14] = 29,
	[181][15] = 30,
	[181][16] = 31,
	[181][17] = 32,
	[181][18] = 33,
	[181][19] = 34,
	[181][20] = 35,
	[181][21] = 187,
	[181][22] = 188,
	[181][23] = 38,
	[181][24] = 189,
	[181][25] = 190,
	[181][32] = 452,
	[182][1] = 16,
	[182][2] = 17,
	[182][3] = 192,
	[182][4] = 19,
	[182][5] = 20,
	[182][6] = 21,
	[182][7] = 22,
	[182][8] = 23,
	[182][9] = 193,
	[182][10] = 25,
	[182][11] = 26,
	[182][12] = 27,
	[182][13] = 28,
	[182][14] = 29,
	[182][15] = 30,
	[182][16] = 31,
	[182][17] = 32,
	[182][18] = 33,
	[182][19] = 34,
	[182][20] = 35,
	[182][21] = 194,
	[182][22] = 195,
	[182][23] = 38,
	[182][24] = 196,
	[182][25] = 197,
	[182][33] = 453,
	[183][1] = 16,
	[183][2] = 17,
	[183][3] = 199,
	[183][4] = 19,
	[183][5] = 20,
	[183][6] = 21,
	[183][7] = 22,
	[183][8] = 23,
	[183][9] = 200,
	[183][10] = 25,
	[183][11] = 26,
	[183][12] = 27,
	[183][13] = 28,
	[183][14] = 29,
	[183][15] = 30,
	[183][16] = 31,
	[183][17] = 32,
	[183][18] = 33,
	[183][19] = 34,
	[183][20] = 35,
	[183][21] = 201,
	[183][22] = 202,
	[183][23] = 38,
	[183][24] = 203,
	[183][25] = 204,
	[183][34] = 454,
	[185][1] = 16,
	[185][2] = 17,
	[185][3] = 139,
	[185][4] = 19,
	[185][5] = 20,
	[185][6] = 21,
	[185][7] = 22,
	[185][8] = 23,
	[185][9] = 140,
	[185][10] = 25,
	[185][11] = 26,
	[185][12] = 27,
	[185][13] = 28,
	[185][14] = 29,
	[185][15] = 30,
	[185][16] = 31,
	[185][17] = 32,
	[185][18] = 33,
	[185][19] = 34,
	[185][20] = 35,
	[185][21] = 141,
	[185][22] = 142,
	[185][23] = 38,
	[185][24] = 143,
	[185][25] = 144,
	[185][28] = 455,
	[186][1] = 16,
	[186][2] = 17,
	[186][3] = 152,
	[186][4] = 19,
	[186][5] = 20,
	[186][6] = 21,
	[186][7] = 22,
	[186][8] = 23,
	[186][9] = 153,
	[186][10] = 25,
	[186][11] = 26,
	[186][12] = 27,
	[186][13] = 28,
	[186][14] = 29,
	[186][15] = 30,
	[186][16] = 31,
	[186][17] = 32,
	[186][18] = 33,
	[186][19] = 34,
	[186][20] = 35,
	[186][21] = 154,
	[186][22] = 155,
	[186][23] = 38,
	[186][24] = 156,
	[186][25] = 157,
	[186][30] = 456,
	[187][1] = 16,
	[187][2] = 17,
	[187][3] = 178,
	[187][4] = 19,
	[187][5] = 20,
	[187][6] = 21,
	[187][7] = 22,
	[187][8] = 23,
	[187][9] = 179,
	[187][10] = 25,
	[187][11] = 26,
	[187][12] = 27,
	[187][13] = 28,
	[187][14] = 29,
	[187][15] = 30,
	[187][16] = 31,
	[187][17] = 32,
	[187][18] = 33,
	[187][19] = 34,
	[187][20] = 35,
	[187][21] = 180,
	[187][22] = 181,
	[187][23] = 38,
	[187][24] = 182,
	[187][25] = 183,
	[187][31] = 457,
	[188][1] = 16,
	[188][2] = 17,
	[188][3] = 185,
	[188][4] = 19,
	[188][5] = 20,
	[188][6] = 21,
	[188][7] = 22,
	[188][8] = 23,
	[188][9] = 186,
	[188][10] = 25,
	[188][11] = 26,
	[188][12] = 27,
	[188][13] = 28,
	[188][14] = 29,
	[188][15] = 30,
	[188][16] = 31,
	[188][17] = 32,
	[188][18] = 33,
	[188][19] = 34,
	[188][20] = 35,
	[188][21] = 187,
	[188][22] = 188,
	[188][23] = 38,
	[188][24] = 189,
	[188][25] = 190,
	[188][32] = 458,
	[189][1] = 16,
	[189][2] = 17,
	[189][3] = 192,
	[189][4] = 19,
	[189][5] = 20,
	[189][6] = 21,
	[189][7] = 22,
	[189][8] = 23,
	[189][9] = 193,
	[189][10] = 25,
	[189][11] = 26,
	[189][12] = 27,
	[189][13] = 28,
	[189][14] = 29,
	[189][15] = 30,
	[189][16] = 31,
	[189][17] = 32,
	[189][18] = 33,
	[189][19] = 34,
	[189][20] = 35,
	[189][21] = 194,
	[189][22] = 195,
	[189][23] = 38,
	[189][24] = 196,
	[189][25] = 197,
	[189][33] = 459,
	[190][1] = 16,
	[190][2] = 17,
	[190][3] = 199,
	[190][4] = 19,
	[190][5] = 20,
	[190][6] = 21,
	[190][7] = 22,
	[190][8] = 23,
	[190][9] = 200,
	[190][10] = 25,
	[190][11] = 26,
	[190][12] = 27,
	[190][13] = 28,
	[190][14] = 29,
	[190][15] = 30,
	[190][16] = 31,
	[190][17] = 32,
	[190][18] = 33,
	[190][19] = 34,
	[190][20] = 35,
	[190][21] = 201,
	[190][22] = 202,
	[190][23] = 38,
	[190][24] = 203,
	[190][25] = 204,
	[190][34] = 460,
	[192][1] = 16,
	[192][2] = 17,
	[192][3] = 139,
	[192][4] = 19,
	[192][5] = 20,
	[192][6] = 21,
	[192][7] = 22,
	[192][8] = 23,
	[192][9] = 140,
	[192][10] = 25,
	[192][11] = 26,
	[192][12] = 27,
	[192][13] = 28,
	[192][14] = 29,
	[192][15] = 30,
	[192][16] = 31,
	[192][17] = 32,
	[192][18] = 33,
	[192][19] = 34,
	[192][20] = 35,
	[192][21] = 141,
	[192][22] = 142,
	[192][23] = 38,
	[192][24] = 143,
	[192][25] = 144,
	[192][28] = 461,
	[193][1] = 16,
	[193][2] = 17,
	[193][3] = 152,
	[193][4] = 19,
	[193][5] = 20,
	[193][6] = 21,
	[193][7] = 22,
	[193][8] = 23,
	[193][9] = 153,
	[193][10] = 25,
	[193][11] = 26,
	[193][12] = 27,
	[193][13] = 28,
	[193][14] = 29,
	[193][15] = 30,
	[193][16] = 31,
	[193][17] = 32,
	[193][18] = 33,
	[193][19] = 34,
	[193][20] = 35,
	[193][21] = 154,
	[193][22] = 155,
	[193][23] = 38,
	[193][24] = 156,
	[193][25] = 157,
	[193][30] = 462,
	[194][1] = 16,
	[194][2] = 17,
	[194][3] = 178,
	[194][4] = 19,
	[194][5] = 20,
	[194][6] = 21,
	[194][7] = 22,
	[194][8] = 23,
	[194][9] = 179,
	[194][10] = 25,
	[194][11] = 26,
	[194][12] = 27,
	[194][13] = 28,
	[194][14] = 29,
	[194][15] = 30,
	[194][16] = 31,
	[194][17] = 32,
	[194][18] = 33,
	[194][19] = 34,
	[194][20] = 35,
	[194][21] = 180,
	[194][22] = 181,
	[194][23] = 38,
	[194][24] = 182,
	[194][25] = 183,
	[194][31] = 463,
	[195][1] = 16,
	[195][2] = 17,
	[195][3] = 185,
	[195][4] = 19,
	[195][5] = 20,
	[195][6] = 21,
	[195][7] = 22,
	[195][8] = 23,
	[195][9] = 186,
	[195][10] = 25,
	[195][11] = 26,
	[195][12] = 27,
	[195][13] = 28,
	[195][14] = 29,
	[195][15] = 30,
	[195][16] = 31,
	[195][17] = 32,
	[195][18] = 33,
	[195][19] = 34,
	[195][20] = 35,
	[195][21] = 187,
	[195][22] = 188,
	[195][23] = 38,
	[195][24] = 189,
	[195][25] = 190,
	[195][32] = 464,
	[196][1] = 16,
	[196][2] = 17,
	[196][3] = 192,
	[196][4] = 19,
	[196][5] = 20,
	[196][6] = 21,
	[196][7] = 22,
	[196][8] = 23,
	[196][9] = 193,
	[196][10] = 25,
	[196][11] = 26,
	[196][12] = 27,
	[196][13] = 28,
	[196][14] = 29,
	[196][15] = 30,
	[196][16] = 31,
	[196][17] = 32,
	[196][18] = 33,
	[196][19] = 34,
	[196][20] = 35,
	[196][21] = 194,
	[196][22] = 195,
	[196][23] = 38,
	[196][24] = 196,
	[196][25] = 197,
	[196][33] = 465,
	[197][1] = 16,
	[197][2] = 17,
	[197][3] = 199,
	[197][4] = 19,
	[197][5] = 20,
	[197][6] = 21,
	[197][7] = 22,
	[197][8] = 23,
	[197][9] = 200,
	[197][10] = 25,
	[197][11] = 26,
	[197][12] = 27,
	[197][13] = 28,
	[197][14] = 29,
	[197][15] = 30,
	[197][16] = 31,
	[197][17] = 32,
	[197][18] = 33,
	[197][19] = 34,
	[197][20] = 35,
	[197][21] = 201,
	[197][22] = 202,
	[197][23] = 38,
	[197][24] = 203,
	[197][25] = 204,
	[197][34] = 466,
	[199][1] = 16,
	[199][2] = 17,
	[199][3] = 139,
	[199][4] = 19,
	[199][5] = 20,
	[199][6] = 21,
	[199][7] = 22,
	[199][8] = 23,
	[199][9] = 140,
	[199][10] = 25,
	[199][11] = 26,
	[199][12] = 27,
	[199][13] = 28,
	[199][14] = 29,
	[199][15] = 30,
	[199][16] = 31,
	[199][17] = 32,
	[199][18] = 33,
	[199][19] = 34,
	[199][20] = 35,
	[199][21] = 141,
	[199][22] = 142,
	[199][23] = 38,
	[199][24] = 143,
	[199][25] = 144,
	[199][28] = 467,
	[200][1] = 16,
	[200][2] = 17,
	[200][3] = 152,
	[200][4] = 19,
	[200][5] = 20,
	[200][6] = 21,
	[200][7] = 22,
	[200][8] = 23,
	[200][9] = 153,
	[200][10] = 25,
	[200][11] = 26,
	[200][12] = 27,
	[200][13] = 28,
	[200][14] = 29,
	[200][15] = 30,
	[200][16] = 31,
	[200][17] = 32,
	[200][18] = 33,
	[200][19] = 34,
	[200][20] = 35,
	[200][21] = 154,
	[200][22] = 155,
	[200][23] = 38,
	[200][24] = 156,
	[200][25] = 157,
	[200][30] = 468,
	[201][1] = 16,
	[201][2] = 17,
	[201][3] = 178,
	[201][4] = 19,
	[201][5] = 20,
	[201][6] = 21,
	[201][7] = 22,
	[201][8] = 23,
	[201][9] = 179,
	[201][10] = 25,
	[201][11] = 26,
	[201][12] = 27,
	[201][13] = 28,
	[201][14] = 29,
	[201][15] = 30,
	[201][16] = 31,
	[201][17] = 32,
	[201][18] = 33,
	[201][19] = 34,
	[201][20] = 35,
	[201][21] = 180,
	[201][22] = 181,
	[201][23] = 38,
	[201][24] = 182,
	[201][25] = 183,
	[201][31] = 469,
	[202][1] = 16,
	[202][2] = 17,
	[202][3] = 185,
	[202][4] = 19,
	[202][5] = 20,
	[202][6] = 21,
	[202][7] = 22,
	[202][8] = 23,
	[202][9] = 186,
	[202][10] = 25,
	[202][11] = 26,
	[202][12] = 27,
	[202][13] = 28,
	[202][14] = 29,
	[202][15] = 30,
	[202][16] = 31,
	[202][17] = 32,
	[202][18] = 33,
	[202][19] = 34,
	[202][20] = 35,
	[202][21] = 187,
	[202][22] = 188,
	[202][23] = 38,
	[202][24] = 189,
	[202][25] = 190,
	[202][32] = 470,
	[203][1] = 16,
	[203][2] = 17,
	[203][3] = 192,
	[203][4] = 19,
	[203][5] = 20,
	[203][6] = 21,
	[203][7] = 22,
	[203][8] = 23,
	[203][9] = 193,
	[203][10] = 25,
	[203][11] = 26,
	[203][12] = 27,
	[203][13] = 28,
	[203][14] = 29,
	[203][15] = 30,
	[203][16] = 31,
	[203][17] = 32,
	[203][18] = 33,
	[203][19] = 34,
	[203][20] = 35,
	[203][21] = 194,
	[203][22] = 195,
	[203][23] = 38,
	[203][24] = 196,
	[203][25] = 197,
	[203][33] = 471,
	[204][1] = 16,
	[204][2] = 17,
	[204][3] = 199,
	[204][4] = 19,
	[204][5] = 20,
	[204][6] = 21,
	[204][7] = 22,
	[204][8] = 23,
	[204][9] = 200,
	[204][10] = 25,
	[204][11] = 26,
	[204][12] = 27,
	[204][13] = 28,
	[204][14] = 29,
	[204][15] = 30,
	[204][16] = 31,
	[204][17] = 32,
	[204][18] = 33,
	[204][19] = 34,
	[204][20] = 35,
	[204][21] = 201,
	[204][22] = 202,
	[204][23] = 38,
	[204][24] = 203,
	[204][25] = 204,
	[204][34] = 472,
	[206][1] = 56,
	[206][2] = 57,
	[206][4] = 58,
	[206][5] = 59,
	[206][6] = 60,
	[206][7] = 61,
	[206][8] = 474,
	[206][10] = 63,
	[206][11] = 64,
	[206][12] = 65,
	[206][13] = 66,
	[206][14] = 67,
	[206][15] = 68,
	[206][16] = 69,
	[206][17] = 70,
	[206][18] = 71,
	[206][19] = 72,
	[206][20] = 73,
	[206][23] = 74,
	[206][35] = 473,
	[212][1] = 93,
	[212][2] = 94,
	[212][4] = 95,
	[212][5] = 96,
	[212][6] = 97,
	[212][7] = 98,
	[212][8] = 480,
	[212][10] = 100,
	[212][11] = 101,
	[212][12] = 102,
	[212][13] = 103,
	[212][14] = 104,
	[212][15] = 105,
	[212][16] = 106,
	[212][17] = 107,
	[212][18] = 108,
	[212][19] = 109,
	[212][20] = 110,
	[212][23] = 111,
	[212][36] = 479,
	[216][1] = 56,
	[216][2] = 57,
	[216][4] = 58,
	[216][5] = 59,
	[216][6] = 60,
	[216][7] = 61,
	[216][8] = 485,
	[216][10] = 63,
	[216][11] = 64,
	[216][12] = 65,
	[216][13] = 66,
	[216][14] = 67,
	[216][15] = 68,
	[216][16] = 69,
	[216][17] = 70,
	[216][18] = 71,
	[216][19] = 72,
	[216][20] = 73,
	[216][23] = 74,
	[218][26] = 133,
	[218][27] = 329,
	[218][41] = 486,
	[218][42] = 487,
	[219][1] = 56,
	[219][2] = 57,
	[219][4] = 58,
	[219][5] = 59,
	[219][6] = 60,
	[219][7] = 61,
	[219][11] = 64,
	[219][12] = 489,
	[219][13] = 66,
	[219][14] = 67,
	[219][15] = 68,
	[219][17] = 70,
	[219][18] = 71,
	[219][19] = 72,
	[219][20] = 73,
	[219][23] = 74,
	[219][43] = 488,
	[221][7] = 61,
	[221][15] = 491,
	[221][17] = 70,
	[221][18] = 71,
	[221][23] = 74,
	[222][7] = 61,
	[222][15] = 492,
	[222][17] = 70,
	[222][18] = 71,
	[222][23] = 74,
	[223][1] = 56,
	[223][5] = 493,
	[223][7] = 61,
	[223][15] = 68,
	[223][17] = 70,
	[223][18] = 71,
	[223][19] = 72,
	[223][20] = 73,
	[223][23] = 74,
	[224][1] = 56,
	[224][7] = 61,
	[224][15] = 68,
	[224][17] = 70,
	[224][18] = 71,
	[224][19] = 494,
	[224][20] = 73,
	[224][23] = 74,
	[225][1] = 56,
	[225][7] = 61,
	[225][15] = 68,
	[225][17] = 70,
	[225][18] = 71,
	[225][19] = 495,
	[225][20] = 73,
	[225][23] = 74,
	[226][1] = 56,
	[226][2] = 496,
	[226][5] = 59,
	[226][7] = 61,
	[226][15] = 68,
	[226][17] = 70,
	[226][18] = 71,
	[226][19] = 72,
	[226][20] = 73,
	[226][23] = 74,
	[227][17] = 70,
	[227][18] = 71,
	[227][23] = 497,
	[229][1] = 56,
	[229][2] = 57,
	[229][4] = 58,
	[229][5] = 59,
	[229][6] = 60,
	[229][7] = 61,
	[229][8] = 211,
	[229][10] = 63,
	[229][11] = 64,
	[229][12] = 65,
	[229][13] = 66,
	[229][14] = 67,
	[229][15] = 68,
	[229][16] = 69,
	[229][17] = 70,
	[229][18] = 71,
	[229][19] = 72,
	[229][20] = 73,
	[229][23] = 74,
	[229][35] = 498,
	[230][1] = 56,
	[230][2] = 57,
	[230][4] = 58,
	[230][5] = 59,
	[230][6] = 60,
	[230][7] = 61,
	[230][10] = 500,
	[230][11] = 64,
	[230][12] = 65,
	[230][13] = 66,
	[230][14] = 67,
	[230][15] = 68,
	[230][16] = 69,
	[230][17] = 70,
	[230][18] = 71,
	[230][19] = 72,
	[230][20] = 73,
	[230][23] = 74,
	[230][44] = 499,
	[231][1] = 56,
	[231][2] = 57,
	[231][5] = 59,
	[231][6] = 501,
	[231][7] = 61,
	[231][15] = 68,
	[231][17] = 70,
	[231][18] = 71,
	[231][19] = 72,
	[231][20] = 73,
	[231][23] = 74,
	[233][1] = 56,
	[233][2] = 57,
	[233][5] = 59,
	[233][6] = 60,
	[233][7] = 61,
	[233][11] = 503,
	[233][15] = 68,
	[233][17] = 70,
	[233][18] = 71,
	[233][19] = 72,
	[233][20] = 73,
	[233][23] = 74,
	[234][1] = 382,
	[234][2] = 383,
	[234][4] = 384,
	[234][5] = 385,
	[234][6] = 386,
	[234][7] = 387,
	[234][8] = 504,
	[234][10] = 389,
	[234][11] = 390,
	[234][12] = 391,
	[234][13] = 392,
	[234][14] = 393,
	[234][15] = 394,
	[234][16] = 395,
	[234][17] = 396,
	[234][18] = 397,
	[234][19] = 398,
	[234][20] = 399,
	[234][23] = 400,
	[235][1] = 56,
	[235][2] = 57,
	[235][5] = 59,
	[235][6] = 60,
	[235][7] = 61,
	[235][11] = 64,
	[235][13] = 505,
	[235][15] = 68,
	[235][17] = 70,
	[235][18] = 71,
	[235][19] = 72,
	[235][20] = 73,
	[235][23] = 74,
	[236][7] = 506,
	[236][17] = 70,
	[236][18] = 71,
	[236][23] = 74,
	[237][7] = 507,
	[237][17] = 70,
	[237][18] = 71,
	[237][23] = 74,
	[238][7] = 508,
	[238][17] = 70,
	[238][18] = 71,
	[238][23] = 74,
	[239][1] = 56,
	[239][2] = 57,
	[239][4] = 58,
	[239][5] = 59,
	[239][6] = 60,
	[239][7] = 61,
	[239][11] = 64,
	[239][12] = 65,
	[239][13] = 66,
	[239][14] = 67,
	[239][15] = 68,
	[239][16] = 510,
	[239][17] = 70,
	[239][18] = 71,
	[239][19] = 72,
	[239][20] = 73,
	[239][23] = 74,
	[239][45] = 509,
	[240][1] = 56,
	[240][2] = 57,
	[240][4] = 58,
	[240][5] = 59,
	[240][6] = 60,
	[240][7] = 61,
	[240][8] = 513,
	[240][10] = 63,
	[240][11] = 64,
	[240][12] = 65,
	[240][13] = 66,
	[240][14] = 67,
	[240][15] = 68,
	[240][16] = 69,
	[240][17] = 70,
	[240][18] = 71,
	[240][19] = 72,
	[240][20] = 73,
	[240][23] = 74,
	[241][1] = 423,
	[241][2] = 424,
	[241][4] = 425,
	[241][5] = 426,
	[241][6] = 427,
	[241][7] = 428,
	[241][8] = 514,
	[241][10] = 430,
	[241][11] = 431,
	[241][12] = 432,
	[241][13] = 433,
	[241][14] = 434,
	[241][15] = 435,
	[241][16] = 436,
	[241][17] = 437,
	[241][18] = 438,
	[241][19] = 439,
	[241][20] = 440,
	[241][23] = 441,
	[243][1] = 56,
	[243][7] = 61,
	[243][15] = 68,
	[243][17] = 70,
	[243][18] = 71,
	[243][20] = 516,
	[243][23] = 74,
	[244][1] = 56,
	[244][7] = 61,
	[244][15] = 68,
	[244][17] = 70,
	[244][18] = 71,
	[244][20] = 517,
	[244][23] = 74,
	[245][1] = 56,
	[245][7] = 61,
	[245][15] = 68,
	[245][17] = 70,
	[245][18] = 71,
	[245][20] = 518,
	[245][23] = 74,
	[246][1] = 56,
	[246][7] = 61,
	[246][15] = 68,
	[246][17] = 70,
	[246][18] = 71,
	[246][20] = 519,
	[246][23] = 74,
	[247][1] = 520,
	[247][7] = 61,
	[247][15] = 68,
	[247][17] = 70,
	[247][18] = 71,
	[247][23] = 74,
	[248][1] = 521,
	[248][7] = 61,
	[248][15] = 68,
	[248][17] = 70,
	[248][18] = 71,
	[248][23] = 74,
	[250][1] = 56,
	[250][2] = 57,
	[250][4] = 58,
	[250][5] = 59,
	[250][6] = 60,
	[250][7] = 61,
	[250][8] = 523,
	[250][10] = 63,
	[250][11] = 64,
	[250][12] = 65,
	[250][13] = 66,
	[250][14] = 67,
	[250][15] = 68,
	[250][16] = 69,
	[250][17] = 70,
	[250][18] = 71,
	[250][19] = 72,
	[250][20] = 73,
	[250][23] = 74,
	[250][35] = 522,
	[256][1] = 93,
	[256][2] = 94,
	[256][4] = 95,
	[256][5] = 96,
	[256][6] = 97,
	[256][7] = 98,
	[256][8] = 529,
	[256][10] = 100,
	[256][11] = 101,
	[256][12] = 102,
	[256][13] = 103,
	[256][14] = 104,
	[256][15] = 105,
	[256][16] = 106,
	[256][17] = 107,
	[256][18] = 108,
	[256][19] = 109,
	[256][20] = 110,
	[256][23] = 111,
	[256][36] = 528,
	[260][1] = 56,
	[260][2] = 57,
	[260][4] = 58,
	[260][5] = 59,
	[260][6] = 60,
	[260][7] = 61,
	[260][8] = 534,
	[260][10] = 63,
	[260][11] = 64,
	[260][12] = 65,
	[260][13] = 66,
	[260][14] = 67,
	[260][15] = 68,
	[260][16] = 69,
	[260][17] = 70,
	[260][18] = 71,
	[260][19] = 72,
	[260][20] = 73,
	[260][23] = 74,
	[262][26] = 133,
	[262][27] = 329,
	[262][41] = 535,
	[262][42] = 536,
	[263][1] = 93,
	[263][2] = 94,
	[263][4] = 95,
	[263][5] = 96,
	[263][6] = 97,
	[263][7] = 98,
	[263][11] = 101,
	[263][12] = 538,
	[263][13] = 103,
	[263][14] = 104,
	[263][15] = 105,
	[263][17] = 107,
	[263][18] = 108,
	[263][19] = 109,
	[263][20] = 110,
	[263][23] = 111,
	[263][43] = 537,
	[265][7] = 98,
	[265][15] = 540,
	[265][17] = 107,
	[265][18] = 108,
	[265][23] = 111,
	[266][7] = 98,
	[266][15] = 541,
	[266][17] = 107,
	[266][18] = 108,
	[266][23] = 111,
	[267][1] = 93,
	[267][5] = 542,
	[267][7] = 98,
	[267][15] = 105,
	[267][17] = 107,
	[267][18] = 108,
	[267][19] = 109,
	[267][20] = 110,
	[267][23] = 111,
	[268][1] = 93,
	[268][7] = 98,
	[268][15] = 105,
	[268][17] = 107,
	[268][18] = 108,
	[268][19] = 543,
	[268][20] = 110,
	[268][23] = 111,
	[269][1] = 93,
	[269][7] = 98,
	[269][15] = 105,
	[269][17] = 107,
	[269][18] = 108,
	[269][19] = 544,
	[269][20] = 110,
	[269][23] = 111,
	[270][1] = 93,
	[270][2] = 545,
	[270][5] = 96,
	[270][7] = 98,
	[270][15] = 105,
	[270][17] = 107,
	[270][18] = 108,
	[270][19] = 109,
	[270][20] = 110,
	[270][23] = 111,
	[271][17] = 107,
	[271][18] = 108,
	[271][23] = 546,
	[272][1] = 93,
	[272][2] = 94,
	[272][4] = 95,
	[272][5] = 96,
	[272][6] = 97,
	[272][7] = 98,
	[272][8] = 255,
	[272][10] = 100,
	[272][11] = 101,
	[272][12] = 102,
	[272][13] = 103,
	[272][14] = 104,
	[272][15] = 105,
	[272][16] = 106,
	[272][17] = 107,
	[272][18] = 108,
	[272][19] = 109,
	[272][20] = 110,
	[272][23] = 111,
	[272][36] = 547,
	[274][1] = 93,
	[274][2] = 94,
	[274][4] = 95,
	[274][5] = 96,
	[274][6] = 97,
	[274][7] = 98,
	[274][10] = 549,
	[274][11] = 101,
	[274][12] = 102,
	[274][13] = 103,
	[274][14] = 104,
	[274][15] = 105,
	[274][16] = 106,
	[274][17] = 107,
	[274][18] = 108,
	[274][19] = 109,
	[274][20] = 110,
	[274][23] = 111,
	[274][44] = 548,
	[275][1] = 93,
	[275][2] = 94,
	[275][5] = 96,
	[275][6] = 550,
	[275][7] = 98,
	[275][15] = 105,
	[275][17] = 107,
	[275][18] = 108,
	[275][19] = 109,
	[275][20] = 110,
	[275][23] = 111,
	[277][1] = 93,
	[277][2] = 94,
	[277][5] = 96,
	[277][6] = 97,
	[277][7] = 98,
	[277][11] = 552,
	[277][15] = 105,
	[277][17] = 107,
	[277][18] = 108,
	[277][19] = 109,
	[277][20] = 110,
	[277][23] = 111,
	[278][1] = 382,
	[278][2] = 383,
	[278][4] = 384,
	[278][5] = 385,
	[278][6] = 386,
	[278][7] = 387,
	[278][8] = 553,
	[278][10] = 389,
	[278][11] = 390,
	[278][12] = 391,
	[278][13] = 392,
	[278][14] = 393,
	[278][15] = 394,
	[278][16] = 395,
	[278][17] = 396,
	[278][18] = 397,
	[278][19] = 398,
	[278][20] = 399,
	[278][23] = 400,
	[279][1] = 93,
	[279][2] = 94,
	[279][5] = 96,
	[279][6] = 97,
	[279][7] = 98,
	[279][11] = 101,
	[279][13] = 554,
	[279][15] = 105,
	[279][17] = 107,
	[279][18] = 108,
	[279][19] = 109,
	[279][20] = 110,
	[279][23] = 111,
	[280][7] = 555,
	[280][17] = 107,
	[280][18] = 108,
	[280][23] = 111,
	[281][7] = 556,
	[281][17] = 107,
	[281][18] = 108,
	[281][23] = 111,
	[282][7] = 557,
	[282][17] = 107,
	[282][18] = 108,
	[282][23] = 111,
	[283][1] = 93,
	[283][2] = 94,
	[283][4] = 95,
	[283][5] = 96,
	[283][6] = 97,
	[283][7] = 98,
	[283][11] = 101,
	[283][12] = 102,
	[283][13] = 103,
	[283][14] = 104,
	[283][15] = 105,
	[283][16] = 559,
	[283][17] = 107,
	[283][18] = 108,
	[283][19] = 109,
	[283][20] = 110,
	[283][23] = 111,
	[283][45] = 558,
	[284][1] = 56,
	[284][2] = 57,
	[284][4] = 58,
	[284][5] = 59,
	[284][6] = 60,
	[284][7] = 61,
	[284][8] = 562,
	[284][10] = 63,
	[284][11] = 64,
	[284][12] = 65,
	[284][13] = 66,
	[284][14] = 67,
	[284][15] = 68,
	[284][16] = 69,
	[284][17] = 70,
	[284][18] = 71,
	[284][19] = 72,
	[284][20] = 73,
	[284][23] = 74,
	[285][1] = 423,
	[285][2] = 424,
	[285][4] = 425,
	[285][5] = 426,
	[285][6] = 427,
	[285][7] = 428,
	[285][8] = 563,
	[285][10] = 430,
	[285][11] = 431,
	[285][12] = 432,
	[285][13] = 433,
	[285][14] = 434,
	[285][15] = 435,
	[285][16] = 436,
	[285][17] = 437,
	[285][18] = 438,
	[285][19] = 439,
	[285][20] = 440,
	[285][23] = 441,
	[287][1] = 93,
	[287][7] = 98,
	[287][15] = 105,
	[287][17] = 107,
	[287][18] = 108,
	[287][20] = 565,
	[287][23] = 111,
	[288][1] = 93,
	[288][7] = 98,
	[288][15] = 105,
	[288][17] = 107,
	[288][18] = 108,
	[288][20] = 566,
	[288][23] = 111,
	[289][1] = 93,
	[289][7] = 98,
	[289][15] = 105,
	[289][17] = 107,
	[289][18] = 108,
	[289][20] = 567,
	[289][23] = 111,
	[290][1] = 93,
	[290][7] = 98,
	[290][15] = 105,
	[290][17] = 107,
	[290][18] = 108,
	[290][20] = 568,
	[290][23] = 111,
	[291][1] = 569,
	[291][7] = 98,
	[291][15] = 105,
	[291][17] = 107,
	[291][18] = 108,
	[291][23] = 111,
	[292][1] = 570,
	[292][7] = 98,
	[292][15] = 105,
	[292][17] = 107,
	[292][18] = 108,
	[292][23] = 111,
	[295][37] = 580,
	[295][38] = 581,
	[295][39] = 582,
	[295][40] = 583,
	[297][46] = 589,
	[297][47] = 590,
	[297][48] = 591,
	[297][49] = 592,
	[297][50] = 593,
	[297][51] = 594,
	[299][52] = 601,
	[299][53] = 602,
	[299][54] = 603,
	[299][55] = 604,
	[303][38] = 301,
	[303][40] = 610,
	[306][1] = 56,
	[306][2] = 57,
	[306][4] = 58,
	[306][5] = 59,
	[306][6] = 60,
	[306][7] = 61,
	[306][8] = 613,
	[306][10] = 63,
	[306][11] = 64,
	[306][12] = 65,
	[306][13] = 66,
	[306][14] = 67,
	[306][15] = 68,
	[306][16] = 69,
	[306][17] = 70,
	[306][18] = 71,
	[306][19] = 72,
	[306][20] = 73,
	[306][23] = 74,
	[306][56] = 612,
	[309][52] = 622,
	[309][53] = 623,
	[309][54] = 624,
	[309][55] = 625,
	[310][37] = 626,
	[310][38] = 301,
	[310][39] = 302,
	[310][40] = 303,
	[311][1] = 16,
	[311][2] = 17,
	[311][4] = 19,
	[311][5] = 20,
	[311][6] = 21,
	[311][7] = 22,
	[311][8] = 628,
	[311][10] = 25,
	[311][11] = 26,
	[311][12] = 27,
	[311][13] = 28,
	[311][14] = 29,
	[311][15] = 30,
	[311][16] = 31,
	[311][17] = 32,
	[311][18] = 33,
	[311][19] = 34,
	[311][20] = 35,
	[311][23] = 38,
	[311][57] = 627,
	[312][1] = 16,
	[312][2] = 17,
	[312][4] = 19,
	[312][5] = 20,
	[312][6] = 21,
	[312][7] = 22,
	[312][8] = 628,
	[312][10] = 25,
	[312][11] = 26,
	[312][12] = 27,
	[312][13] = 28,
	[312][14] = 29,
	[312][15] = 30,
	[312][16] = 31,
	[312][17] = 32,
	[312][18] = 33,
	[312][19] = 34,
	[312][20] = 35,
	[312][23] = 38,
	[312][57] = 629,
	[313][1] = 16,
	[313][2] = 17,
	[313][4] = 19,
	[313][5] = 20,
	[313][6] = 21,
	[313][7] = 22,
	[313][8] = 628,
	[313][10] = 25,
	[313][11] = 26,
	[313][12] = 27,
	[313][13] = 28,
	[313][14] = 29,
	[313][15] = 30,
	[313][16] = 31,
	[313][17] = 32,
	[313][18] = 33,
	[313][19] = 34,
	[313][20] = 35,
	[313][23] = 38,
	[313][57] = 630,
	[314][1] = 16,
	[314][2] = 17,
	[314][4] = 19,
	[314][5] = 20,
	[314][6] = 21,
	[314][7] = 22,
	[314][8] = 628,
	[314][10] = 25,
	[314][11] = 26,
	[314][12] = 27,
	[314][13] = 28,
	[314][14] = 29,
	[314][15] = 30,
	[314][16] = 31,
	[314][17] = 32,
	[314][18] = 33,
	[314][19] = 34,
	[314][20] = 35,
	[314][23] = 38,
	[314][57] = 631,
	[315][26] = 324,
	[315][27] = 634,
	[317][26] = 324,
	[317][27] = 636,
	[317][58] = 635,
	[323][26] = 341,
	[323][27] = 639,
	[332][26] = 324,
	[332][27] = 648,
	[333][26] = 341,
	[333][27] = 650,
	[333][59] = 649,
	[335][26] = 133,
	[335][27] = 652,
	[335][60] = 651,
	[340][26] = 341,
	[340][27] = 655,
	[371][1] = 56,
	[371][2] = 57,
	[371][4] = 58,
	[371][5] = 59,
	[371][6] = 60,
	[371][7] = 61,
	[371][8] = 664,
	[371][10] = 63,
	[371][11] = 64,
	[371][12] = 65,
	[371][13] = 66,
	[371][14] = 67,
	[371][15] = 68,
	[371][16] = 69,
	[371][17] = 70,
	[371][18] = 71,
	[371][19] = 72,
	[371][20] = 73,
	[371][23] = 74,
	[372][17] = 396,
	[372][18] = 397,
	[372][23] = 665,
	[373][17] = 396,
	[373][18] = 397,
	[373][23] = 666,
	[375][1] = 93,
	[375][2] = 94,
	[375][4] = 95,
	[375][5] = 96,
	[375][6] = 97,
	[375][7] = 98,
	[375][8] = 669,
	[375][10] = 100,
	[375][11] = 101,
	[375][12] = 102,
	[375][13] = 103,
	[375][14] = 104,
	[375][15] = 105,
	[375][16] = 106,
	[375][17] = 107,
	[375][18] = 108,
	[375][19] = 109,
	[375][20] = 110,
	[375][23] = 111,
	[376][17] = 396,
	[376][18] = 397,
	[376][23] = 670,
	[380][17] = 396,
	[380][18] = 397,
	[380][23] = 672,
	[381][26] = 133,
	[381][27] = 675,
	[408][1] = 56,
	[408][2] = 57,
	[408][4] = 58,
	[408][5] = 59,
	[408][6] = 60,
	[408][7] = 61,
	[408][8] = 705,
	[408][10] = 63,
	[408][11] = 64,
	[408][12] = 65,
	[408][13] = 66,
	[408][14] = 67,
	[408][15] = 68,
	[408][16] = 69,
	[408][17] = 70,
	[408][18] = 71,
	[408][19] = 72,
	[408][20] = 73,
	[408][23] = 74,
	[408][61] = 704,
	[412][1] = 56,
	[412][2] = 57,
	[412][4] = 58,
	[412][5] = 59,
	[412][6] = 60,
	[412][7] = 61,
	[412][8] = 710,
	[412][10] = 63,
	[412][11] = 64,
	[412][12] = 65,
	[412][13] = 66,
	[412][14] = 67,
	[412][15] = 68,
	[412][16] = 69,
	[412][17] = 70,
	[412][18] = 71,
	[412][19] = 72,
	[412][20] = 73,
	[412][23] = 74,
	[413][17] = 437,
	[413][18] = 438,
	[413][23] = 711,
	[414][17] = 437,
	[414][18] = 438,
	[414][23] = 712,
	[416][1] = 93,
	[416][2] = 94,
	[416][4] = 95,
	[416][5] = 96,
	[416][6] = 97,
	[416][7] = 98,
	[416][8] = 715,
	[416][10] = 100,
	[416][11] = 101,
	[416][12] = 102,
	[416][13] = 103,
	[416][14] = 104,
	[416][15] = 105,
	[416][16] = 106,
	[416][17] = 107,
	[416][18] = 108,
	[416][19] = 109,
	[416][20] = 110,
	[416][23] = 111,
	[417][17] = 437,
	[417][18] = 438,
	[417][23] = 716,
	[421][17] = 437,
	[421][18] = 438,
	[421][23] = 718,
	[422][26] = 133,
	[422][27] = 721,
	[476][1] = 56,
	[476][2] = 57,
	[476][4] = 58,
	[476][5] = 59,
	[476][6] = 60,
	[476][7] = 61,
	[476][8] = 474,
	[476][10] = 63,
	[476][11] = 64,
	[476][12] = 65,
	[476][13] = 66,
	[476][14] = 67,
	[476][15] = 68,
	[476][16] = 69,
	[476][17] = 70,
	[476][18] = 71,
	[476][19] = 72,
	[476][20] = 73,
	[476][23] = 74,
	[476][35] = 751,
	[478][1] = 56,
	[478][2] = 57,
	[478][4] = 58,
	[478][5] = 59,
	[478][6] = 60,
	[478][7] = 61,
	[478][8] = 211,
	[478][10] = 63,
	[478][11] = 64,
	[478][12] = 65,
	[478][13] = 66,
	[478][14] = 67,
	[478][15] = 68,
	[478][16] = 69,
	[478][17] = 70,
	[478][18] = 71,
	[478][19] = 72,
	[478][20] = 73,
	[478][23] = 74,
	[478][35] = 752,
	[481][1] = 93,
	[481][2] = 94,
	[481][4] = 95,
	[481][5] = 96,
	[481][6] = 97,
	[481][7] = 98,
	[481][8] = 480,
	[481][10] = 100,
	[481][11] = 101,
	[481][12] = 102,
	[481][13] = 103,
	[481][14] = 104,
	[481][15] = 105,
	[481][16] = 106,
	[481][17] = 107,
	[481][18] = 108,
	[481][19] = 109,
	[481][20] = 110,
	[481][23] = 111,
	[481][36] = 755,
	[484][1] = 56,
	[484][2] = 57,
	[484][4] = 58,
	[484][5] = 59,
	[484][6] = 60,
	[484][7] = 61,
	[484][8] = 757,
	[484][10] = 63,
	[484][11] = 64,
	[484][12] = 65,
	[484][13] = 66,
	[484][14] = 67,
	[484][15] = 68,
	[484][16] = 69,
	[484][17] = 70,
	[484][18] = 71,
	[484][19] = 72,
	[484][20] = 73,
	[484][23] = 74,
	[484][56] = 756,
	[512][1] = 56,
	[512][2] = 57,
	[512][4] = 58,
	[512][5] = 59,
	[512][6] = 60,
	[512][7] = 61,
	[512][8] = 768,
	[512][10] = 63,
	[512][11] = 64,
	[512][12] = 65,
	[512][13] = 66,
	[512][14] = 67,
	[512][15] = 68,
	[512][16] = 69,
	[512][17] = 70,
	[512][18] = 71,
	[512][19] = 72,
	[512][20] = 73,
	[512][23] = 74,
	[512][61] = 767,
	[525][1] = 56,
	[525][2] = 57,
	[525][4] = 58,
	[525][5] = 59,
	[525][6] = 60,
	[525][7] = 61,
	[525][8] = 523,
	[525][10] = 63,
	[525][11] = 64,
	[525][12] = 65,
	[525][13] = 66,
	[525][14] = 67,
	[525][15] = 68,
	[525][16] = 69,
	[525][17] = 70,
	[525][18] = 71,
	[525][19] = 72,
	[525][20] = 73,
	[525][23] = 74,
	[525][35] = 774,
	[526][1] = 93,
	[526][2] = 94,
	[526][4] = 95,
	[526][5] = 96,
	[526][6] = 97,
	[526][7] = 98,
	[526][8] = 255,
	[526][10] = 100,
	[526][11] = 101,
	[526][12] = 102,
	[526][13] = 103,
	[526][14] = 104,
	[526][15] = 105,
	[526][16] = 106,
	[526][17] = 107,
	[526][18] = 108,
	[526][19] = 109,
	[526][20] = 110,
	[526][23] = 111,
	[526][36] = 775,
	[530][1] = 93,
	[530][2] = 94,
	[530][4] = 95,
	[530][5] = 96,
	[530][6] = 97,
	[530][7] = 98,
	[530][8] = 529,
	[530][10] = 100,
	[530][11] = 101,
	[530][12] = 102,
	[530][13] = 103,
	[530][14] = 104,
	[530][15] = 105,
	[530][16] = 106,
	[530][17] = 107,
	[530][18] = 108,
	[530][19] = 109,
	[530][20] = 110,
	[530][23] = 111,
	[530][36] = 778,
	[533][1] = 56,
	[533][2] = 57,
	[533][4] = 58,
	[533][5] = 59,
	[533][6] = 60,
	[533][7] = 61,
	[533][8] = 780,
	[533][10] = 63,
	[533][11] = 64,
	[533][12] = 65,
	[533][13] = 66,
	[533][14] = 67,
	[533][15] = 68,
	[533][16] = 69,
	[533][17] = 70,
	[533][18] = 71,
	[533][19] = 72,
	[533][20] = 73,
	[533][23] = 74,
	[533][56] = 779,
	[561][1] = 56,
	[561][2] = 57,
	[561][4] = 58,
	[561][5] = 59,
	[561][6] = 60,
	[561][7] = 61,
	[561][8] = 791,
	[561][10] = 63,
	[561][11] = 64,
	[561][12] = 65,
	[561][13] = 66,
	[561][14] = 67,
	[561][15] = 68,
	[561][16] = 69,
	[561][17] = 70,
	[561][18] = 71,
	[561][19] = 72,
	[561][20] = 73,
	[561][23] = 74,
	[561][61] = 790,
	[571][62] = 796,
	[572][63] = 798,
	[575][37] = 801,
	[575][38] = 581,
	[575][39] = 582,
	[575][40] = 583,
	[577][46] = 803,
	[577][47] = 590,
	[577][48] = 591,
	[577][49] = 592,
	[577][50] = 593,
	[577][51] = 594,
	[579][52] = 805,
	[579][53] = 602,
	[579][54] = 603,
	[579][55] = 604,
	[583][38] = 581,
	[583][40] = 811,
	[584][64] = 813,
	[587][46] = 818,
	[587][47] = 819,
	[587][48] = 820,
	[587][49] = 821,
	[587][50] = 822,
	[587][51] = 823,
	[588][47] = 824,
	[594][47] = 590,
	[594][48] = 591,
	[594][49] = 592,
	[594][50] = 593,
	[594][51] = 831,
	[595][65] = 833,
	[598][52] = 839,
	[598][53] = 840,
	[598][54] = 841,
	[598][55] = 842,
	[600][46] = 843,
	[600][47] = 590,
	[600][48] = 591,
	[600][49] = 592,
	[600][50] = 593,
	[600][51] = 594,
	[604][53] = 602,
	[604][55] = 849,
	[609][38] = 301,
	[609][39] = 851,
	[609][40] = 303,
	[609][66] = 850,
	[610][38] = 301,
	[610][40] = 853,
	[610][67] = 852,
	[615][1] = 56,
	[615][2] = 57,
	[615][4] = 58,
	[615][5] = 59,
	[615][6] = 60,
	[615][7] = 61,
	[615][8] = 613,
	[615][10] = 63,
	[615][11] = 64,
	[615][12] = 65,
	[615][13] = 66,
	[615][14] = 67,
	[615][15] = 68,
	[615][16] = 69,
	[615][17] = 70,
	[615][18] = 71,
	[615][19] = 72,
	[615][20] = 73,
	[615][23] = 74,
	[615][56] = 856,
	[619][52] = 857,
	[619][53] = 840,
	[619][54] = 841,
	[619][55] = 842,
	[621][46] = 858,
	[621][47] = 590,
	[621][48] = 591,
	[621][49] = 592,
	[621][50] = 593,
	[621][51] = 594,
	[625][53] = 623,
	[625][55] = 864,
	[628][29] = 866,
	[633][26] = 324,
	[633][27] = 868,
	[633][58] = 867,
	[637][26] = 341,
	[637][27] = 874,
	[637][59] = 873,
	[638][26] = 324,
	[638][27] = 876,
	[638][60] = 875,
	[642][26] = 324,
	[642][27] = 636,
	[642][58] = 879,
	[643][26] = 133,
	[643][27] = 329,
	[643][41] = 880,
	[643][42] = 328,
	[644][1] = 16,
	[644][2] = 17,
	[644][4] = 19,
	[644][5] = 20,
	[644][6] = 21,
	[644][7] = 22,
	[644][11] = 26,
	[644][12] = 331,
	[644][13] = 28,
	[644][14] = 29,
	[644][15] = 30,
	[644][17] = 32,
	[644][18] = 33,
	[644][19] = 34,
	[644][20] = 35,
	[644][23] = 38,
	[644][43] = 881,
	[647][26] = 324,
	[647][27] = 883,
	[647][58] = 882,
	[653][26] = 341,
	[653][27] = 889,
	[653][59] = 888,
	[654][26] = 341,
	[654][27] = 891,
	[654][60] = 890,
	[657][26] = 341,
	[657][27] = 650,
	[657][59] = 894,
	[658][26] = 133,
	[658][27] = 652,
	[658][60] = 895,
	[659][26] = 133,
	[659][27] = 329,
	[659][41] = 896,
	[659][42] = 328,
	[660][1] = 16,
	[660][2] = 17,
	[660][4] = 19,
	[660][5] = 20,
	[660][6] = 21,
	[660][7] = 22,
	[660][11] = 26,
	[660][12] = 331,
	[660][13] = 28,
	[660][14] = 29,
	[660][15] = 30,
	[660][17] = 32,
	[660][18] = 33,
	[660][19] = 34,
	[660][20] = 35,
	[660][23] = 38,
	[660][43] = 897,
	[661][1] = 16,
	[661][2] = 17,
	[661][4] = 19,
	[661][5] = 20,
	[661][6] = 21,
	[661][7] = 22,
	[661][10] = 365,
	[661][11] = 26,
	[661][12] = 27,
	[661][13] = 28,
	[661][14] = 29,
	[661][15] = 30,
	[661][16] = 31,
	[661][17] = 32,
	[661][18] = 33,
	[661][19] = 34,
	[661][20] = 35,
	[661][23] = 38,
	[661][44] = 898,
	[663][1] = 56,
	[663][2] = 57,
	[663][4] = 58,
	[663][5] = 59,
	[663][6] = 60,
	[663][7] = 61,
	[663][8] = 900,
	[663][10] = 63,
	[663][11] = 64,
	[663][12] = 65,
	[663][13] = 66,
	[663][14] = 67,
	[663][15] = 68,
	[663][16] = 69,
	[663][17] = 70,
	[663][18] = 71,
	[663][19] = 72,
	[663][20] = 73,
	[663][23] = 74,
	[663][35] = 899,
	[667][1] = 93,
	[667][2] = 94,
	[667][4] = 95,
	[667][5] = 96,
	[667][6] = 97,
	[667][7] = 98,
	[667][8] = 904,
	[667][10] = 100,
	[667][11] = 101,
	[667][12] = 102,
	[667][13] = 103,
	[667][14] = 104,
	[667][15] = 105,
	[667][16] = 106,
	[667][17] = 107,
	[667][18] = 108,
	[667][19] = 109,
	[667][20] = 110,
	[667][23] = 111,
	[667][36] = 903,
	[671][1] = 56,
	[671][2] = 57,
	[671][4] = 58,
	[671][5] = 59,
	[671][6] = 60,
	[671][7] = 61,
	[671][8] = 909,
	[671][10] = 63,
	[671][11] = 64,
	[671][12] = 65,
	[671][13] = 66,
	[671][14] = 67,
	[671][15] = 68,
	[671][16] = 69,
	[671][17] = 70,
	[671][18] = 71,
	[671][19] = 72,
	[671][20] = 73,
	[671][23] = 74,
	[673][26] = 133,
	[673][27] = 329,
	[673][41] = 910,
	[673][42] = 911,
	[674][1] = 382,
	[674][2] = 383,
	[674][4] = 384,
	[674][5] = 385,
	[674][6] = 386,
	[674][7] = 387,
	[674][11] = 390,
	[674][12] = 913,
	[674][13] = 392,
	[674][14] = 393,
	[674][15] = 394,
	[674][17] = 396,
	[674][18] = 397,
	[674][19] = 398,
	[674][20] = 399,
	[674][23] = 400,
	[674][43] = 912,
	[676][7] = 387,
	[676][15] = 915,
	[676][17] = 396,
	[676][18] = 397,
	[676][23] = 400,
	[677][7] = 387,
	[677][15] = 916,
	[677][17] = 396,
	[677][18] = 397,
	[677][23] = 400,
	[678][1] = 382,
	[678][5] = 917,
	[678][7] = 387,
	[678][15] = 394,
	[678][17] = 396,
	[678][18] = 397,
	[678][19] = 398,
	[678][20] = 399,
	[678][23] = 400,
	[679][1] = 382,
	[679][7] = 387,
	[679][15] = 394,
	[679][17] = 396,
	[679][18] = 397,
	[679][19] = 918,
	[679][20] = 399,
	[679][23] = 400,
	[680][1] = 382,
	[680][7] = 387,
	[680][15] = 394,
	[680][17] = 396,
	[680][18] = 397,
	[680][19] = 919,
	[680][20] = 399,
	[680][23] = 400,
	[681][1] = 382,
	[681][2] = 920,
	[681][5] = 385,
	[681][7] = 387,
	[681][15] = 394,
	[681][17] = 396,
	[681][18] = 397,
	[681][19] = 398,
	[681][20] = 399,
	[681][23] = 400,
	[682][17] = 396,
	[682][18] = 397,
	[682][23] = 921,
	[683][1] = 16,
	[683][2] = 17,
	[683][4] = 922,
	[683][5] = 20,
	[683][6] = 21,
	[683][7] = 22,
	[683][11] = 26,
	[683][13] = 28,
	[683][14] = 29,
	[683][15] = 30,
	[683][17] = 32,
	[683][18] = 33,
	[683][19] = 34,
	[683][20] = 35,
	[683][23] = 38,
	[684][1] = 382,
	[684][2] = 383,
	[684][4] = 384,
	[684][5] = 385,
	[684][6] = 386,
	[684][7] = 387,
	[684][10] = 924,
	[684][11] = 390,
	[684][12] = 391,
	[684][13] = 392,
	[684][14] = 393,
	[684][15] = 394,
	[684][16] = 395,
	[684][17] = 396,
	[684][18] = 397,
	[684][19] = 398,
	[684][20] = 399,
	[684][23] = 400,
	[684][44] = 923,
	[685][1] = 382,
	[685][2] = 383,
	[685][5] = 385,
	[685][6] = 925,
	[685][7] = 387,
	[685][15] = 394,
	[685][17] = 396,
	[685][18] = 397,
	[685][19] = 398,
	[685][20] = 399,
	[685][23] = 400,
	[687][1] = 382,
	[687][2] = 383,
	[687][5] = 385,
	[687][6] = 386,
	[687][7] = 387,
	[687][11] = 927,
	[687][15] = 394,
	[687][17] = 396,
	[687][18] = 397,
	[687][19] = 398,
	[687][20] = 399,
	[687][23] = 400,
	[688][1] = 382,
	[688][2] = 383,
	[688][4] = 384,
	[688][5] = 385,
	[688][6] = 386,
	[688][7] = 387,
	[688][8] = 928,
	[688][10] = 389,
	[688][11] = 390,
	[688][12] = 391,
	[688][13] = 392,
	[688][14] = 393,
	[688][15] = 394,
	[688][16] = 395,
	[688][17] = 396,
	[688][18] = 397,
	[688][19] = 398,
	[688][20] = 399,
	[688][23] = 400,
	[689][1] = 382,
	[689][2] = 383,
	[689][5] = 385,
	[689][6] = 386,
	[689][7] = 387,
	[689][11] = 390,
	[689][13] = 929,
	[689][15] = 394,
	[689][17] = 396,
	[689][18] = 397,
	[689][19] = 398,
	[689][20] = 399,
	[689][23] = 400,
	[690][7] = 930,
	[690][17] = 396,
	[690][18] = 397,
	[690][23] = 400,
	[691][7] = 931,
	[691][17] = 396,
	[691][18] = 397,
	[691][23] = 400,
	[692][7] = 932,
	[692][17] = 396,
	[692][18] = 397,
	[692][23] = 400,
	[693][1] = 382,
	[693][2] = 383,
	[693][4] = 384,
	[693][5] = 385,
	[693][6] = 386,
	[693][7] = 387,
	[693][11] = 390,
	[693][12] = 391,
	[693][13] = 392,
	[693][14] = 393,
	[693][15] = 394,
	[693][16] = 934,
	[693][17] = 396,
	[693][18] = 397,
	[693][19] = 398,
	[693][20] = 399,
	[693][23] = 400,
	[693][45] = 933,
	[694][1] = 56,
	[694][2] = 57,
	[694][4] = 58,
	[694][5] = 59,
	[694][6] = 60,
	[694][7] = 61,
	[694][8] = 937,
	[694][10] = 63,
	[694][11] = 64,
	[694][12] = 65,
	[694][13] = 66,
	[694][14] = 67,
	[694][15] = 68,
	[694][16] = 69,
	[694][17] = 70,
	[694][18] = 71,
	[694][19] = 72,
	[694][20] = 73,
	[694][23] = 74,
	[695][1] = 423,
	[695][2] = 424,
	[695][4] = 425,
	[695][5] = 426,
	[695][6] = 427,
	[695][7] = 428,
	[695][8] = 938,
	[695][10] = 430,
	[695][11] = 431,
	[695][12] = 432,
	[695][13] = 433,
	[695][14] = 434,
	[695][15] = 435,
	[695][16] = 436,
	[695][17] = 437,
	[695][18] = 438,
	[695][19] = 439,
	[695][20] = 440,
	[695][23] = 441,
	[697][1] = 382,
	[697][7] = 387,
	[697][15] = 394,
	[697][17] = 396,
	[697][18] = 397,
	[697][20] = 940,
	[697][23] = 400,
	[698][1] = 382,
	[698][7] = 387,
	[698][15] = 394,
	[698][17] = 396,
	[698][18] = 397,
	[698][20] = 941,
	[698][23] = 400,
	[699][1] = 382,
	[699][7] = 387,
	[699][15] = 394,
	[699][17] = 396,
	[699][18] = 397,
	[699][20] = 942,
	[699][23] = 400,
	[700][1] = 382,
	[700][7] = 387,
	[700][15] = 394,
	[700][17] = 396,
	[700][18] = 397,
	[700][20] = 943,
	[700][23] = 400,
	[701][1] = 944,
	[701][7] = 387,
	[701][15] = 394,
	[701][17] = 396,
	[701][18] = 397,
	[701][23] = 400,
	[702][1] = 945,
	[702][7] = 387,
	[702][15] = 394,
	[702][17] = 396,
	[702][18] = 397,
	[702][23] = 400,
	[703][1] = 16,
	[703][2] = 17,
	[703][4] = 19,
	[703][5] = 20,
	[703][6] = 21,
	[703][7] = 22,
	[703][11] = 26,
	[703][12] = 27,
	[703][13] = 28,
	[703][14] = 29,
	[703][15] = 30,
	[703][16] = 406,
	[703][17] = 32,
	[703][18] = 33,
	[703][19] = 34,
	[703][20] = 35,
	[703][23] = 38,
	[703][45] = 946,
	[707][1] = 56,
	[707][2] = 57,
	[707][4] = 58,
	[707][5] = 59,
	[707][6] = 60,
	[707][7] = 61,
	[707][8] = 705,
	[707][10] = 63,
	[707][11] = 64,
	[707][12] = 65,
	[707][13] = 66,
	[707][14] = 67,
	[707][15] = 68,
	[707][16] = 69,
	[707][17] = 70,
	[707][18] = 71,
	[707][19] = 72,
	[707][20] = 73,
	[707][23] = 74,
	[707][61] = 949,
	[709][1] = 56,
	[709][2] = 57,
	[709][4] = 58,
	[709][5] = 59,
	[709][6] = 60,
	[709][7] = 61,
	[709][8] = 951,
	[709][10] = 63,
	[709][11] = 64,
	[709][12] = 65,
	[709][13] = 66,
	[709][14] = 67,
	[709][15] = 68,
	[709][16] = 69,
	[709][17] = 70,
	[709][18] = 71,
	[709][19] = 72,
	[709][20] = 73,
	[709][23] = 74,
	[709][35] = 950,
	[713][1] = 93,
	[713][2] = 94,
	[713][4] = 95,
	[713][5] = 96,
	[713][6] = 97,
	[713][7] = 98,
	[713][8] = 955,
	[713][10] = 100,
	[713][11] = 101,
	[713][12] = 102,
	[713][13] = 103,
	[713][14] = 104,
	[713][15] = 105,
	[713][16] = 106,
	[713][17] = 107,
	[713][18] = 108,
	[713][19] = 109,
	[713][20] = 110,
	[713][23] = 111,
	[713][36] = 954,
	[717][1] = 56,
	[717][2] = 57,
	[717][4] = 58,
	[717][5] = 59,
	[717][6] = 60,
	[717][7] = 61,
	[717][8] = 960,
	[717][10] = 63,
	[717][11] = 64,
	[717][12] = 65,
	[717][13] = 66,
	[717][14] = 67,
	[717][15] = 68,
	[717][16] = 69,
	[717][17] = 70,
	[717][18] = 71,
	[717][19] = 72,
	[717][20] = 73,
	[717][23] = 74,
	[719][26] = 133,
	[719][27] = 329,
	[719][41] = 961,
	[719][42] = 962,
	[720][1] = 423,
	[720][2] = 424,
	[720][4] = 425,
	[720][5] = 426,
	[720][6] = 427,
	[720][7] = 428,
	[720][11] = 431,
	[720][12] = 964,
	[720][13] = 433,
	[720][14] = 434,
	[720][15] = 435,
	[720][17] = 437,
	[720][18] = 438,
	[720][19] = 439,
	[720][20] = 440,
	[720][23] = 441,
	[720][43] = 963,
	[722][7] = 428,
	[722][15] = 966,
	[722][17] = 437,
	[722][18] = 438,
	[722][23] = 441,
	[723][7] = 428,
	[723][15] = 967,
	[723][17] = 437,
	[723][18] = 438,
	[723][23] = 441,
	[724][1] = 423,
	[724][5] = 968,
	[724][7] = 428,
	[724][15] = 435,
	[724][17] = 437,
	[724][18] = 438,
	[724][19] = 439,
	[724][20] = 440,
	[724][23] = 441,
	[725][1] = 423,
	[725][7] = 428,
	[725][15] = 435,
	[725][17] = 437,
	[725][18] = 438,
	[725][19] = 969,
	[725][20] = 440,
	[725][23] = 441,
	[726][1] = 423,
	[726][7] = 428,
	[726][15] = 435,
	[726][17] = 437,
	[726][18] = 438,
	[726][19] = 970,
	[726][20] = 440,
	[726][23] = 441,
	[727][1] = 423,
	[727][2] = 971,
	[727][5] = 426,
	[727][7] = 428,
	[727][15] = 435,
	[727][17] = 437,
	[727][18] = 438,
	[727][19] = 439,
	[727][20] = 440,
	[727][23] = 441,
	[728][17] = 437,
	[728][18] = 438,
	[728][23] = 972,
	[730][1] = 423,
	[730][2] = 424,
	[730][4] = 425,
	[730][5] = 426,
	[730][6] = 427,
	[730][7] = 428,
	[730][10] = 974,
	[730][11] = 431,
	[730][12] = 432,
	[730][13] = 433,
	[730][14] = 434,
	[730][15] = 435,
	[730][16] = 436,
	[730][17] = 437,
	[730][18] = 438,
	[730][19] = 439,
	[730][20] = 440,
	[730][23] = 441,
	[730][44] = 973,
	[731][1] = 423,
	[731][2] = 424,
	[731][5] = 426,
	[731][6] = 975,
	[731][7] = 428,
	[731][15] = 435,
	[731][17] = 437,
	[731][18] = 438,
	[731][19] = 439,
	[731][20] = 440,
	[731][23] = 441,
	[733][1] = 423,
	[733][2] = 424,
	[733][5] = 426,
	[733][6] = 427,
	[733][7] = 428,
	[733][11] = 977,
	[733][15] = 435,
	[733][17] = 437,
	[733][18] = 438,
	[733][19] = 439,
	[733][20] = 440,
	[733][23] = 441,
	[734][1] = 382,
	[734][2] = 383,
	[734][4] = 384,
	[734][5] = 385,
	[734][6] = 386,
	[734][7] = 387,
	[734][8] = 978,
	[734][10] = 389,
	[734][11] = 390,
	[734][12] = 391,
	[734][13] = 392,
	[734][14] = 393,
	[734][15] = 394,
	[734][16] = 395,
	[734][17] = 396,
	[734][18] = 397,
	[734][19] = 398,
	[734][20] = 399,
	[734][23] = 400,
	[735][1] = 423,
	[735][2] = 424,
	[735][5] = 426,
	[735][6] = 427,
	[735][7] = 428,
	[735][11] = 431,
	[735][13] = 979,
	[735][15] = 435,
	[735][17] = 437,
	[735][18] = 438,
	[735][19] = 439,
	[735][20] = 440,
	[735][23] = 441,
	[736][7] = 980,
	[736][17] = 437,
	[736][18] = 438,
	[736][23] = 441,
	[737][7] = 981,
	[737][17] = 437,
	[737][18] = 438,
	[737][23] = 441,
	[738][7] = 982,
	[738][17] = 437,
	[738][18] = 438,
	[738][23] = 441,
	[739][1] = 423,
	[739][2] = 424,
	[739][4] = 425,
	[739][5] = 426,
	[739][6] = 427,
	[739][7] = 428,
	[739][11] = 431,
	[739][12] = 432,
	[739][13] = 433,
	[739][14] = 434,
	[739][15] = 435,
	[739][16] = 984,
	[739][17] = 437,
	[739][18] = 438,
	[739][19] = 439,
	[739][20] = 440,
	[739][23] = 441,
	[739][45] = 983,
	[740][1] = 56,
	[740][2] = 57,
	[740][4] = 58,
	[740][5] = 59,
	[740][6] = 60,
	[740][7] = 61,
	[740][8] = 987,
	[740][10] = 63,
	[740][11] = 64,
	[740][12] = 65,
	[740][13] = 66,
	[740][14] = 67,
	[740][15] = 68,
	[740][16] = 69,
	[740][17] = 70,
	[740][18] = 71,
	[740][19] = 72,
	[740][20] = 73,
	[740][23] = 74,
	[741][1] = 423,
	[741][2] = 424,
	[741][4] = 425,
	[741][5] = 426,
	[741][6] = 427,
	[741][7] = 428,
	[741][8] = 988,
	[741][10] = 430,
	[741][11] = 431,
	[741][12] = 432,
	[741][13] = 433,
	[741][14] = 434,
	[741][15] = 435,
	[741][16] = 436,
	[741][17] = 437,
	[741][18] = 438,
	[741][19] = 439,
	[741][20] = 440,
	[741][23] = 441,
	[743][1] = 423,
	[743][7] = 428,
	[743][15] = 435,
	[743][17] = 437,
	[743][18] = 438,
	[743][20] = 990,
	[743][23] = 441,
	[744][1] = 423,
	[744][7] = 428,
	[744][15] = 435,
	[744][17] = 437,
	[744][18] = 438,
	[744][20] = 991,
	[744][23] = 441,
	[745][1] = 423,
	[745][7] = 428,
	[745][15] = 435,
	[745][17] = 437,
	[745][18] = 438,
	[745][20] = 992,
	[745][23] = 441,
	[746][1] = 423,
	[746][7] = 428,
	[746][15] = 435,
	[746][17] = 437,
	[746][18] = 438,
	[746][20] = 993,
	[746][23] = 441,
	[747][1] = 994,
	[747][7] = 428,
	[747][15] = 435,
	[747][17] = 437,
	[747][18] = 438,
	[747][23] = 441,
	[748][1] = 995,
	[748][7] = 428,
	[748][15] = 435,
	[748][17] = 437,
	[748][18] = 438,
	[748][23] = 441,
	[750][1] = 56,
	[750][2] = 57,
	[750][4] = 58,
	[750][5] = 59,
	[750][6] = 60,
	[750][7] = 61,
	[750][8] = 474,
	[750][10] = 63,
	[750][11] = 64,
	[750][12] = 65,
	[750][13] = 66,
	[750][14] = 67,
	[750][15] = 68,
	[750][16] = 69,
	[750][17] = 70,
	[750][18] = 71,
	[750][19] = 72,
	[750][20] = 73,
	[750][23] = 74,
	[750][35] = 996,
	[753][1] = 93,
	[753][2] = 94,
	[753][4] = 95,
	[753][5] = 96,
	[753][6] = 97,
	[753][7] = 98,
	[753][8] = 480,
	[753][10] = 100,
	[753][11] = 101,
	[753][12] = 102,
	[753][13] = 103,
	[753][14] = 104,
	[753][15] = 105,
	[753][16] = 106,
	[753][17] = 107,
	[753][18] = 108,
	[753][19] = 109,
	[753][20] = 110,
	[753][23] = 111,
	[753][36] = 997,
	[759][1] = 56,
	[759][2] = 57,
	[759][4] = 58,
	[759][5] = 59,
	[759][6] = 60,
	[759][7] = 61,
	[759][8] = 757,
	[759][10] = 63,
	[759][11] = 64,
	[759][12] = 65,
	[759][13] = 66,
	[759][14] = 67,
	[759][15] = 68,
	[759][16] = 69,
	[759][17] = 70,
	[759][18] = 71,
	[759][19] = 72,
	[759][20] = 73,
	[759][23] = 74,
	[759][56] = 1000,
	[760][26] = 133,
	[760][27] = 329,
	[760][41] = 1001,
	[760][42] = 487,
	[761][1] = 56,
	[761][2] = 57,
	[761][4] = 58,
	[761][5] = 59,
	[761][6] = 60,
	[761][7] = 61,
	[761][11] = 64,
	[761][12] = 489,
	[761][13] = 66,
	[761][14] = 67,
	[761][15] = 68,
	[761][17] = 70,
	[761][18] = 71,
	[761][19] = 72,
	[761][20] = 73,
	[761][23] = 74,
	[761][43] = 1002,
	[762][26] = 133,
	[762][27] = 329,
	[762][41] = 1003,
	[762][42] = 487,
	[763][1] = 56,
	[763][2] = 57,
	[763][4] = 58,
	[763][5] = 59,
	[763][6] = 60,
	[763][7] = 61,
	[763][11] = 64,
	[763][12] = 489,
	[763][13] = 66,
	[763][14] = 67,
	[763][15] = 68,
	[763][17] = 70,
	[763][18] = 71,
	[763][19] = 72,
	[763][20] = 73,
	[763][23] = 74,
	[763][43] = 1004,
	[764][1] = 56,
	[764][2] = 57,
	[764][4] = 58,
	[764][5] = 59,
	[764][6] = 60,
	[764][7] = 61,
	[764][10] = 500,
	[764][11] = 64,
	[764][12] = 65,
	[764][13] = 66,
	[764][14] = 67,
	[764][15] = 68,
	[764][16] = 69,
	[764][17] = 70,
	[764][18] = 71,
	[764][19] = 72,
	[764][20] = 73,
	[764][23] = 74,
	[764][44] = 1005,
	[765][1] = 56,
	[765][2] = 57,
	[765][4] = 1006,
	[765][5] = 59,
	[765][6] = 60,
	[765][7] = 61,
	[765][11] = 64,
	[765][13] = 66,
	[765][14] = 67,
	[765][15] = 68,
	[765][17] = 70,
	[765][18] = 71,
	[765][19] = 72,
	[765][20] = 73,
	[765][23] = 74,
	[766][1] = 56,
	[766][2] = 57,
	[766][4] = 58,
	[766][5] = 59,
	[766][6] = 60,
	[766][7] = 61,
	[766][11] = 64,
	[766][12] = 65,
	[766][13] = 66,
	[766][14] = 67,
	[766][15] = 68,
	[766][16] = 510,
	[766][17] = 70,
	[766][18] = 71,
	[766][19] = 72,
	[766][20] = 73,
	[766][23] = 74,
	[766][45] = 1007,
	[770][1] = 56,
	[770][2] = 57,
	[770][4] = 58,
	[770][5] = 59,
	[770][6] = 60,
	[770][7] = 61,
	[770][8] = 768,
	[770][10] = 63,
	[770][11] = 64,
	[770][12] = 65,
	[770][13] = 66,
	[770][14] = 67,
	[770][15] = 68,
	[770][16] = 69,
	[770][17] = 70,
	[770][18] = 71,
	[770][19] = 72,
	[770][20] = 73,
	[770][23] = 74,
	[770][61] = 1010,
	[773][1] = 56,
	[773][2] = 57,
	[773][4] = 58,
	[773][5] = 59,
	[773][6] = 60,
	[773][7] = 61,
	[773][8] = 523,
	[773][10] = 63,
	[773][11] = 64,
	[773][12] = 65,
	[773][13] = 66,
	[773][14] = 67,
	[773][15] = 68,
	[773][16] = 69,
	[773][17] = 70,
	[773][18] = 71,
	[773][19] = 72,
	[773][20] = 73,
	[773][23] = 74,
	[773][35] = 1011,
	[776][1] = 93,
	[776][2] = 94,
	[776][4] = 95,
	[776][5] = 96,
	[776][6] = 97,
	[776][7] = 98,
	[776][8] = 529,
	[776][10] = 100,
	[776][11] = 101,
	[776][12] = 102,
	[776][13] = 103,
	[776][14] = 104,
	[776][15] = 105,
	[776][16] = 106,
	[776][17] = 107,
	[776][18] = 108,
	[776][19] = 109,
	[776][20] = 110,
	[776][23] = 111,
	[776][36] = 1012,
	[782][1] = 56,
	[782][2] = 57,
	[782][4] = 58,
	[782][5] = 59,
	[782][6] = 60,
	[782][7] = 61,
	[782][8] = 780,
	[782][10] = 63,
	[782][11] = 64,
	[782][12] = 65,
	[782][13] = 66,
	[782][14] = 67,
	[782][15] = 68,
	[782][16] = 69,
	[782][17] = 70,
	[782][18] = 71,
	[782][19] = 72,
	[782][20] = 73,
	[782][23] = 74,
	[782][56] = 1015,
	[783][26] = 133,
	[783][27] = 329,
	[783][41] = 1016,
	[783][42] = 536,
	[784][1] = 93,
	[784][2] = 94,
	[784][4] = 95,
	[784][5] = 96,
	[784][6] = 97,
	[784][7] = 98,
	[784][11] = 101,
	[784][12] = 538,
	[784][13] = 103,
	[784][14] = 104,
	[784][15] = 105,
	[784][17] = 107,
	[784][18] = 108,
	[784][19] = 109,
	[784][20] = 110,
	[784][23] = 111,
	[784][43] = 1017,
	[785][26] = 133,
	[785][27] = 329,
	[785][41] = 1018,
	[785][42] = 536,
	[786][1] = 93,
	[786][2] = 94,
	[786][4] = 95,
	[786][5] = 96,
	[786][6] = 97,
	[786][7] = 98,
	[786][11] = 101,
	[786][12] = 538,
	[786][13] = 103,
	[786][14] = 104,
	[786][15] = 105,
	[786][17] = 107,
	[786][18] = 108,
	[786][19] = 109,
	[786][20] = 110,
	[786][23] = 111,
	[786][43] = 1019,
	[787][1] = 93,
	[787][2] = 94,
	[787][4] = 95,
	[787][5] = 96,
	[787][6] = 97,
	[787][7] = 98,
	[787][10] = 549,
	[787][11] = 101,
	[787][12] = 102,
	[787][13] = 103,
	[787][14] = 104,
	[787][15] = 105,
	[787][16] = 106,
	[787][17] = 107,
	[787][18] = 108,
	[787][19] = 109,
	[787][20] = 110,
	[787][23] = 111,
	[787][44] = 1020,
	[788][1] = 93,
	[788][2] = 94,
	[788][4] = 1021,
	[788][5] = 96,
	[788][6] = 97,
	[788][7] = 98,
	[788][11] = 101,
	[788][13] = 103,
	[788][14] = 104,
	[788][15] = 105,
	[788][17] = 107,
	[788][18] = 108,
	[788][19] = 109,
	[788][20] = 110,
	[788][23] = 111,
	[789][1] = 93,
	[789][2] = 94,
	[789][4] = 95,
	[789][5] = 96,
	[789][6] = 97,
	[789][7] = 98,
	[789][11] = 101,
	[789][12] = 102,
	[789][13] = 103,
	[789][14] = 104,
	[789][15] = 105,
	[789][16] = 559,
	[789][17] = 107,
	[789][18] = 108,
	[789][19] = 109,
	[789][20] = 110,
	[789][23] = 111,
	[789][45] = 1022,
	[793][1] = 56,
	[793][2] = 57,
	[793][4] = 58,
	[793][5] = 59,
	[793][6] = 60,
	[793][7] = 61,
	[793][8] = 791,
	[793][10] = 63,
	[793][11] = 64,
	[793][12] = 65,
	[793][13] = 66,
	[793][14] = 67,
	[793][15] = 68,
	[793][16] = 69,
	[793][17] = 70,
	[793][18] = 71,
	[793][19] = 72,
	[793][20] = 73,
	[793][23] = 74,
	[793][61] = 1025,
	[795][62] = 1026,
	[797][63] = 1027,
	[799][62] = 1029,
	[800][63] = 1031,
	[802][64] = 1034,
	[804][65] = 1037,
	[810][38] = 581,
	[810][39] = 1041,
	[810][40] = 583,
	[810][66] = 1040,
	[811][38] = 581,
	[811][40] = 1043,
	[811][67] = 1042,
	[812][64] = 1044,
	[816][46] = 1045,
	[816][47] = 819,
	[816][48] = 820,
	[816][49] = 821,
	[816][50] = 822,
	[816][51] = 823,
	[817][47] = 1046,
	[823][47] = 819,
	[823][48] = 820,
	[823][49] = 821,
	[823][50] = 822,
	[823][51] = 1053,
	[826][47] = 590,
	[826][48] = 1056,
	[826][49] = 592,
	[826][50] = 593,
	[826][68] = 1055,
	[827][47] = 1061,
	[827][49] = 1062,
	[828][47] = 590,
	[828][49] = 592,
	[828][50] = 1064,
	[828][69] = 1063,
	[829][47] = 590,
	[829][48] = 591,
	[829][49] = 592,
	[829][50] = 593,
	[829][51] = 1066,
	[829][70] = 1065,
	[830][47] = 590,
	[830][48] = 591,
	[830][49] = 592,
	[830][50] = 593,
	[830][51] = 1068,
	[830][71] = 1067,
	[831][47] = 590,
	[831][48] = 591,
	[831][49] = 592,
	[831][50] = 593,
	[831][51] = 1072,
	[831][72] = 1071,
	[832][65] = 1073,
	[836][52] = 1074,
	[836][53] = 840,
	[836][54] = 841,
	[836][55] = 842,
	[838][46] = 1075,
	[838][47] = 590,
	[838][48] = 591,
	[838][49] = 592,
	[838][50] = 593,
	[838][51] = 594,
	[842][53] = 840,
	[842][55] = 1081,
	[848][53] = 602,
	[848][54] = 1085,
	[848][55] = 604,
	[848][73] = 1084,
	[849][53] = 602,
	[849][55] = 1087,
	[849][74] = 1086,
	[853][38] = 301,
	[853][40] = 853,
	[853][67] = 1089,
	[855][1] = 56,
	[855][2] = 57,
	[855][4] = 58,
	[855][5] = 59,
	[855][6] = 60,
	[855][7] = 61,
	[855][8] = 613,
	[855][10] = 63,
	[855][11] = 64,
	[855][12] = 65,
	[855][13] = 66,
	[855][14] = 67,
	[855][15] = 68,
	[855][16] = 69,
	[855][17] = 70,
	[855][18] = 71,
	[855][19] = 72,
	[855][20] = 73,
	[855][23] = 74,
	[855][56] = 1090,
	[863][53] = 623,
	[863][54] = 1094,
	[863][55] = 625,
	[863][73] = 1093,
	[864][53] = 623,
	[864][55] = 1096,
	[864][74] = 1095,
	[870][26] = 324,
	[870][27] = 868,
	[870][58] = 1099,
	[872][26] = 324,
	[872][27] = 636,
	[872][58] = 1100,
	[877][26] = 341,
	[877][27] = 874,
	[877][59] = 1103,
	[878][26] = 324,
	[878][27] = 876,
	[878][60] = 1104,
	[885][26] = 324,
	[885][27] = 883,
	[885][58] = 1107,
	[886][26] = 341,
	[886][27] = 650,
	[886][59] = 1108,
	[887][26] = 133,
	[887][27] = 652,
	[887][60] = 1109,
	[892][26] = 341,
	[892][27] = 889,
	[892][59] = 1112,
	[893][26] = 341,
	[893][27] = 891,
	[893][60] = 1113,
	[902][1] = 56,
	[902][2] = 57,
	[902][4] = 58,
	[902][5] = 59,
	[902][6] = 60,
	[902][7] = 61,
	[902][8] = 900,
	[902][10] = 63,
	[902][11] = 64,
	[902][12] = 65,
	[902][13] = 66,
	[902][14] = 67,
	[902][15] = 68,
	[902][16] = 69,
	[902][17] = 70,
	[902][18] = 71,
	[902][19] = 72,
	[902][20] = 73,
	[902][23] = 74,
	[902][35] = 1116,
	[905][1] = 93,
	[905][2] = 94,
	[905][4] = 95,
	[905][5] = 96,
	[905][6] = 97,
	[905][7] = 98,
	[905][8] = 904,
	[905][10] = 100,
	[905][11] = 101,
	[905][12] = 102,
	[905][13] = 103,
	[905][14] = 104,
	[905][15] = 105,
	[905][16] = 106,
	[905][17] = 107,
	[905][18] = 108,
	[905][19] = 109,
	[905][20] = 110,
	[905][23] = 111,
	[905][36] = 1119,
	[908][1] = 56,
	[908][2] = 57,
	[908][4] = 58,
	[908][5] = 59,
	[908][6] = 60,
	[908][7] = 61,
	[908][8] = 1121,
	[908][10] = 63,
	[908][11] = 64,
	[908][12] = 65,
	[908][13] = 66,
	[908][14] = 67,
	[908][15] = 68,
	[908][16] = 69,
	[908][17] = 70,
	[908][18] = 71,
	[908][19] = 72,
	[908][20] = 73,
	[908][23] = 74,
	[908][56] = 1120,
	[936][1] = 56,
	[936][2] = 57,
	[936][4] = 58,
	[936][5] = 59,
	[936][6] = 60,
	[936][7] = 61,
	[936][8] = 1132,
	[936][10] = 63,
	[936][11] = 64,
	[936][12] = 65,
	[936][13] = 66,
	[936][14] = 67,
	[936][15] = 68,
	[936][16] = 69,
	[936][17] = 70,
	[936][18] = 71,
	[936][19] = 72,
	[936][20] = 73,
	[936][23] = 74,
	[936][61] = 1131,
	[948][1] = 56,
	[948][2] = 57,
	[948][4] = 58,
	[948][5] = 59,
	[948][6] = 60,
	[948][7] = 61,
	[948][8] = 705,
	[948][10] = 63,
	[948][11] = 64,
	[948][12] = 65,
	[948][13] = 66,
	[948][14] = 67,
	[948][15] = 68,
	[948][16] = 69,
	[948][17] = 70,
	[948][18] = 71,
	[948][19] = 72,
	[948][20] = 73,
	[948][23] = 74,
	[948][61] = 1136,
	[953][1] = 56,
	[953][2] = 57,
	[953][4] = 58,
	[953][5] = 59,
	[953][6] = 60,
	[953][7] = 61,
	[953][8] = 951,
	[953][10] = 63,
	[953][11] = 64,
	[953][12] = 65,
	[953][13] = 66,
	[953][14] = 67,
	[953][15] = 68,
	[953][16] = 69,
	[953][17] = 70,
	[953][18] = 71,
	[953][19] = 72,
	[953][20] = 73,
	[953][23] = 74,
	[953][35] = 1139,
	[956][1] = 93,
	[956][2] = 94,
	[956][4] = 95,
	[956][5] = 96,
	[956][6] = 97,
	[956][7] = 98,
	[956][8] = 955,
	[956][10] = 100,
	[956][11] = 101,
	[956][12] = 102,
	[956][13] = 103,
	[956][14] = 104,
	[956][15] = 105,
	[956][16] = 106,
	[956][17] = 107,
	[956][18] = 108,
	[956][19] = 109,
	[956][20] = 110,
	[956][23] = 111,
	[956][36] = 1142,
	[959][1] = 56,
	[959][2] = 57,
	[959][4] = 58,
	[959][5] = 59,
	[959][6] = 60,
	[959][7] = 61,
	[959][8] = 1144,
	[959][10] = 63,
	[959][11] = 64,
	[959][12] = 65,
	[959][13] = 66,
	[959][14] = 67,
	[959][15] = 68,
	[959][16] = 69,
	[959][17] = 70,
	[959][18] = 71,
	[959][19] = 72,
	[959][20] = 73,
	[959][23] = 74,
	[959][56] = 1143,
	[986][1] = 56,
	[986][2] = 57,
	[986][4] = 58,
	[986][5] = 59,
	[986][6] = 60,
	[986][7] = 61,
	[986][8] = 1155,
	[986][10] = 63,
	[986][11] = 64,
	[986][12] = 65,
	[986][13] = 66,
	[986][14] = 67,
	[986][15] = 68,
	[986][16] = 69,
	[986][17] = 70,
	[986][18] = 71,
	[986][19] = 72,
	[986][20] = 73,
	[986][23] = 74,
	[986][61] = 1154,
	[999][1] = 56,
	[999][2] = 57,
	[999][4] = 58,
	[999][5] = 59,
	[999][6] = 60,
	[999][7] = 61,
	[999][8] = 757,
	[999][10] = 63,
	[999][11] = 64,
	[999][12] = 65,
	[999][13] = 66,
	[999][14] = 67,
	[999][15] = 68,
	[999][16] = 69,
	[999][17] = 70,
	[999][18] = 71,
	[999][19] = 72,
	[999][20] = 73,
	[999][23] = 74,
	[999][56] = 1159,
	[1009][1] = 56,
	[1009][2] = 57,
	[1009][4] = 58,
	[1009][5] = 59,
	[1009][6] = 60,
	[1009][7] = 61,
	[1009][8] = 768,
	[1009][10] = 63,
	[1009][11] = 64,
	[1009][12] = 65,
	[1009][13] = 66,
	[1009][14] = 67,
	[1009][15] = 68,
	[1009][16] = 69,
	[1009][17] = 70,
	[1009][18] = 71,
	[1009][19] = 72,
	[1009][20] = 73,
	[1009][23] = 74,
	[1009][61] = 1160,
	[1014][1] = 56,
	[1014][2] = 57,
	[1014][4] = 58,
	[1014][5] = 59,
	[1014][6] = 60,
	[1014][7] = 61,
	[1014][8] = 780,
	[1014][10] = 63,
	[1014][11] = 64,
	[1014][12] = 65,
	[1014][13] = 66,
	[1014][14] = 67,
	[1014][15] = 68,
	[1014][16] = 69,
	[1014][17] = 70,
	[1014][18] = 71,
	[1014][19] = 72,
	[1014][20] = 73,
	[1014][23] = 74,
	[1014][56] = 1161,
	[1024][1] = 56,
	[1024][2] = 57,
	[1024][4] = 58,
	[1024][5] = 59,
	[1024][6] = 60,
	[1024][7] = 61,
	[1024][8] = 791,
	[1024][10] = 63,
	[1024][11] = 64,
	[1024][12] = 65,
	[1024][13] = 66,
	[1024][14] = 67,
	[1024][15] = 68,
	[1024][16] = 69,
	[1024][17] = 70,
	[1024][18] = 71,
	[1024][19] = 72,
	[1024][20] = 73,
	[1024][23] = 74,
	[1024][61] = 1162,
	[1028][62] = 1163,
	[1030][63] = 1164,
	[1033][64] = 1166,
	[1036][65] = 1168,
	[1039][62] = 1170,
	[1043][38] = 581,
	[1043][40] = 1043,
	[1043][67] = 1172,
	[1048][47] = 819,
	[1048][48] = 1175,
	[1048][49] = 821,
	[1048][50] = 822,
	[1048][68] = 1174,
	[1049][47] = 1180,
	[1049][49] = 1181,
	[1050][47] = 819,
	[1050][49] = 821,
	[1050][50] = 1183,
	[1050][69] = 1182,
	[1051][47] = 819,
	[1051][48] = 820,
	[1051][49] = 821,
	[1051][50] = 822,
	[1051][51] = 1185,
	[1051][70] = 1184,
	[1052][47] = 819,
	[1052][48] = 820,
	[1052][49] = 821,
	[1052][50] = 822,
	[1052][51] = 1187,
	[1052][71] = 1186,
	[1053][47] = 819,
	[1053][48] = 820,
	[1053][49] = 821,
	[1053][50] = 822,
	[1053][51] = 1191,
	[1053][72] = 1190,
	[1054][75] = 1193,
	[1059][46] = 1195,
	[1059][47] = 819,
	[1059][48] = 820,
	[1059][49] = 821,
	[1059][50] = 822,
	[1059][51] = 823,
	[1060][47] = 1196,
	[1066][47] = 590,
	[1066][48] = 591,
	[1066][49] = 592,
	[1066][50] = 593,
	[1066][51] = 1072,
	[1066][72] = 1198,
	[1068][47] = 590,
	[1068][48] = 591,
	[1068][49] = 592,
	[1068][50] = 593,
	[1068][51] = 1072,
	[1068][72] = 1199,
	[1069][47] = 590,
	[1069][48] = 591,
	[1069][49] = 592,
	[1069][50] = 593,
	[1069][51] = 1066,
	[1069][70] = 1200,
	[1070][47] = 590,
	[1070][48] = 591,
	[1070][49] = 592,
	[1070][50] = 593,
	[1070][51] = 1068,
	[1070][71] = 1201,
	[1072][47] = 590,
	[1072][48] = 591,
	[1072][49] = 592,
	[1072][50] = 593,
	[1072][51] = 1072,
	[1072][72] = 1202,
	[1080][53] = 840,
	[1080][54] = 1206,
	[1080][55] = 842,
	[1080][73] = 1205,
	[1081][53] = 840,
	[1081][55] = 1208,
	[1081][74] = 1207,
	[1083][76] = 1210,
	[1087][53] = 602,
	[1087][55] = 1087,
	[1087][74] = 1212,
	[1088][38] = 301,
	[1088][39] = 851,
	[1088][40] = 303,
	[1088][66] = 1213,
	[1096][53] = 623,
	[1096][55] = 1096,
	[1096][74] = 1215,
	[1098][26] = 324,
	[1098][27] = 868,
	[1098][58] = 1216,
	[1101][26] = 341,
	[1101][27] = 874,
	[1101][59] = 1217,
	[1102][26] = 324,
	[1102][27] = 876,
	[1102][60] = 1218,
	[1106][26] = 324,
	[1106][27] = 883,
	[1106][58] = 1219,
	[1110][26] = 341,
	[1110][27] = 889,
	[1110][59] = 1220,
	[1111][26] = 341,
	[1111][27] = 891,
	[1111][60] = 1221,
	[1115][1] = 56,
	[1115][2] = 57,
	[1115][4] = 58,
	[1115][5] = 59,
	[1115][6] = 60,
	[1115][7] = 61,
	[1115][8] = 900,
	[1115][10] = 63,
	[1115][11] = 64,
	[1115][12] = 65,
	[1115][13] = 66,
	[1115][14] = 67,
	[1115][15] = 68,
	[1115][16] = 69,
	[1115][17] = 70,
	[1115][18] = 71,
	[1115][19] = 72,
	[1115][20] = 73,
	[1115][23] = 74,
	[1115][35] = 1222,
	[1117][1] = 93,
	[1117][2] = 94,
	[1117][4] = 95,
	[1117][5] = 96,
	[1117][6] = 97,
	[1117][7] = 98,
	[1117][8] = 904,
	[1117][10] = 100,
	[1117][11] = 101,
	[1117][12] = 102,
	[1117][13] = 103,
	[1117][14] = 104,
	[1117][15] = 105,
	[1117][16] = 106,
	[1117][17] = 107,
	[1117][18] = 108,
	[1117][19] = 109,
	[1117][20] = 110,
	[1117][23] = 111,
	[1117][36] = 1223,
	[1123][1] = 56,
	[1123][2] = 57,
	[1123][4] = 58,
	[1123][5] = 59,
	[1123][6] = 60,
	[1123][7] = 61,
	[1123][8] = 1121,
	[1123][10] = 63,
	[1123][11] = 64,
	[1123][12] = 65,
	[1123][13] = 66,
	[1123][14] = 67,
	[1123][15] = 68,
	[1123][16] = 69,
	[1123][17] = 70,
	[1123][18] = 71,
	[1123][19] = 72,
	[1123][20] = 73,
	[1123][23] = 74,
	[1123][56] = 1226,
	[1124][26] = 133,
	[1124][27] = 329,
	[1124][41] = 1227,
	[1124][42] = 911,
	[1125][1] = 382,
	[1125][2] = 383,
	[1125][4] = 384,
	[1125][5] = 385,
	[1125][6] = 386,
	[1125][7] = 387,
	[1125][11] = 390,
	[1125][12] = 913,
	[1125][13] = 392,
	[1125][14] = 393,
	[1125][15] = 394,
	[1125][17] = 396,
	[1125][18] = 397,
	[1125][19] = 398,
	[1125][20] = 399,
	[1125][23] = 400,
	[1125][43] = 1228,
	[1126][26] = 133,
	[1126][27] = 329,
	[1126][41] = 1229,
	[1126][42] = 911,
	[1127][1] = 382,
	[1127][2] = 383,
	[1127][4] = 384,
	[1127][5] = 385,
	[1127][6] = 386,
	[1127][7] = 387,
	[1127][11] = 390,
	[1127][12] = 913,
	[1127][13] = 392,
	[1127][14] = 393,
	[1127][15] = 394,
	[1127][17] = 396,
	[1127][18] = 397,
	[1127][19] = 398,
	[1127][20] = 399,
	[1127][23] = 400,
	[1127][43] = 1230,
	[1128][1] = 382,
	[1128][2] = 383,
	[1128][4] = 384,
	[1128][5] = 385,
	[1128][6] = 386,
	[1128][7] = 387,
	[1128][10] = 924,
	[1128][11] = 390,
	[1128][12] = 391,
	[1128][13] = 392,
	[1128][14] = 393,
	[1128][15] = 394,
	[1128][16] = 395,
	[1128][17] = 396,
	[1128][18] = 397,
	[1128][19] = 398,
	[1128][20] = 399,
	[1128][23] = 400,
	[1128][44] = 1231,
	[1129][1] = 382,
	[1129][2] = 383,
	[1129][4] = 1232,
	[1129][5] = 385,
	[1129][6] = 386,
	[1129][7] = 387,
	[1129][11] = 390,
	[1129][13] = 392,
	[1129][14] = 393,
	[1129][15] = 394,
	[1129][17] = 396,
	[1129][18] = 397,
	[1129][19] = 398,
	[1129][20] = 399,
	[1129][23] = 400,
	[1130][1] = 382,
	[1130][2] = 383,
	[1130][4] = 384,
	[1130][5] = 385,
	[1130][6] = 386,
	[1130][7] = 387,
	[1130][11] = 390,
	[1130][12] = 391,
	[1130][13] = 392,
	[1130][14] = 393,
	[1130][15] = 394,
	[1130][16] = 934,
	[1130][17] = 396,
	[1130][18] = 397,
	[1130][19] = 398,
	[1130][20] = 399,
	[1130][23] = 400,
	[1130][45] = 1233,
	[1134][1] = 56,
	[1134][2] = 57,
	[1134][4] = 58,
	[1134][5] = 59,
	[1134][6] = 60,
	[1134][7] = 61,
	[1134][8] = 1132,
	[1134][10] = 63,
	[1134][11] = 64,
	[1134][12] = 65,
	[1134][13] = 66,
	[1134][14] = 67,
	[1134][15] = 68,
	[1134][16] = 69,
	[1134][17] = 70,
	[1134][18] = 71,
	[1134][19] = 72,
	[1134][20] = 73,
	[1134][23] = 74,
	[1134][61] = 1236,
	[1138][1] = 56,
	[1138][2] = 57,
	[1138][4] = 58,
	[1138][5] = 59,
	[1138][6] = 60,
	[1138][7] = 61,
	[1138][8] = 951,
	[1138][10] = 63,
	[1138][11] = 64,
	[1138][12] = 65,
	[1138][13] = 66,
	[1138][14] = 67,
	[1138][15] = 68,
	[1138][16] = 69,
	[1138][17] = 70,
	[1138][18] = 71,
	[1138][19] = 72,
	[1138][20] = 73,
	[1138][23] = 74,
	[1138][35] = 1237,
	[1140][1] = 93,
	[1140][2] = 94,
	[1140][4] = 95,
	[1140][5] = 96,
	[1140][6] = 97,
	[1140][7] = 98,
	[1140][8] = 955,
	[1140][10] = 100,
	[1140][11] = 101,
	[1140][12] = 102,
	[1140][13] = 103,
	[1140][14] = 104,
	[1140][15] = 105,
	[1140][16] = 106,
	[1140][17] = 107,
	[1140][18] = 108,
	[1140][19] = 109,
	[1140][20] = 110,
	[1140][23] = 111,
	[1140][36] = 1238,
	[1146][1] = 56,
	[1146][2] = 57,
	[1146][4] = 58,
	[1146][5] = 59,
	[1146][6] = 60,
	[1146][7] = 61,
	[1146][8] = 1144,
	[1146][10] = 63,
	[1146][11] = 64,
	[1146][12] = 65,
	[1146][13] = 66,
	[1146][14] = 67,
	[1146][15] = 68,
	[1146][16] = 69,
	[1146][17] = 70,
	[1146][18] = 71,
	[1146][19] = 72,
	[1146][20] = 73,
	[1146][23] = 74,
	[1146][56] = 1241,
	[1147][26] = 133,
	[1147][27] = 329,
	[1147][41] = 1242,
	[1147][42] = 962,
	[1148][1] = 423,
	[1148][2] = 424,
	[1148][4] = 425,
	[1148][5] = 426,
	[1148][6] = 427,
	[1148][7] = 428,
	[1148][11] = 431,
	[1148][12] = 964,
	[1148][13] = 433,
	[1148][14] = 434,
	[1148][15] = 435,
	[1148][17] = 437,
	[1148][18] = 438,
	[1148][19] = 439,
	[1148][20] = 440,
	[1148][23] = 441,
	[1148][43] = 1243,
	[1149][26] = 133,
	[1149][27] = 329,
	[1149][41] = 1244,
	[1149][42] = 962,
	[1150][1] = 423,
	[1150][2] = 424,
	[1150][4] = 425,
	[1150][5] = 426,
	[1150][6] = 427,
	[1150][7] = 428,
	[1150][11] = 431,
	[1150][12] = 964,
	[1150][13] = 433,
	[1150][14] = 434,
	[1150][15] = 435,
	[1150][17] = 437,
	[1150][18] = 438,
	[1150][19] = 439,
	[1150][20] = 440,
	[1150][23] = 441,
	[1150][43] = 1245,
	[1151][1] = 423,
	[1151][2] = 424,
	[1151][4] = 425,
	[1151][5] = 426,
	[1151][6] = 427,
	[1151][7] = 428,
	[1151][10] = 974,
	[1151][11] = 431,
	[1151][12] = 432,
	[1151][13] = 433,
	[1151][14] = 434,
	[1151][15] = 435,
	[1151][16] = 436,
	[1151][17] = 437,
	[1151][18] = 438,
	[1151][19] = 439,
	[1151][20] = 440,
	[1151][23] = 441,
	[1151][44] = 1246,
	[1152][1] = 423,
	[1152][2] = 424,
	[1152][4] = 1247,
	[1152][5] = 426,
	[1152][6] = 427,
	[1152][7] = 428,
	[1152][11] = 431,
	[1152][13] = 433,
	[1152][14] = 434,
	[1152][15] = 435,
	[1152][17] = 437,
	[1152][18] = 438,
	[1152][19] = 439,
	[1152][20] = 440,
	[1152][23] = 441,
	[1153][1] = 423,
	[1153][2] = 424,
	[1153][4] = 425,
	[1153][5] = 426,
	[1153][6] = 427,
	[1153][7] = 428,
	[1153][11] = 431,
	[1153][12] = 432,
	[1153][13] = 433,
	[1153][14] = 434,
	[1153][15] = 435,
	[1153][16] = 984,
	[1153][17] = 437,
	[1153][18] = 438,
	[1153][19] = 439,
	[1153][20] = 440,
	[1153][23] = 441,
	[1153][45] = 1248,
	[1157][1] = 56,
	[1157][2] = 57,
	[1157][4] = 58,
	[1157][5] = 59,
	[1157][6] = 60,
	[1157][7] = 61,
	[1157][8] = 1155,
	[1157][10] = 63,
	[1157][11] = 64,
	[1157][12] = 65,
	[1157][13] = 66,
	[1157][14] = 67,
	[1157][15] = 68,
	[1157][16] = 69,
	[1157][17] = 70,
	[1157][18] = 71,
	[1157][19] = 72,
	[1157][20] = 73,
	[1157][23] = 74,
	[1157][61] = 1251,
	[1165][62] = 1252,
	[1167][75] = 1254,
	[1169][76] = 1256,
	[1171][38] = 581,
	[1171][39] = 1041,
	[1171][40] = 583,
	[1171][66] = 1257,
	[1178][46] = 1259,
	[1178][47] = 819,
	[1178][48] = 820,
	[1178][49] = 821,
	[1178][50] = 822,
	[1178][51] = 823,
	[1179][47] = 1260,
	[1185][47] = 819,
	[1185][48] = 820,
	[1185][49] = 821,
	[1185][50] = 822,
	[1185][51] = 1191,
	[1185][72] = 1262,
	[1187][47] = 819,
	[1187][48] = 820,
	[1187][49] = 821,
	[1187][50] = 822,
	[1187][51] = 1191,
	[1187][72] = 1263,
	[1188][47] = 819,
	[1188][48] = 820,
	[1188][49] = 821,
	[1188][50] = 822,
	[1188][51] = 1185,
	[1188][70] = 1264,
	[1189][47] = 819,
	[1189][48] = 820,
	[1189][49] = 821,
	[1189][50] = 822,
	[1189][51] = 1187,
	[1189][71] = 1265,
	[1191][47] = 819,
	[1191][48] = 820,
	[1191][49] = 821,
	[1191][50] = 822,
	[1191][51] = 1191,
	[1191][72] = 1266,
	[1192][75] = 1267,
	[1194][47] = 590,
	[1194][48] = 1056,
	[1194][49] = 592,
	[1194][50] = 593,
	[1194][68] = 1268,
	[1197][47] = 590,
	[1197][49] = 592,
	[1197][50] = 1064,
	[1197][69] = 1270,
	[1208][53] = 840,
	[1208][55] = 1208,
	[1208][74] = 1272,
	[1209][76] = 1273,
	[1211][53] = 602,
	[1211][54] = 1085,
	[1211][55] = 604,
	[1211][73] = 1274,
	[1214][53] = 623,
	[1214][54] = 1094,
	[1214][55] = 625,
	[1214][73] = 1275,
	[1225][1] = 56,
	[1225][2] = 57,
	[1225][4] = 58,
	[1225][5] = 59,
	[1225][6] = 60,
	[1225][7] = 61,
	[1225][8] = 1121,
	[1225][10] = 63,
	[1225][11] = 64,
	[1225][12] = 65,
	[1225][13] = 66,
	[1225][14] = 67,
	[1225][15] = 68,
	[1225][16] = 69,
	[1225][17] = 70,
	[1225][18] = 71,
	[1225][19] = 72,
	[1225][20] = 73,
	[1225][23] = 74,
	[1225][56] = 1276,
	[1235][1] = 56,
	[1235][2] = 57,
	[1235][4] = 58,
	[1235][5] = 59,
	[1235][6] = 60,
	[1235][7] = 61,
	[1235][8] = 1132,
	[1235][10] = 63,
	[1235][11] = 64,
	[1235][12] = 65,
	[1235][13] = 66,
	[1235][14] = 67,
	[1235][15] = 68,
	[1235][16] = 69,
	[1235][17] = 70,
	[1235][18] = 71,
	[1235][19] = 72,
	[1235][20] = 73,
	[1235][23] = 74,
	[1235][61] = 1277,
	[1240][1] = 56,
	[1240][2] = 57,
	[1240][4] = 58,
	[1240][5] = 59,
	[1240][6] = 60,
	[1240][7] = 61,
	[1240][8] = 1144,
	[1240][10] = 63,
	[1240][11] = 64,
	[1240][12] = 65,
	[1240][13] = 66,
	[1240][14] = 67,
	[1240][15] = 68,
	[1240][16] = 69,
	[1240][17] = 70,
	[1240][18] = 71,
	[1240][19] = 72,
	[1240][20] = 73,
	[1240][23] = 74,
	[1240][56] = 1278,
	[1250][1] = 56,
	[1250][2] = 57,
	[1250][4] = 58,
	[1250][5] = 59,
	[1250][6] = 60,
	[1250][7] = 61,
	[1250][8] = 1155,
	[1250][10] = 63,
	[1250][11] = 64,
	[1250][12] = 65,
	[1250][13] = 66,
	[1250][14] = 67,
	[1250][15] = 68,
	[1250][16] = 69,
	[1250][17] = 70,
	[1250][18] = 71,
	[1250][19] = 72,
	[1250][20] = 73,
	[1250][23] = 74,
	[1250][61] = 1279,
	[1253][75] = 1280,
	[1255][76] = 1281,
	[1258][47] = 819,
	[1258][48] = 1175,
	[1258][49] = 821,
	[1258][50] = 822,
	[1258][68] = 1282,
	[1261][47] = 819,
	[1261][49] = 821,
	[1261][50] = 1183,
	[1261][69] = 1284,
	[1271][53] = 840,
	[1271][54] = 1206,
	[1271][55] = 842,
	[1271][73] = 1285,
};


const unsigned zebu_lexer[261][256] = {
	[1][9] = 130,
	[1][10] = 130,
	[1][32] = 130,
	[1][33] = 131,
	[1][34] = 132,
	[1][36] = 133,
	[1][37] = 134,
	[1][39] = 135,
	[1][40] = 136,
	[1][43] = 137,
	[1][45] = 138,
	[1][47] = 139,
	[1][48] = 140,
	[1][49] = 141,
	[1][50] = 141,
	[1][51] = 141,
	[1][52] = 141,
	[1][53] = 141,
	[1][54] = 141,
	[1][55] = 141,
	[1][56] = 141,
	[1][57] = 141,
	[1][91] = 142,
	[1][97] = 143,
	[1][98] = 143,
	[1][99] = 143,
	[1][100] = 143,
	[1][101] = 143,
	[1][102] = 143,
	[1][103] = 143,
	[1][104] = 143,
	[1][105] = 143,
	[1][106] = 143,
	[1][107] = 143,
	[1][108] = 143,
	[1][109] = 144,
	[1][110] = 143,
	[1][111] = 143,
	[1][112] = 143,
	[1][113] = 143,
	[1][114] = 143,
	[1][115] = 143,
	[1][116] = 143,
	[1][117] = 143,
	[1][118] = 143,
	[1][119] = 143,
	[1][120] = 143,
	[1][121] = 143,
	[1][122] = 143,
	[1][126] = 145,
	[2][9] = 130,
	[2][10] = 130,
	[2][32] = 130,
	[2][33] = 146,
	[2][37] = 134,
	[2][38] = 147,
	[2][40] = 136,
	[2][42] = 148,
	[2][43] = 137,
	[2][45] = 138,
	[2][46] = 149,
	[2][47] = 150,
	[2][59] = 151,
	[2][60] = 152,
	[2][61] = 153,
	[2][62] = 154,
	[2][63] = 155,
	[2][91] = 142,
	[2][94] = 156,
	[2][104] = 157,
	[2][105] = 158,
	[2][124] = 159,
	[3][9] = 130,
	[3][10] = 130,
	[3][32] = 130,
	[3][33] = 131,
	[3][34] = 132,
	[3][36] = 133,
	[3][39] = 135,
	[3][40] = 136,
	[3][41] = 160,
	[3][43] = 137,
	[3][44] = 161,
	[3][45] = 138,
	[3][47] = 139,
	[3][48] = 140,
	[3][49] = 141,
	[3][50] = 141,
	[3][51] = 141,
	[3][52] = 141,
	[3][53] = 141,
	[3][54] = 141,
	[3][55] = 141,
	[3][56] = 141,
	[3][57] = 141,
	[3][91] = 142,
	[3][97] = 143,
	[3][98] = 143,
	[3][99] = 143,
	[3][100] = 143,
	[3][101] = 143,
	[3][102] = 143,
	[3][103] = 143,
	[3][104] = 143,
	[3][105] = 143,
	[3][106] = 143,
	[3][107] = 143,
	[3][108] = 143,
	[3][109] = 144,
	[3][110] = 143,
	[3][111] = 143,
	[3][112] = 143,
	[3][113] = 143,
	[3][114] = 143,
	[3][115] = 143,
	[3][116] = 143,
	[3][117] = 143,
	[3][118] = 143,
	[3][119] = 143,
	[3][120] = 143,
	[3][121] = 143,
	[3][122] = 143,
	[3][126] = 145,
	[4][9] = 130,
	[4][10] = 130,
	[4][32] = 130,
	[4][33] = 131,
	[4][34] = 132,
	[4][39] = 135,
	[4][40] = 136,
	[4][43] = 137,
	[4][45] = 138,
	[4][47] = 139,
	[4][48] = 140,
	[4][49] = 141,
	[4][50] = 141,
	[4][51] = 141,
	[4][52] = 141,
	[4][53] = 141,
	[4][54] = 141,
	[4][55] = 141,
	[4][56] = 141,
	[4][57] = 141,
	[4][91] = 142,
	[4][97] = 143,
	[4][98] = 143,
	[4][99] = 143,
	[4][100] = 143,
	[4][101] = 143,
	[4][102] = 143,
	[4][103] = 143,
	[4][104] = 143,
	[4][105] = 143,
	[4][106] = 143,
	[4][107] = 143,
	[4][108] = 143,
	[4][109] = 144,
	[4][110] = 143,
	[4][111] = 143,
	[4][112] = 143,
	[4][113] = 143,
	[4][114] = 143,
	[4][115] = 143,
	[4][116] = 143,
	[4][117] = 143,
	[4][118] = 143,
	[4][119] = 143,
	[4][120] = 143,
	[4][121] = 143,
	[4][122] = 143,
	[4][126] = 145,
	[5][9] = 130,
	[5][10] = 130,
	[5][32] = 130,
	[5][33] = 131,
	[5][34] = 132,
	[5][36] = 133,
	[5][39] = 135,
	[5][40] = 136,
	[5][43] = 137,
	[5][44] = 161,
	[5][45] = 138,
	[5][47] = 139,
	[5][48] = 140,
	[5][49] = 141,
	[5][50] = 141,
	[5][51] = 141,
	[5][52] = 141,
	[5][53] = 141,
	[5][54] = 141,
	[5][55] = 141,
	[5][56] = 141,
	[5][57] = 141,
	[5][91] = 142,
	[5][93] = 162,
	[5][97] = 143,
	[5][98] = 143,
	[5][99] = 143,
	[5][100] = 143,
	[5][101] = 143,
	[5][102] = 143,
	[5][103] = 143,
	[5][104] = 143,
	[5][105] = 143,
	[5][106] = 143,
	[5][107] = 143,
	[5][108] = 143,
	[5][109] = 144,
	[5][110] = 143,
	[5][111] = 143,
	[5][112] = 143,
	[5][113] = 143,
	[5][114] = 143,
	[5][115] = 143,
	[5][116] = 143,
	[5][117] = 143,
	[5][118] = 143,
	[5][119] = 143,
	[5][120] = 143,
	[5][121] = 143,
	[5][122] = 143,
	[5][126] = 145,
	[6][9] = 130,
	[6][10] = 130,
	[6][32] = 130,
	[6][33] = 146,
	[6][37] = 134,
	[6][38] = 147,
	[6][40] = 136,
	[6][42] = 148,
	[6][43] = 137,
	[6][45] = 138,
	[6][46] = 149,
	[6][47] = 150,
	[6][58] = 163,
	[6][59] = 151,
	[6][60] = 152,
	[6][61] = 164,
	[6][62] = 154,
	[6][63] = 155,
	[6][91] = 142,
	[6][94] = 156,
	[6][104] = 157,
	[6][105] = 158,
	[6][124] = 159,
	[7][9] = 130,
	[7][10] = 130,
	[7][32] = 130,
	[7][40] = 136,
	[7][47] = 139,
	[8][9] = 130,
	[8][10] = 130,
	[8][32] = 130,
	[8][47] = 139,
	[8][100] = 165,
	[8][101] = 166,
	[8][110] = 167,
	[8][115] = 168,
	[8][117] = 169,
	[8][119] = 170,
	[9][9] = 130,
	[9][10] = 130,
	[9][32] = 130,
	[9][36] = 133,
	[9][40] = 136,
	[9][44] = 161,
	[9][47] = 139,
	[9][58] = 163,
	[9][97] = 143,
	[9][98] = 171,
	[9][99] = 172,
	[9][100] = 143,
	[9][101] = 143,
	[9][102] = 173,
	[9][103] = 143,
	[9][104] = 143,
	[9][105] = 174,
	[9][106] = 143,
	[9][107] = 143,
	[9][108] = 143,
	[9][109] = 143,
	[9][110] = 143,
	[9][111] = 143,
	[9][112] = 143,
	[9][113] = 143,
	[9][114] = 143,
	[9][115] = 143,
	[9][116] = 143,
	[9][117] = 143,
	[9][118] = 143,
	[9][119] = 143,
	[9][120] = 143,
	[9][121] = 143,
	[9][122] = 143,
	[10][9] = 130,
	[10][10] = 130,
	[10][32] = 130,
	[10][33] = 146,
	[10][38] = 147,
	[10][43] = 137,
	[10][45] = 138,
	[10][47] = 139,
	[10][59] = 151,
	[10][60] = 152,
	[10][61] = 153,
	[10][62] = 154,
	[10][63] = 155,
	[10][94] = 156,
	[10][104] = 157,
	[10][105] = 158,
	[10][124] = 159,
	[11][9] = 130,
	[11][10] = 130,
	[11][32] = 130,
	[11][38] = 147,
	[11][47] = 139,
	[11][59] = 151,
	[11][63] = 155,
	[11][94] = 156,
	[11][104] = 157,
	[11][105] = 158,
	[11][124] = 159,
	[12][9] = 130,
	[12][10] = 130,
	[12][32] = 130,
	[12][33] = 131,
	[12][34] = 132,
	[12][36] = 133,
	[12][37] = 134,
	[12][39] = 135,
	[12][40] = 136,
	[12][43] = 137,
	[12][45] = 138,
	[12][47] = 139,
	[12][48] = 140,
	[12][49] = 141,
	[12][50] = 141,
	[12][51] = 141,
	[12][52] = 141,
	[12][53] = 141,
	[12][54] = 141,
	[12][55] = 141,
	[12][56] = 141,
	[12][57] = 141,
	[12][91] = 142,
	[12][97] = 143,
	[12][98] = 143,
	[12][99] = 143,
	[12][100] = 143,
	[12][101] = 143,
	[12][102] = 143,
	[12][103] = 143,
	[12][104] = 143,
	[12][105] = 143,
	[12][106] = 143,
	[12][107] = 143,
	[12][108] = 143,
	[12][109] = 144,
	[12][110] = 143,
	[12][111] = 143,
	[12][112] = 143,
	[12][113] = 143,
	[12][114] = 143,
	[12][115] = 143,
	[12][116] = 143,
	[12][117] = 143,
	[12][118] = 143,
	[12][119] = 143,
	[12][120] = 143,
	[12][121] = 143,
	[12][122] = 143,
	[12][126] = 145,
	[13][9] = 130,
	[13][10] = 130,
	[13][32] = 130,
	[13][47] = 139,
	[13][59] = 151,
	[13][104] = 157,
	[13][105] = 158,
	[14][9] = 130,
	[14][10] = 130,
	[14][32] = 130,
	[14][33] = 146,
	[14][38] = 147,
	[14][47] = 139,
	[14][59] = 151,
	[14][61] = 153,
	[14][63] = 155,
	[14][94] = 156,
	[14][104] = 157,
	[14][105] = 158,
	[14][124] = 159,
	[15][9] = 130,
	[15][10] = 130,
	[15][32] = 130,
	[15][38] = 176,
	[15][47] = 139,
	[15][59] = 151,
	[15][63] = 155,
	[15][94] = 156,
	[15][104] = 157,
	[15][105] = 158,
	[15][124] = 159,
	[16][9] = 130,
	[16][10] = 130,
	[16][32] = 130,
	[16][33] = 146,
	[16][37] = 134,
	[16][38] = 147,
	[16][42] = 148,
	[16][43] = 137,
	[16][45] = 138,
	[16][47] = 150,
	[16][59] = 151,
	[16][60] = 152,
	[16][61] = 153,
	[16][62] = 154,
	[16][63] = 155,
	[16][94] = 156,
	[16][104] = 157,
	[16][105] = 158,
	[16][124] = 159,
	[17][9] = 130,
	[17][10] = 130,
	[17][32] = 130,
	[17][47] = 139,
	[17][59] = 151,
	[18][9] = 130,
	[18][10] = 130,
	[18][32] = 130,
	[18][47] = 139,
	[18][59] = 151,
	[18][105] = 177,
	[19][9] = 130,
	[19][10] = 130,
	[19][32] = 130,
	[19][38] = 176,
	[19][47] = 139,
	[19][59] = 151,
	[19][63] = 155,
	[19][104] = 157,
	[19][105] = 158,
	[19][124] = 159,
	[20][9] = 130,
	[20][10] = 130,
	[20][32] = 130,
	[20][38] = 176,
	[20][47] = 139,
	[20][59] = 151,
	[20][63] = 155,
	[20][104] = 157,
	[20][105] = 158,
	[20][124] = 178,
	[21][9] = 130,
	[21][10] = 130,
	[21][32] = 130,
	[21][47] = 139,
	[21][59] = 151,
	[21][63] = 155,
	[21][104] = 157,
	[21][105] = 158,
	[21][124] = 178,
	[22][9] = 130,
	[22][10] = 130,
	[22][32] = 130,
	[22][33] = 146,
	[22][37] = 134,
	[22][38] = 147,
	[22][42] = 179,
	[22][43] = 137,
	[22][45] = 138,
	[22][47] = 150,
	[22][59] = 151,
	[22][60] = 152,
	[22][61] = 153,
	[22][62] = 154,
	[22][63] = 155,
	[22][94] = 156,
	[22][104] = 157,
	[22][105] = 158,
	[22][124] = 159,
	[23][9] = 130,
	[23][10] = 130,
	[23][32] = 130,
	[23][47] = 139,
	[23][59] = 151,
	[23][105] = 158,
	[24][9] = 130,
	[24][10] = 130,
	[24][32] = 130,
	[24][33] = 146,
	[24][38] = 147,
	[24][47] = 139,
	[24][59] = 151,
	[24][60] = 180,
	[24][61] = 153,
	[24][62] = 181,
	[24][63] = 155,
	[24][94] = 156,
	[24][104] = 157,
	[24][105] = 158,
	[24][124] = 159,
	[25][9] = 130,
	[25][10] = 130,
	[25][32] = 130,
	[25][33] = 146,
	[25][38] = 147,
	[25][47] = 139,
	[25][59] = 151,
	[25][60] = 152,
	[25][61] = 153,
	[25][62] = 154,
	[25][63] = 155,
	[25][94] = 156,
	[25][104] = 157,
	[25][105] = 158,
	[25][124] = 159,
	[26][9] = 130,
	[26][10] = 130,
	[26][32] = 130,
	[26][33] = 146,
	[26][37] = 134,
	[26][38] = 147,
	[26][40] = 136,
	[26][41] = 160,
	[26][42] = 148,
	[26][43] = 137,
	[26][44] = 161,
	[26][45] = 138,
	[26][46] = 149,
	[26][47] = 150,
	[26][60] = 152,
	[26][61] = 153,
	[26][62] = 154,
	[26][63] = 155,
	[26][91] = 142,
	[26][94] = 156,
	[26][104] = 157,
	[26][105] = 158,
	[26][124] = 159,
	[27][9] = 130,
	[27][10] = 130,
	[27][32] = 130,
	[27][33] = 131,
	[27][34] = 132,
	[27][36] = 133,
	[27][39] = 135,
	[27][40] = 136,
	[27][43] = 137,
	[27][45] = 138,
	[27][47] = 139,
	[27][48] = 140,
	[27][49] = 141,
	[27][50] = 141,
	[27][51] = 141,
	[27][52] = 141,
	[27][53] = 141,
	[27][54] = 141,
	[27][55] = 141,
	[27][56] = 141,
	[27][57] = 141,
	[27][91] = 142,
	[27][97] = 143,
	[27][98] = 143,
	[27][99] = 143,
	[27][100] = 143,
	[27][101] = 143,
	[27][102] = 143,
	[27][103] = 143,
	[27][104] = 143,
	[27][105] = 143,
	[27][106] = 143,
	[27][107] = 143,
	[27][108] = 143,
	[27][109] = 144,
	[27][110] = 143,
	[27][111] = 143,
	[27][112] = 143,
	[27][113] = 143,
	[27][114] = 143,
	[27][115] = 143,
	[27][116] = 143,
	[27][117] = 143,
	[27][118] = 143,
	[27][119] = 143,
	[27][120] = 143,
	[27][121] = 143,
	[27][122] = 143,
	[27][126] = 145,
	[28][9] = 130,
	[28][10] = 130,
	[28][32] = 130,
	[28][33] = 146,
	[28][38] = 147,
	[28][41] = 160,
	[28][43] = 137,
	[28][44] = 161,
	[28][45] = 138,
	[28][47] = 139,
	[28][60] = 152,
	[28][61] = 153,
	[28][62] = 154,
	[28][63] = 155,
	[28][94] = 156,
	[28][104] = 157,
	[28][105] = 158,
	[28][124] = 159,
	[29][9] = 130,
	[29][10] = 130,
	[29][32] = 130,
	[29][38] = 147,
	[29][41] = 160,
	[29][44] = 161,
	[29][47] = 139,
	[29][63] = 155,
	[29][94] = 156,
	[29][104] = 157,
	[29][105] = 158,
	[29][124] = 159,
	[30][9] = 130,
	[30][10] = 130,
	[30][32] = 130,
	[30][41] = 160,
	[30][44] = 161,
	[30][47] = 139,
	[30][104] = 157,
	[30][105] = 158,
	[31][9] = 130,
	[31][10] = 130,
	[31][32] = 130,
	[31][33] = 146,
	[31][38] = 147,
	[31][41] = 160,
	[31][44] = 161,
	[31][47] = 139,
	[31][61] = 153,
	[31][63] = 155,
	[31][94] = 156,
	[31][104] = 157,
	[31][105] = 158,
	[31][124] = 159,
	[32][9] = 130,
	[32][10] = 130,
	[32][32] = 130,
	[32][38] = 176,
	[32][41] = 160,
	[32][44] = 161,
	[32][47] = 139,
	[32][63] = 155,
	[32][94] = 156,
	[32][104] = 157,
	[32][105] = 158,
	[32][124] = 159,
	[33][9] = 130,
	[33][10] = 130,
	[33][32] = 130,
	[33][33] = 146,
	[33][37] = 134,
	[33][38] = 147,
	[33][41] = 160,
	[33][42] = 148,
	[33][43] = 137,
	[33][44] = 161,
	[33][45] = 138,
	[33][47] = 150,
	[33][60] = 152,
	[33][61] = 153,
	[33][62] = 154,
	[33][63] = 155,
	[33][94] = 156,
	[33][104] = 157,
	[33][105] = 158,
	[33][124] = 159,
	[34][9] = 130,
	[34][10] = 130,
	[34][32] = 130,
	[34][41] = 160,
	[34][44] = 161,
	[34][47] = 139,
	[35][9] = 130,
	[35][10] = 130,
	[35][32] = 130,
	[35][41] = 160,
	[35][44] = 161,
	[35][47] = 139,
	[35][105] = 177,
	[36][9] = 130,
	[36][10] = 130,
	[36][32] = 130,
	[36][38] = 176,
	[36][41] = 160,
	[36][44] = 161,
	[36][47] = 139,
	[36][63] = 155,
	[36][104] = 157,
	[36][105] = 158,
	[36][124] = 159,
	[37][9] = 130,
	[37][10] = 130,
	[37][32] = 130,
	[37][38] = 176,
	[37][41] = 160,
	[37][44] = 161,
	[37][47] = 139,
	[37][63] = 155,
	[37][104] = 157,
	[37][105] = 158,
	[37][124] = 178,
	[38][9] = 130,
	[38][10] = 130,
	[38][32] = 130,
	[38][41] = 160,
	[38][44] = 161,
	[38][47] = 139,
	[38][63] = 155,
	[38][104] = 157,
	[38][105] = 158,
	[38][124] = 178,
	[39][9] = 130,
	[39][10] = 130,
	[39][32] = 130,
	[39][33] = 146,
	[39][37] = 134,
	[39][38] = 147,
	[39][41] = 160,
	[39][42] = 179,
	[39][43] = 137,
	[39][44] = 161,
	[39][45] = 138,
	[39][47] = 150,
	[39][60] = 152,
	[39][61] = 153,
	[39][62] = 154,
	[39][63] = 155,
	[39][94] = 156,
	[39][104] = 157,
	[39][105] = 158,
	[39][124] = 159,
	[40][9] = 130,
	[40][10] = 130,
	[40][32] = 130,
	[40][41] = 160,
	[40][44] = 161,
	[40][47] = 139,
	[40][105] = 158,
	[41][9] = 130,
	[41][10] = 130,
	[41][32] = 130,
	[41][33] = 146,
	[41][38] = 147,
	[41][41] = 160,
	[41][44] = 161,
	[41][47] = 139,
	[41][60] = 180,
	[41][61] = 153,
	[41][62] = 181,
	[41][63] = 155,
	[41][94] = 156,
	[41][104] = 157,
	[41][105] = 158,
	[41][124] = 159,
	[42][9] = 130,
	[42][10] = 130,
	[42][32] = 130,
	[42][33] = 146,
	[42][38] = 147,
	[42][41] = 160,
	[42][44] = 161,
	[42][47] = 139,
	[42][60] = 152,
	[42][61] = 153,
	[42][62] = 154,
	[42][63] = 155,
	[42][94] = 156,
	[42][104] = 157,
	[42][105] = 158,
	[42][124] = 159,
	[43][9] = 130,
	[43][10] = 130,
	[43][32] = 130,
	[43][33] = 146,
	[43][37] = 134,
	[43][38] = 147,
	[43][40] = 136,
	[43][42] = 148,
	[43][43] = 137,
	[43][44] = 161,
	[43][45] = 138,
	[43][46] = 149,
	[43][47] = 150,
	[43][60] = 152,
	[43][61] = 153,
	[43][62] = 154,
	[43][63] = 155,
	[43][91] = 142,
	[43][93] = 162,
	[43][94] = 156,
	[43][104] = 157,
	[43][105] = 158,
	[43][124] = 159,
	[44][9] = 130,
	[44][10] = 130,
	[44][32] = 130,
	[44][33] = 146,
	[44][38] = 147,
	[44][43] = 137,
	[44][44] = 161,
	[44][45] = 138,
	[44][47] = 139,
	[44][60] = 152,
	[44][61] = 153,
	[44][62] = 154,
	[44][63] = 155,
	[44][93] = 162,
	[44][94] = 156,
	[44][104] = 157,
	[44][105] = 158,
	[44][124] = 159,
	[45][9] = 130,
	[45][10] = 130,
	[45][32] = 130,
	[45][38] = 147,
	[45][44] = 161,
	[45][47] = 139,
	[45][63] = 155,
	[45][93] = 162,
	[45][94] = 156,
	[45][104] = 157,
	[45][105] = 158,
	[45][124] = 159,
	[46][9] = 130,
	[46][10] = 130,
	[46][32] = 130,
	[46][44] = 161,
	[46][47] = 139,
	[46][93] = 162,
	[46][104] = 157,
	[46][105] = 158,
	[47][9] = 130,
	[47][10] = 130,
	[47][32] = 130,
	[47][33] = 146,
	[47][38] = 147,
	[47][44] = 161,
	[47][47] = 139,
	[47][61] = 153,
	[47][63] = 155,
	[47][93] = 162,
	[47][94] = 156,
	[47][104] = 157,
	[47][105] = 158,
	[47][124] = 159,
	[48][9] = 130,
	[48][10] = 130,
	[48][32] = 130,
	[48][38] = 176,
	[48][44] = 161,
	[48][47] = 139,
	[48][63] = 155,
	[48][93] = 162,
	[48][94] = 156,
	[48][104] = 157,
	[48][105] = 158,
	[48][124] = 159,
	[49][9] = 130,
	[49][10] = 130,
	[49][32] = 130,
	[49][33] = 146,
	[49][37] = 134,
	[49][38] = 147,
	[49][42] = 148,
	[49][43] = 137,
	[49][44] = 161,
	[49][45] = 138,
	[49][47] = 150,
	[49][60] = 152,
	[49][61] = 153,
	[49][62] = 154,
	[49][63] = 155,
	[49][93] = 162,
	[49][94] = 156,
	[49][104] = 157,
	[49][105] = 158,
	[49][124] = 159,
	[50][9] = 130,
	[50][10] = 130,
	[50][32] = 130,
	[50][44] = 161,
	[50][47] = 139,
	[50][93] = 162,
	[51][9] = 130,
	[51][10] = 130,
	[51][32] = 130,
	[51][44] = 161,
	[51][47] = 139,
	[51][93] = 162,
	[51][105] = 177,
	[52][9] = 130,
	[52][10] = 130,
	[52][32] = 130,
	[52][38] = 176,
	[52][44] = 161,
	[52][47] = 139,
	[52][63] = 155,
	[52][93] = 162,
	[52][104] = 157,
	[52][105] = 158,
	[52][124] = 159,
	[53][9] = 130,
	[53][10] = 130,
	[53][32] = 130,
	[53][38] = 176,
	[53][44] = 161,
	[53][47] = 139,
	[53][63] = 155,
	[53][93] = 162,
	[53][104] = 157,
	[53][105] = 158,
	[53][124] = 178,
	[54][9] = 130,
	[54][10] = 130,
	[54][32] = 130,
	[54][44] = 161,
	[54][47] = 139,
	[54][63] = 155,
	[54][93] = 162,
	[54][104] = 157,
	[54][105] = 158,
	[54][124] = 178,
	[55][9] = 130,
	[55][10] = 130,
	[55][32] = 130,
	[55][33] = 146,
	[55][37] = 134,
	[55][38] = 147,
	[55][42] = 179,
	[55][43] = 137,
	[55][44] = 161,
	[55][45] = 138,
	[55][47] = 150,
	[55][60] = 152,
	[55][61] = 153,
	[55][62] = 154,
	[55][63] = 155,
	[55][93] = 162,
	[55][94] = 156,
	[55][104] = 157,
	[55][105] = 158,
	[55][124] = 159,
	[56][9] = 130,
	[56][10] = 130,
	[56][32] = 130,
	[56][44] = 161,
	[56][47] = 139,
	[56][93] = 162,
	[56][105] = 158,
	[57][9] = 130,
	[57][10] = 130,
	[57][32] = 130,
	[57][33] = 146,
	[57][38] = 147,
	[57][44] = 161,
	[57][47] = 139,
	[57][60] = 180,
	[57][61] = 153,
	[57][62] = 181,
	[57][63] = 155,
	[57][93] = 162,
	[57][94] = 156,
	[57][104] = 157,
	[57][105] = 158,
	[57][124] = 159,
	[58][9] = 130,
	[58][10] = 130,
	[58][32] = 130,
	[58][33] = 146,
	[58][38] = 147,
	[58][44] = 161,
	[58][47] = 139,
	[58][60] = 152,
	[58][61] = 153,
	[58][62] = 154,
	[58][63] = 155,
	[58][93] = 162,
	[58][94] = 156,
	[58][104] = 157,
	[58][105] = 158,
	[58][124] = 159,
	[59][9] = 130,
	[59][10] = 130,
	[59][32] = 130,
	[59][34] = 132,
	[59][39] = 135,
	[59][40] = 136,
	[59][47] = 150,
	[59][48] = 182,
	[59][49] = 183,
	[59][50] = 183,
	[59][51] = 183,
	[59][52] = 183,
	[59][53] = 183,
	[59][54] = 183,
	[59][55] = 183,
	[59][56] = 183,
	[59][57] = 183,
	[59][91] = 142,
	[59][97] = 143,
	[59][98] = 143,
	[59][99] = 143,
	[59][100] = 143,
	[59][101] = 143,
	[59][102] = 143,
	[59][103] = 143,
	[59][104] = 143,
	[59][105] = 143,
	[59][106] = 143,
	[59][107] = 143,
	[59][108] = 143,
	[59][109] = 143,
	[59][110] = 143,
	[59][111] = 143,
	[59][112] = 143,
	[59][113] = 143,
	[59][114] = 143,
	[59][115] = 143,
	[59][116] = 143,
	[59][117] = 143,
	[59][118] = 143,
	[59][119] = 143,
	[59][120] = 143,
	[59][121] = 143,
	[59][122] = 143,
	[60][9] = 130,
	[60][10] = 130,
	[60][32] = 130,
	[60][34] = 132,
	[60][47] = 139,
	[61][9] = 130,
	[61][10] = 130,
	[61][32] = 130,
	[61][47] = 139,
	[61][58] = 163,
	[62][9] = 130,
	[62][10] = 130,
	[62][32] = 130,
	[62][36] = 133,
	[62][40] = 136,
	[62][41] = 160,
	[62][44] = 161,
	[62][47] = 139,
	[62][97] = 143,
	[62][98] = 171,
	[62][99] = 172,
	[62][100] = 143,
	[62][101] = 143,
	[62][102] = 173,
	[62][103] = 143,
	[62][104] = 143,
	[62][105] = 174,
	[62][106] = 143,
	[62][107] = 143,
	[62][108] = 143,
	[62][109] = 143,
	[62][110] = 143,
	[62][111] = 143,
	[62][112] = 143,
	[62][113] = 143,
	[62][114] = 143,
	[62][115] = 143,
	[62][116] = 143,
	[62][117] = 143,
	[62][118] = 143,
	[62][119] = 143,
	[62][120] = 143,
	[62][121] = 143,
	[62][122] = 143,
	[63][9] = 130,
	[63][10] = 130,
	[63][32] = 130,
	[63][36] = 133,
	[63][40] = 136,
	[63][47] = 139,
	[63][97] = 143,
	[63][98] = 171,
	[63][99] = 172,
	[63][100] = 143,
	[63][101] = 143,
	[63][102] = 173,
	[63][103] = 143,
	[63][104] = 143,
	[63][105] = 174,
	[63][106] = 143,
	[63][107] = 143,
	[63][108] = 143,
	[63][109] = 143,
	[63][110] = 143,
	[63][111] = 143,
	[63][112] = 143,
	[63][113] = 143,
	[63][114] = 143,
	[63][115] = 143,
	[63][116] = 143,
	[63][117] = 143,
	[63][118] = 143,
	[63][119] = 143,
	[63][120] = 143,
	[63][121] = 143,
	[63][122] = 143,
	[64][9] = 130,
	[64][10] = 130,
	[64][32] = 130,
	[64][47] = 139,
	[64][91] = 184,
	[64][97] = 143,
	[64][98] = 143,
	[64][99] = 143,
	[64][100] = 143,
	[64][101] = 143,
	[64][102] = 143,
	[64][103] = 143,
	[64][104] = 143,
	[64][105] = 143,
	[64][106] = 143,
	[64][107] = 143,
	[64][108] = 143,
	[64][109] = 143,
	[64][110] = 143,
	[64][111] = 143,
	[64][112] = 143,
	[64][113] = 143,
	[64][114] = 143,
	[64][115] = 143,
	[64][116] = 143,
	[64][117] = 143,
	[64][118] = 143,
	[64][119] = 143,
	[64][120] = 143,
	[64][121] = 143,
	[64][122] = 143,
	[65][9] = 130,
	[65][10] = 130,
	[65][32] = 130,
	[65][47] = 139,
	[65][97] = 143,
	[65][98] = 143,
	[65][99] = 143,
	[65][100] = 143,
	[65][101] = 143,
	[65][102] = 143,
	[65][103] = 143,
	[65][104] = 143,
	[65][105] = 143,
	[65][106] = 143,
	[65][107] = 143,
	[65][108] = 143,
	[65][109] = 143,
	[65][110] = 143,
	[65][111] = 143,
	[65][112] = 143,
	[65][113] = 143,
	[65][114] = 143,
	[65][115] = 143,
	[65][116] = 143,
	[65][117] = 143,
	[65][118] = 143,
	[65][119] = 143,
	[65][120] = 143,
	[65][121] = 143,
	[65][122] = 143,
	[66][9] = 130,
	[66][10] = 130,
	[66][32] = 130,
	[66][47] = 139,
	[67][9] = 130,
	[67][10] = 130,
	[67][32] = 130,
	[67][34] = 132,
	[67][35] = 185,
	[67][39] = 135,
	[67][40] = 136,
	[67][42] = 179,
	[67][43] = 137,
	[67][47] = 150,
	[67][48] = 182,
	[67][49] = 183,
	[67][50] = 183,
	[67][51] = 183,
	[67][52] = 183,
	[67][53] = 183,
	[67][54] = 183,
	[67][55] = 183,
	[67][56] = 183,
	[67][57] = 183,
	[67][59] = 151,
	[67][63] = 155,
	[67][91] = 142,
	[67][97] = 143,
	[67][98] = 143,
	[67][99] = 143,
	[67][100] = 143,
	[67][101] = 143,
	[67][102] = 143,
	[67][103] = 143,
	[67][104] = 143,
	[67][105] = 143,
	[67][106] = 143,
	[67][107] = 143,
	[67][108] = 143,
	[67][109] = 143,
	[67][110] = 143,
	[67][111] = 143,
	[67][112] = 143,
	[67][113] = 143,
	[67][114] = 143,
	[67][115] = 143,
	[67][116] = 143,
	[67][117] = 143,
	[67][118] = 143,
	[67][119] = 143,
	[67][120] = 143,
	[67][121] = 143,
	[67][122] = 143,
	[67][124] = 186,
	[68][9] = 130,
	[68][10] = 130,
	[68][32] = 130,
	[68][33] = 131,
	[68][39] = 135,
	[68][40] = 136,
	[68][47] = 139,
	[68][48] = 182,
	[68][49] = 183,
	[68][50] = 183,
	[68][51] = 183,
	[68][52] = 183,
	[68][53] = 183,
	[68][54] = 183,
	[68][55] = 183,
	[68][56] = 183,
	[68][57] = 183,
	[69][9] = 130,
	[69][10] = 130,
	[69][32] = 130,
	[69][34] = 132,
	[69][39] = 135,
	[69][40] = 136,
	[69][47] = 139,
	[69][48] = 182,
	[69][49] = 183,
	[69][50] = 183,
	[69][51] = 183,
	[69][52] = 183,
	[69][53] = 183,
	[69][54] = 183,
	[69][55] = 183,
	[69][56] = 183,
	[69][57] = 183,
	[69][91] = 142,
	[70][9] = 130,
	[70][10] = 130,
	[70][32] = 130,
	[70][34] = 132,
	[70][39] = 135,
	[70][40] = 136,
	[70][42] = 179,
	[70][43] = 137,
	[70][47] = 150,
	[70][48] = 182,
	[70][49] = 183,
	[70][50] = 183,
	[70][51] = 183,
	[70][52] = 183,
	[70][53] = 183,
	[70][54] = 183,
	[70][55] = 183,
	[70][56] = 183,
	[70][57] = 183,
	[70][59] = 151,
	[70][63] = 155,
	[70][91] = 142,
	[70][97] = 143,
	[70][98] = 143,
	[70][99] = 143,
	[70][100] = 143,
	[70][101] = 143,
	[70][102] = 143,
	[70][103] = 143,
	[70][104] = 143,
	[70][105] = 143,
	[70][106] = 143,
	[70][107] = 143,
	[70][108] = 143,
	[70][109] = 143,
	[70][110] = 143,
	[70][111] = 143,
	[70][112] = 143,
	[70][113] = 143,
	[70][114] = 143,
	[70][115] = 143,
	[70][116] = 143,
	[70][117] = 143,
	[70][118] = 143,
	[70][119] = 143,
	[70][120] = 143,
	[70][121] = 143,
	[70][122] = 143,
	[70][124] = 186,
	[71][9] = 130,
	[71][10] = 130,
	[71][32] = 130,
	[71][47] = 139,
	[71][59] = 151,
	[71][124] = 186,
	[72][9] = 130,
	[72][10] = 130,
	[72][32] = 130,
	[72][34] = 132,
	[72][39] = 135,
	[72][40] = 136,
	[72][47] = 150,
	[72][48] = 182,
	[72][49] = 183,
	[72][50] = 183,
	[72][51] = 183,
	[72][52] = 183,
	[72][53] = 183,
	[72][54] = 183,
	[72][55] = 183,
	[72][56] = 183,
	[72][57] = 183,
	[72][59] = 151,
	[72][91] = 142,
	[72][97] = 143,
	[72][98] = 143,
	[72][99] = 143,
	[72][100] = 143,
	[72][101] = 143,
	[72][102] = 143,
	[72][103] = 143,
	[72][104] = 143,
	[72][105] = 143,
	[72][106] = 143,
	[72][107] = 143,
	[72][108] = 143,
	[72][109] = 143,
	[72][110] = 143,
	[72][111] = 143,
	[72][112] = 143,
	[72][113] = 143,
	[72][114] = 143,
	[72][115] = 143,
	[72][116] = 143,
	[72][117] = 143,
	[72][118] = 143,
	[72][119] = 143,
	[72][120] = 143,
	[72][121] = 143,
	[72][122] = 143,
	[72][124] = 186,
	[73][9] = 130,
	[73][10] = 130,
	[73][32] = 130,
	[73][41] = 160,
	[73][44] = 161,
	[73][47] = 139,
	[73][91] = 184,
	[74][9] = 130,
	[74][10] = 130,
	[74][32] = 130,
	[74][44] = 161,
	[74][47] = 139,
	[74][58] = 163,
	[74][91] = 184,
	[74][97] = 143,
	[74][98] = 143,
	[74][99] = 143,
	[74][100] = 143,
	[74][101] = 143,
	[74][102] = 143,
	[74][103] = 143,
	[74][104] = 143,
	[74][105] = 143,
	[74][106] = 143,
	[74][107] = 143,
	[74][108] = 143,
	[74][109] = 143,
	[74][110] = 143,
	[74][111] = 143,
	[74][112] = 143,
	[74][113] = 143,
	[74][114] = 143,
	[74][115] = 143,
	[74][116] = 143,
	[74][117] = 143,
	[74][118] = 143,
	[74][119] = 143,
	[74][120] = 143,
	[74][121] = 143,
	[74][122] = 143,
	[75][9] = 130,
	[75][10] = 130,
	[75][32] = 130,
	[75][44] = 161,
	[75][47] = 139,
	[75][58] = 163,
	[76][9] = 130,
	[76][10] = 130,
	[76][32] = 130,
	[76][44] = 161,
	[76][47] = 139,
	[76][58] = 163,
	[76][91] = 184,
	[77][9] = 130,
	[77][10] = 130,
	[77][32] = 130,
	[77][33] = 146,
	[77][37] = 134,
	[77][38] = 147,
	[77][40] = 136,
	[77][42] = 148,
	[77][43] = 137,
	[77][45] = 138,
	[77][46] = 149,
	[77][47] = 150,
	[77][58] = 163,
	[77][60] = 152,
	[77][61] = 153,
	[77][62] = 154,
	[77][63] = 155,
	[77][91] = 142,
	[77][94] = 156,
	[77][104] = 157,
	[77][105] = 158,
	[77][124] = 159,
	[78][9] = 130,
	[78][10] = 130,
	[78][32] = 130,
	[78][33] = 146,
	[78][38] = 147,
	[78][43] = 137,
	[78][45] = 138,
	[78][47] = 139,
	[78][58] = 163,
	[78][60] = 152,
	[78][61] = 153,
	[78][62] = 154,
	[78][63] = 155,
	[78][94] = 156,
	[78][104] = 157,
	[78][105] = 158,
	[78][124] = 159,
	[79][9] = 130,
	[79][10] = 130,
	[79][32] = 130,
	[79][38] = 147,
	[79][47] = 139,
	[79][58] = 163,
	[79][63] = 155,
	[79][94] = 156,
	[79][104] = 157,
	[79][105] = 158,
	[79][124] = 159,
	[80][9] = 130,
	[80][10] = 130,
	[80][32] = 130,
	[80][47] = 139,
	[80][58] = 163,
	[80][104] = 157,
	[80][105] = 158,
	[81][9] = 130,
	[81][10] = 130,
	[81][32] = 130,
	[81][33] = 146,
	[81][38] = 147,
	[81][47] = 139,
	[81][58] = 163,
	[81][61] = 153,
	[81][63] = 155,
	[81][94] = 156,
	[81][104] = 157,
	[81][105] = 158,
	[81][124] = 159,
	[82][9] = 130,
	[82][10] = 130,
	[82][32] = 130,
	[82][38] = 176,
	[82][47] = 139,
	[82][58] = 163,
	[82][63] = 155,
	[82][94] = 156,
	[82][104] = 157,
	[82][105] = 158,
	[82][124] = 159,
	[83][9] = 130,
	[83][10] = 130,
	[83][32] = 130,
	[83][33] = 146,
	[83][37] = 134,
	[83][38] = 147,
	[83][42] = 148,
	[83][43] = 137,
	[83][45] = 138,
	[83][47] = 150,
	[83][58] = 163,
	[83][60] = 152,
	[83][61] = 153,
	[83][62] = 154,
	[83][63] = 155,
	[83][94] = 156,
	[83][104] = 157,
	[83][105] = 158,
	[83][124] = 159,
	[84][9] = 130,
	[84][10] = 130,
	[84][32] = 130,
	[84][47] = 139,
	[84][58] = 163,
	[84][105] = 177,
	[85][9] = 130,
	[85][10] = 130,
	[85][32] = 130,
	[85][38] = 176,
	[85][47] = 139,
	[85][58] = 163,
	[85][63] = 155,
	[85][104] = 157,
	[85][105] = 158,
	[85][124] = 159,
	[86][9] = 130,
	[86][10] = 130,
	[86][32] = 130,
	[86][38] = 176,
	[86][47] = 139,
	[86][58] = 163,
	[86][63] = 155,
	[86][104] = 157,
	[86][105] = 158,
	[86][124] = 178,
	[87][9] = 130,
	[87][10] = 130,
	[87][32] = 130,
	[87][47] = 139,
	[87][58] = 163,
	[87][63] = 155,
	[87][104] = 157,
	[87][105] = 158,
	[87][124] = 178,
	[88][9] = 130,
	[88][10] = 130,
	[88][32] = 130,
	[88][33] = 146,
	[88][37] = 134,
	[88][38] = 147,
	[88][42] = 179,
	[88][43] = 137,
	[88][45] = 138,
	[88][47] = 150,
	[88][58] = 163,
	[88][60] = 152,
	[88][61] = 153,
	[88][62] = 154,
	[88][63] = 155,
	[88][94] = 156,
	[88][104] = 157,
	[88][105] = 158,
	[88][124] = 159,
	[89][9] = 130,
	[89][10] = 130,
	[89][32] = 130,
	[89][47] = 139,
	[89][58] = 163,
	[89][105] = 158,
	[90][9] = 130,
	[90][10] = 130,
	[90][32] = 130,
	[90][33] = 146,
	[90][38] = 147,
	[90][47] = 139,
	[90][58] = 163,
	[90][60] = 180,
	[90][61] = 153,
	[90][62] = 181,
	[90][63] = 155,
	[90][94] = 156,
	[90][104] = 157,
	[90][105] = 158,
	[90][124] = 159,
	[91][9] = 130,
	[91][10] = 130,
	[91][32] = 130,
	[91][33] = 146,
	[91][38] = 147,
	[91][47] = 139,
	[91][58] = 163,
	[91][60] = 152,
	[91][61] = 153,
	[91][62] = 154,
	[91][63] = 155,
	[91][94] = 156,
	[91][104] = 157,
	[91][105] = 158,
	[91][124] = 159,
	[92][9] = 130,
	[92][10] = 130,
	[92][32] = 130,
	[92][33] = 146,
	[92][37] = 134,
	[92][38] = 147,
	[92][40] = 136,
	[92][42] = 148,
	[92][43] = 137,
	[92][45] = 138,
	[92][46] = 149,
	[92][47] = 150,
	[92][60] = 152,
	[92][61] = 153,
	[92][62] = 154,
	[92][63] = 155,
	[92][91] = 142,
	[92][93] = 162,
	[92][94] = 156,
	[92][104] = 157,
	[92][105] = 158,
	[92][124] = 159,
	[93][9] = 130,
	[93][10] = 130,
	[93][32] = 130,
	[93][33] = 146,
	[93][38] = 147,
	[93][43] = 137,
	[93][45] = 138,
	[93][47] = 139,
	[93][60] = 152,
	[93][61] = 153,
	[93][62] = 154,
	[93][63] = 155,
	[93][93] = 162,
	[93][94] = 156,
	[93][104] = 157,
	[93][105] = 158,
	[93][124] = 159,
	[94][9] = 130,
	[94][10] = 130,
	[94][32] = 130,
	[94][38] = 147,
	[94][47] = 139,
	[94][63] = 155,
	[94][93] = 162,
	[94][94] = 156,
	[94][104] = 157,
	[94][105] = 158,
	[94][124] = 159,
	[95][9] = 130,
	[95][10] = 130,
	[95][32] = 130,
	[95][47] = 139,
	[95][93] = 162,
	[95][104] = 157,
	[95][105] = 158,
	[96][9] = 130,
	[96][10] = 130,
	[96][32] = 130,
	[96][33] = 146,
	[96][38] = 147,
	[96][47] = 139,
	[96][61] = 153,
	[96][63] = 155,
	[96][93] = 162,
	[96][94] = 156,
	[96][104] = 157,
	[96][105] = 158,
	[96][124] = 159,
	[97][9] = 130,
	[97][10] = 130,
	[97][32] = 130,
	[97][38] = 176,
	[97][47] = 139,
	[97][63] = 155,
	[97][93] = 162,
	[97][94] = 156,
	[97][104] = 157,
	[97][105] = 158,
	[97][124] = 159,
	[98][9] = 130,
	[98][10] = 130,
	[98][32] = 130,
	[98][33] = 146,
	[98][37] = 134,
	[98][38] = 147,
	[98][42] = 148,
	[98][43] = 137,
	[98][45] = 138,
	[98][47] = 150,
	[98][60] = 152,
	[98][61] = 153,
	[98][62] = 154,
	[98][63] = 155,
	[98][93] = 162,
	[98][94] = 156,
	[98][104] = 157,
	[98][105] = 158,
	[98][124] = 159,
	[99][9] = 130,
	[99][10] = 130,
	[99][32] = 130,
	[99][47] = 139,
	[99][93] = 162,
	[100][9] = 130,
	[100][10] = 130,
	[100][32] = 130,
	[100][47] = 139,
	[100][93] = 162,
	[100][105] = 177,
	[101][9] = 130,
	[101][10] = 130,
	[101][32] = 130,
	[101][38] = 176,
	[101][47] = 139,
	[101][63] = 155,
	[101][93] = 162,
	[101][104] = 157,
	[101][105] = 158,
	[101][124] = 159,
	[102][9] = 130,
	[102][10] = 130,
	[102][32] = 130,
	[102][38] = 176,
	[102][47] = 139,
	[102][63] = 155,
	[102][93] = 162,
	[102][104] = 157,
	[102][105] = 158,
	[102][124] = 178,
	[103][9] = 130,
	[103][10] = 130,
	[103][32] = 130,
	[103][47] = 139,
	[103][63] = 155,
	[103][93] = 162,
	[103][104] = 157,
	[103][105] = 158,
	[103][124] = 178,
	[104][9] = 130,
	[104][10] = 130,
	[104][32] = 130,
	[104][33] = 146,
	[104][37] = 134,
	[104][38] = 147,
	[104][42] = 179,
	[104][43] = 137,
	[104][45] = 138,
	[104][47] = 150,
	[104][60] = 152,
	[104][61] = 153,
	[104][62] = 154,
	[104][63] = 155,
	[104][93] = 162,
	[104][94] = 156,
	[104][104] = 157,
	[104][105] = 158,
	[104][124] = 159,
	[105][9] = 130,
	[105][10] = 130,
	[105][32] = 130,
	[105][47] = 139,
	[105][93] = 162,
	[105][105] = 158,
	[106][9] = 130,
	[106][10] = 130,
	[106][32] = 130,
	[106][33] = 146,
	[106][38] = 147,
	[106][47] = 139,
	[106][60] = 180,
	[106][61] = 153,
	[106][62] = 181,
	[106][63] = 155,
	[106][93] = 162,
	[106][94] = 156,
	[106][104] = 157,
	[106][105] = 158,
	[106][124] = 159,
	[107][9] = 130,
	[107][10] = 130,
	[107][32] = 130,
	[107][33] = 146,
	[107][38] = 147,
	[107][47] = 139,
	[107][60] = 152,
	[107][61] = 153,
	[107][62] = 154,
	[107][63] = 155,
	[107][93] = 162,
	[107][94] = 156,
	[107][104] = 157,
	[107][105] = 158,
	[107][124] = 159,
	[108][9] = 130,
	[108][10] = 130,
	[108][32] = 130,
	[108][34] = 132,
	[108][35] = 185,
	[108][39] = 135,
	[108][40] = 136,
	[108][41] = 160,
	[108][42] = 179,
	[108][43] = 137,
	[108][47] = 150,
	[108][48] = 182,
	[108][49] = 183,
	[108][50] = 183,
	[108][51] = 183,
	[108][52] = 183,
	[108][53] = 183,
	[108][54] = 183,
	[108][55] = 183,
	[108][56] = 183,
	[108][57] = 183,
	[108][63] = 155,
	[108][91] = 142,
	[108][97] = 143,
	[108][98] = 143,
	[108][99] = 143,
	[108][100] = 143,
	[108][101] = 143,
	[108][102] = 143,
	[108][103] = 143,
	[108][104] = 143,
	[108][105] = 143,
	[108][106] = 143,
	[108][107] = 143,
	[108][108] = 143,
	[108][109] = 143,
	[108][110] = 143,
	[108][111] = 143,
	[108][112] = 143,
	[108][113] = 143,
	[108][114] = 143,
	[108][115] = 143,
	[108][116] = 143,
	[108][117] = 143,
	[108][118] = 143,
	[108][119] = 143,
	[108][120] = 143,
	[108][121] = 143,
	[108][122] = 143,
	[108][124] = 186,
	[109][9] = 130,
	[109][10] = 130,
	[109][32] = 130,
	[109][41] = 160,
	[109][47] = 139,
	[110][9] = 130,
	[110][10] = 130,
	[110][32] = 130,
	[110][34] = 132,
	[110][39] = 135,
	[110][40] = 136,
	[110][41] = 160,
	[110][42] = 179,
	[110][43] = 137,
	[110][47] = 150,
	[110][48] = 182,
	[110][49] = 183,
	[110][50] = 183,
	[110][51] = 183,
	[110][52] = 183,
	[110][53] = 183,
	[110][54] = 183,
	[110][55] = 183,
	[110][56] = 183,
	[110][57] = 183,
	[110][63] = 155,
	[110][91] = 142,
	[110][97] = 143,
	[110][98] = 143,
	[110][99] = 143,
	[110][100] = 143,
	[110][101] = 143,
	[110][102] = 143,
	[110][103] = 143,
	[110][104] = 143,
	[110][105] = 143,
	[110][106] = 143,
	[110][107] = 143,
	[110][108] = 143,
	[110][109] = 143,
	[110][110] = 143,
	[110][111] = 143,
	[110][112] = 143,
	[110][113] = 143,
	[110][114] = 143,
	[110][115] = 143,
	[110][116] = 143,
	[110][117] = 143,
	[110][118] = 143,
	[110][119] = 143,
	[110][120] = 143,
	[110][121] = 143,
	[110][122] = 143,
	[110][124] = 186,
	[111][9] = 130,
	[111][10] = 130,
	[111][32] = 130,
	[111][41] = 160,
	[111][47] = 139,
	[111][124] = 186,
	[112][9] = 130,
	[112][10] = 130,
	[112][32] = 130,
	[112][34] = 132,
	[112][39] = 135,
	[112][40] = 136,
	[112][41] = 160,
	[112][47] = 150,
	[112][48] = 182,
	[112][49] = 183,
	[112][50] = 183,
	[112][51] = 183,
	[112][52] = 183,
	[112][53] = 183,
	[112][54] = 183,
	[112][55] = 183,
	[112][56] = 183,
	[112][57] = 183,
	[112][91] = 142,
	[112][97] = 143,
	[112][98] = 143,
	[112][99] = 143,
	[112][100] = 143,
	[112][101] = 143,
	[112][102] = 143,
	[112][103] = 143,
	[112][104] = 143,
	[112][105] = 143,
	[112][106] = 143,
	[112][107] = 143,
	[112][108] = 143,
	[112][109] = 143,
	[112][110] = 143,
	[112][111] = 143,
	[112][112] = 143,
	[112][113] = 143,
	[112][114] = 143,
	[112][115] = 143,
	[112][116] = 143,
	[112][117] = 143,
	[112][118] = 143,
	[112][119] = 143,
	[112][120] = 143,
	[112][121] = 143,
	[112][122] = 143,
	[112][124] = 186,
	[113][9] = 130,
	[113][10] = 130,
	[113][32] = 130,
	[113][33] = 131,
	[113][38] = 187,
	[113][39] = 135,
	[113][40] = 136,
	[113][44] = 161,
	[113][45] = 138,
	[113][47] = 139,
	[113][48] = 182,
	[113][49] = 183,
	[113][50] = 183,
	[113][51] = 183,
	[113][52] = 183,
	[113][53] = 183,
	[113][54] = 183,
	[113][55] = 183,
	[113][56] = 183,
	[113][57] = 183,
	[113][93] = 162,
	[113][94] = 156,
	[113][124] = 186,
	[114][9] = 130,
	[114][10] = 130,
	[114][32] = 130,
	[114][39] = 135,
	[114][40] = 136,
	[114][47] = 139,
	[114][48] = 182,
	[114][49] = 183,
	[114][50] = 183,
	[114][51] = 183,
	[114][52] = 183,
	[114][53] = 183,
	[114][54] = 183,
	[114][55] = 183,
	[114][56] = 183,
	[114][57] = 183,
	[115][9] = 130,
	[115][10] = 130,
	[115][32] = 130,
	[115][33] = 131,
	[115][39] = 135,
	[115][40] = 136,
	[115][44] = 161,
	[115][47] = 139,
	[115][48] = 182,
	[115][49] = 183,
	[115][50] = 183,
	[115][51] = 183,
	[115][52] = 183,
	[115][53] = 183,
	[115][54] = 183,
	[115][55] = 183,
	[115][56] = 183,
	[115][57] = 183,
	[115][93] = 162,
	[115][94] = 156,
	[115][124] = 186,
	[116][9] = 130,
	[116][10] = 130,
	[116][32] = 130,
	[116][33] = 131,
	[116][38] = 187,
	[116][39] = 135,
	[116][40] = 136,
	[116][44] = 161,
	[116][47] = 139,
	[116][48] = 182,
	[116][49] = 183,
	[116][50] = 183,
	[116][51] = 183,
	[116][52] = 183,
	[116][53] = 183,
	[116][54] = 183,
	[116][55] = 183,
	[116][56] = 183,
	[116][57] = 183,
	[116][93] = 162,
	[116][94] = 156,
	[116][124] = 186,
	[117][9] = 130,
	[117][10] = 130,
	[117][32] = 130,
	[117][33] = 131,
	[117][39] = 135,
	[117][40] = 136,
	[117][44] = 161,
	[117][47] = 139,
	[117][48] = 182,
	[117][49] = 183,
	[117][50] = 183,
	[117][51] = 183,
	[117][52] = 183,
	[117][53] = 183,
	[117][54] = 183,
	[117][55] = 183,
	[117][56] = 183,
	[117][57] = 183,
	[117][93] = 162,
	[117][124] = 186,
	[118][9] = 130,
	[118][10] = 130,
	[118][32] = 130,
	[118][34] = 132,
	[118][39] = 135,
	[118][40] = 136,
	[118][42] = 179,
	[118][43] = 137,
	[118][47] = 150,
	[118][48] = 182,
	[118][49] = 183,
	[118][50] = 183,
	[118][51] = 183,
	[118][52] = 183,
	[118][53] = 183,
	[118][54] = 183,
	[118][55] = 183,
	[118][56] = 183,
	[118][57] = 183,
	[118][63] = 155,
	[118][91] = 142,
	[118][124] = 186,
	[119][9] = 130,
	[119][10] = 130,
	[119][32] = 130,
	[119][47] = 150,
	[120][9] = 130,
	[120][10] = 130,
	[120][32] = 130,
	[120][47] = 150,
	[120][124] = 186,
	[121][9] = 130,
	[121][10] = 130,
	[121][32] = 130,
	[121][34] = 132,
	[121][39] = 135,
	[121][40] = 136,
	[121][47] = 150,
	[121][48] = 182,
	[121][49] = 183,
	[121][50] = 183,
	[121][51] = 183,
	[121][52] = 183,
	[121][53] = 183,
	[121][54] = 183,
	[121][55] = 183,
	[121][56] = 183,
	[121][57] = 183,
	[121][91] = 142,
	[121][124] = 186,
	[122][9] = 130,
	[122][10] = 130,
	[122][32] = 130,
	[122][34] = 132,
	[122][39] = 135,
	[122][40] = 136,
	[122][42] = 179,
	[122][43] = 137,
	[122][47] = 139,
	[122][48] = 182,
	[122][49] = 183,
	[122][50] = 183,
	[122][51] = 183,
	[122][52] = 183,
	[122][53] = 183,
	[122][54] = 183,
	[122][55] = 183,
	[122][56] = 183,
	[122][57] = 183,
	[122][59] = 151,
	[122][63] = 155,
	[122][91] = 142,
	[122][124] = 186,
	[123][9] = 130,
	[123][10] = 130,
	[123][32] = 130,
	[123][34] = 132,
	[123][39] = 135,
	[123][40] = 136,
	[123][47] = 139,
	[123][48] = 182,
	[123][49] = 183,
	[123][50] = 183,
	[123][51] = 183,
	[123][52] = 183,
	[123][53] = 183,
	[123][54] = 183,
	[123][55] = 183,
	[123][56] = 183,
	[123][57] = 183,
	[123][59] = 151,
	[123][91] = 142,
	[123][124] = 186,
	[124][9] = 130,
	[124][10] = 130,
	[124][32] = 130,
	[124][33] = 131,
	[124][38] = 187,
	[124][39] = 135,
	[124][40] = 136,
	[124][41] = 160,
	[124][44] = 161,
	[124][45] = 138,
	[124][47] = 139,
	[124][48] = 182,
	[124][49] = 183,
	[124][50] = 183,
	[124][51] = 183,
	[124][52] = 183,
	[124][53] = 183,
	[124][54] = 183,
	[124][55] = 183,
	[124][56] = 183,
	[124][57] = 183,
	[124][94] = 156,
	[124][124] = 186,
	[125][9] = 130,
	[125][10] = 130,
	[125][32] = 130,
	[125][33] = 131,
	[125][39] = 135,
	[125][40] = 136,
	[125][41] = 160,
	[125][44] = 161,
	[125][47] = 139,
	[125][48] = 182,
	[125][49] = 183,
	[125][50] = 183,
	[125][51] = 183,
	[125][52] = 183,
	[125][53] = 183,
	[125][54] = 183,
	[125][55] = 183,
	[125][56] = 183,
	[125][57] = 183,
	[125][94] = 156,
	[125][124] = 186,
	[126][9] = 130,
	[126][10] = 130,
	[126][32] = 130,
	[126][33] = 131,
	[126][38] = 187,
	[126][39] = 135,
	[126][40] = 136,
	[126][41] = 160,
	[126][44] = 161,
	[126][47] = 139,
	[126][48] = 182,
	[126][49] = 183,
	[126][50] = 183,
	[126][51] = 183,
	[126][52] = 183,
	[126][53] = 183,
	[126][54] = 183,
	[126][55] = 183,
	[126][56] = 183,
	[126][57] = 183,
	[126][94] = 156,
	[126][124] = 186,
	[127][9] = 130,
	[127][10] = 130,
	[127][32] = 130,
	[127][33] = 131,
	[127][39] = 135,
	[127][40] = 136,
	[127][41] = 160,
	[127][44] = 161,
	[127][47] = 139,
	[127][48] = 182,
	[127][49] = 183,
	[127][50] = 183,
	[127][51] = 183,
	[127][52] = 183,
	[127][53] = 183,
	[127][54] = 183,
	[127][55] = 183,
	[127][56] = 183,
	[127][57] = 183,
	[127][124] = 186,
	[128][9] = 130,
	[128][10] = 130,
	[128][32] = 130,
	[128][34] = 132,
	[128][39] = 135,
	[128][40] = 136,
	[128][41] = 160,
	[128][42] = 179,
	[128][43] = 137,
	[128][47] = 139,
	[128][48] = 182,
	[128][49] = 183,
	[128][50] = 183,
	[128][51] = 183,
	[128][52] = 183,
	[128][53] = 183,
	[128][54] = 183,
	[128][55] = 183,
	[128][56] = 183,
	[128][57] = 183,
	[128][63] = 155,
	[128][91] = 142,
	[128][124] = 186,
	[129][9] = 130,
	[129][10] = 130,
	[129][32] = 130,
	[129][34] = 132,
	[129][39] = 135,
	[129][40] = 136,
	[129][41] = 160,
	[129][47] = 139,
	[129][48] = 182,
	[129][49] = 183,
	[129][50] = 183,
	[129][51] = 183,
	[129][52] = 183,
	[129][53] = 183,
	[129][54] = 183,
	[129][55] = 183,
	[129][56] = 183,
	[129][57] = 183,
	[129][91] = 142,
	[129][124] = 186,
	[130][9] = 130,
	[130][10] = 130,
	[130][32] = 130,
	[130][47] = 139,
	[132][0] = 132,
	[132][1] = 132,
	[132][2] = 132,
	[132][3] = 132,
	[132][4] = 132,
	[132][5] = 132,
	[132][6] = 132,
	[132][7] = 132,
	[132][8] = 132,
	[132][9] = 132,
	[132][10] = 132,
	[132][11] = 132,
	[132][12] = 132,
	[132][13] = 132,
	[132][14] = 132,
	[132][15] = 132,
	[132][16] = 132,
	[132][17] = 132,
	[132][18] = 132,
	[132][19] = 132,
	[132][20] = 132,
	[132][21] = 132,
	[132][22] = 132,
	[132][23] = 132,
	[132][24] = 132,
	[132][25] = 132,
	[132][26] = 132,
	[132][27] = 132,
	[132][28] = 132,
	[132][29] = 132,
	[132][30] = 132,
	[132][31] = 132,
	[132][32] = 132,
	[132][33] = 132,
	[132][34] = 188,
	[132][35] = 132,
	[132][36] = 132,
	[132][37] = 132,
	[132][38] = 132,
	[132][39] = 132,
	[132][40] = 132,
	[132][41] = 132,
	[132][42] = 132,
	[132][43] = 132,
	[132][44] = 132,
	[132][45] = 132,
	[132][46] = 132,
	[132][47] = 132,
	[132][48] = 132,
	[132][49] = 132,
	[132][50] = 132,
	[132][51] = 132,
	[132][52] = 132,
	[132][53] = 132,
	[132][54] = 132,
	[132][55] = 132,
	[132][56] = 132,
	[132][57] = 132,
	[132][58] = 132,
	[132][59] = 132,
	[132][60] = 132,
	[132][61] = 132,
	[132][62] = 132,
	[132][63] = 132,
	[132][64] = 132,
	[132][65] = 132,
	[132][66] = 132,
	[132][67] = 132,
	[132][68] = 132,
	[132][69] = 132,
	[132][70] = 132,
	[132][71] = 132,
	[132][72] = 132,
	[132][73] = 132,
	[132][74] = 132,
	[132][75] = 132,
	[132][76] = 132,
	[132][77] = 132,
	[132][78] = 132,
	[132][79] = 132,
	[132][80] = 132,
	[132][81] = 132,
	[132][82] = 132,
	[132][83] = 132,
	[132][84] = 132,
	[132][85] = 132,
	[132][86] = 132,
	[132][87] = 132,
	[132][88] = 132,
	[132][89] = 132,
	[132][90] = 132,
	[132][91] = 132,
	[132][92] = 189,
	[132][93] = 132,
	[132][94] = 132,
	[132][95] = 132,
	[132][96] = 132,
	[132][97] = 132,
	[132][98] = 132,
	[132][99] = 132,
	[132][100] = 132,
	[132][101] = 132,
	[132][102] = 132,
	[132][103] = 132,
	[132][104] = 132,
	[132][105] = 132,
	[132][106] = 132,
	[132][107] = 132,
	[132][108] = 132,
	[132][109] = 132,
	[132][110] = 132,
	[132][111] = 132,
	[132][112] = 132,
	[132][113] = 132,
	[132][114] = 132,
	[132][115] = 132,
	[132][116] = 132,
	[132][117] = 132,
	[132][118] = 132,
	[132][119] = 132,
	[132][120] = 132,
	[132][121] = 132,
	[132][122] = 132,
	[132][123] = 132,
	[132][124] = 132,
	[132][125] = 132,
	[132][126] = 132,
	[132][127] = 132,
	[132][128] = 132,
	[132][129] = 132,
	[132][130] = 132,
	[132][131] = 132,
	[132][132] = 132,
	[132][133] = 132,
	[132][134] = 132,
	[132][135] = 132,
	[132][136] = 132,
	[132][137] = 132,
	[132][138] = 132,
	[132][139] = 132,
	[132][140] = 132,
	[132][141] = 132,
	[132][142] = 132,
	[132][143] = 132,
	[132][144] = 132,
	[132][145] = 132,
	[132][146] = 132,
	[132][147] = 132,
	[132][148] = 132,
	[132][149] = 132,
	[132][150] = 132,
	[132][151] = 132,
	[132][152] = 132,
	[132][153] = 132,
	[132][154] = 132,
	[132][155] = 132,
	[132][156] = 132,
	[132][157] = 132,
	[132][158] = 132,
	[132][159] = 132,
	[132][160] = 132,
	[132][161] = 132,
	[132][162] = 132,
	[132][163] = 132,
	[132][164] = 132,
	[132][165] = 132,
	[132][166] = 132,
	[132][167] = 132,
	[132][168] = 132,
	[132][169] = 132,
	[132][170] = 132,
	[132][171] = 132,
	[132][172] = 132,
	[132][173] = 132,
	[132][174] = 132,
	[132][175] = 132,
	[132][176] = 132,
	[132][177] = 132,
	[132][178] = 132,
	[132][179] = 132,
	[132][180] = 132,
	[132][181] = 132,
	[132][182] = 132,
	[132][183] = 132,
	[132][184] = 132,
	[132][185] = 132,
	[132][186] = 132,
	[132][187] = 132,
	[132][188] = 132,
	[132][189] = 132,
	[132][190] = 132,
	[132][191] = 132,
	[132][192] = 132,
	[132][193] = 132,
	[132][194] = 132,
	[132][195] = 132,
	[132][196] = 132,
	[132][197] = 132,
	[132][198] = 132,
	[132][199] = 132,
	[132][200] = 132,
	[132][201] = 132,
	[132][202] = 132,
	[132][203] = 132,
	[132][204] = 132,
	[132][205] = 132,
	[132][206] = 132,
	[132][207] = 132,
	[132][208] = 132,
	[132][209] = 132,
	[132][210] = 132,
	[132][211] = 132,
	[132][212] = 132,
	[132][213] = 132,
	[132][214] = 132,
	[132][215] = 132,
	[132][216] = 132,
	[132][217] = 132,
	[132][218] = 132,
	[132][219] = 132,
	[132][220] = 132,
	[132][221] = 132,
	[132][222] = 132,
	[132][223] = 132,
	[132][224] = 132,
	[132][225] = 132,
	[132][226] = 132,
	[132][227] = 132,
	[132][228] = 132,
	[132][229] = 132,
	[132][230] = 132,
	[132][231] = 132,
	[132][232] = 132,
	[132][233] = 132,
	[132][234] = 132,
	[132][235] = 132,
	[132][236] = 132,
	[132][237] = 132,
	[132][238] = 132,
	[132][239] = 132,
	[132][240] = 132,
	[132][241] = 132,
	[132][242] = 132,
	[132][243] = 132,
	[132][244] = 132,
	[132][245] = 132,
	[132][246] = 132,
	[132][247] = 132,
	[132][248] = 132,
	[132][249] = 132,
	[132][250] = 132,
	[132][251] = 132,
	[132][252] = 132,
	[132][253] = 132,
	[132][254] = 132,
	[132][255] = 132,
	[135][0] = 190,
	[135][1] = 190,
	[135][2] = 190,
	[135][3] = 190,
	[135][4] = 190,
	[135][5] = 190,
	[135][6] = 190,
	[135][7] = 190,
	[135][8] = 190,
	[135][9] = 190,
	[135][10] = 190,
	[135][11] = 190,
	[135][12] = 190,
	[135][13] = 190,
	[135][14] = 190,
	[135][15] = 190,
	[135][16] = 190,
	[135][17] = 190,
	[135][18] = 190,
	[135][19] = 190,
	[135][20] = 190,
	[135][21] = 190,
	[135][22] = 190,
	[135][23] = 190,
	[135][24] = 190,
	[135][25] = 190,
	[135][26] = 190,
	[135][27] = 190,
	[135][28] = 190,
	[135][29] = 190,
	[135][30] = 190,
	[135][31] = 190,
	[135][32] = 190,
	[135][33] = 190,
	[135][34] = 190,
	[135][35] = 190,
	[135][36] = 190,
	[135][37] = 190,
	[135][38] = 190,
	[135][40] = 190,
	[135][41] = 190,
	[135][42] = 190,
	[135][43] = 190,
	[135][44] = 190,
	[135][45] = 190,
	[135][46] = 190,
	[135][47] = 190,
	[135][48] = 190,
	[135][49] = 190,
	[135][50] = 190,
	[135][51] = 190,
	[135][52] = 190,
	[135][53] = 190,
	[135][54] = 190,
	[135][55] = 190,
	[135][56] = 190,
	[135][57] = 190,
	[135][58] = 190,
	[135][59] = 190,
	[135][60] = 190,
	[135][61] = 190,
	[135][62] = 190,
	[135][63] = 190,
	[135][64] = 190,
	[135][65] = 190,
	[135][66] = 190,
	[135][67] = 190,
	[135][68] = 190,
	[135][69] = 190,
	[135][70] = 190,
	[135][71] = 190,
	[135][72] = 190,
	[135][73] = 190,
	[135][74] = 190,
	[135][75] = 190,
	[135][76] = 190,
	[135][77] = 190,
	[135][78] = 190,
	[135][79] = 190,
	[135][80] = 190,
	[135][81] = 190,
	[135][82] = 190,
	[135][83] = 190,
	[135][84] = 190,
	[135][85] = 190,
	[135][86] = 190,
	[135][87] = 190,
	[135][88] = 190,
	[135][89] = 190,
	[135][90] = 190,
	[135][91] = 190,
	[135][92] = 191,
	[135][93] = 190,
	[135][94] = 190,
	[135][95] = 190,
	[135][96] = 190,
	[135][97] = 190,
	[135][98] = 190,
	[135][99] = 190,
	[135][100] = 190,
	[135][101] = 190,
	[135][102] = 190,
	[135][103] = 190,
	[135][104] = 190,
	[135][105] = 190,
	[135][106] = 190,
	[135][107] = 190,
	[135][108] = 190,
	[135][109] = 190,
	[135][110] = 190,
	[135][111] = 190,
	[135][112] = 190,
	[135][113] = 190,
	[135][114] = 190,
	[135][115] = 190,
	[135][116] = 190,
	[135][117] = 190,
	[135][118] = 190,
	[135][119] = 190,
	[135][120] = 190,
	[135][121] = 190,
	[135][122] = 190,
	[135][123] = 190,
	[135][124] = 190,
	[135][125] = 190,
	[135][126] = 190,
	[135][127] = 190,
	[135][128] = 190,
	[135][129] = 190,
	[135][130] = 190,
	[135][131] = 190,
	[135][132] = 190,
	[135][133] = 190,
	[135][134] = 190,
	[135][135] = 190,
	[135][136] = 190,
	[135][137] = 190,
	[135][138] = 190,
	[135][139] = 190,
	[135][140] = 190,
	[135][141] = 190,
	[135][142] = 190,
	[135][143] = 190,
	[135][144] = 190,
	[135][145] = 190,
	[135][146] = 190,
	[135][147] = 190,
	[135][148] = 190,
	[135][149] = 190,
	[135][150] = 190,
	[135][151] = 190,
	[135][152] = 190,
	[135][153] = 190,
	[135][154] = 190,
	[135][155] = 190,
	[135][156] = 190,
	[135][157] = 190,
	[135][158] = 190,
	[135][159] = 190,
	[135][160] = 190,
	[135][161] = 190,
	[135][162] = 190,
	[135][163] = 190,
	[135][164] = 190,
	[135][165] = 190,
	[135][166] = 190,
	[135][167] = 190,
	[135][168] = 190,
	[135][169] = 190,
	[135][170] = 190,
	[135][171] = 190,
	[135][172] = 190,
	[135][173] = 190,
	[135][174] = 190,
	[135][175] = 190,
	[135][176] = 190,
	[135][177] = 190,
	[135][178] = 190,
	[135][179] = 190,
	[135][180] = 190,
	[135][181] = 190,
	[135][182] = 190,
	[135][183] = 190,
	[135][184] = 190,
	[135][185] = 190,
	[135][186] = 190,
	[135][187] = 190,
	[135][188] = 190,
	[135][189] = 190,
	[135][190] = 190,
	[135][191] = 190,
	[135][192] = 190,
	[135][193] = 190,
	[135][194] = 190,
	[135][195] = 190,
	[135][196] = 190,
	[135][197] = 190,
	[135][198] = 190,
	[135][199] = 190,
	[135][200] = 190,
	[135][201] = 190,
	[135][202] = 190,
	[135][203] = 190,
	[135][204] = 190,
	[135][205] = 190,
	[135][206] = 190,
	[135][207] = 190,
	[135][208] = 190,
	[135][209] = 190,
	[135][210] = 190,
	[135][211] = 190,
	[135][212] = 190,
	[135][213] = 190,
	[135][214] = 190,
	[135][215] = 190,
	[135][216] = 190,
	[135][217] = 190,
	[135][218] = 190,
	[135][219] = 190,
	[135][220] = 190,
	[135][221] = 190,
	[135][222] = 190,
	[135][223] = 190,
	[135][224] = 190,
	[135][225] = 190,
	[135][226] = 190,
	[135][227] = 190,
	[135][228] = 190,
	[135][229] = 190,
	[135][230] = 190,
	[135][231] = 190,
	[135][232] = 190,
	[135][233] = 190,
	[135][234] = 190,
	[135][235] = 190,
	[135][236] = 190,
	[135][237] = 190,
	[135][238] = 190,
	[135][239] = 190,
	[135][240] = 190,
	[135][241] = 190,
	[135][242] = 190,
	[135][243] = 190,
	[135][244] = 190,
	[135][245] = 190,
	[135][246] = 190,
	[135][247] = 190,
	[135][248] = 190,
	[135][249] = 190,
	[135][250] = 190,
	[135][251] = 190,
	[135][252] = 190,
	[135][253] = 190,
	[135][254] = 190,
	[135][255] = 190,
	[139][47] = 192,
	[140][46] = 193,
	[140][48] = 194,
	[140][49] = 141,
	[140][50] = 141,
	[140][51] = 141,
	[140][52] = 141,
	[140][53] = 141,
	[140][54] = 141,
	[140][55] = 141,
	[140][56] = 141,
	[140][57] = 141,
	[140][98] = 195,
	[140][120] = 195,
	[141][46] = 193,
	[141][48] = 141,
	[141][49] = 141,
	[141][50] = 141,
	[141][51] = 141,
	[141][52] = 141,
	[141][53] = 141,
	[141][54] = 141,
	[141][55] = 141,
	[141][56] = 141,
	[141][57] = 141,
	[143][48] = 143,
	[143][49] = 143,
	[143][50] = 143,
	[143][51] = 143,
	[143][52] = 143,
	[143][53] = 143,
	[143][54] = 143,
	[143][55] = 143,
	[143][56] = 143,
	[143][57] = 143,
	[143][95] = 143,
	[143][97] = 143,
	[143][98] = 143,
	[143][99] = 143,
	[143][100] = 143,
	[143][101] = 143,
	[143][102] = 143,
	[143][103] = 143,
	[143][104] = 143,
	[143][105] = 143,
	[143][106] = 143,
	[143][107] = 143,
	[143][108] = 143,
	[143][109] = 143,
	[143][110] = 143,
	[143][111] = 143,
	[143][112] = 143,
	[143][113] = 143,
	[143][114] = 143,
	[143][115] = 143,
	[143][116] = 143,
	[143][117] = 143,
	[143][118] = 143,
	[143][119] = 143,
	[143][120] = 143,
	[143][121] = 143,
	[143][122] = 143,
	[144][48] = 143,
	[144][49] = 143,
	[144][50] = 143,
	[144][51] = 143,
	[144][52] = 143,
	[144][53] = 143,
	[144][54] = 143,
	[144][55] = 143,
	[144][56] = 143,
	[144][57] = 143,
	[144][95] = 143,
	[144][97] = 196,
	[144][98] = 143,
	[144][99] = 143,
	[144][100] = 143,
	[144][101] = 143,
	[144][102] = 143,
	[144][103] = 143,
	[144][104] = 143,
	[144][105] = 143,
	[144][106] = 143,
	[144][107] = 143,
	[144][108] = 143,
	[144][109] = 143,
	[144][110] = 143,
	[144][111] = 143,
	[144][112] = 143,
	[144][113] = 143,
	[144][114] = 143,
	[144][115] = 143,
	[144][116] = 143,
	[144][117] = 143,
	[144][118] = 143,
	[144][119] = 143,
	[144][120] = 143,
	[144][121] = 143,
	[144][122] = 143,
	[146][61] = 197,
	[147][38] = 198,
	[148][42] = 199,
	[150][47] = 192,
	[152][60] = 200,
	[152][61] = 201,
	[153][61] = 202,
	[154][61] = 203,
	[154][62] = 204,
	[157][97] = 205,
	[158][102] = 206,
	[158][109] = 207,
	[159][124] = 208,
	[164][61] = 202,
	[165][101] = 209,
	[166][114] = 210,
	[167][111] = 211,
	[168][107] = 212,
	[168][116] = 213,
	[169][115] = 214,
	[170][97] = 215,
	[171][48] = 143,
	[171][49] = 143,
	[171][50] = 143,
	[171][51] = 143,
	[171][52] = 143,
	[171][53] = 143,
	[171][54] = 143,
	[171][55] = 143,
	[171][56] = 143,
	[171][57] = 143,
	[171][95] = 143,
	[171][97] = 143,
	[171][98] = 143,
	[171][99] = 143,
	[171][100] = 143,
	[171][101] = 143,
	[171][102] = 143,
	[171][103] = 143,
	[171][104] = 143,
	[171][105] = 143,
	[171][106] = 143,
	[171][107] = 143,
	[171][108] = 143,
	[171][109] = 143,
	[171][110] = 143,
	[171][111] = 216,
	[171][112] = 143,
	[171][113] = 143,
	[171][114] = 143,
	[171][115] = 143,
	[171][116] = 143,
	[171][117] = 143,
	[171][118] = 143,
	[171][119] = 143,
	[171][120] = 143,
	[171][121] = 143,
	[171][122] = 143,
	[172][48] = 143,
	[172][49] = 143,
	[172][50] = 143,
	[172][51] = 143,
	[172][52] = 143,
	[172][53] = 143,
	[172][54] = 143,
	[172][55] = 143,
	[172][56] = 143,
	[172][57] = 143,
	[172][95] = 143,
	[172][97] = 143,
	[172][98] = 143,
	[172][99] = 143,
	[172][100] = 143,
	[172][101] = 143,
	[172][102] = 143,
	[172][103] = 143,
	[172][104] = 217,
	[172][105] = 143,
	[172][106] = 143,
	[172][107] = 143,
	[172][108] = 143,
	[172][109] = 143,
	[172][110] = 143,
	[172][111] = 143,
	[172][112] = 143,
	[172][113] = 143,
	[172][114] = 143,
	[172][115] = 143,
	[172][116] = 143,
	[172][117] = 143,
	[172][118] = 143,
	[172][119] = 143,
	[172][120] = 143,
	[172][121] = 143,
	[172][122] = 143,
	[173][48] = 143,
	[173][49] = 143,
	[173][50] = 143,
	[173][51] = 143,
	[173][52] = 143,
	[173][53] = 143,
	[173][54] = 143,
	[173][55] = 143,
	[173][56] = 143,
	[173][57] = 143,
	[173][95] = 143,
	[173][97] = 143,
	[173][98] = 143,
	[173][99] = 143,
	[173][100] = 143,
	[173][101] = 143,
	[173][102] = 143,
	[173][103] = 143,
	[173][104] = 143,
	[173][105] = 143,
	[173][106] = 143,
	[173][107] = 143,
	[173][108] = 218,
	[173][109] = 143,
	[173][110] = 143,
	[173][111] = 143,
	[173][112] = 143,
	[173][113] = 143,
	[173][114] = 143,
	[173][115] = 143,
	[173][116] = 143,
	[173][117] = 143,
	[173][118] = 143,
	[173][119] = 143,
	[173][120] = 143,
	[173][121] = 143,
	[173][122] = 143,
	[174][48] = 143,
	[174][49] = 143,
	[174][50] = 143,
	[174][51] = 143,
	[174][52] = 143,
	[174][53] = 143,
	[174][54] = 143,
	[174][55] = 143,
	[174][56] = 143,
	[174][57] = 143,
	[174][95] = 143,
	[174][97] = 143,
	[174][98] = 143,
	[174][99] = 143,
	[174][100] = 143,
	[174][101] = 143,
	[174][102] = 143,
	[174][103] = 143,
	[174][104] = 143,
	[174][105] = 143,
	[174][106] = 143,
	[174][107] = 143,
	[174][108] = 143,
	[174][109] = 143,
	[174][110] = 219,
	[174][111] = 143,
	[174][112] = 143,
	[174][113] = 143,
	[174][114] = 143,
	[174][115] = 143,
	[174][116] = 143,
	[174][117] = 143,
	[174][118] = 143,
	[174][119] = 143,
	[174][120] = 143,
	[174][121] = 143,
	[174][122] = 143,
	[176][38] = 198,
	[177][102] = 206,
	[178][124] = 208,
	[180][61] = 201,
	[181][61] = 203,
	[182][49] = 183,
	[182][50] = 183,
	[182][51] = 183,
	[182][52] = 183,
	[182][53] = 183,
	[182][54] = 183,
	[182][55] = 183,
	[182][56] = 183,
	[182][57] = 183,
	[182][98] = 195,
	[182][120] = 195,
	[183][48] = 183,
	[183][49] = 183,
	[183][50] = 183,
	[183][51] = 183,
	[183][52] = 183,
	[183][53] = 183,
	[183][54] = 183,
	[183][55] = 183,
	[183][56] = 183,
	[183][57] = 183,
	[184][93] = 220,
	[185][95] = 221,
	[185][97] = 221,
	[185][98] = 221,
	[185][99] = 221,
	[185][100] = 221,
	[185][101] = 221,
	[185][102] = 221,
	[185][103] = 221,
	[185][104] = 221,
	[185][105] = 221,
	[185][106] = 221,
	[185][107] = 221,
	[185][108] = 221,
	[185][109] = 221,
	[185][110] = 221,
	[185][111] = 221,
	[185][112] = 221,
	[185][113] = 221,
	[185][114] = 221,
	[185][115] = 221,
	[185][116] = 221,
	[185][117] = 221,
	[185][118] = 221,
	[185][119] = 221,
	[185][120] = 221,
	[185][121] = 221,
	[185][122] = 221,
	[189][0] = 132,
	[189][1] = 132,
	[189][2] = 132,
	[189][3] = 132,
	[189][4] = 132,
	[189][5] = 132,
	[189][6] = 132,
	[189][7] = 132,
	[189][8] = 132,
	[189][9] = 132,
	[189][10] = 132,
	[189][11] = 132,
	[189][12] = 132,
	[189][13] = 132,
	[189][14] = 132,
	[189][15] = 132,
	[189][16] = 132,
	[189][17] = 132,
	[189][18] = 132,
	[189][19] = 132,
	[189][20] = 132,
	[189][21] = 132,
	[189][22] = 132,
	[189][23] = 132,
	[189][24] = 132,
	[189][25] = 132,
	[189][26] = 132,
	[189][27] = 132,
	[189][28] = 132,
	[189][29] = 132,
	[189][30] = 132,
	[189][31] = 132,
	[189][32] = 132,
	[189][33] = 132,
	[189][34] = 132,
	[189][35] = 132,
	[189][36] = 132,
	[189][37] = 132,
	[189][38] = 132,
	[189][39] = 132,
	[189][40] = 132,
	[189][41] = 132,
	[189][42] = 132,
	[189][43] = 132,
	[189][44] = 132,
	[189][45] = 132,
	[189][46] = 132,
	[189][47] = 132,
	[189][48] = 132,
	[189][49] = 132,
	[189][50] = 132,
	[189][51] = 132,
	[189][52] = 132,
	[189][53] = 132,
	[189][54] = 132,
	[189][55] = 132,
	[189][56] = 132,
	[189][57] = 132,
	[189][58] = 132,
	[189][59] = 132,
	[189][60] = 132,
	[189][61] = 132,
	[189][62] = 132,
	[189][63] = 132,
	[189][64] = 132,
	[189][65] = 132,
	[189][66] = 132,
	[189][67] = 132,
	[189][68] = 132,
	[189][69] = 132,
	[189][70] = 132,
	[189][71] = 132,
	[189][72] = 132,
	[189][73] = 132,
	[189][74] = 132,
	[189][75] = 132,
	[189][76] = 132,
	[189][77] = 132,
	[189][78] = 132,
	[189][79] = 132,
	[189][80] = 132,
	[189][81] = 132,
	[189][82] = 132,
	[189][83] = 132,
	[189][84] = 132,
	[189][85] = 132,
	[189][86] = 132,
	[189][87] = 132,
	[189][88] = 132,
	[189][89] = 132,
	[189][90] = 132,
	[189][91] = 132,
	[189][92] = 132,
	[189][93] = 132,
	[189][94] = 132,
	[189][95] = 132,
	[189][96] = 132,
	[189][97] = 132,
	[189][98] = 132,
	[189][99] = 132,
	[189][100] = 132,
	[189][101] = 132,
	[189][102] = 132,
	[189][103] = 132,
	[189][104] = 132,
	[189][105] = 132,
	[189][106] = 132,
	[189][107] = 132,
	[189][108] = 132,
	[189][109] = 132,
	[189][110] = 132,
	[189][111] = 132,
	[189][112] = 132,
	[189][113] = 132,
	[189][114] = 132,
	[189][115] = 132,
	[189][116] = 132,
	[189][117] = 132,
	[189][118] = 132,
	[189][119] = 132,
	[189][120] = 132,
	[189][121] = 132,
	[189][122] = 132,
	[189][123] = 132,
	[189][124] = 132,
	[189][125] = 132,
	[189][126] = 132,
	[189][127] = 132,
	[189][128] = 132,
	[189][129] = 132,
	[189][130] = 132,
	[189][131] = 132,
	[189][132] = 132,
	[189][133] = 132,
	[189][134] = 132,
	[189][135] = 132,
	[189][136] = 132,
	[189][137] = 132,
	[189][138] = 132,
	[189][139] = 132,
	[189][140] = 132,
	[189][141] = 132,
	[189][142] = 132,
	[189][143] = 132,
	[189][144] = 132,
	[189][145] = 132,
	[189][146] = 132,
	[189][147] = 132,
	[189][148] = 132,
	[189][149] = 132,
	[189][150] = 132,
	[189][151] = 132,
	[189][152] = 132,
	[189][153] = 132,
	[189][154] = 132,
	[189][155] = 132,
	[189][156] = 132,
	[189][157] = 132,
	[189][158] = 132,
	[189][159] = 132,
	[189][160] = 132,
	[189][161] = 132,
	[189][162] = 132,
	[189][163] = 132,
	[189][164] = 132,
	[189][165] = 132,
	[189][166] = 132,
	[189][167] = 132,
	[189][168] = 132,
	[189][169] = 132,
	[189][170] = 132,
	[189][171] = 132,
	[189][172] = 132,
	[189][173] = 132,
	[189][174] = 132,
	[189][175] = 132,
	[189][176] = 132,
	[189][177] = 132,
	[189][178] = 132,
	[189][179] = 132,
	[189][180] = 132,
	[189][181] = 132,
	[189][182] = 132,
	[189][183] = 132,
	[189][184] = 132,
	[189][185] = 132,
	[189][186] = 132,
	[189][187] = 132,
	[189][188] = 132,
	[189][189] = 132,
	[189][190] = 132,
	[189][191] = 132,
	[189][192] = 132,
	[189][193] = 132,
	[189][194] = 132,
	[189][195] = 132,
	[189][196] = 132,
	[189][197] = 132,
	[189][198] = 132,
	[189][199] = 132,
	[189][200] = 132,
	[189][201] = 132,
	[189][202] = 132,
	[189][203] = 132,
	[189][204] = 132,
	[189][205] = 132,
	[189][206] = 132,
	[189][207] = 132,
	[189][208] = 132,
	[189][209] = 132,
	[189][210] = 132,
	[189][211] = 132,
	[189][212] = 132,
	[189][213] = 132,
	[189][214] = 132,
	[189][215] = 132,
	[189][216] = 132,
	[189][217] = 132,
	[189][218] = 132,
	[189][219] = 132,
	[189][220] = 132,
	[189][221] = 132,
	[189][222] = 132,
	[189][223] = 132,
	[189][224] = 132,
	[189][225] = 132,
	[189][226] = 132,
	[189][227] = 132,
	[189][228] = 132,
	[189][229] = 132,
	[189][230] = 132,
	[189][231] = 132,
	[189][232] = 132,
	[189][233] = 132,
	[189][234] = 132,
	[189][235] = 132,
	[189][236] = 132,
	[189][237] = 132,
	[189][238] = 132,
	[189][239] = 132,
	[189][240] = 132,
	[189][241] = 132,
	[189][242] = 132,
	[189][243] = 132,
	[189][244] = 132,
	[189][245] = 132,
	[189][246] = 132,
	[189][247] = 132,
	[189][248] = 132,
	[189][249] = 132,
	[189][250] = 132,
	[189][251] = 132,
	[189][252] = 132,
	[189][253] = 132,
	[189][254] = 132,
	[189][255] = 132,
	[190][39] = 222,
	[191][0] = 190,
	[191][1] = 190,
	[191][2] = 190,
	[191][3] = 190,
	[191][4] = 190,
	[191][5] = 190,
	[191][6] = 190,
	[191][7] = 190,
	[191][8] = 190,
	[191][9] = 190,
	[191][10] = 190,
	[191][11] = 190,
	[191][12] = 190,
	[191][13] = 190,
	[191][14] = 190,
	[191][15] = 190,
	[191][16] = 190,
	[191][17] = 190,
	[191][18] = 190,
	[191][19] = 190,
	[191][20] = 190,
	[191][21] = 190,
	[191][22] = 190,
	[191][23] = 190,
	[191][24] = 190,
	[191][25] = 190,
	[191][26] = 190,
	[191][27] = 190,
	[191][28] = 190,
	[191][29] = 190,
	[191][30] = 190,
	[191][31] = 190,
	[191][32] = 190,
	[191][33] = 190,
	[191][34] = 190,
	[191][35] = 190,
	[191][36] = 190,
	[191][37] = 190,
	[191][38] = 190,
	[191][39] = 190,
	[191][40] = 190,
	[191][41] = 190,
	[191][42] = 190,
	[191][43] = 190,
	[191][44] = 190,
	[191][45] = 190,
	[191][46] = 190,
	[191][47] = 190,
	[191][48] = 190,
	[191][49] = 190,
	[191][50] = 190,
	[191][51] = 190,
	[191][52] = 190,
	[191][53] = 190,
	[191][54] = 190,
	[191][55] = 190,
	[191][56] = 190,
	[191][57] = 190,
	[191][58] = 190,
	[191][59] = 190,
	[191][60] = 190,
	[191][61] = 190,
	[191][62] = 190,
	[191][63] = 190,
	[191][64] = 190,
	[191][65] = 190,
	[191][66] = 190,
	[191][67] = 190,
	[191][68] = 190,
	[191][69] = 190,
	[191][70] = 190,
	[191][71] = 190,
	[191][72] = 190,
	[191][73] = 190,
	[191][74] = 190,
	[191][75] = 190,
	[191][76] = 190,
	[191][77] = 190,
	[191][78] = 190,
	[191][79] = 190,
	[191][80] = 190,
	[191][81] = 190,
	[191][82] = 190,
	[191][83] = 190,
	[191][84] = 190,
	[191][85] = 190,
	[191][86] = 190,
	[191][87] = 190,
	[191][88] = 190,
	[191][89] = 190,
	[191][90] = 190,
	[191][91] = 190,
	[191][92] = 190,
	[191][93] = 190,
	[191][94] = 190,
	[191][95] = 190,
	[191][96] = 190,
	[191][97] = 190,
	[191][98] = 190,
	[191][99] = 190,
	[191][100] = 190,
	[191][101] = 190,
	[191][102] = 190,
	[191][103] = 190,
	[191][104] = 190,
	[191][105] = 190,
	[191][106] = 190,
	[191][107] = 190,
	[191][108] = 190,
	[191][109] = 190,
	[191][110] = 190,
	[191][111] = 190,
	[191][112] = 190,
	[191][113] = 190,
	[191][114] = 190,
	[191][115] = 190,
	[191][116] = 190,
	[191][117] = 190,
	[191][118] = 190,
	[191][119] = 190,
	[191][120] = 190,
	[191][121] = 190,
	[191][122] = 190,
	[191][123] = 190,
	[191][124] = 190,
	[191][125] = 190,
	[191][126] = 190,
	[191][127] = 190,
	[191][128] = 190,
	[191][129] = 190,
	[191][130] = 190,
	[191][131] = 190,
	[191][132] = 190,
	[191][133] = 190,
	[191][134] = 190,
	[191][135] = 190,
	[191][136] = 190,
	[191][137] = 190,
	[191][138] = 190,
	[191][139] = 190,
	[191][140] = 190,
	[191][141] = 190,
	[191][142] = 190,
	[191][143] = 190,
	[191][144] = 190,
	[191][145] = 190,
	[191][146] = 190,
	[191][147] = 190,
	[191][148] = 190,
	[191][149] = 190,
	[191][150] = 190,
	[191][151] = 190,
	[191][152] = 190,
	[191][153] = 190,
	[191][154] = 190,
	[191][155] = 190,
	[191][156] = 190,
	[191][157] = 190,
	[191][158] = 190,
	[191][159] = 190,
	[191][160] = 190,
	[191][161] = 190,
	[191][162] = 190,
	[191][163] = 190,
	[191][164] = 190,
	[191][165] = 190,
	[191][166] = 190,
	[191][167] = 190,
	[191][168] = 190,
	[191][169] = 190,
	[191][170] = 190,
	[191][171] = 190,
	[191][172] = 190,
	[191][173] = 190,
	[191][174] = 190,
	[191][175] = 190,
	[191][176] = 190,
	[191][177] = 190,
	[191][178] = 190,
	[191][179] = 190,
	[191][180] = 190,
	[191][181] = 190,
	[191][182] = 190,
	[191][183] = 190,
	[191][184] = 190,
	[191][185] = 190,
	[191][186] = 190,
	[191][187] = 190,
	[191][188] = 190,
	[191][189] = 190,
	[191][190] = 190,
	[191][191] = 190,
	[191][192] = 190,
	[191][193] = 190,
	[191][194] = 190,
	[191][195] = 190,
	[191][196] = 190,
	[191][197] = 190,
	[191][198] = 190,
	[191][199] = 190,
	[191][200] = 190,
	[191][201] = 190,
	[191][202] = 190,
	[191][203] = 190,
	[191][204] = 190,
	[191][205] = 190,
	[191][206] = 190,
	[191][207] = 190,
	[191][208] = 190,
	[191][209] = 190,
	[191][210] = 190,
	[191][211] = 190,
	[191][212] = 190,
	[191][213] = 190,
	[191][214] = 190,
	[191][215] = 190,
	[191][216] = 190,
	[191][217] = 190,
	[191][218] = 190,
	[191][219] = 190,
	[191][220] = 190,
	[191][221] = 190,
	[191][222] = 190,
	[191][223] = 190,
	[191][224] = 190,
	[191][225] = 190,
	[191][226] = 190,
	[191][227] = 190,
	[191][228] = 190,
	[191][229] = 190,
	[191][230] = 190,
	[191][231] = 190,
	[191][232] = 190,
	[191][233] = 190,
	[191][234] = 190,
	[191][235] = 190,
	[191][236] = 190,
	[191][237] = 190,
	[191][238] = 190,
	[191][239] = 190,
	[191][240] = 190,
	[191][241] = 190,
	[191][242] = 190,
	[191][243] = 190,
	[191][244] = 190,
	[191][245] = 190,
	[191][246] = 190,
	[191][247] = 190,
	[191][248] = 190,
	[191][249] = 190,
	[191][250] = 190,
	[191][251] = 190,
	[191][252] = 190,
	[191][253] = 190,
	[191][254] = 190,
	[191][255] = 190,
	[192][0] = 192,
	[192][1] = 192,
	[192][2] = 192,
	[192][3] = 192,
	[192][4] = 192,
	[192][5] = 192,
	[192][6] = 192,
	[192][7] = 192,
	[192][8] = 192,
	[192][9] = 192,
	[192][10] = 130,
	[192][11] = 192,
	[192][12] = 192,
	[192][13] = 192,
	[192][14] = 192,
	[192][15] = 192,
	[192][16] = 192,
	[192][17] = 192,
	[192][18] = 192,
	[192][19] = 192,
	[192][20] = 192,
	[192][21] = 192,
	[192][22] = 192,
	[192][23] = 192,
	[192][24] = 192,
	[192][25] = 192,
	[192][26] = 192,
	[192][27] = 192,
	[192][28] = 192,
	[192][29] = 192,
	[192][30] = 192,
	[192][31] = 192,
	[192][32] = 192,
	[192][33] = 192,
	[192][34] = 192,
	[192][35] = 192,
	[192][36] = 192,
	[192][37] = 192,
	[192][38] = 192,
	[192][39] = 192,
	[192][40] = 192,
	[192][41] = 192,
	[192][42] = 192,
	[192][43] = 192,
	[192][44] = 192,
	[192][45] = 192,
	[192][46] = 192,
	[192][47] = 192,
	[192][48] = 192,
	[192][49] = 192,
	[192][50] = 192,
	[192][51] = 192,
	[192][52] = 192,
	[192][53] = 192,
	[192][54] = 192,
	[192][55] = 192,
	[192][56] = 192,
	[192][57] = 192,
	[192][58] = 192,
	[192][59] = 192,
	[192][60] = 192,
	[192][61] = 192,
	[192][62] = 192,
	[192][63] = 192,
	[192][64] = 192,
	[192][65] = 192,
	[192][66] = 192,
	[192][67] = 192,
	[192][68] = 192,
	[192][69] = 192,
	[192][70] = 192,
	[192][71] = 192,
	[192][72] = 192,
	[192][73] = 192,
	[192][74] = 192,
	[192][75] = 192,
	[192][76] = 192,
	[192][77] = 192,
	[192][78] = 192,
	[192][79] = 192,
	[192][80] = 192,
	[192][81] = 192,
	[192][82] = 192,
	[192][83] = 192,
	[192][84] = 192,
	[192][85] = 192,
	[192][86] = 192,
	[192][87] = 192,
	[192][88] = 192,
	[192][89] = 192,
	[192][90] = 192,
	[192][91] = 192,
	[192][92] = 192,
	[192][93] = 192,
	[192][94] = 192,
	[192][95] = 192,
	[192][96] = 192,
	[192][97] = 192,
	[192][98] = 192,
	[192][99] = 192,
	[192][100] = 192,
	[192][101] = 192,
	[192][102] = 192,
	[192][103] = 192,
	[192][104] = 192,
	[192][105] = 192,
	[192][106] = 192,
	[192][107] = 192,
	[192][108] = 192,
	[192][109] = 192,
	[192][110] = 192,
	[192][111] = 192,
	[192][112] = 192,
	[192][113] = 192,
	[192][114] = 192,
	[192][115] = 192,
	[192][116] = 192,
	[192][117] = 192,
	[192][118] = 192,
	[192][119] = 192,
	[192][120] = 192,
	[192][121] = 192,
	[192][122] = 192,
	[192][123] = 192,
	[192][124] = 192,
	[192][125] = 192,
	[192][126] = 192,
	[192][127] = 192,
	[192][128] = 192,
	[192][129] = 192,
	[192][130] = 192,
	[192][131] = 192,
	[192][132] = 192,
	[192][133] = 192,
	[192][134] = 192,
	[192][135] = 192,
	[192][136] = 192,
	[192][137] = 192,
	[192][138] = 192,
	[192][139] = 192,
	[192][140] = 192,
	[192][141] = 192,
	[192][142] = 192,
	[192][143] = 192,
	[192][144] = 192,
	[192][145] = 192,
	[192][146] = 192,
	[192][147] = 192,
	[192][148] = 192,
	[192][149] = 192,
	[192][150] = 192,
	[192][151] = 192,
	[192][152] = 192,
	[192][153] = 192,
	[192][154] = 192,
	[192][155] = 192,
	[192][156] = 192,
	[192][157] = 192,
	[192][158] = 192,
	[192][159] = 192,
	[192][160] = 192,
	[192][161] = 192,
	[192][162] = 192,
	[192][163] = 192,
	[192][164] = 192,
	[192][165] = 192,
	[192][166] = 192,
	[192][167] = 192,
	[192][168] = 192,
	[192][169] = 192,
	[192][170] = 192,
	[192][171] = 192,
	[192][172] = 192,
	[192][173] = 192,
	[192][174] = 192,
	[192][175] = 192,
	[192][176] = 192,
	[192][177] = 192,
	[192][178] = 192,
	[192][179] = 192,
	[192][180] = 192,
	[192][181] = 192,
	[192][182] = 192,
	[192][183] = 192,
	[192][184] = 192,
	[192][185] = 192,
	[192][186] = 192,
	[192][187] = 192,
	[192][188] = 192,
	[192][189] = 192,
	[192][190] = 192,
	[192][191] = 192,
	[192][192] = 192,
	[192][193] = 192,
	[192][194] = 192,
	[192][195] = 192,
	[192][196] = 192,
	[192][197] = 192,
	[192][198] = 192,
	[192][199] = 192,
	[192][200] = 192,
	[192][201] = 192,
	[192][202] = 192,
	[192][203] = 192,
	[192][204] = 192,
	[192][205] = 192,
	[192][206] = 192,
	[192][207] = 192,
	[192][208] = 192,
	[192][209] = 192,
	[192][210] = 192,
	[192][211] = 192,
	[192][212] = 192,
	[192][213] = 192,
	[192][214] = 192,
	[192][215] = 192,
	[192][216] = 192,
	[192][217] = 192,
	[192][218] = 192,
	[192][219] = 192,
	[192][220] = 192,
	[192][221] = 192,
	[192][222] = 192,
	[192][223] = 192,
	[192][224] = 192,
	[192][225] = 192,
	[192][226] = 192,
	[192][227] = 192,
	[192][228] = 192,
	[192][229] = 192,
	[192][230] = 192,
	[192][231] = 192,
	[192][232] = 192,
	[192][233] = 192,
	[192][234] = 192,
	[192][235] = 192,
	[192][236] = 192,
	[192][237] = 192,
	[192][238] = 192,
	[192][239] = 192,
	[192][240] = 192,
	[192][241] = 192,
	[192][242] = 192,
	[192][243] = 192,
	[192][244] = 192,
	[192][245] = 192,
	[192][246] = 192,
	[192][247] = 192,
	[192][248] = 192,
	[192][249] = 192,
	[192][250] = 192,
	[192][251] = 192,
	[192][252] = 192,
	[192][253] = 192,
	[192][254] = 192,
	[192][255] = 192,
	[193][48] = 223,
	[193][49] = 223,
	[193][50] = 223,
	[193][51] = 223,
	[193][52] = 223,
	[193][53] = 223,
	[193][54] = 223,
	[193][55] = 223,
	[193][56] = 223,
	[193][57] = 223,
	[194][46] = 193,
	[194][48] = 194,
	[194][49] = 194,
	[194][50] = 194,
	[194][51] = 194,
	[194][52] = 194,
	[194][53] = 194,
	[194][54] = 194,
	[194][55] = 194,
	[194][56] = 194,
	[194][57] = 194,
	[195][49] = 183,
	[195][50] = 183,
	[195][51] = 183,
	[195][52] = 183,
	[195][53] = 183,
	[195][54] = 183,
	[195][55] = 183,
	[195][56] = 183,
	[195][57] = 183,
	[196][48] = 143,
	[196][49] = 143,
	[196][50] = 143,
	[196][51] = 143,
	[196][52] = 143,
	[196][53] = 143,
	[196][54] = 143,
	[196][55] = 143,
	[196][56] = 143,
	[196][57] = 143,
	[196][95] = 143,
	[196][97] = 143,
	[196][98] = 143,
	[196][99] = 143,
	[196][100] = 143,
	[196][101] = 143,
	[196][102] = 143,
	[196][103] = 143,
	[196][104] = 143,
	[196][105] = 143,
	[196][106] = 143,
	[196][107] = 143,
	[196][108] = 143,
	[196][109] = 143,
	[196][110] = 143,
	[196][111] = 143,
	[196][112] = 224,
	[196][113] = 143,
	[196][114] = 143,
	[196][115] = 143,
	[196][116] = 143,
	[196][117] = 143,
	[196][118] = 143,
	[196][119] = 143,
	[196][120] = 143,
	[196][121] = 143,
	[196][122] = 143,
	[205][115] = 225,
	[206][102] = 226,
	[207][112] = 227,
	[209][98] = 228,
	[210][114] = 229,
	[211][116] = 230,
	[212][105] = 231,
	[213][97] = 232,
	[214][105] = 233,
	[215][114] = 234,
	[216][48] = 143,
	[216][49] = 143,
	[216][50] = 143,
	[216][51] = 143,
	[216][52] = 143,
	[216][53] = 143,
	[216][54] = 143,
	[216][55] = 143,
	[216][56] = 143,
	[216][57] = 143,
	[216][95] = 143,
	[216][97] = 143,
	[216][98] = 143,
	[216][99] = 143,
	[216][100] = 143,
	[216][101] = 143,
	[216][102] = 143,
	[216][103] = 143,
	[216][104] = 143,
	[216][105] = 143,
	[216][106] = 143,
	[216][107] = 143,
	[216][108] = 143,
	[216][109] = 143,
	[216][110] = 143,
	[216][111] = 235,
	[216][112] = 143,
	[216][113] = 143,
	[216][114] = 143,
	[216][115] = 143,
	[216][116] = 143,
	[216][117] = 143,
	[216][118] = 143,
	[216][119] = 143,
	[216][120] = 143,
	[216][121] = 143,
	[216][122] = 143,
	[217][48] = 143,
	[217][49] = 143,
	[217][50] = 143,
	[217][51] = 143,
	[217][52] = 143,
	[217][53] = 143,
	[217][54] = 143,
	[217][55] = 143,
	[217][56] = 143,
	[217][57] = 143,
	[217][95] = 143,
	[217][97] = 236,
	[217][98] = 143,
	[217][99] = 143,
	[217][100] = 143,
	[217][101] = 143,
	[217][102] = 143,
	[217][103] = 143,
	[217][104] = 143,
	[217][105] = 143,
	[217][106] = 143,
	[217][107] = 143,
	[217][108] = 143,
	[217][109] = 143,
	[217][110] = 143,
	[217][111] = 143,
	[217][112] = 143,
	[217][113] = 143,
	[217][114] = 143,
	[217][115] = 143,
	[217][116] = 143,
	[217][117] = 143,
	[217][118] = 143,
	[217][119] = 143,
	[217][120] = 143,
	[217][121] = 143,
	[217][122] = 143,
	[218][48] = 143,
	[218][49] = 143,
	[218][50] = 143,
	[218][51] = 143,
	[218][52] = 143,
	[218][53] = 143,
	[218][54] = 143,
	[218][55] = 143,
	[218][56] = 143,
	[218][57] = 143,
	[218][95] = 143,
	[218][97] = 143,
	[218][98] = 143,
	[218][99] = 143,
	[218][100] = 143,
	[218][101] = 143,
	[218][102] = 143,
	[218][103] = 143,
	[218][104] = 143,
	[218][105] = 143,
	[218][106] = 143,
	[218][107] = 143,
	[218][108] = 143,
	[218][109] = 143,
	[218][110] = 143,
	[218][111] = 237,
	[218][112] = 143,
	[218][113] = 143,
	[218][114] = 143,
	[218][115] = 143,
	[218][116] = 143,
	[218][117] = 143,
	[218][118] = 143,
	[218][119] = 143,
	[218][120] = 143,
	[218][121] = 143,
	[218][122] = 143,
	[219][48] = 143,
	[219][49] = 143,
	[219][50] = 143,
	[219][51] = 143,
	[219][52] = 143,
	[219][53] = 143,
	[219][54] = 143,
	[219][55] = 143,
	[219][56] = 143,
	[219][57] = 143,
	[219][95] = 143,
	[219][97] = 143,
	[219][98] = 143,
	[219][99] = 143,
	[219][100] = 143,
	[219][101] = 143,
	[219][102] = 143,
	[219][103] = 143,
	[219][104] = 143,
	[219][105] = 143,
	[219][106] = 143,
	[219][107] = 143,
	[219][108] = 143,
	[219][109] = 143,
	[219][110] = 143,
	[219][111] = 143,
	[219][112] = 143,
	[219][113] = 143,
	[219][114] = 143,
	[219][115] = 143,
	[219][116] = 238,
	[219][117] = 143,
	[219][118] = 143,
	[219][119] = 143,
	[219][120] = 143,
	[219][121] = 143,
	[219][122] = 143,
	[221][91] = 239,
	[221][95] = 221,
	[221][97] = 221,
	[221][98] = 221,
	[221][99] = 221,
	[221][100] = 221,
	[221][101] = 221,
	[221][102] = 221,
	[221][103] = 221,
	[221][104] = 221,
	[221][105] = 221,
	[221][106] = 221,
	[221][107] = 221,
	[221][108] = 221,
	[221][109] = 221,
	[221][110] = 221,
	[221][111] = 221,
	[221][112] = 221,
	[221][113] = 221,
	[221][114] = 221,
	[221][115] = 221,
	[221][116] = 221,
	[221][117] = 221,
	[221][118] = 221,
	[221][119] = 221,
	[221][120] = 221,
	[221][121] = 221,
	[221][122] = 221,
	[223][48] = 223,
	[223][49] = 223,
	[223][50] = 223,
	[223][51] = 223,
	[223][52] = 223,
	[223][53] = 223,
	[223][54] = 223,
	[223][55] = 223,
	[223][56] = 223,
	[223][57] = 223,
	[224][48] = 143,
	[224][49] = 143,
	[224][50] = 143,
	[224][51] = 143,
	[224][52] = 143,
	[224][53] = 143,
	[224][54] = 143,
	[224][55] = 143,
	[224][56] = 143,
	[224][57] = 143,
	[224][95] = 143,
	[224][97] = 143,
	[224][98] = 143,
	[224][99] = 143,
	[224][100] = 143,
	[224][101] = 143,
	[224][102] = 143,
	[224][103] = 143,
	[224][104] = 143,
	[224][105] = 143,
	[224][106] = 143,
	[224][107] = 143,
	[224][108] = 143,
	[224][109] = 143,
	[224][110] = 143,
	[224][111] = 143,
	[224][112] = 143,
	[224][113] = 143,
	[224][114] = 143,
	[224][115] = 143,
	[224][116] = 143,
	[224][117] = 143,
	[224][118] = 143,
	[224][119] = 143,
	[224][120] = 143,
	[224][121] = 143,
	[224][122] = 143,
	[227][108] = 240,
	[228][117] = 241,
	[229][111] = 242,
	[230][101] = 243,
	[231][112] = 244,
	[232][114] = 245,
	[233][110] = 246,
	[234][110] = 247,
	[235][48] = 143,
	[235][49] = 143,
	[235][50] = 143,
	[235][51] = 143,
	[235][52] = 143,
	[235][53] = 143,
	[235][54] = 143,
	[235][55] = 143,
	[235][56] = 143,
	[235][57] = 143,
	[235][95] = 143,
	[235][97] = 143,
	[235][98] = 143,
	[235][99] = 143,
	[235][100] = 143,
	[235][101] = 143,
	[235][102] = 143,
	[235][103] = 143,
	[235][104] = 143,
	[235][105] = 143,
	[235][106] = 143,
	[235][107] = 143,
	[235][108] = 248,
	[235][109] = 143,
	[235][110] = 143,
	[235][111] = 143,
	[235][112] = 143,
	[235][113] = 143,
	[235][114] = 143,
	[235][115] = 143,
	[235][116] = 143,
	[235][117] = 143,
	[235][118] = 143,
	[235][119] = 143,
	[235][120] = 143,
	[235][121] = 143,
	[235][122] = 143,
	[236][48] = 143,
	[236][49] = 143,
	[236][50] = 143,
	[236][51] = 143,
	[236][52] = 143,
	[236][53] = 143,
	[236][54] = 143,
	[236][55] = 143,
	[236][56] = 143,
	[236][57] = 143,
	[236][95] = 143,
	[236][97] = 143,
	[236][98] = 143,
	[236][99] = 143,
	[236][100] = 143,
	[236][101] = 143,
	[236][102] = 143,
	[236][103] = 143,
	[236][104] = 143,
	[236][105] = 143,
	[236][106] = 143,
	[236][107] = 143,
	[236][108] = 143,
	[236][109] = 143,
	[236][110] = 143,
	[236][111] = 143,
	[236][112] = 143,
	[236][113] = 143,
	[236][114] = 249,
	[236][115] = 143,
	[236][116] = 143,
	[236][117] = 143,
	[236][118] = 143,
	[236][119] = 143,
	[236][120] = 143,
	[236][121] = 143,
	[236][122] = 143,
	[237][48] = 143,
	[237][49] = 143,
	[237][50] = 143,
	[237][51] = 143,
	[237][52] = 143,
	[237][53] = 143,
	[237][54] = 143,
	[237][55] = 143,
	[237][56] = 143,
	[237][57] = 143,
	[237][95] = 143,
	[237][97] = 250,
	[237][98] = 143,
	[237][99] = 143,
	[237][100] = 143,
	[237][101] = 143,
	[237][102] = 143,
	[237][103] = 143,
	[237][104] = 143,
	[237][105] = 143,
	[237][106] = 143,
	[237][107] = 143,
	[237][108] = 143,
	[237][109] = 143,
	[237][110] = 143,
	[237][111] = 143,
	[237][112] = 143,
	[237][113] = 143,
	[237][114] = 143,
	[237][115] = 143,
	[237][116] = 143,
	[237][117] = 143,
	[237][118] = 143,
	[237][119] = 143,
	[237][120] = 143,
	[237][121] = 143,
	[237][122] = 143,
	[238][48] = 143,
	[238][49] = 143,
	[238][50] = 143,
	[238][51] = 143,
	[238][52] = 143,
	[238][53] = 143,
	[238][54] = 143,
	[238][55] = 143,
	[238][56] = 143,
	[238][57] = 143,
	[238][95] = 143,
	[238][97] = 143,
	[238][98] = 143,
	[238][99] = 143,
	[238][100] = 143,
	[238][101] = 143,
	[238][102] = 143,
	[238][103] = 143,
	[238][104] = 143,
	[238][105] = 143,
	[238][106] = 143,
	[238][107] = 143,
	[238][108] = 143,
	[238][109] = 143,
	[238][110] = 143,
	[238][111] = 143,
	[238][112] = 143,
	[238][113] = 143,
	[238][114] = 143,
	[238][115] = 143,
	[238][116] = 143,
	[238][117] = 143,
	[238][118] = 143,
	[238][119] = 143,
	[238][120] = 143,
	[238][121] = 143,
	[238][122] = 143,
	[239][93] = 251,
	[240][105] = 252,
	[241][103] = 253,
	[242][114] = 254,
	[245][116] = 255,
	[246][103] = 256,
	[247][105] = 257,
	[248][48] = 143,
	[248][49] = 143,
	[248][50] = 143,
	[248][51] = 143,
	[248][52] = 143,
	[248][53] = 143,
	[248][54] = 143,
	[248][55] = 143,
	[248][56] = 143,
	[248][57] = 143,
	[248][95] = 143,
	[248][97] = 143,
	[248][98] = 143,
	[248][99] = 143,
	[248][100] = 143,
	[248][101] = 143,
	[248][102] = 143,
	[248][103] = 143,
	[248][104] = 143,
	[248][105] = 143,
	[248][106] = 143,
	[248][107] = 143,
	[248][108] = 143,
	[248][109] = 143,
	[248][110] = 143,
	[248][111] = 143,
	[248][112] = 143,
	[248][113] = 143,
	[248][114] = 143,
	[248][115] = 143,
	[248][116] = 143,
	[248][117] = 143,
	[248][118] = 143,
	[248][119] = 143,
	[248][120] = 143,
	[248][121] = 143,
	[248][122] = 143,
	[249][48] = 143,
	[249][49] = 143,
	[249][50] = 143,
	[249][51] = 143,
	[249][52] = 143,
	[249][53] = 143,
	[249][54] = 143,
	[249][55] = 143,
	[249][56] = 143,
	[249][57] = 143,
	[249][95] = 143,
	[249][97] = 143,
	[249][98] = 143,
	[249][99] = 143,
	[249][100] = 143,
	[249][101] = 143,
	[249][102] = 143,
	[249][103] = 143,
	[249][104] = 143,
	[249][105] = 143,
	[249][106] = 143,
	[249][107] = 143,
	[249][108] = 143,
	[249][109] = 143,
	[249][110] = 143,
	[249][111] = 143,
	[249][112] = 143,
	[249][113] = 143,
	[249][114] = 143,
	[249][115] = 143,
	[249][116] = 143,
	[249][117] = 143,
	[249][118] = 143,
	[249][119] = 143,
	[249][120] = 143,
	[249][121] = 143,
	[249][122] = 143,
	[250][48] = 143,
	[250][49] = 143,
	[250][50] = 143,
	[250][51] = 143,
	[250][52] = 143,
	[250][53] = 143,
	[250][54] = 143,
	[250][55] = 143,
	[250][56] = 143,
	[250][57] = 143,
	[250][95] = 143,
	[250][97] = 143,
	[250][98] = 143,
	[250][99] = 143,
	[250][100] = 143,
	[250][101] = 143,
	[250][102] = 143,
	[250][103] = 143,
	[250][104] = 143,
	[250][105] = 143,
	[250][106] = 143,
	[250][107] = 143,
	[250][108] = 143,
	[250][109] = 143,
	[250][110] = 143,
	[250][111] = 143,
	[250][112] = 143,
	[250][113] = 143,
	[250][114] = 143,
	[250][115] = 143,
	[250][116] = 258,
	[250][117] = 143,
	[250][118] = 143,
	[250][119] = 143,
	[250][120] = 143,
	[250][121] = 143,
	[250][122] = 143,
	[252][101] = 259,
	[257][110] = 260,
	[258][48] = 143,
	[258][49] = 143,
	[258][50] = 143,
	[258][51] = 143,
	[258][52] = 143,
	[258][53] = 143,
	[258][54] = 143,
	[258][55] = 143,
	[258][56] = 143,
	[258][57] = 143,
	[258][95] = 143,
	[258][97] = 143,
	[258][98] = 143,
	[258][99] = 143,
	[258][100] = 143,
	[258][101] = 143,
	[258][102] = 143,
	[258][103] = 143,
	[258][104] = 143,
	[258][105] = 143,
	[258][106] = 143,
	[258][107] = 143,
	[258][108] = 143,
	[258][109] = 143,
	[258][110] = 143,
	[258][111] = 143,
	[258][112] = 143,
	[258][113] = 143,
	[258][114] = 143,
	[258][115] = 143,
	[258][116] = 143,
	[258][117] = 143,
	[258][118] = 143,
	[258][119] = 143,
	[258][120] = 143,
	[258][121] = 143,
	[258][122] = 143,
	[259][115] = 261,
	[260][103] = 262,
};


const unsigned zebu_lexer_starts[1286] = {
	[1] = 1,
	[2] = 2,
	[3] = 2,
	[4] = 3,
	[5] = 4,
	[6] = 4,
	[7] = 2,
	[8] = 5,
	[9] = 4,
	[10] = 2,
	[11] = 6,
	[12] = 7,
	[13] = 4,
	[14] = 8,
	[15] = 9,
	[16] = 10,
	[17] = 11,
	[18] = 12,
	[19] = 13,
	[20] = 14,
	[21] = 15,
	[22] = 16,
	[23] = 17,
	[24] = 12,
	[25] = 18,
	[26] = 19,
	[27] = 13,
	[28] = 20,
	[29] = 21,
	[30] = 22,
	[31] = 23,
	[32] = 2,
	[33] = 2,
	[34] = 24,
	[35] = 25,
	[36] = 12,
	[37] = 12,
	[38] = 16,
	[39] = 12,
	[40] = 12,
	[41] = 26,
	[42] = 26,
	[43] = 3,
	[44] = 2,
	[45] = 4,
	[46] = 4,
	[47] = 27,
	[48] = 26,
	[49] = 5,
	[50] = 4,
	[51] = 26,
	[52] = 26,
	[53] = 7,
	[54] = 4,
	[55] = 9,
	[56] = 28,
	[57] = 29,
	[58] = 30,
	[59] = 31,
	[60] = 32,
	[61] = 33,
	[62] = 34,
	[63] = 35,
	[64] = 36,
	[65] = 30,
	[66] = 37,
	[67] = 38,
	[68] = 39,
	[69] = 40,
	[70] = 26,
	[71] = 26,
	[72] = 41,
	[73] = 42,
	[74] = 33,
	[75] = 2,
	[76] = 16,
	[77] = 16,
	[78] = 43,
	[79] = 43,
	[80] = 3,
	[81] = 4,
	[82] = 4,
	[83] = 27,
	[84] = 43,
	[85] = 5,
	[86] = 2,
	[87] = 4,
	[88] = 43,
	[89] = 43,
	[90] = 7,
	[91] = 4,
	[92] = 9,
	[93] = 44,
	[94] = 45,
	[95] = 46,
	[96] = 47,
	[97] = 48,
	[98] = 49,
	[99] = 50,
	[100] = 51,
	[101] = 52,
	[102] = 46,
	[103] = 53,
	[104] = 54,
	[105] = 55,
	[106] = 56,
	[107] = 43,
	[108] = 43,
	[109] = 57,
	[110] = 58,
	[111] = 49,
	[112] = 16,
	[113] = 59,
	[114] = 27,
	[115] = 3,
	[116] = 16,
	[117] = 60,
	[118] = 61,
	[119] = 61,
	[120] = 61,
	[121] = 61,
	[122] = 61,
	[123] = 61,
	[124] = 62,
	[125] = 63,
	[126] = 64,
	[127] = 27,
	[128] = 64,
	[129] = 64,
	[130] = 64,
	[131] = 64,
	[132] = 9,
	[133] = 64,
	[134] = 65,
	[135] = 4,
	[136] = 4,
	[137] = 4,
	[138] = 66,
	[139] = 12,
	[140] = 12,
	[141] = 12,
	[142] = 12,
	[143] = 12,
	[144] = 12,
	[145] = 4,
	[146] = 4,
	[147] = 4,
	[148] = 4,
	[149] = 12,
	[150] = 12,
	[151] = 66,
	[152] = 12,
	[153] = 12,
	[154] = 12,
	[155] = 12,
	[156] = 12,
	[157] = 12,
	[158] = 27,
	[159] = 4,
	[160] = 65,
	[161] = 4,
	[162] = 27,
	[163] = 4,
	[164] = 4,
	[165] = 4,
	[166] = 4,
	[167] = 27,
	[168] = 3,
	[169] = 27,
	[170] = 65,
	[171] = 4,
	[172] = 4,
	[173] = 4,
	[174] = 4,
	[175] = 4,
	[176] = 4,
	[177] = 66,
	[178] = 12,
	[179] = 12,
	[180] = 12,
	[181] = 12,
	[182] = 12,
	[183] = 12,
	[184] = 66,
	[185] = 12,
	[186] = 12,
	[187] = 12,
	[188] = 12,
	[189] = 12,
	[190] = 12,
	[191] = 66,
	[192] = 12,
	[193] = 12,
	[194] = 12,
	[195] = 12,
	[196] = 12,
	[197] = 12,
	[198] = 66,
	[199] = 12,
	[200] = 12,
	[201] = 12,
	[202] = 12,
	[203] = 12,
	[204] = 12,
	[205] = 26,
	[206] = 27,
	[207] = 34,
	[208] = 33,
	[209] = 33,
	[210] = 2,
	[211] = 34,
	[212] = 27,
	[213] = 26,
	[214] = 50,
	[215] = 33,
	[216] = 3,
	[217] = 33,
	[218] = 63,
	[219] = 27,
	[220] = 65,
	[221] = 4,
	[222] = 4,
	[223] = 4,
	[224] = 4,
	[225] = 4,
	[226] = 4,
	[227] = 4,
	[228] = 2,
	[229] = 27,
	[230] = 27,
	[231] = 4,
	[232] = 65,
	[233] = 4,
	[234] = 27,
	[235] = 4,
	[236] = 4,
	[237] = 4,
	[238] = 4,
	[239] = 27,
	[240] = 3,
	[241] = 27,
	[242] = 65,
	[243] = 4,
	[244] = 4,
	[245] = 4,
	[246] = 4,
	[247] = 4,
	[248] = 4,
	[249] = 43,
	[250] = 27,
	[251] = 34,
	[252] = 49,
	[253] = 49,
	[254] = 2,
	[255] = 50,
	[256] = 27,
	[257] = 43,
	[258] = 50,
	[259] = 49,
	[260] = 3,
	[261] = 49,
	[262] = 63,
	[263] = 27,
	[264] = 65,
	[265] = 4,
	[266] = 4,
	[267] = 4,
	[268] = 4,
	[269] = 4,
	[270] = 4,
	[271] = 4,
	[272] = 27,
	[273] = 2,
	[274] = 27,
	[275] = 4,
	[276] = 65,
	[277] = 4,
	[278] = 27,
	[279] = 4,
	[280] = 4,
	[281] = 4,
	[282] = 4,
	[283] = 27,
	[284] = 3,
	[285] = 27,
	[286] = 65,
	[287] = 4,
	[288] = 4,
	[289] = 4,
	[290] = 4,
	[291] = 4,
	[292] = 4,
	[293] = 67,
	[294] = 67,
	[295] = 59,
	[296] = 67,
	[297] = 68,
	[298] = 67,
	[299] = 69,
	[300] = 17,
	[301] = 70,
	[302] = 71,
	[303] = 72,
	[304] = 17,
	[305] = 2,
	[306] = 27,
	[307] = 34,
	[308] = 17,
	[309] = 69,
	[310] = 59,
	[311] = 27,
	[312] = 27,
	[313] = 27,
	[314] = 27,
	[315] = 62,
	[316] = 64,
	[317] = 63,
	[318] = 73,
	[319] = 73,
	[320] = 73,
	[321] = 73,
	[322] = 73,
	[323] = 9,
	[324] = 73,
	[325] = 34,
	[326] = 74,
	[327] = 13,
	[328] = 75,
	[329] = 65,
	[330] = 13,
	[331] = 13,
	[332] = 62,
	[333] = 63,
	[334] = 76,
	[335] = 63,
	[336] = 76,
	[337] = 76,
	[338] = 76,
	[339] = 76,
	[340] = 9,
	[341] = 76,
	[342] = 75,
	[343] = 64,
	[344] = 75,
	[345] = 22,
	[346] = 22,
	[347] = 14,
	[348] = 66,
	[349] = 66,
	[350] = 66,
	[351] = 66,
	[352] = 66,
	[353] = 66,
	[354] = 24,
	[355] = 24,
	[356] = 11,
	[357] = 16,
	[358] = 66,
	[359] = 66,
	[360] = 66,
	[361] = 66,
	[362] = 66,
	[363] = 66,
	[364] = 17,
	[365] = 18,
	[366] = 15,
	[367] = 23,
	[368] = 19,
	[369] = 77,
	[370] = 77,
	[371] = 3,
	[372] = 4,
	[373] = 4,
	[374] = 77,
	[375] = 5,
	[376] = 4,
	[377] = 77,
	[378] = 77,
	[379] = 7,
	[380] = 4,
	[381] = 9,
	[382] = 78,
	[383] = 79,
	[384] = 80,
	[385] = 81,
	[386] = 82,
	[387] = 83,
	[388] = 61,
	[389] = 84,
	[390] = 85,
	[391] = 80,
	[392] = 86,
	[393] = 87,
	[394] = 88,
	[395] = 89,
	[396] = 77,
	[397] = 77,
	[398] = 90,
	[399] = 91,
	[400] = 83,
	[401] = 20,
	[402] = 16,
	[403] = 16,
	[404] = 16,
	[405] = 18,
	[406] = 23,
	[407] = 2,
	[408] = 27,
	[409] = 34,
	[410] = 92,
	[411] = 92,
	[412] = 3,
	[413] = 4,
	[414] = 4,
	[415] = 92,
	[416] = 5,
	[417] = 4,
	[418] = 92,
	[419] = 92,
	[420] = 7,
	[421] = 4,
	[422] = 9,
	[423] = 93,
	[424] = 94,
	[425] = 95,
	[426] = 96,
	[427] = 97,
	[428] = 98,
	[429] = 99,
	[430] = 100,
	[431] = 101,
	[432] = 95,
	[433] = 102,
	[434] = 103,
	[435] = 104,
	[436] = 105,
	[437] = 92,
	[438] = 92,
	[439] = 106,
	[440] = 107,
	[441] = 98,
	[442] = 2,
	[443] = 25,
	[444] = 25,
	[445] = 25,
	[446] = 25,
	[447] = 10,
	[448] = 10,
	[449] = 66,
	[450] = 66,
	[451] = 66,
	[452] = 66,
	[453] = 66,
	[454] = 66,
	[455] = 66,
	[456] = 66,
	[457] = 66,
	[458] = 66,
	[459] = 66,
	[460] = 66,
	[461] = 66,
	[462] = 66,
	[463] = 66,
	[464] = 66,
	[465] = 66,
	[466] = 66,
	[467] = 66,
	[468] = 66,
	[469] = 66,
	[470] = 66,
	[471] = 66,
	[472] = 66,
	[473] = 26,
	[474] = 34,
	[475] = 26,
	[476] = 27,
	[477] = 2,
	[478] = 27,
	[479] = 26,
	[480] = 50,
	[481] = 27,
	[482] = 26,
	[483] = 26,
	[484] = 27,
	[485] = 34,
	[486] = 30,
	[487] = 75,
	[488] = 30,
	[489] = 30,
	[490] = 75,
	[491] = 39,
	[492] = 39,
	[493] = 31,
	[494] = 41,
	[495] = 41,
	[496] = 29,
	[497] = 33,
	[498] = 2,
	[499] = 34,
	[500] = 35,
	[501] = 32,
	[502] = 40,
	[503] = 36,
	[504] = 61,
	[505] = 37,
	[506] = 33,
	[507] = 33,
	[508] = 33,
	[509] = 35,
	[510] = 40,
	[511] = 26,
	[512] = 27,
	[513] = 34,
	[514] = 99,
	[515] = 26,
	[516] = 42,
	[517] = 42,
	[518] = 42,
	[519] = 42,
	[520] = 28,
	[521] = 28,
	[522] = 43,
	[523] = 34,
	[524] = 43,
	[525] = 27,
	[526] = 27,
	[527] = 2,
	[528] = 43,
	[529] = 50,
	[530] = 27,
	[531] = 43,
	[532] = 43,
	[533] = 27,
	[534] = 34,
	[535] = 46,
	[536] = 75,
	[537] = 46,
	[538] = 46,
	[539] = 75,
	[540] = 55,
	[541] = 55,
	[542] = 47,
	[543] = 57,
	[544] = 57,
	[545] = 45,
	[546] = 49,
	[547] = 2,
	[548] = 50,
	[549] = 51,
	[550] = 48,
	[551] = 56,
	[552] = 52,
	[553] = 61,
	[554] = 53,
	[555] = 49,
	[556] = 49,
	[557] = 49,
	[558] = 51,
	[559] = 56,
	[560] = 43,
	[561] = 27,
	[562] = 34,
	[563] = 99,
	[564] = 43,
	[565] = 58,
	[566] = 58,
	[567] = 58,
	[568] = 58,
	[569] = 44,
	[570] = 44,
	[571] = 67,
	[572] = 67,
	[573] = 108,
	[574] = 108,
	[575] = 59,
	[576] = 108,
	[577] = 68,
	[578] = 108,
	[579] = 69,
	[580] = 109,
	[581] = 110,
	[582] = 111,
	[583] = 112,
	[584] = 67,
	[585] = 113,
	[586] = 113,
	[587] = 68,
	[588] = 114,
	[589] = 99,
	[590] = 113,
	[591] = 115,
	[592] = 113,
	[593] = 116,
	[594] = 117,
	[595] = 67,
	[596] = 118,
	[597] = 118,
	[598] = 69,
	[599] = 118,
	[600] = 68,
	[601] = 119,
	[602] = 118,
	[603] = 120,
	[604] = 121,
	[605] = 12,
	[606] = 72,
	[607] = 72,
	[608] = 72,
	[609] = 59,
	[610] = 72,
	[611] = 12,
	[612] = 2,
	[613] = 34,
	[614] = 2,
	[615] = 27,
	[616] = 12,
	[617] = 122,
	[618] = 122,
	[619] = 69,
	[620] = 122,
	[621] = 68,
	[622] = 17,
	[623] = 122,
	[624] = 71,
	[625] = 123,
	[626] = 17,
	[627] = 12,
	[628] = 17,
	[629] = 12,
	[630] = 12,
	[631] = 12,
	[632] = 73,
	[633] = 63,
	[634] = 34,
	[635] = 64,
	[636] = 34,
	[637] = 63,
	[638] = 63,
	[639] = 75,
	[640] = 73,
	[641] = 64,
	[642] = 63,
	[643] = 63,
	[644] = 27,
	[645] = 75,
	[646] = 76,
	[647] = 63,
	[648] = 34,
	[649] = 65,
	[650] = 75,
	[651] = 65,
	[652] = 65,
	[653] = 63,
	[654] = 63,
	[655] = 75,
	[656] = 76,
	[657] = 63,
	[658] = 63,
	[659] = 63,
	[660] = 27,
	[661] = 27,
	[662] = 77,
	[663] = 27,
	[664] = 34,
	[665] = 83,
	[666] = 83,
	[667] = 27,
	[668] = 77,
	[669] = 50,
	[670] = 83,
	[671] = 3,
	[672] = 83,
	[673] = 63,
	[674] = 27,
	[675] = 65,
	[676] = 4,
	[677] = 4,
	[678] = 4,
	[679] = 4,
	[680] = 4,
	[681] = 4,
	[682] = 4,
	[683] = 4,
	[684] = 27,
	[685] = 4,
	[686] = 65,
	[687] = 4,
	[688] = 27,
	[689] = 4,
	[690] = 4,
	[691] = 4,
	[692] = 4,
	[693] = 27,
	[694] = 3,
	[695] = 27,
	[696] = 65,
	[697] = 4,
	[698] = 4,
	[699] = 4,
	[700] = 4,
	[701] = 4,
	[702] = 4,
	[703] = 27,
	[704] = 2,
	[705] = 34,
	[706] = 2,
	[707] = 27,
	[708] = 92,
	[709] = 27,
	[710] = 34,
	[711] = 98,
	[712] = 98,
	[713] = 27,
	[714] = 92,
	[715] = 50,
	[716] = 98,
	[717] = 3,
	[718] = 98,
	[719] = 63,
	[720] = 27,
	[721] = 65,
	[722] = 4,
	[723] = 4,
	[724] = 4,
	[725] = 4,
	[726] = 4,
	[727] = 4,
	[728] = 4,
	[729] = 2,
	[730] = 27,
	[731] = 4,
	[732] = 65,
	[733] = 4,
	[734] = 27,
	[735] = 4,
	[736] = 4,
	[737] = 4,
	[738] = 4,
	[739] = 27,
	[740] = 3,
	[741] = 27,
	[742] = 65,
	[743] = 4,
	[744] = 4,
	[745] = 4,
	[746] = 4,
	[747] = 4,
	[748] = 4,
	[749] = 26,
	[750] = 27,
	[751] = 26,
	[752] = 2,
	[753] = 27,
	[754] = 26,
	[755] = 26,
	[756] = 26,
	[757] = 34,
	[758] = 26,
	[759] = 27,
	[760] = 63,
	[761] = 27,
	[762] = 63,
	[763] = 27,
	[764] = 27,
	[765] = 4,
	[766] = 27,
	[767] = 26,
	[768] = 34,
	[769] = 26,
	[770] = 27,
	[771] = 26,
	[772] = 43,
	[773] = 27,
	[774] = 43,
	[775] = 2,
	[776] = 27,
	[777] = 43,
	[778] = 43,
	[779] = 43,
	[780] = 34,
	[781] = 43,
	[782] = 27,
	[783] = 63,
	[784] = 27,
	[785] = 63,
	[786] = 27,
	[787] = 27,
	[788] = 4,
	[789] = 27,
	[790] = 43,
	[791] = 34,
	[792] = 43,
	[793] = 27,
	[794] = 43,
	[795] = 67,
	[796] = 70,
	[797] = 67,
	[798] = 70,
	[799] = 108,
	[800] = 108,
	[801] = 109,
	[802] = 108,
	[803] = 99,
	[804] = 108,
	[805] = 119,
	[806] = 67,
	[807] = 112,
	[808] = 112,
	[809] = 112,
	[810] = 59,
	[811] = 112,
	[812] = 67,
	[813] = 70,
	[814] = 124,
	[815] = 124,
	[816] = 68,
	[817] = 114,
	[818] = 109,
	[819] = 124,
	[820] = 125,
	[821] = 124,
	[822] = 126,
	[823] = 127,
	[824] = 113,
	[825] = 67,
	[826] = 68,
	[827] = 68,
	[828] = 68,
	[829] = 68,
	[830] = 68,
	[831] = 117,
	[832] = 67,
	[833] = 70,
	[834] = 128,
	[835] = 128,
	[836] = 69,
	[837] = 128,
	[838] = 68,
	[839] = 109,
	[840] = 128,
	[841] = 111,
	[842] = 129,
	[843] = 99,
	[844] = 67,
	[845] = 121,
	[846] = 121,
	[847] = 121,
	[848] = 69,
	[849] = 121,
	[850] = 17,
	[851] = 71,
	[852] = 71,
	[853] = 72,
	[854] = 2,
	[855] = 27,
	[856] = 2,
	[857] = 109,
	[858] = 99,
	[859] = 12,
	[860] = 123,
	[861] = 123,
	[862] = 123,
	[863] = 69,
	[864] = 123,
	[865] = 12,
	[866] = 12,
	[867] = 73,
	[868] = 34,
	[869] = 73,
	[870] = 63,
	[871] = 64,
	[872] = 63,
	[873] = 34,
	[874] = 75,
	[875] = 34,
	[876] = 34,
	[877] = 63,
	[878] = 63,
	[879] = 64,
	[880] = 13,
	[881] = 13,
	[882] = 76,
	[883] = 34,
	[884] = 76,
	[885] = 63,
	[886] = 63,
	[887] = 63,
	[888] = 75,
	[889] = 75,
	[890] = 75,
	[891] = 75,
	[892] = 63,
	[893] = 63,
	[894] = 65,
	[895] = 65,
	[896] = 13,
	[897] = 13,
	[898] = 17,
	[899] = 77,
	[900] = 34,
	[901] = 77,
	[902] = 27,
	[903] = 77,
	[904] = 50,
	[905] = 27,
	[906] = 77,
	[907] = 77,
	[908] = 27,
	[909] = 34,
	[910] = 80,
	[911] = 75,
	[912] = 80,
	[913] = 80,
	[914] = 75,
	[915] = 88,
	[916] = 88,
	[917] = 81,
	[918] = 90,
	[919] = 90,
	[920] = 79,
	[921] = 83,
	[922] = 13,
	[923] = 61,
	[924] = 84,
	[925] = 82,
	[926] = 89,
	[927] = 85,
	[928] = 61,
	[929] = 86,
	[930] = 83,
	[931] = 83,
	[932] = 83,
	[933] = 84,
	[934] = 89,
	[935] = 77,
	[936] = 27,
	[937] = 34,
	[938] = 99,
	[939] = 77,
	[940] = 91,
	[941] = 91,
	[942] = 91,
	[943] = 91,
	[944] = 78,
	[945] = 78,
	[946] = 18,
	[947] = 2,
	[948] = 27,
	[949] = 2,
	[950] = 92,
	[951] = 34,
	[952] = 92,
	[953] = 27,
	[954] = 92,
	[955] = 50,
	[956] = 27,
	[957] = 92,
	[958] = 92,
	[959] = 27,
	[960] = 34,
	[961] = 95,
	[962] = 75,
	[963] = 95,
	[964] = 95,
	[965] = 75,
	[966] = 104,
	[967] = 104,
	[968] = 96,
	[969] = 106,
	[970] = 106,
	[971] = 94,
	[972] = 98,
	[973] = 99,
	[974] = 100,
	[975] = 97,
	[976] = 105,
	[977] = 101,
	[978] = 61,
	[979] = 102,
	[980] = 98,
	[981] = 98,
	[982] = 98,
	[983] = 100,
	[984] = 105,
	[985] = 92,
	[986] = 27,
	[987] = 34,
	[988] = 99,
	[989] = 92,
	[990] = 107,
	[991] = 107,
	[992] = 107,
	[993] = 107,
	[994] = 93,
	[995] = 93,
	[996] = 26,
	[997] = 26,
	[998] = 26,
	[999] = 27,
	[1000] = 26,
	[1001] = 30,
	[1002] = 30,
	[1003] = 30,
	[1004] = 30,
	[1005] = 34,
	[1006] = 30,
	[1007] = 35,
	[1008] = 26,
	[1009] = 27,
	[1010] = 26,
	[1011] = 43,
	[1012] = 43,
	[1013] = 43,
	[1014] = 27,
	[1015] = 43,
	[1016] = 46,
	[1017] = 46,
	[1018] = 46,
	[1019] = 46,
	[1020] = 50,
	[1021] = 46,
	[1022] = 51,
	[1023] = 43,
	[1024] = 27,
	[1025] = 43,
	[1026] = 70,
	[1027] = 70,
	[1028] = 108,
	[1029] = 110,
	[1030] = 108,
	[1031] = 110,
	[1032] = 108,
	[1033] = 108,
	[1034] = 110,
	[1035] = 108,
	[1036] = 108,
	[1037] = 110,
	[1038] = 108,
	[1039] = 67,
	[1040] = 109,
	[1041] = 111,
	[1042] = 111,
	[1043] = 112,
	[1044] = 70,
	[1045] = 109,
	[1046] = 124,
	[1047] = 113,
	[1048] = 68,
	[1049] = 68,
	[1050] = 68,
	[1051] = 68,
	[1052] = 68,
	[1053] = 127,
	[1054] = 67,
	[1055] = 117,
	[1056] = 115,
	[1057] = 116,
	[1058] = 116,
	[1059] = 68,
	[1060] = 114,
	[1061] = 116,
	[1062] = 116,
	[1063] = 115,
	[1064] = 116,
	[1065] = 99,
	[1066] = 117,
	[1067] = 99,
	[1068] = 117,
	[1069] = 68,
	[1070] = 68,
	[1071] = 99,
	[1072] = 117,
	[1073] = 70,
	[1074] = 109,
	[1075] = 99,
	[1076] = 118,
	[1077] = 129,
	[1078] = 129,
	[1079] = 129,
	[1080] = 69,
	[1081] = 129,
	[1082] = 118,
	[1083] = 67,
	[1084] = 119,
	[1085] = 120,
	[1086] = 120,
	[1087] = 121,
	[1088] = 59,
	[1089] = 71,
	[1090] = 2,
	[1091] = 122,
	[1092] = 122,
	[1093] = 17,
	[1094] = 71,
	[1095] = 71,
	[1096] = 123,
	[1097] = 73,
	[1098] = 63,
	[1099] = 73,
	[1100] = 64,
	[1101] = 63,
	[1102] = 63,
	[1103] = 34,
	[1104] = 34,
	[1105] = 76,
	[1106] = 63,
	[1107] = 76,
	[1108] = 65,
	[1109] = 65,
	[1110] = 63,
	[1111] = 63,
	[1112] = 75,
	[1113] = 75,
	[1114] = 77,
	[1115] = 27,
	[1116] = 77,
	[1117] = 27,
	[1118] = 77,
	[1119] = 77,
	[1120] = 77,
	[1121] = 34,
	[1122] = 77,
	[1123] = 27,
	[1124] = 63,
	[1125] = 27,
	[1126] = 63,
	[1127] = 27,
	[1128] = 27,
	[1129] = 4,
	[1130] = 27,
	[1131] = 77,
	[1132] = 34,
	[1133] = 77,
	[1134] = 27,
	[1135] = 77,
	[1136] = 2,
	[1137] = 92,
	[1138] = 27,
	[1139] = 92,
	[1140] = 27,
	[1141] = 92,
	[1142] = 92,
	[1143] = 92,
	[1144] = 34,
	[1145] = 92,
	[1146] = 27,
	[1147] = 63,
	[1148] = 27,
	[1149] = 63,
	[1150] = 27,
	[1151] = 27,
	[1152] = 4,
	[1153] = 27,
	[1154] = 92,
	[1155] = 34,
	[1156] = 92,
	[1157] = 27,
	[1158] = 92,
	[1159] = 26,
	[1160] = 26,
	[1161] = 43,
	[1162] = 43,
	[1163] = 110,
	[1164] = 110,
	[1165] = 108,
	[1166] = 110,
	[1167] = 108,
	[1168] = 110,
	[1169] = 108,
	[1170] = 70,
	[1171] = 59,
	[1172] = 111,
	[1173] = 124,
	[1174] = 127,
	[1175] = 125,
	[1176] = 126,
	[1177] = 126,
	[1178] = 68,
	[1179] = 114,
	[1180] = 126,
	[1181] = 126,
	[1182] = 125,
	[1183] = 126,
	[1184] = 109,
	[1185] = 127,
	[1186] = 109,
	[1187] = 127,
	[1188] = 68,
	[1189] = 68,
	[1190] = 109,
	[1191] = 127,
	[1192] = 67,
	[1193] = 70,
	[1194] = 68,
	[1195] = 109,
	[1196] = 116,
	[1197] = 68,
	[1198] = 99,
	[1199] = 99,
	[1200] = 99,
	[1201] = 99,
	[1202] = 99,
	[1203] = 128,
	[1204] = 128,
	[1205] = 109,
	[1206] = 111,
	[1207] = 111,
	[1208] = 129,
	[1209] = 67,
	[1210] = 70,
	[1211] = 69,
	[1212] = 120,
	[1213] = 17,
	[1214] = 69,
	[1215] = 71,
	[1216] = 73,
	[1217] = 34,
	[1218] = 34,
	[1219] = 76,
	[1220] = 75,
	[1221] = 75,
	[1222] = 77,
	[1223] = 77,
	[1224] = 77,
	[1225] = 27,
	[1226] = 77,
	[1227] = 80,
	[1228] = 80,
	[1229] = 80,
	[1230] = 80,
	[1231] = 61,
	[1232] = 80,
	[1233] = 84,
	[1234] = 77,
	[1235] = 27,
	[1236] = 77,
	[1237] = 92,
	[1238] = 92,
	[1239] = 92,
	[1240] = 27,
	[1241] = 92,
	[1242] = 95,
	[1243] = 95,
	[1244] = 95,
	[1245] = 95,
	[1246] = 99,
	[1247] = 95,
	[1248] = 100,
	[1249] = 92,
	[1250] = 27,
	[1251] = 92,
	[1252] = 110,
	[1253] = 108,
	[1254] = 110,
	[1255] = 108,
	[1256] = 110,
	[1257] = 109,
	[1258] = 68,
	[1259] = 109,
	[1260] = 126,
	[1261] = 68,
	[1262] = 109,
	[1263] = 109,
	[1264] = 109,
	[1265] = 109,
	[1266] = 109,
	[1267] = 70,
	[1268] = 117,
	[1269] = 116,
	[1270] = 115,
	[1271] = 69,
	[1272] = 111,
	[1273] = 70,
	[1274] = 119,
	[1275] = 17,
	[1276] = 77,
	[1277] = 77,
	[1278] = 92,
	[1279] = 92,
	[1280] = 110,
	[1281] = 110,
	[1282] = 127,
	[1283] = 126,
	[1284] = 125,
	[1285] = 109,
};


const unsigned zebu_lexer_accepts[263] = {
	[130] = 1,
	[131] = 5,
	[133] = 15,
	[134] = 14,
	[136] = 4,
	[137] = 9,
	[138] = 6,
	[140] = 3,
	[141] = 3,
	[142] = 8,
	[143] = 11,
	[144] = 11,
	[145] = 13,
	[147] = 16,
	[148] = 20,
	[149] = 21,
	[150] = 23,
	[151] = 37,
	[152] = 26,
	[154] = 27,
	[155] = 19,
	[156] = 17,
	[159] = 18,
	[160] = 38,
	[161] = 39,
	[162] = 40,
	[163] = 41,
	[164] = 42,
	[171] = 11,
	[172] = 11,
	[173] = 11,
	[174] = 11,
	[175] = 54,
	[179] = 20,
	[180] = 26,
	[181] = 27,
	[182] = 3,
	[183] = 3,
	[186] = 18,
	[187] = 16,
	[188] = 7,
	[196] = 11,
	[197] = 31,
	[198] = 32,
	[199] = 22,
	[200] = 24,
	[201] = 28,
	[202] = 30,
	[203] = 29,
	[204] = 25,
	[208] = 33,
	[216] = 11,
	[217] = 11,
	[218] = 11,
	[219] = 11,
	[220] = 55,
	[221] = 56,
	[222] = 2,
	[223] = 10,
	[224] = 12,
	[225] = 34,
	[226] = 36,
	[235] = 11,
	[236] = 11,
	[237] = 11,
	[238] = 50,
	[243] = 47,
	[244] = 44,
	[248] = 52,
	[249] = 51,
	[250] = 11,
	[251] = 56,
	[253] = 46,
	[254] = 49,
	[255] = 45,
	[256] = 43,
	[258] = 53,
	[261] = 35,
	[262] = 48,
};


const unsigned zebu_lexer_EOFs[67] = {
	[12] = 175,
	[66] = 175,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m)\n");
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_0$parameter(struct link* links, enum prefix p, const char* name, struct zebu_0$parameter* ptree);

void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree);

void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree);

void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree);

void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree);

void print_zebu_charset_highest(struct link* links, enum prefix p, const char* name, struct zebu_charset_highest* ptree);

void print_zebu_charset_intersect(struct link* links, enum prefix p, const char* name, struct zebu_charset_intersect* ptree);

void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree);

void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree);

void print_zebu_charset_symdiff(struct link* links, enum prefix p, const char* name, struct zebu_charset_symdiff* ptree);

void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree);

void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree);

void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree);

void print_zebu_exponentiation_expression(struct link* links, enum prefix p, const char* name, struct zebu_exponentiation_expression* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_grammar(struct link* links, enum prefix p, const char* name, struct zebu_grammar* ptree);

void print_zebu_grammar_highest(struct link* links, enum prefix p, const char* name, struct zebu_grammar_highest* ptree);

void print_zebu_grammar_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_grammar_juxtaposition* ptree);

void print_zebu_grammar_postfix(struct link* links, enum prefix p, const char* name, struct zebu_grammar_postfix* ptree);

void print_zebu_grammar_rule(struct link* links, enum prefix p, const char* name, struct zebu_grammar_rule* ptree);

void print_zebu_implication_expression(struct link* links, enum prefix p, const char* name, struct zebu_implication_expression* ptree);

void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree);

void print_zebu_lambda_expression(struct link* links, enum prefix p, const char* name, struct zebu_lambda_expression* ptree);

void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree);

void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree);

void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree);

void print_zebu_possession_expression(struct link* links, enum prefix p, const char* name, struct zebu_possession_expression* ptree);

void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree);

void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree);

void print_zebu_primary_type(struct link* links, enum prefix p, const char* name, struct zebu_primary_type* ptree);

void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree);

void print_zebu_regex_highest(struct link* links, enum prefix p, const char* name, struct zebu_regex_highest* ptree);

void print_zebu_regex_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_regex_juxtaposition* ptree);

void print_zebu_regex_postfix(struct link* links, enum prefix p, const char* name, struct zebu_regex_postfix* ptree);

void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree);

void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree);

void print_zebu_skip_directive(struct link* links, enum prefix p, const char* name, struct zebu_skip_directive* ptree);

void print_zebu_start_directive(struct link* links, enum prefix p, const char* name, struct zebu_start_directive* ptree);

void print_zebu_type(struct link* links, enum prefix p, const char* name, struct zebu_type* ptree);

void print_zebu_unary_expression(struct link* links, enum prefix p, const char* name, struct zebu_unary_expression* ptree);

void print_zebu_using_directive(struct link* links, enum prefix p, const char* name, struct zebu_using_directive* ptree);

void print_zebu_value_declare(struct link* links, enum prefix p, const char* name, struct zebu_value_declare* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m)\n", name);
	if (ptree->assertions.n)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "assertions[%u]", i);
			print_zebu_assertion(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->assertions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "assertion[]", "assertions");
	}
	if (ptree->declares.n)
	{
		for (unsigned i = 0, n = ptree->declares.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "declares[%u]", i);
			print_zebu_value_declare(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->declares.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "value_declare[]", "declares");
	}
	if (ptree->grammars.n)
	{
		for (unsigned i = 0, n = ptree->grammars.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "grammars[%u]", i);
			print_zebu_grammar_rule(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->grammars.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_rule[]", "grammars");
	}
	if (ptree->skips.n)
	{
		for (unsigned i = 0, n = ptree->skips.n; i < n; i++)
		{
			char label[5 + 30];
			snprintf(label, sizeof(label), "skips[%u]", i);
			print_zebu_skip_directive(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->skips.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "skip_directive[]", "skips");
	}
	if (ptree->starts.n)
	{
		for (unsigned i = 0, n = ptree->starts.n; i < n; i++)
		{
			char label[6 + 30];
			snprintf(label, sizeof(label), "starts[%u]", i);
			print_zebu_start_directive(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->starts.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "start_directive[]", "starts");
	}
	if (ptree->usings.n)
	{
		for (unsigned i = 0, n = ptree->usings.n; i < n; i++)
		{
			char label[6 + 30];
			snprintf(label, sizeof(label), "usings[%u]", i);
			print_zebu_using_directive(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->usings.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "using_directive[]", "usings");
	}
	free(new);
}
void print_zebu_0$parameter(struct link* links, enum prefix p, const char* name, struct zebu_0$parameter* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m0$parameter\e[m)\n", name);
	if (ptree->name)
		print_token_leaf(new ?: links, p_not_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "name");
	if (ptree->type)
		print_zebu_type(new ?: links, p_last_child, "type", ptree->type);
	else
		print_empty_leaf(new ?: links, p_last_child, "type", "type");
	free(new);
}
void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36madditive_expression\e[m)\n", name);
	if (ptree->add)
		print_token_leaf(new ?: links, p_not_last_child, "add", ptree->add);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "add");
	if (ptree->base)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "base");
	if (ptree->left)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "left");
	if (ptree->right)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "right");
	if (ptree->sub)
		print_token_leaf(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "sub");
	free(new);
}
void print_zebu_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mand_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "base");
	if (ptree->left)
		print_zebu_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "left");
	if (ptree->right)
		print_zebu_equality_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "equality_expression", "right");
	free(new);
}
void print_zebu_assertion(struct link* links, enum prefix p, const char* name, struct zebu_assertion* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36massertion\e[m)\n", name);
	if (ptree->debug)
		print_token_leaf(new ?: links, p_not_last_child, "debug", ptree->debug);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "debug");
	if (ptree->error)
		print_token_leaf(new ?: links, p_not_last_child, "error", ptree->error);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "error");
	if (ptree->expression)
		print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
	if (ptree->note)
		print_token_leaf(new ?: links, p_not_last_child, "note", ptree->note);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "note");
	if (ptree->warning)
		print_token_leaf(new ?: links, p_last_child, "warning", ptree->warning);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "warning");
	free(new);
}
void print_zebu_charset(struct link* links, enum prefix p, const char* name, struct zebu_charset* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_symdiff(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_symdiff", "base");
	if (ptree->ors.n)
	{
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
		{
			char label[3 + 30];
			snprintf(label, sizeof(label), "ors[%u]", i);
			print_zebu_charset_symdiff(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->ors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "charset_symdiff[]", "ors");
	}
	free(new);
}
void print_zebu_charset_highest(struct link* links, enum prefix p, const char* name, struct zebu_charset_highest* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_highest\e[m)\n", name);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->subcharset)
		print_zebu_charset(new ?: links, p_last_child, "subcharset", ptree->subcharset);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset", "subcharset");
	free(new);
}
void print_zebu_charset_intersect(struct link* links, enum prefix p, const char* name, struct zebu_charset_intersect* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_intersect\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_range(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_range", "base");
	if (ptree->intersects.n)
	{
		for (unsigned i = 0, n = ptree->intersects.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "intersects[%u]", i);
			print_zebu_charset_range(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->intersects.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "charset_range[]", "intersects");
	}
	free(new);
}
void print_zebu_charset_prefix(struct link* links, enum prefix p, const char* name, struct zebu_charset_prefix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_prefix\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_highest(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_highest", "base");
	if (ptree->emark)
		print_token_leaf(new ?: links, p_last_child, "emark", ptree->emark);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "emark");
	free(new);
}
void print_zebu_charset_range(struct link* links, enum prefix p, const char* name, struct zebu_charset_range* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_range\e[m)\n", name);
	if (ptree->left)
		print_zebu_charset_prefix(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_prefix", "left");
	if (ptree->right)
		print_zebu_charset_prefix(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "charset_prefix", "right");
	free(new);
}
void print_zebu_charset_symdiff(struct link* links, enum prefix p, const char* name, struct zebu_charset_symdiff* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mcharset_symdiff\e[m)\n", name);
	if (ptree->base)
		print_zebu_charset_intersect(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset_intersect", "base");
	if (ptree->xors.n)
	{
		for (unsigned i = 0, n = ptree->xors.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "xors[%u]", i);
			print_zebu_charset_intersect(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->xors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "charset_intersect[]", "xors");
	}
	free(new);
}
void print_zebu_conditional_expression(struct link* links, enum prefix p, const char* name, struct zebu_conditional_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mconditional_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "base");
	if (ptree->false_case)
		print_zebu_conditional_expression(new ?: links, p_not_last_child, "false_case", ptree->false_case);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "conditional_expression", "false_case");
	if (ptree->true_case)
		print_zebu_expression(new ?: links, p_last_child, "true_case", ptree->true_case);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "true_case");
	free(new);
}
void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mequality_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "base");
	if (ptree->left)
		print_zebu_equality_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "left");
	if (ptree->right)
		print_zebu_relational_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "relational_expression", "right");
	free(new);
}
void print_zebu_exclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_exclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexclusive_or_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_and_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "and_expression", "base");
	if (ptree->left)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "and_expression", "right");
	free(new);
}
void print_zebu_exponentiation_expression(struct link* links, enum prefix p, const char* name, struct zebu_exponentiation_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexponentiation_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_unary_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "unary_expression", "base");
	if (ptree->left)
		print_zebu_exponentiation_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exponentiation_expression", "left");
	if (ptree->right)
		print_zebu_unary_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "unary_expression", "right");
	free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression\e[m)\n", name);
	if (ptree->base)
		print_zebu_implication_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "implication_expression", "base");
	if (ptree->iffs.n)
	{
		for (unsigned i = 0, n = ptree->iffs.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "iffs[%u]", i);
			print_zebu_implication_expression(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->iffs.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "implication_expression[]", "iffs");
	}
	free(new);
}
void print_zebu_grammar(struct link* links, enum prefix p, const char* name, struct zebu_grammar* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar\e[m)\n", name);
	if (ptree->base)
		print_zebu_grammar_juxtaposition(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_juxtaposition", "base");
	if (ptree->ors.n)
	{
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
		{
			char label[3 + 30];
			snprintf(label, sizeof(label), "ors[%u]", i);
			print_zebu_grammar_juxtaposition(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->ors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "grammar_juxtaposition[]", "ors");
	}
	free(new);
}
void print_zebu_grammar_highest(struct link* links, enum prefix p, const char* name, struct zebu_grammar_highest* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_highest\e[m)\n", name);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->charset)
		print_zebu_charset(new ?: links, p_not_last_child, "charset", ptree->charset);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset", "charset");
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->name)
		print_token_leaf(new ?: links, p_not_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "name");
	if (ptree->regex)
		print_zebu_regex(new ?: links, p_not_last_child, "regex", ptree->regex);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex", "regex");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->subgrammar)
		print_zebu_grammar(new ?: links, p_not_last_child, "subgrammar", ptree->subgrammar);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar", "subgrammar");
	if (ptree->tags.n)
	{
		for (unsigned i = 0, n = ptree->tags.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "tags[%u]", i);
			print_token_leaf(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->tags.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "token[]", "tags");
	}
	free(new);
}
void print_zebu_grammar_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_grammar_juxtaposition* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_juxtaposition\e[m)\n", name);
	if (ptree->base)
		print_zebu_grammar_postfix(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_postfix", "base");
	if (ptree->juxtapositions.n)
	{
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
		{
			char label[14 + 30];
			snprintf(label, sizeof(label), "juxtapositions[%u]", i);
			print_zebu_grammar_postfix(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->juxtapositions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "grammar_postfix[]", "juxtapositions");
	}
	free(new);
}
void print_zebu_grammar_postfix(struct link* links, enum prefix p, const char* name, struct zebu_grammar_postfix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_postfix\e[m)\n", name);
	if (ptree->base)
		print_zebu_grammar_highest(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar_highest", "base");
	if (ptree->plus)
		print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
	if (ptree->qmark)
		print_token_leaf(new ?: links, p_not_last_child, "qmark", ptree->qmark);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "qmark");
	if (ptree->star)
		print_token_leaf(new ?: links, p_last_child, "star", ptree->star);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "star");
	free(new);
}
void print_zebu_grammar_rule(struct link* links, enum prefix p, const char* name, struct zebu_grammar_rule* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mgrammar_rule\e[m)\n", name);
	if (ptree->grammar)
		print_zebu_grammar(new ?: links, p_not_last_child, "grammar", ptree->grammar);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "grammar", "grammar");
	if (ptree->name)
		print_token_leaf(new ?: links, p_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "name");
	free(new);
}
void print_zebu_implication_expression(struct link* links, enum prefix p, const char* name, struct zebu_implication_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mimplication_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_possession_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "possession_expression", "base");
	if (ptree->implies.n)
	{
		for (unsigned i = 0, n = ptree->implies.n; i < n; i++)
		{
			char label[7 + 30];
			snprintf(label, sizeof(label), "implies[%u]", i);
			print_zebu_possession_expression(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->implies.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "possession_expression[]", "implies");
	}
	free(new);
}
void print_zebu_inclusive_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_inclusive_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36minclusive_or_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_exclusive_or_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exclusive_or_expression", "base");
	if (ptree->left)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "left");
	if (ptree->right)
		print_zebu_exclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "exclusive_or_expression", "right");
	free(new);
}
void print_zebu_lambda_expression(struct link* links, enum prefix p, const char* name, struct zebu_lambda_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlambda_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_conditional_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "conditional_expression", "base");
	if (ptree->lambda)
		print_zebu_lambda_expression(new ?: links, p_not_last_child, "lambda", ptree->lambda);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "lambda_expression", "lambda");
	print_empty_leaf(new ?: links, p_not_last_child, "struct unresolved*", "lambda_captures");
	if (ptree->name)
		print_token_leaf(new ?: links, p_not_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "name");
	if (ptree->parameters.n)
	{
		for (unsigned i = 0, n = ptree->parameters.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "parameters[%u]", i);
			print_zebu_0$parameter(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->parameters.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "0$parameter[]", "parameters");
	}
	if (ptree->type)
		print_zebu_type(new ?: links, p_last_child, "type", ptree->type);
	else
		print_empty_leaf(new ?: links, p_last_child, "type", "type");
	free(new);
}
void print_zebu_logical_and_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_and_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_and_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_inclusive_or_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "inclusive_or_expression", "base");
	if (ptree->left)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "left");
	if (ptree->right)
		print_zebu_inclusive_or_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "inclusive_or_expression", "right");
	free(new);
}
void print_zebu_logical_or_expression(struct link* links, enum prefix p, const char* name, struct zebu_logical_or_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mlogical_or_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_logical_and_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_and_expression", "base");
	if (ptree->left)
		print_zebu_logical_or_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "logical_or_expression", "left");
	if (ptree->right)
		print_zebu_logical_and_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "logical_and_expression", "right");
	free(new);
}
void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mmultiplicative_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_exponentiation_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "exponentiation_expression", "base");
	if (ptree->left)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "left");
	if (ptree->right)
		print_zebu_exponentiation_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "exponentiation_expression", "right");
	free(new);
}
void print_zebu_possession_expression(struct link* links, enum prefix p, const char* name, struct zebu_possession_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mpossession_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_lambda_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "lambda_expression", "base");
	if (ptree->has)
		print_token_leaf(new ?: links, p_last_child, "has", ptree->has);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "has");
	free(new);
}
void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mpostfix_expression\e[m)\n", name);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_expression(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "expression[]", "args");
	}
	if (ptree->base)
		print_zebu_primary_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_expression", "base");
	if (ptree->call)
		print_token_leaf(new ?: links, p_not_last_child, "call", ptree->call);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "call");
	if (ptree->field)
		print_token_leaf(new ?: links, p_not_last_child, "field", ptree->field);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "field");
	if (ptree->index)
		print_zebu_expression(new ?: links, p_not_last_child, "index", ptree->index);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "index");
	if (ptree->sub)
		print_zebu_postfix_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "postfix_expression", "sub");
	free(new);
}
void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprimary_expression\e[m)\n", name);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_expression(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "expression[]", "args");
	}
	if (ptree->character_literal)
		print_token_leaf(new ?: links, p_not_last_child, "character_literal", ptree->character_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character_literal");
	if (ptree->elements.n)
	{
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "elements[%u]", i);
			print_zebu_expression(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->elements.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "expression[]", "elements");
	}
	if (ptree->float_literal)
		print_token_leaf(new ?: links, p_not_last_child, "float_literal", ptree->float_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "float_literal");
	if (ptree->identifier)
		print_token_leaf(new ?: links, p_not_last_child, "identifier", ptree->identifier);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "identifier");
	if (ptree->integer_literal)
		print_token_leaf(new ?: links, p_not_last_child, "integer_literal", ptree->integer_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer_literal");
	if (ptree->list)
		print_token_leaf(new ?: links, p_not_last_child, "list", ptree->list);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "list");
	if (ptree->map)
		print_token_leaf(new ?: links, p_not_last_child, "map", ptree->map);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "map");
	if (ptree->string_literal)
		print_token_leaf(new ?: links, p_not_last_child, "string_literal", ptree->string_literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string_literal");
	if (ptree->tuple)
		print_token_leaf(new ?: links, p_not_last_child, "tuple", ptree->tuple);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "tuple");
	print_empty_leaf(new ?: links, p_not_last_child, "struct type*", "type");
	print_empty_leaf(new ?: links, p_last_child, "struct value*", "value");
	free(new);
}
void print_zebu_primary_type(struct link* links, enum prefix p, const char* name, struct zebu_primary_type* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprimary_type\e[m)\n", name);
	if (ptree->array)
		print_zebu_primary_type(new ?: links, p_not_last_child, "array", ptree->array);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_type", "array");
	if (ptree->bool_type)
		print_token_leaf(new ?: links, p_not_last_child, "bool_type", ptree->bool_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "bool_type");
	if (ptree->char_type)
		print_token_leaf(new ?: links, p_not_last_child, "char_type", ptree->char_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "char_type");
	if (ptree->elements.n)
	{
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
		{
			char label[8 + 30];
			snprintf(label, sizeof(label), "elements[%u]", i);
			print_zebu_type(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->elements.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "type[]", "elements");
	}
	if (ptree->float_type)
		print_token_leaf(new ?: links, p_not_last_child, "float_type", ptree->float_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "float_type");
	if (ptree->grammar)
		print_token_leaf(new ?: links, p_not_last_child, "grammar", ptree->grammar);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "grammar");
	if (ptree->int_type)
		print_token_leaf(new ?: links, p_not_last_child, "int_type", ptree->int_type);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "int_type");
	if (ptree->tuple)
		print_token_leaf(new ?: links, p_last_child, "tuple", ptree->tuple);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "tuple");
	free(new);
}
void print_zebu_regex(struct link* links, enum prefix p, const char* name, struct zebu_regex* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex\e[m)\n", name);
	if (ptree->base)
		print_zebu_regex_juxtaposition(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_juxtaposition", "base");
	if (ptree->ors.n)
	{
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
		{
			char label[3 + 30];
			snprintf(label, sizeof(label), "ors[%u]", i);
			print_zebu_regex_juxtaposition(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->ors.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "regex_juxtaposition[]", "ors");
	}
	free(new);
}
void print_zebu_regex_highest(struct link* links, enum prefix p, const char* name, struct zebu_regex_highest* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_highest\e[m)\n", name);
	if (ptree->character)
		print_token_leaf(new ?: links, p_not_last_child, "character", ptree->character);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "character");
	if (ptree->charset)
		print_zebu_charset(new ?: links, p_not_last_child, "charset", ptree->charset);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "charset", "charset");
	if (ptree->integer)
		print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
	if (ptree->string)
		print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
	if (ptree->subregex)
		print_zebu_regex(new ?: links, p_last_child, "subregex", ptree->subregex);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex", "subregex");
	free(new);
}
void print_zebu_regex_juxtaposition(struct link* links, enum prefix p, const char* name, struct zebu_regex_juxtaposition* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_juxtaposition\e[m)\n", name);
	if (ptree->base)
		print_zebu_regex_postfix(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_postfix", "base");
	if (ptree->juxtapositions.n)
	{
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
		{
			char label[14 + 30];
			snprintf(label, sizeof(label), "juxtapositions[%u]", i);
			print_zebu_regex_postfix(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->juxtapositions.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "regex_postfix[]", "juxtapositions");
	}
	free(new);
}
void print_zebu_regex_postfix(struct link* links, enum prefix p, const char* name, struct zebu_regex_postfix* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mregex_postfix\e[m)\n", name);
	if (ptree->base)
		print_zebu_regex_highest(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "regex_highest", "base");
	if (ptree->plus)
		print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
	if (ptree->qmark)
		print_token_leaf(new ?: links, p_not_last_child, "qmark", ptree->qmark);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "qmark");
	if (ptree->star)
		print_token_leaf(new ?: links, p_last_child, "star", ptree->star);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "star");
	free(new);
}
void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mrelational_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "base");
	if (ptree->left)
		print_zebu_relational_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "left");
	if (ptree->right)
		print_zebu_shift_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "shift_expression", "right");
	free(new);
}
void print_zebu_shift_expression(struct link* links, enum prefix p, const char* name, struct zebu_shift_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mshift_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "base");
	if (ptree->left)
		print_zebu_shift_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "shift_expression", "left");
	if (ptree->right)
		print_zebu_additive_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "additive_expression", "right");
	free(new);
}
void print_zebu_skip_directive(struct link* links, enum prefix p, const char* name, struct zebu_skip_directive* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mskip_directive\e[m)\n", name);
	if (ptree->regex)
		print_zebu_regex(new ?: links, p_last_child, "regex", ptree->regex);
	else
		print_empty_leaf(new ?: links, p_last_child, "regex", "regex");
	free(new);
}
void print_zebu_start_directive(struct link* links, enum prefix p, const char* name, struct zebu_start_directive* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mstart_directive\e[m)\n", name);
	if (ptree->grammar)
		print_zebu_grammar(new ?: links, p_last_child, "grammar", ptree->grammar);
	else
		print_empty_leaf(new ?: links, p_last_child, "grammar", "grammar");
	free(new);
}
void print_zebu_type(struct link* links, enum prefix p, const char* name, struct zebu_type* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mtype\e[m)\n", name);
	if (ptree->args.n)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
		{
			char label[4 + 30];
			snprintf(label, sizeof(label), "args[%u]", i);
			print_zebu_type(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->args.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_not_last_child, "type[]", "args");
	}
	if (ptree->base)
		print_zebu_primary_type(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "primary_type", "base");
	if (ptree->rettype)
		print_zebu_type(new ?: links, p_last_child, "rettype", ptree->rettype);
	else
		print_empty_leaf(new ?: links, p_last_child, "type", "rettype");
	free(new);
}
void print_zebu_unary_expression(struct link* links, enum prefix p, const char* name, struct zebu_unary_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36munary_expression\e[m)\n", name);
	if (ptree->base)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "base", ptree->base);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "base");
	if (ptree->sub)
		print_zebu_unary_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "unary_expression", "sub");
	free(new);
}
void print_zebu_using_directive(struct link* links, enum prefix p, const char* name, struct zebu_using_directive* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36musing_directive\e[m)\n", name);
	if (ptree->path)
		print_token_leaf(new ?: links, p_last_child, "path", ptree->path);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "path");
	free(new);
}
void print_zebu_value_declare(struct link* links, enum prefix p, const char* name, struct zebu_value_declare* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mvalue_declare\e[m)\n", name);
	if (ptree->expression)
		print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
	if (ptree->name)
		print_token_leaf(new ?: links, p_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "name");
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* this)
{
	if (this) this->refcount++;
	return this;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_0$parameter* inc_zebu_0$parameter(struct zebu_0$parameter* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_additive_expression* inc_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_and_expression* inc_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_assertion* inc_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset* inc_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_highest* inc_zebu_charset_highest(struct zebu_charset_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_intersect* inc_zebu_charset_intersect(struct zebu_charset_intersect* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_prefix* inc_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_range* inc_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_charset_symdiff* inc_zebu_charset_symdiff(struct zebu_charset_symdiff* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_conditional_expression* inc_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_equality_expression* inc_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_exclusive_or_expression* inc_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_exponentiation_expression* inc_zebu_exponentiation_expression(struct zebu_exponentiation_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar* inc_zebu_grammar(struct zebu_grammar* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_highest* inc_zebu_grammar_highest(struct zebu_grammar_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_juxtaposition* inc_zebu_grammar_juxtaposition(struct zebu_grammar_juxtaposition* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_postfix* inc_zebu_grammar_postfix(struct zebu_grammar_postfix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_grammar_rule* inc_zebu_grammar_rule(struct zebu_grammar_rule* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_implication_expression* inc_zebu_implication_expression(struct zebu_implication_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_inclusive_or_expression* inc_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_lambda_expression* inc_zebu_lambda_expression(struct zebu_lambda_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_and_expression* inc_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_logical_or_expression* inc_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_multiplicative_expression* inc_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_possession_expression* inc_zebu_possession_expression(struct zebu_possession_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_postfix_expression* inc_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_expression* inc_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_type* inc_zebu_primary_type(struct zebu_primary_type* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex* inc_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_highest* inc_zebu_regex_highest(struct zebu_regex_highest* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_juxtaposition* inc_zebu_regex_juxtaposition(struct zebu_regex_juxtaposition* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_regex_postfix* inc_zebu_regex_postfix(struct zebu_regex_postfix* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_relational_expression* inc_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_shift_expression* inc_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_skip_directive* inc_zebu_skip_directive(struct zebu_skip_directive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_start_directive* inc_zebu_start_directive(struct zebu_start_directive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_type* inc_zebu_type(struct zebu_type* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_unary_expression* inc_zebu_unary_expression(struct zebu_unary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_using_directive* inc_zebu_using_directive(struct zebu_using_directive* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_value_declare* inc_zebu_value_declare(struct zebu_value_declare* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* this);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_0$parameter(struct zebu_0$parameter* ptree);

extern void free_zebu_additive_expression(struct zebu_additive_expression* ptree);

extern void free_zebu_and_expression(struct zebu_and_expression* ptree);

extern void free_zebu_assertion(struct zebu_assertion* ptree);

extern void free_zebu_charset(struct zebu_charset* ptree);

extern void free_zebu_charset_highest(struct zebu_charset_highest* ptree);

extern void free_zebu_charset_intersect(struct zebu_charset_intersect* ptree);

extern void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree);

extern void free_zebu_charset_range(struct zebu_charset_range* ptree);

extern void free_zebu_charset_symdiff(struct zebu_charset_symdiff* ptree);

extern void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree);

extern void free_zebu_equality_expression(struct zebu_equality_expression* ptree);

extern void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree);

extern void free_zebu_exponentiation_expression(struct zebu_exponentiation_expression* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_grammar(struct zebu_grammar* ptree);

extern void free_zebu_grammar_highest(struct zebu_grammar_highest* ptree);

extern void free_zebu_grammar_juxtaposition(struct zebu_grammar_juxtaposition* ptree);

extern void free_zebu_grammar_postfix(struct zebu_grammar_postfix* ptree);

extern void free_zebu_grammar_rule(struct zebu_grammar_rule* ptree);

extern void free_zebu_implication_expression(struct zebu_implication_expression* ptree);

extern void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree);

extern void free_zebu_lambda_expression(struct zebu_lambda_expression* ptree);

extern void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree);

extern void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree);

extern void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree);

extern void free_zebu_possession_expression(struct zebu_possession_expression* ptree);

extern void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree);

extern void free_zebu_primary_expression(struct zebu_primary_expression* ptree);

extern void free_zebu_primary_type(struct zebu_primary_type* ptree);

extern void free_zebu_regex(struct zebu_regex* ptree);

extern void free_zebu_regex_highest(struct zebu_regex_highest* ptree);

extern void free_zebu_regex_juxtaposition(struct zebu_regex_juxtaposition* ptree);

extern void free_zebu_regex_postfix(struct zebu_regex_postfix* ptree);

extern void free_zebu_relational_expression(struct zebu_relational_expression* ptree);

extern void free_zebu_shift_expression(struct zebu_shift_expression* ptree);

extern void free_zebu_skip_directive(struct zebu_skip_directive* ptree);

extern void free_zebu_start_directive(struct zebu_start_directive* ptree);

extern void free_zebu_type(struct zebu_type* ptree);

extern void free_zebu_unary_expression(struct zebu_unary_expression* ptree);

extern void free_zebu_using_directive(struct zebu_using_directive* ptree);

extern void free_zebu_value_declare(struct zebu_value_declare* ptree);

void free_zebu_token(struct zebu_token* this)
{
	if (this && !--this->refcount)
	{
		free(this->data);
		free(this);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->assertions.n; i < n; i++)
			free_zebu_assertion(ptree->assertions.data[i]);
		free(ptree->assertions.data);
		for (unsigned i = 0, n = ptree->declares.n; i < n; i++)
			free_zebu_value_declare(ptree->declares.data[i]);
		free(ptree->declares.data);
		for (unsigned i = 0, n = ptree->grammars.n; i < n; i++)
			free_zebu_grammar_rule(ptree->grammars.data[i]);
		free(ptree->grammars.data);
		for (unsigned i = 0, n = ptree->skips.n; i < n; i++)
			free_zebu_skip_directive(ptree->skips.data[i]);
		free(ptree->skips.data);
		for (unsigned i = 0, n = ptree->starts.n; i < n; i++)
			free_zebu_start_directive(ptree->starts.data[i]);
		free(ptree->starts.data);
		for (unsigned i = 0, n = ptree->usings.n; i < n; i++)
			free_zebu_using_directive(ptree->usings.data[i]);
		free(ptree->usings.data);
		free(ptree);
	}
}

void free_zebu_0$parameter(struct zebu_0$parameter* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->name);
		free_zebu_type(ptree->type);
		free(ptree);
	}
}

void free_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->add);
		free_zebu_multiplicative_expression(ptree->base);
		free_zebu_additive_expression(ptree->left);
		free_zebu_multiplicative_expression(ptree->right);
		free_zebu_token(ptree->sub);
		free(ptree);
	}
}

void free_zebu_and_expression(struct zebu_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_equality_expression(ptree->base);
		free_zebu_and_expression(ptree->left);
		free_zebu_equality_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_assertion(struct zebu_assertion* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->debug);
		free_zebu_token(ptree->error);
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->note);
		free_zebu_token(ptree->warning);
		free(ptree);
	}
}

void free_zebu_charset(struct zebu_charset* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_symdiff(ptree->base);
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
			free_zebu_charset_symdiff(ptree->ors.data[i]);
		free(ptree->ors.data);
		free(ptree);
	}
}

void free_zebu_charset_highest(struct zebu_charset_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_token(ptree->integer);
		free_zebu_charset(ptree->subcharset);
		free(ptree);
	}
}

void free_zebu_charset_intersect(struct zebu_charset_intersect* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_range(ptree->base);
		for (unsigned i = 0, n = ptree->intersects.n; i < n; i++)
			free_zebu_charset_range(ptree->intersects.data[i]);
		free(ptree->intersects.data);
		free(ptree);
	}
}

void free_zebu_charset_prefix(struct zebu_charset_prefix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_highest(ptree->base);
		free_zebu_token(ptree->emark);
		free(ptree);
	}
}

void free_zebu_charset_range(struct zebu_charset_range* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_prefix(ptree->left);
		free_zebu_charset_prefix(ptree->right);
		free(ptree);
	}
}

void free_zebu_charset_symdiff(struct zebu_charset_symdiff* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_charset_intersect(ptree->base);
		for (unsigned i = 0, n = ptree->xors.n; i < n; i++)
			free_zebu_charset_intersect(ptree->xors.data[i]);
		free(ptree->xors.data);
		free(ptree);
	}
}

void free_zebu_conditional_expression(struct zebu_conditional_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_or_expression(ptree->base);
		free_zebu_conditional_expression(ptree->false_case);
		free_zebu_expression(ptree->true_case);
		free(ptree);
	}
}

void free_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_relational_expression(ptree->base);
		free_zebu_equality_expression(ptree->left);
		free_zebu_relational_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_exclusive_or_expression(struct zebu_exclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_and_expression(ptree->base);
		free_zebu_exclusive_or_expression(ptree->left);
		free_zebu_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_exponentiation_expression(struct zebu_exponentiation_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_unary_expression(ptree->base);
		free_zebu_exponentiation_expression(ptree->left);
		free_zebu_unary_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_implication_expression(ptree->base);
		for (unsigned i = 0, n = ptree->iffs.n; i < n; i++)
			free_zebu_implication_expression(ptree->iffs.data[i]);
		free(ptree->iffs.data);
		free(ptree);
	}
}

void free_zebu_grammar(struct zebu_grammar* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar_juxtaposition(ptree->base);
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
			free_zebu_grammar_juxtaposition(ptree->ors.data[i]);
		free(ptree->ors.data);
		free(ptree);
	}
}

void free_zebu_grammar_highest(struct zebu_grammar_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->charset);
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->name);
		free_zebu_regex(ptree->regex);
		free_zebu_token(ptree->string);
		free_zebu_grammar(ptree->subgrammar);
		for (unsigned i = 0, n = ptree->tags.n; i < n; i++)
			free_zebu_token(ptree->tags.data[i]);
		free(ptree->tags.data);
		free(ptree);
	}
}

void free_zebu_grammar_juxtaposition(struct zebu_grammar_juxtaposition* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar_postfix(ptree->base);
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
			free_zebu_grammar_postfix(ptree->juxtapositions.data[i]);
		free(ptree->juxtapositions.data);
		free(ptree);
	}
}

void free_zebu_grammar_postfix(struct zebu_grammar_postfix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar_highest(ptree->base);
		free_zebu_token(ptree->plus);
		free_zebu_token(ptree->qmark);
		free_zebu_token(ptree->star);
		free(ptree);
	}
}

void free_zebu_grammar_rule(struct zebu_grammar_rule* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar(ptree->grammar);
		free_zebu_token(ptree->name);
		free(ptree);
	}
}

void free_zebu_implication_expression(struct zebu_implication_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_possession_expression(ptree->base);
		for (unsigned i = 0, n = ptree->implies.n; i < n; i++)
			free_zebu_possession_expression(ptree->implies.data[i]);
		free(ptree->implies.data);
		free(ptree);
	}
}

void free_zebu_inclusive_or_expression(struct zebu_inclusive_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_exclusive_or_expression(ptree->base);
		free_zebu_inclusive_or_expression(ptree->left);
		free_zebu_exclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_lambda_expression(struct zebu_lambda_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_conditional_expression(ptree->base);
		free_zebu_lambda_expression(ptree->lambda);
		void free_unresolved(struct unresolved*);
		free_unresolved(ptree->lambda_captures);
		free_zebu_token(ptree->name);
		for (unsigned i = 0, n = ptree->parameters.n; i < n; i++)
			free_zebu_0$parameter(ptree->parameters.data[i]);
		free(ptree->parameters.data);
		free_zebu_type(ptree->type);
		free(ptree);
	}
}

void free_zebu_logical_and_expression(struct zebu_logical_and_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_inclusive_or_expression(ptree->base);
		free_zebu_logical_and_expression(ptree->left);
		free_zebu_inclusive_or_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_logical_or_expression(struct zebu_logical_or_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_logical_and_expression(ptree->base);
		free_zebu_logical_or_expression(ptree->left);
		free_zebu_logical_and_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_exponentiation_expression(ptree->base);
		free_zebu_multiplicative_expression(ptree->left);
		free_zebu_exponentiation_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_possession_expression(struct zebu_possession_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_lambda_expression(ptree->base);
		free_zebu_token(ptree->has);
		free(ptree);
	}
}

void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_expression(ptree->args.data[i]);
		free(ptree->args.data);
		free_zebu_primary_expression(ptree->base);
		free_zebu_token(ptree->call);
		free_zebu_token(ptree->field);
		free_zebu_expression(ptree->index);
		free_zebu_postfix_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_expression(ptree->args.data[i]);
		free(ptree->args.data);
		free_zebu_token(ptree->character_literal);
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
			free_zebu_expression(ptree->elements.data[i]);
		free(ptree->elements.data);
		free_zebu_token(ptree->float_literal);
		free_zebu_token(ptree->identifier);
		free_zebu_token(ptree->integer_literal);
		free_zebu_token(ptree->list);
		free_zebu_token(ptree->map);
		free_zebu_token(ptree->string_literal);
		free_zebu_token(ptree->tuple);
		void free_type(struct type*);
		free_type(ptree->type);
		void free_value(struct value*);
		free_value(ptree->value);
		free(ptree);
	}
}

void free_zebu_primary_type(struct zebu_primary_type* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_primary_type(ptree->array);
		free_zebu_token(ptree->bool_type);
		free_zebu_token(ptree->char_type);
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
			free_zebu_type(ptree->elements.data[i]);
		free(ptree->elements.data);
		free_zebu_token(ptree->float_type);
		free_zebu_token(ptree->grammar);
		free_zebu_token(ptree->int_type);
		free_zebu_token(ptree->tuple);
		free(ptree);
	}
}

void free_zebu_regex(struct zebu_regex* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_juxtaposition(ptree->base);
		for (unsigned i = 0, n = ptree->ors.n; i < n; i++)
			free_zebu_regex_juxtaposition(ptree->ors.data[i]);
		free(ptree->ors.data);
		free(ptree);
	}
}

void free_zebu_regex_highest(struct zebu_regex_highest* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->character);
		free_zebu_charset(ptree->charset);
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->string);
		free_zebu_regex(ptree->subregex);
		free(ptree);
	}
}

void free_zebu_regex_juxtaposition(struct zebu_regex_juxtaposition* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_postfix(ptree->base);
		for (unsigned i = 0, n = ptree->juxtapositions.n; i < n; i++)
			free_zebu_regex_postfix(ptree->juxtapositions.data[i]);
		free(ptree->juxtapositions.data);
		free(ptree);
	}
}

void free_zebu_regex_postfix(struct zebu_regex_postfix* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex_highest(ptree->base);
		free_zebu_token(ptree->plus);
		free_zebu_token(ptree->qmark);
		free_zebu_token(ptree->star);
		free(ptree);
	}
}

void free_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_shift_expression(ptree->base);
		free_zebu_relational_expression(ptree->left);
		free_zebu_shift_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_shift_expression(struct zebu_shift_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_additive_expression(ptree->base);
		free_zebu_shift_expression(ptree->left);
		free_zebu_additive_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_skip_directive(struct zebu_skip_directive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_regex(ptree->regex);
		free(ptree);
	}
}

void free_zebu_start_directive(struct zebu_start_directive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_grammar(ptree->grammar);
		free(ptree);
	}
}

void free_zebu_type(struct zebu_type* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_type(ptree->args.data[i]);
		free(ptree->args.data);
		free_zebu_primary_type(ptree->base);
		free_zebu_type(ptree->rettype);
		free(ptree);
	}
}

void free_zebu_unary_expression(struct zebu_unary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_postfix_expression(ptree->base);
		free_zebu_unary_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_using_directive(struct zebu_using_directive* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->path);
		free(ptree);
	}
}

void free_zebu_value_declare(struct zebu_value_declare* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->name);
		free(ptree);
	}
}



#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap; } lexer = {};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		void append(unsigned char c)
		{
			while (lexer.n + 1 >= lexer.cap)
			{
				lexer.cap = lexer.cap << 1 ?: 1;
				#ifdef ZEBU_DEBUG
				ddprintf("lexer.cap == %u\n", lexer.cap);
				#endif
				lexer.data = realloc(lexer.data, lexer.cap);
			}
			
			lexer.data[lexer.n++] = c;
		}
		
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				append(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\"\n", i, lexer.data);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->len = i;
					token->data[i] = 0;
					t = b, td = token;
					
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (f)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->len = f;
					token->data[f] = 0;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				assert(!"168");
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 42:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 13:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 8:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 26:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 79:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 72:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 29:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 58:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 28:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 51:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 65:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 25:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 77;
		break;
	}
	case 45:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 46:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 107:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 110:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 44:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 43:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 112:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 111:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 47:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 109:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 108:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 48:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 28;
		break;
	}
	case 119:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 118:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 53:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 57:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 117:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 54:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 122:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 121:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 55:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 120:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 52:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 56:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 30;
		break;
	}
	case 264:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 71;
		break;
	}
	case 285:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 71;
		break;
	}
	case 260:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		if (value->intersects.n == value->intersects.cap)
		{
			value->intersects.cap = value->intersects.cap << 1 ?: 1;
			value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
		}
		memmove(value->intersects.data + 1, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
		value->intersects.data[0] = inc_zebu_charset_range(subgrammar), value->intersects.n++;
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 69;
		break;
	}
	case 295:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_intersect* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_range(value->base); value->base = inc_zebu_charset_range(trie->base); }
			if (trie->intersects.n)
			{
				while (value->intersects.n + trie->intersects.n > value->intersects.cap)
				{
					value->intersects.cap = value->intersects.cap << 1 ?: 1;
					value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
				}
				memmove(value->intersects.data + trie->intersects.n, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
				for (unsigned i = 0, n = trie->intersects.n; i < n; i++)
					value->intersects.data[i] = inc_zebu_charset_range(trie->intersects.data[i]);
				value->intersects.n += trie->intersects.n;
			}
			free_zebu_charset_intersect(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		if (value->intersects.n == value->intersects.cap)
		{
			value->intersects.cap = value->intersects.cap << 1 ?: 1;
			value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
		}
		memmove(value->intersects.data + 1, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
		value->intersects.data[0] = inc_zebu_charset_range(subgrammar), value->intersects.n++;
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 69;
		break;
	}
	case 257:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		if (value->xors.n == value->xors.cap)
		{
			value->xors.cap = value->xors.cap << 1 ?: 1;
			value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
		}
		memmove(value->xors.data + 1, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
		value->xors.data[0] = inc_zebu_charset_intersect(subgrammar), value->xors.n++;
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 68;
		break;
	}
	case 294:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_symdiff* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_intersect(value->base); value->base = inc_zebu_charset_intersect(trie->base); }
			if (trie->xors.n)
			{
				while (value->xors.n + trie->xors.n > value->xors.cap)
				{
					value->xors.cap = value->xors.cap << 1 ?: 1;
					value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
				}
				memmove(value->xors.data + trie->xors.n, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
				for (unsigned i = 0, n = trie->xors.n; i < n; i++)
					value->xors.data[i] = inc_zebu_charset_intersect(trie->xors.data[i]);
				value->xors.n += trie->xors.n;
			}
			free_zebu_charset_symdiff(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		if (value->xors.n == value->xors.cap)
		{
			value->xors.cap = value->xors.cap << 1 ?: 1;
			value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
		}
		memmove(value->xors.data + 1, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
		value->xors.data[0] = inc_zebu_charset_intersect(subgrammar), value->xors.n++;
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 68;
		break;
	}
	case 124:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->iffs.n == value->iffs.cap)
		{
			value->iffs.cap = value->iffs.cap << 1 ?: 1;
			value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
		}
		memmove(value->iffs.data + 1, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
		value->iffs.data[0] = inc_zebu_implication_expression(subgrammar), value->iffs.n++;
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 44;
		break;
	}
	case 245:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_implication_expression(value->base); value->base = inc_zebu_implication_expression(trie->base); }
			if (trie->iffs.n)
			{
				while (value->iffs.n + trie->iffs.n > value->iffs.cap)
				{
					value->iffs.cap = value->iffs.cap << 1 ?: 1;
					value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
				}
				memmove(value->iffs.data + trie->iffs.n, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
				for (unsigned i = 0, n = trie->iffs.n; i < n; i++)
					value->iffs.data[i] = inc_zebu_implication_expression(trie->iffs.data[i]);
				value->iffs.n += trie->iffs.n;
			}
			free_zebu_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->iffs.n == value->iffs.cap)
		{
			value->iffs.cap = value->iffs.cap << 1 ?: 1;
			value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
		}
		memmove(value->iffs.data + 1, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
		value->iffs.data[0] = inc_zebu_implication_expression(subgrammar), value->iffs.n++;
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 44;
		break;
	}
	case 229:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_grammar_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 66;
		break;
	}
	case 292:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_juxtaposition(value->base); value->base = inc_zebu_grammar_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_grammar_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_grammar(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_grammar_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 66;
		break;
	}
	case 211:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 62;
		break;
	}
	case 250:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 62;
		break;
	}
	case 213:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 63;
		break;
	}
	case 251:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 63;
		break;
	}
	case 216:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 64;
		break;
	}
	case 253:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 64;
		break;
	}
	case 221:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 65;
		break;
	}
	case 267:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 65;
		break;
	}
	case 282:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 75;
		break;
	}
	case 293:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 75;
		break;
	}
	case 61:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 59:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 60:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 62:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 143:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 145:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 63:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 146:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 142:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 147:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 144:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 64:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 31;
		break;
	}
	case 289:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 76;
		break;
	}
	case 296:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		d = value, g = 76;
		break;
	}
	case 231:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 67;
		break;
	}
	case 275:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_postfix(value->base); value->base = inc_zebu_grammar_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_grammar_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_grammar_juxtaposition(trie);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 67;
		break;
	}
	case 133:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->implies.n == value->implies.cap)
		{
			value->implies.cap = value->implies.cap << 1 ?: 1;
			value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
		}
		memmove(value->implies.data + 1, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
		value->implies.data[0] = inc_zebu_possession_expression(subgrammar), value->implies.n++;
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 45;
		break;
	}
	case 247:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_implication_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_possession_expression(value->base); value->base = inc_zebu_possession_expression(trie->base); }
			if (trie->implies.n)
			{
				while (value->implies.n + trie->implies.n > value->implies.cap)
				{
					value->implies.cap = value->implies.cap << 1 ?: 1;
					value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
				}
				memmove(value->implies.data + trie->implies.n, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
				for (unsigned i = 0, n = trie->implies.n; i < n; i++)
					value->implies.data[i] = inc_zebu_possession_expression(trie->implies.data[i]);
				value->implies.n += trie->implies.n;
			}
			free_zebu_implication_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->implies.n == value->implies.cap)
		{
			value->implies.cap = value->implies.cap << 1 ?: 1;
			value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
		}
		memmove(value->implies.data + 1, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
		value->implies.data[0] = inc_zebu_possession_expression(subgrammar), value->implies.n++;
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 45;
		break;
	}
	case 239:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_0$parameter* subgrammar = data.data[--yacc.n, --data.n];
		if (value->parameters.n == value->parameters.cap)
		{
			value->parameters.cap = value->parameters.cap << 1 ?: 1;
			value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
		}
		memmove(value->parameters.data + 1, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
		value->parameters.data[0] = inc_zebu_0$parameter(subgrammar), value->parameters.n++;
		free_zebu_0$parameter(subgrammar);
		}
		d = value, g = 41;
		break;
	}
	case 240:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_0$parameter* subgrammar = data.data[--yacc.n, --data.n];
		if (value->parameters.n == value->parameters.cap)
		{
			value->parameters.cap = value->parameters.cap << 1 ?: 1;
			value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
		}
		memmove(value->parameters.data + 1, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
		value->parameters.data[0] = inc_zebu_0$parameter(subgrammar), value->parameters.n++;
		free_zebu_0$parameter(subgrammar);
		}
		d = value, g = 41;
		break;
	}
	case 102:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_lambda_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_lambda_expression(value->lambda), value->lambda = inc_zebu_lambda_expression(subgrammar);
		free_zebu_lambda_expression(subgrammar);
		}
		d = value, g = 43;
		break;
	}
	case 248:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 61;
		break;
	}
	case 280:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_expression(value->base); value->base = inc_zebu_primary_expression(trie->base); }
			if (trie->call) { free_zebu_token(value->call); value->call = inc_zebu_token(trie->call); }
			if (trie->field) { free_zebu_token(value->field); value->field = inc_zebu_token(trie->field); }
			if (trie->index) { free_zebu_expression(value->index); value->index = inc_zebu_expression(trie->index); }
			if (trie->sub) { free_zebu_postfix_expression(value->sub); value->sub = inc_zebu_postfix_expression(trie->sub); }
			free_zebu_postfix_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 61;
		break;
	}
	case 166:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 35;
		break;
	}
	case 209:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 35;
		break;
	}
	case 210:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 36;
		break;
	}
	case 168:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 36;
		break;
	}
	case 232:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 56;
		break;
	}
	case 276:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		d = value, g = 56;
		break;
	}
	case 237:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 58;
		break;
	}
	case 277:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_type* trie = data.data[--yacc.n, --data.n];
			if (trie->array) { free_zebu_primary_type(value->array); value->array = inc_zebu_primary_type(trie->array); }
			if (trie->bool_type) { free_zebu_token(value->bool_type); value->bool_type = inc_zebu_token(trie->bool_type); }
			if (trie->char_type) { free_zebu_token(value->char_type); value->char_type = inc_zebu_token(trie->char_type); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_type(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_type) { free_zebu_token(value->float_type); value->float_type = inc_zebu_token(trie->float_type); }
			if (trie->grammar) { free_zebu_token(value->grammar); value->grammar = inc_zebu_token(trie->grammar); }
			if (trie->int_type) { free_zebu_token(value->int_type); value->int_type = inc_zebu_token(trie->int_type); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 58;
		break;
	}
	case 149:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 68:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 150:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 71:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 69:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 70:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 67:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 148:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 152:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 153:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 66:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 151:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 32;
		break;
	}
	case 272:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_regex_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 73;
		break;
	}
	case 297:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_juxtaposition(value->base); value->base = inc_zebu_regex_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_regex_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_regex(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_regex_juxtaposition(subgrammar), value->ors.n++;
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 73;
		break;
	}
	case 274:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 74;
		break;
	}
	case 291:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_postfix(value->base); value->base = inc_zebu_regex_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_regex_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_regex_juxtaposition(trie);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 74;
		break;
	}
	case 278:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 59;
		break;
	}
	case 279:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		d = value, g = 59;
		break;
	}
	case 205:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->rettype), value->rettype = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		d = value, g = 60;
		break;
	}
	case 73:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 154:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 78:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 74:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 155:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 75:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 156:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 76:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 157:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 77:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 158:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 159:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 33;
		break;
	}
	case 80:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 160:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_assertion* subgrammar = data.data[--yacc.n, --data.n];
		if (value->assertions.n == value->assertions.cap)
		{
			value->assertions.cap = value->assertions.cap << 1 ?: 1;
			value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
		}
		memmove(value->assertions.data + 1, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
		value->assertions.data[0] = inc_zebu_assertion(subgrammar), value->assertions.n++;
		free_zebu_assertion(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 81:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 161:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_grammar_rule* subgrammar = data.data[--yacc.n, --data.n];
		if (value->grammars.n == value->grammars.cap)
		{
			value->grammars.cap = value->grammars.cap << 1 ?: 1;
			value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
		}
		memmove(value->grammars.data + 1, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
		value->grammars.data[0] = inc_zebu_grammar_rule(subgrammar), value->grammars.n++;
		free_zebu_grammar_rule(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 82:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 162:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_skip_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->skips.n == value->skips.cap)
		{
			value->skips.cap = value->skips.cap << 1 ?: 1;
			value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
		}
		memmove(value->skips.data + 1, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
		value->skips.data[0] = inc_zebu_skip_directive(subgrammar), value->skips.n++;
		free_zebu_skip_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 85:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 83:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 163:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_start_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->starts.n == value->starts.cap)
		{
			value->starts.cap = value->starts.cap << 1 ?: 1;
			value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
		}
		memmove(value->starts.data + 1, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
		value->starts.data[0] = inc_zebu_start_directive(subgrammar), value->starts.n++;
		free_zebu_start_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 84:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 164:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_using_directive* subgrammar = data.data[--yacc.n, --data.n];
		if (value->usings.n == value->usings.cap)
		{
			value->usings.cap = value->usings.cap << 1 ?: 1;
			value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
		}
		memmove(value->usings.data + 1, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
		value->usings.data[0] = inc_zebu_using_directive(subgrammar), value->usings.n++;
		free_zebu_using_directive(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 165:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_$start* trie = data.data[--yacc.n, --data.n];
			if (trie->assertions.n)
			{
				while (value->assertions.n + trie->assertions.n > value->assertions.cap)
				{
					value->assertions.cap = value->assertions.cap << 1 ?: 1;
					value->assertions.data = realloc(value->assertions.data, sizeof(*value->assertions.data) * value->assertions.cap);
				}
				memmove(value->assertions.data + trie->assertions.n, value->assertions.data, sizeof(*value->assertions.data) * value->assertions.n);
				for (unsigned i = 0, n = trie->assertions.n; i < n; i++)
					value->assertions.data[i] = inc_zebu_assertion(trie->assertions.data[i]);
				value->assertions.n += trie->assertions.n;
			}
			if (trie->declares.n)
			{
				while (value->declares.n + trie->declares.n > value->declares.cap)
				{
					value->declares.cap = value->declares.cap << 1 ?: 1;
					value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
				}
				memmove(value->declares.data + trie->declares.n, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
				for (unsigned i = 0, n = trie->declares.n; i < n; i++)
					value->declares.data[i] = inc_zebu_value_declare(trie->declares.data[i]);
				value->declares.n += trie->declares.n;
			}
			if (trie->grammars.n)
			{
				while (value->grammars.n + trie->grammars.n > value->grammars.cap)
				{
					value->grammars.cap = value->grammars.cap << 1 ?: 1;
					value->grammars.data = realloc(value->grammars.data, sizeof(*value->grammars.data) * value->grammars.cap);
				}
				memmove(value->grammars.data + trie->grammars.n, value->grammars.data, sizeof(*value->grammars.data) * value->grammars.n);
				for (unsigned i = 0, n = trie->grammars.n; i < n; i++)
					value->grammars.data[i] = inc_zebu_grammar_rule(trie->grammars.data[i]);
				value->grammars.n += trie->grammars.n;
			}
			if (trie->skips.n)
			{
				while (value->skips.n + trie->skips.n > value->skips.cap)
				{
					value->skips.cap = value->skips.cap << 1 ?: 1;
					value->skips.data = realloc(value->skips.data, sizeof(*value->skips.data) * value->skips.cap);
				}
				memmove(value->skips.data + trie->skips.n, value->skips.data, sizeof(*value->skips.data) * value->skips.n);
				for (unsigned i = 0, n = trie->skips.n; i < n; i++)
					value->skips.data[i] = inc_zebu_skip_directive(trie->skips.data[i]);
				value->skips.n += trie->skips.n;
			}
			if (trie->starts.n)
			{
				while (value->starts.n + trie->starts.n > value->starts.cap)
				{
					value->starts.cap = value->starts.cap << 1 ?: 1;
					value->starts.data = realloc(value->starts.data, sizeof(*value->starts.data) * value->starts.cap);
				}
				memmove(value->starts.data + trie->starts.n, value->starts.data, sizeof(*value->starts.data) * value->starts.n);
				for (unsigned i = 0, n = trie->starts.n; i < n; i++)
					value->starts.data[i] = inc_zebu_start_directive(trie->starts.data[i]);
				value->starts.n += trie->starts.n;
			}
			if (trie->usings.n)
			{
				while (value->usings.n + trie->usings.n > value->usings.cap)
				{
					value->usings.cap = value->usings.cap << 1 ?: 1;
					value->usings.data = realloc(value->usings.data, sizeof(*value->usings.data) * value->usings.cap);
				}
				memmove(value->usings.data + trie->usings.n, value->usings.data, sizeof(*value->usings.data) * value->usings.n);
				for (unsigned i = 0, n = trie->usings.n; i < n; i++)
					value->usings.data[i] = inc_zebu_using_directive(trie->usings.data[i]);
				value->usings.n += trie->usings.n;
			}
			free_zebu_$start(trie);
		}
		{
		struct zebu_value_declare* subgrammar = data.data[--yacc.n, --data.n];
		if (value->declares.n == value->declares.cap)
		{
			value->declares.cap = value->declares.cap << 1 ?: 1;
			value->declares.data = realloc(value->declares.data, sizeof(*value->declares.data) * value->declares.cap);
		}
		memmove(value->declares.data + 1, value->declares.data, sizeof(*value->declares.data) * value->declares.n);
		value->declares.data[0] = inc_zebu_value_declare(subgrammar), value->declares.n++;
		free_zebu_value_declare(subgrammar);
		}
		d = value, g = 34;
		break;
	}
	case 236:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		d = value, g = 57;
		break;
	}
	case 49:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 29;
		break;
	}
	case 286:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 72;
		break;
	}
	case 287:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 72;
		break;
	}
	case 266:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 72;
		break;
	}
	case 288:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 72;
		break;
	}
	case 262:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 70;
		break;
	}
	case 284:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 70;
		break;
	}
	case 99:
	{
		struct zebu_0$parameter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 42;
		break;
	}
	case 202:
	{
		struct zebu_0$parameter* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->type), value->type = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		d = value, g = 42;
		break;
	}
	case 104:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->sub), value->sub = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		d = value, g = 1;
		break;
	}
	case 105:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->add), value->add = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		d = value, g = 1;
		break;
	}
	case 19:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->base), value->base = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 1;
		break;
	}
	case 106:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->right), value->right = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_and_expression(value->left), value->left = inc_zebu_and_expression(subgrammar);
		free_zebu_and_expression(subgrammar);
		}
		d = value, g = 2;
		break;
	}
	case 10:
	{
		struct zebu_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->base), value->base = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		d = value, g = 2;
		break;
	}
	case 196:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->debug), value->debug = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 197:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->note), value->note = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 198:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->warning), value->warning = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 199:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->error), value->error = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 3;
		break;
	}
	case 50:
	{
		struct zebu_assertion* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_assertion* trie = data.data[--yacc.n, --data.n];
			if (trie->debug) { free_zebu_token(value->debug); value->debug = inc_zebu_token(trie->debug); }
			if (trie->error) { free_zebu_token(value->error); value->error = inc_zebu_token(trie->error); }
			if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
			if (trie->note) { free_zebu_token(value->note); value->note = inc_zebu_token(trie->note); }
			if (trie->warning) { free_zebu_token(value->warning); value->warning = inc_zebu_token(trie->warning); }
			free_zebu_assertion(trie);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		d = value, g = 3;
		break;
	}
	case 179:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 261:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 263:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 220:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 265:
	{
		struct zebu_charset* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_symdiff(value->base); value->base = inc_zebu_charset_symdiff(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_charset_symdiff(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_charset(trie);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		if (value->ors.n == value->ors.cap)
		{
			value->ors.cap = value->ors.cap << 1 ?: 1;
			value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
		}
		memmove(value->ors.data + 1, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
		value->ors.data[0] = inc_zebu_charset_symdiff(subgrammar), value->ors.n++;
		free_zebu_charset_symdiff(subgrammar);
		}
		{
		struct zebu_charset_symdiff* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_symdiff(value->base), value->base = inc_zebu_charset_symdiff(subgrammar);
		free_zebu_charset_symdiff(subgrammar);
		}
		d = value, g = 46;
		break;
	}
	case 173:
	{
		struct zebu_charset_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 47;
		break;
	}
	case 174:
	{
		struct zebu_charset_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 47;
		break;
	}
	case 254:
	{
		struct zebu_charset_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->subcharset), value->subcharset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 47;
		break;
	}
	case 178:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_range(value->base), value->base = inc_zebu_charset_range(subgrammar);
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 48;
		break;
	}
	case 259:
	{
		struct zebu_charset_intersect* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_intersect* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_range(value->base); value->base = inc_zebu_charset_range(trie->base); }
			if (trie->intersects.n)
			{
				while (value->intersects.n + trie->intersects.n > value->intersects.cap)
				{
					value->intersects.cap = value->intersects.cap << 1 ?: 1;
					value->intersects.data = realloc(value->intersects.data, sizeof(*value->intersects.data) * value->intersects.cap);
				}
				memmove(value->intersects.data + trie->intersects.n, value->intersects.data, sizeof(*value->intersects.data) * value->intersects.n);
				for (unsigned i = 0, n = trie->intersects.n; i < n; i++)
					value->intersects.data[i] = inc_zebu_charset_range(trie->intersects.data[i]);
				value->intersects.n += trie->intersects.n;
			}
			free_zebu_charset_intersect(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_range* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_range(value->base), value->base = inc_zebu_charset_range(subgrammar);
		free_zebu_charset_range(subgrammar);
		}
		d = value, g = 48;
		break;
	}
	case 218:
	{
		struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_highest(value->base), value->base = inc_zebu_charset_highest(subgrammar);
		free_zebu_charset_highest(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->emark), value->emark = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 49;
		break;
	}
	case 175:
	{
		struct zebu_charset_prefix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_highest(value->base), value->base = inc_zebu_charset_highest(subgrammar);
		free_zebu_charset_highest(subgrammar);
		}
		d = value, g = 49;
		break;
	}
	case 177:
	{
		struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
		free_zebu_charset_prefix(subgrammar);
		}
		d = value, g = 50;
		break;
	}
	case 258:
	{
		struct zebu_charset_range* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_prefix(value->right), value->right = inc_zebu_charset_prefix(subgrammar);
		free_zebu_charset_prefix(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_prefix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_prefix(value->left), value->left = inc_zebu_charset_prefix(subgrammar);
		free_zebu_charset_prefix(subgrammar);
		}
		d = value, g = 50;
		break;
	}
	case 176:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_intersect(value->base), value->base = inc_zebu_charset_intersect(subgrammar);
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 51;
		break;
	}
	case 256:
	{
		struct zebu_charset_symdiff* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_charset_symdiff* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_charset_intersect(value->base); value->base = inc_zebu_charset_intersect(trie->base); }
			if (trie->xors.n)
			{
				while (value->xors.n + trie->xors.n > value->xors.cap)
				{
					value->xors.cap = value->xors.cap << 1 ?: 1;
					value->xors.data = realloc(value->xors.data, sizeof(*value->xors.data) * value->xors.cap);
				}
				memmove(value->xors.data + trie->xors.n, value->xors.data, sizeof(*value->xors.data) * value->xors.n);
				for (unsigned i = 0, n = trie->xors.n; i < n; i++)
					value->xors.data[i] = inc_zebu_charset_intersect(trie->xors.data[i]);
				value->xors.n += trie->xors.n;
			}
			free_zebu_charset_symdiff(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset_intersect* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset_intersect(value->base), value->base = inc_zebu_charset_intersect(subgrammar);
		free_zebu_charset_intersect(subgrammar);
		}
		d = value, g = 51;
		break;
	}
	case 18:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_or_expression(value->base), value->base = inc_zebu_logical_or_expression(subgrammar);
		free_zebu_logical_or_expression(subgrammar);
		}
		d = value, g = 4;
		break;
	}
	case 246:
	{
		struct zebu_conditional_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_conditional_expression(value->false_case), value->false_case = inc_zebu_conditional_expression(subgrammar);
		free_zebu_conditional_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->true_case), value->true_case = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_or_expression(value->base), value->base = inc_zebu_logical_or_expression(subgrammar);
		free_zebu_logical_or_expression(subgrammar);
		}
		d = value, g = 4;
		break;
	}
	case 113:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->right), value->right = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		d = value, g = 5;
		break;
	}
	case 114:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->right), value->right = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
		free_zebu_equality_expression(subgrammar);
		}
		d = value, g = 5;
		break;
	}
	case 23:
	{
		struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->base), value->base = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 5;
		break;
	}
	case 7:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_and_expression(value->base), value->base = inc_zebu_and_expression(subgrammar);
		free_zebu_and_expression(subgrammar);
		}
		d = value, g = 6;
		break;
	}
	case 115:
	{
		struct zebu_exclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_and_expression(value->right), value->right = inc_zebu_and_expression(subgrammar);
		free_zebu_and_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exclusive_or_expression(value->left), value->left = inc_zebu_exclusive_or_expression(subgrammar);
		free_zebu_exclusive_or_expression(subgrammar);
		}
		d = value, g = 6;
		break;
	}
	case 116:
	{
		struct zebu_exponentiation_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->right), value->right = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->left), value->left = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		d = value, g = 7;
		break;
	}
	case 27:
	{
		struct zebu_exponentiation_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->base), value->base = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		d = value, g = 7;
		break;
	}
	case 14:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_implication_expression(value->base), value->base = inc_zebu_implication_expression(subgrammar);
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 8;
		break;
	}
	case 123:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_implication_expression(value->base); value->base = inc_zebu_implication_expression(trie->base); }
			if (trie->iffs.n)
			{
				while (value->iffs.n + trie->iffs.n > value->iffs.cap)
				{
					value->iffs.cap = value->iffs.cap << 1 ?: 1;
					value->iffs.data = realloc(value->iffs.data, sizeof(*value->iffs.data) * value->iffs.cap);
				}
				memmove(value->iffs.data + trie->iffs.n, value->iffs.data, sizeof(*value->iffs.data) * value->iffs.n);
				for (unsigned i = 0, n = trie->iffs.n; i < n; i++)
					value->iffs.data[i] = inc_zebu_implication_expression(trie->iffs.data[i]);
				value->iffs.n += trie->iffs.n;
			}
			free_zebu_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_implication_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_implication_expression(value->base), value->base = inc_zebu_implication_expression(subgrammar);
		free_zebu_implication_expression(subgrammar);
		}
		d = value, g = 8;
		break;
	}
	case 95:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_juxtaposition(value->base), value->base = inc_zebu_grammar_juxtaposition(subgrammar);
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 37;
		break;
	}
	case 228:
	{
		struct zebu_grammar* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_juxtaposition(value->base); value->base = inc_zebu_grammar_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_grammar_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_grammar(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_juxtaposition(value->base), value->base = inc_zebu_grammar_juxtaposition(subgrammar);
		free_zebu_grammar_juxtaposition(subgrammar);
		}
		d = value, g = 37;
		break;
	}
	case 90:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 170:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 212:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 91:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 171:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 214:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 215:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->subgrammar), value->subgrammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 252:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->subgrammar), value->subgrammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 281:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->subgrammar), value->subgrammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 93:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 92:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 172:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 217:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 219:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 255:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 283:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 180:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 222:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 223:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 270:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 290:
	{
		struct zebu_grammar_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_highest* trie = data.data[--yacc.n, --data.n];
			if (trie->character) { free_zebu_token(value->character); value->character = inc_zebu_token(trie->character); }
			if (trie->charset) { free_zebu_charset(value->charset); value->charset = inc_zebu_charset(trie->charset); }
			if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->regex) { free_zebu_regex(value->regex); value->regex = inc_zebu_regex(trie->regex); }
			if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
			if (trie->subgrammar) { free_zebu_grammar(value->subgrammar); value->subgrammar = inc_zebu_grammar(trie->subgrammar); }
			if (trie->tags.n)			{
				while (value->tags.n + trie->tags.n > value->tags.cap)
				{
					value->tags.cap = value->tags.cap << 1 ?: 1;
					value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
				}
				memmove(value->tags.data + trie->tags.n, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
				for (unsigned i = 0, n = trie->tags.n; i < n; i++)
					value->tags.data[i] = inc_zebu_token(trie->tags.data[i]);
				value->tags.n += trie->tags.n;
			}
			free_zebu_grammar_highest(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		if (value->tags.n == value->tags.cap)
		{
			value->tags.cap = value->tags.cap << 1 ?: 1;
			value->tags.data = realloc(value->tags.data, sizeof(*value->tags.data) * value->tags.cap);
		}
		memmove(value->tags.data + 1, value->tags.data, sizeof(*value->tags.data) * value->tags.n);
		value->tags.data[0] = inc_zebu_token(token), value->tags.n++;
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 38;
		break;
	}
	case 96:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_postfix(value->base), value->base = inc_zebu_grammar_postfix(subgrammar);
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 39;
		break;
	}
	case 191:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_postfix(value->base), value->base = inc_zebu_grammar_postfix(subgrammar);
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 39;
		break;
	}
	case 230:
	{
		struct zebu_grammar_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_grammar_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_grammar_postfix(value->base); value->base = inc_zebu_grammar_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_grammar_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_grammar_juxtaposition(trie);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_grammar_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_grammar_postfix(subgrammar);
		}
		{
		struct zebu_grammar_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_postfix(value->base), value->base = inc_zebu_grammar_postfix(subgrammar);
		free_zebu_grammar_postfix(subgrammar);
		}
		d = value, g = 39;
		break;
	}
	case 94:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 188:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 189:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->qmark), value->qmark = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 190:
	{
		struct zebu_grammar_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->star), value->star = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_grammar_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar_highest(value->base), value->base = inc_zebu_grammar_highest(subgrammar);
		free_zebu_grammar_highest(subgrammar);
		}
		d = value, g = 40;
		break;
	}
	case 187:
	{
		struct zebu_grammar_rule* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->grammar), value->grammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 9;
		break;
	}
	case 20:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_possession_expression(value->base), value->base = inc_zebu_possession_expression(subgrammar);
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 10;
		break;
	}
	case 132:
	{
		struct zebu_implication_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_implication_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_possession_expression(value->base); value->base = inc_zebu_possession_expression(trie->base); }
			if (trie->implies.n)
			{
				while (value->implies.n + trie->implies.n > value->implies.cap)
				{
					value->implies.cap = value->implies.cap << 1 ?: 1;
					value->implies.data = realloc(value->implies.data, sizeof(*value->implies.data) * value->implies.cap);
				}
				memmove(value->implies.data + trie->implies.n, value->implies.data, sizeof(*value->implies.data) * value->implies.n);
				for (unsigned i = 0, n = trie->implies.n; i < n; i++)
					value->implies.data[i] = inc_zebu_possession_expression(trie->implies.data[i]);
				value->implies.n += trie->implies.n;
			}
			free_zebu_implication_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_possession_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_possession_expression(value->base), value->base = inc_zebu_possession_expression(subgrammar);
		free_zebu_possession_expression(subgrammar);
		}
		d = value, g = 10;
		break;
	}
	case 11:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exclusive_or_expression(value->base), value->base = inc_zebu_exclusive_or_expression(subgrammar);
		free_zebu_exclusive_or_expression(subgrammar);
		}
		d = value, g = 11;
		break;
	}
	case 125:
	{
		struct zebu_inclusive_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exclusive_or_expression(value->right), value->right = inc_zebu_exclusive_or_expression(subgrammar);
		free_zebu_exclusive_or_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_inclusive_or_expression(value->left), value->left = inc_zebu_inclusive_or_expression(subgrammar);
		free_zebu_inclusive_or_expression(subgrammar);
		}
		d = value, g = 11;
		break;
	}
	case 100:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 101:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 243:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->type), value->type = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 244:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_lambda_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_conditional_expression(value->base); value->base = inc_zebu_conditional_expression(trie->base); }
			if (trie->lambda) { free_zebu_lambda_expression(value->lambda); value->lambda = inc_zebu_lambda_expression(trie->lambda); }
			if (trie->name) { free_zebu_token(value->name); value->name = inc_zebu_token(trie->name); }
			if (trie->parameters.n)
			{
				while (value->parameters.n + trie->parameters.n > value->parameters.cap)
				{
					value->parameters.cap = value->parameters.cap << 1 ?: 1;
					value->parameters.data = realloc(value->parameters.data, sizeof(*value->parameters.data) * value->parameters.cap);
				}
				memmove(value->parameters.data + trie->parameters.n, value->parameters.data, sizeof(*value->parameters.data) * value->parameters.n);
				for (unsigned i = 0, n = trie->parameters.n; i < n; i++)
					value->parameters.data[i] = inc_zebu_0$parameter(trie->parameters.data[i]);
				value->parameters.n += trie->parameters.n;
			}
			if (trie->type) { free_zebu_type(value->type); value->type = inc_zebu_type(trie->type); }
			free_zebu_lambda_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_type(value->type), value->type = inc_zebu_type(subgrammar);
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 12;
		break;
	}
	case 9:
	{
		struct zebu_lambda_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_conditional_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_conditional_expression(value->base), value->base = inc_zebu_conditional_expression(subgrammar);
		free_zebu_conditional_expression(subgrammar);
		}
		d = value, g = 12;
		break;
	}
	case 15:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_inclusive_or_expression(value->base), value->base = inc_zebu_inclusive_or_expression(subgrammar);
		free_zebu_inclusive_or_expression(subgrammar);
		}
		d = value, g = 13;
		break;
	}
	case 127:
	{
		struct zebu_logical_and_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_inclusive_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_inclusive_or_expression(value->right), value->right = inc_zebu_inclusive_or_expression(subgrammar);
		free_zebu_inclusive_or_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_and_expression(value->left), value->left = inc_zebu_logical_and_expression(subgrammar);
		free_zebu_logical_and_expression(subgrammar);
		}
		d = value, g = 13;
		break;
	}
	case 17:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_and_expression(value->base), value->base = inc_zebu_logical_and_expression(subgrammar);
		free_zebu_logical_and_expression(subgrammar);
		}
		d = value, g = 14;
		break;
	}
	case 128:
	{
		struct zebu_logical_or_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_logical_and_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_and_expression(value->right), value->right = inc_zebu_logical_and_expression(subgrammar);
		free_zebu_logical_and_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_logical_or_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_logical_or_expression(value->left), value->left = inc_zebu_logical_or_expression(subgrammar);
		free_zebu_logical_or_expression(subgrammar);
		}
		d = value, g = 14;
		break;
	}
	case 12:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->base), value->base = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 129:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->right), value->right = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 130:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->right), value->right = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 131:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_exponentiation_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_exponentiation_expression(value->right), value->right = inc_zebu_exponentiation_expression(subgrammar);
		free_zebu_exponentiation_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
		free_zebu_multiplicative_expression(subgrammar);
		}
		d = value, g = 15;
		break;
	}
	case 16:
	{
		struct zebu_possession_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_lambda_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_lambda_expression(value->base), value->base = inc_zebu_lambda_expression(subgrammar);
		free_zebu_lambda_expression(subgrammar);
		}
		d = value, g = 16;
		break;
	}
	case 126:
	{
		struct zebu_possession_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->has), value->has = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_lambda_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_lambda_expression(value->base), value->base = inc_zebu_lambda_expression(subgrammar);
		free_zebu_lambda_expression(subgrammar);
		}
		d = value, g = 16;
		break;
	}
	case 134:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 206:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_expression(value->base); value->base = inc_zebu_primary_expression(trie->base); }
			if (trie->call) { free_zebu_token(value->call); value->call = inc_zebu_token(trie->call); }
			if (trie->field) { free_zebu_token(value->field); value->field = inc_zebu_token(trie->field); }
			if (trie->index) { free_zebu_expression(value->index); value->index = inc_zebu_expression(trie->index); }
			if (trie->sub) { free_zebu_postfix_expression(value->sub); value->sub = inc_zebu_postfix_expression(trie->sub); }
			free_zebu_postfix_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 207:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 249:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_expression(value->base); value->base = inc_zebu_primary_expression(trie->base); }
			if (trie->call) { free_zebu_token(value->call); value->call = inc_zebu_token(trie->call); }
			if (trie->field) { free_zebu_token(value->field); value->field = inc_zebu_token(trie->field); }
			if (trie->index) { free_zebu_expression(value->index); value->index = inc_zebu_expression(trie->index); }
			if (trie->sub) { free_zebu_postfix_expression(value->sub); value->sub = inc_zebu_postfix_expression(trie->sub); }
			free_zebu_postfix_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->call), value->call = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 208:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->index), value->index = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 135:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->field), value->field = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->sub), value->sub = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 22:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_primary_expression(value->base), value->base = inc_zebu_primary_expression(subgrammar);
		free_zebu_primary_expression(subgrammar);
		}
		d = value, g = 17;
		break;
	}
	case 1:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character_literal), value->character_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 2:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer_literal), value->integer_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 30:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 86:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 87:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 167:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 4:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->float_literal), value->float_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 3:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string_literal), value->string_literal = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 88:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 33:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 169:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 89:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->list), value->list = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 5:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->identifier), value->identifier = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 97:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->map), value->map = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 193:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->map), value->map = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 194:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->map), value->map = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 233:
	{
		struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_expression(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->character_literal) { free_zebu_token(value->character_literal); value->character_literal = inc_zebu_token(trie->character_literal); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_literal) { free_zebu_token(value->float_literal); value->float_literal = inc_zebu_token(trie->float_literal); }
			if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
			if (trie->integer_literal) { free_zebu_token(value->integer_literal); value->integer_literal = inc_zebu_token(trie->integer_literal); }
			if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
			if (trie->map) { free_zebu_token(value->map); value->map = inc_zebu_token(trie->map); }
			if (trie->string_literal) { free_zebu_token(value->string_literal); value->string_literal = inc_zebu_token(trie->string_literal); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_expression(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_expression(subgrammar), value->args.n++;
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->map), value->map = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 18;
		break;
	}
	case 98:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 200:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_type* trie = data.data[--yacc.n, --data.n];
			if (trie->array) { free_zebu_primary_type(value->array); value->array = inc_zebu_primary_type(trie->array); }
			if (trie->bool_type) { free_zebu_token(value->bool_type); value->bool_type = inc_zebu_token(trie->bool_type); }
			if (trie->char_type) { free_zebu_token(value->char_type); value->char_type = inc_zebu_token(trie->char_type); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_type(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_type) { free_zebu_token(value->float_type); value->float_type = inc_zebu_token(trie->float_type); }
			if (trie->grammar) { free_zebu_token(value->grammar); value->grammar = inc_zebu_token(trie->grammar); }
			if (trie->int_type) { free_zebu_token(value->int_type); value->int_type = inc_zebu_token(trie->int_type); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 201:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 238:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_primary_type* trie = data.data[--yacc.n, --data.n];
			if (trie->array) { free_zebu_primary_type(value->array); value->array = inc_zebu_primary_type(trie->array); }
			if (trie->bool_type) { free_zebu_token(value->bool_type); value->bool_type = inc_zebu_token(trie->bool_type); }
			if (trie->char_type) { free_zebu_token(value->char_type); value->char_type = inc_zebu_token(trie->char_type); }
			if (trie->elements.n)
			{
				while (value->elements.n + trie->elements.n > value->elements.cap)
				{
					value->elements.cap = value->elements.cap << 1 ?: 1;
					value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
				}
				memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
				for (unsigned i = 0, n = trie->elements.n; i < n; i++)
					value->elements.data[i] = inc_zebu_type(trie->elements.data[i]);
				value->elements.n += trie->elements.n;
			}
			if (trie->float_type) { free_zebu_token(value->float_type); value->float_type = inc_zebu_token(trie->float_type); }
			if (trie->grammar) { free_zebu_token(value->grammar); value->grammar = inc_zebu_token(trie->grammar); }
			if (trie->int_type) { free_zebu_token(value->int_type); value->int_type = inc_zebu_token(trie->int_type); }
			if (trie->tuple) { free_zebu_token(value->tuple); value->tuple = inc_zebu_token(trie->tuple); }
			free_zebu_primary_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->elements.n == value->elements.cap)
		{
			value->elements.cap = value->elements.cap << 1 ?: 1;
			value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
		}
		memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
		value->elements.data[0] = inc_zebu_type(subgrammar), value->elements.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->tuple), value->tuple = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 36:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->grammar), value->grammar = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 37:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->int_type), value->int_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 40:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->float_type), value->float_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 38:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->char_type), value->char_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 39:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->bool_type), value->bool_type = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 26;
		break;
	}
	case 103:
	{
		struct zebu_primary_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_primary_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_primary_type(value->array), value->array = inc_zebu_primary_type(subgrammar);
		free_zebu_primary_type(subgrammar);
		}
		d = value, g = 26;
		break;
	}
	case 185:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_juxtaposition(value->base), value->base = inc_zebu_regex_juxtaposition(subgrammar);
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 52;
		break;
	}
	case 271:
	{
		struct zebu_regex* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_juxtaposition(value->base); value->base = inc_zebu_regex_juxtaposition(trie->base); }
			if (trie->ors.n)
			{
				while (value->ors.n + trie->ors.n > value->ors.cap)
				{
					value->ors.cap = value->ors.cap << 1 ?: 1;
					value->ors.data = realloc(value->ors.data, sizeof(*value->ors.data) * value->ors.cap);
				}
				memmove(value->ors.data + trie->ors.n, value->ors.data, sizeof(*value->ors.data) * value->ors.n);
				for (unsigned i = 0, n = trie->ors.n; i < n; i++)
					value->ors.data[i] = inc_zebu_regex_juxtaposition(trie->ors.data[i]);
				value->ors.n += trie->ors.n;
			}
			free_zebu_regex(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex_juxtaposition* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_juxtaposition(value->base), value->base = inc_zebu_regex_juxtaposition(subgrammar);
		free_zebu_regex_juxtaposition(subgrammar);
		}
		d = value, g = 52;
		break;
	}
	case 181:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->character), value->character = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 182:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 268:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->subregex), value->subregex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 183:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->string), value->string = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 269:
	{
		struct zebu_regex_highest* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_charset* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_charset(value->charset), value->charset = inc_zebu_charset(subgrammar);
		free_zebu_charset(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 53;
		break;
	}
	case 186:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_postfix(value->base), value->base = inc_zebu_regex_postfix(subgrammar);
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 54;
		break;
	}
	case 227:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_postfix(value->base), value->base = inc_zebu_regex_postfix(subgrammar);
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 54;
		break;
	}
	case 273:
	{
		struct zebu_regex_juxtaposition* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_regex_juxtaposition* trie = data.data[--yacc.n, --data.n];
			if (trie->base) { free_zebu_regex_postfix(value->base); value->base = inc_zebu_regex_postfix(trie->base); }
			if (trie->juxtapositions.n)
			{
				while (value->juxtapositions.n + trie->juxtapositions.n > value->juxtapositions.cap)
				{
					value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
					value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
				}
				memmove(value->juxtapositions.data + trie->juxtapositions.n, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
				for (unsigned i = 0, n = trie->juxtapositions.n; i < n; i++)
					value->juxtapositions.data[i] = inc_zebu_regex_postfix(trie->juxtapositions.data[i]);
				value->juxtapositions.n += trie->juxtapositions.n;
			}
			free_zebu_regex_juxtaposition(trie);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		if (value->juxtapositions.n == value->juxtapositions.cap)
		{
			value->juxtapositions.cap = value->juxtapositions.cap << 1 ?: 1;
			value->juxtapositions.data = realloc(value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.cap);
		}
		memmove(value->juxtapositions.data + 1, value->juxtapositions.data, sizeof(*value->juxtapositions.data) * value->juxtapositions.n);
		value->juxtapositions.data[0] = inc_zebu_regex_postfix(subgrammar), value->juxtapositions.n++;
		free_zebu_regex_postfix(subgrammar);
		}
		{
		struct zebu_regex_postfix* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_postfix(value->base), value->base = inc_zebu_regex_postfix(subgrammar);
		free_zebu_regex_postfix(subgrammar);
		}
		d = value, g = 54;
		break;
	}
	case 184:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 224:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 225:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->qmark), value->qmark = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 226:
	{
		struct zebu_regex_postfix* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->star), value->star = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_regex_highest* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex_highest(value->base), value->base = inc_zebu_regex_highest(subgrammar);
		free_zebu_regex_highest(subgrammar);
		}
		d = value, g = 55;
		break;
	}
	case 136:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 137:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 138:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 139:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->right), value->right = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
		free_zebu_relational_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 24:
	{
		struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->base), value->base = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		d = value, g = 19;
		break;
	}
	case 6:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->base), value->base = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		d = value, g = 20;
		break;
	}
	case 140:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		d = value, g = 20;
		break;
	}
	case 141:
	{
		struct zebu_shift_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
		free_zebu_additive_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_shift_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_shift_expression(value->left), value->left = inc_zebu_shift_expression(subgrammar);
		free_zebu_shift_expression(subgrammar);
		}
		d = value, g = 20;
		break;
	}
	case 234:
	{
		struct zebu_skip_directive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_regex* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_regex(value->regex), value->regex = inc_zebu_regex(subgrammar);
		free_zebu_regex(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 21;
		break;
	}
	case 235:
	{
		struct zebu_start_directive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_grammar* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_grammar(value->grammar), value->grammar = inc_zebu_grammar(subgrammar);
		free_zebu_grammar(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 22;
		break;
	}
	case 203:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 204:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 241:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 242:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
			struct zebu_type* trie = data.data[--yacc.n, --data.n];
			if (trie->args.n)
			{
				while (value->args.n + trie->args.n > value->args.cap)
				{
					value->args.cap = value->args.cap << 1 ?: 1;
					value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
				}
				memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
				for (unsigned i = 0, n = trie->args.n; i < n; i++)
					value->args.data[i] = inc_zebu_type(trie->args.data[i]);
				value->args.n += trie->args.n;
			}
			if (trie->base) { free_zebu_primary_type(value->base); value->base = inc_zebu_primary_type(trie->base); }
			if (trie->rettype) { free_zebu_type(value->rettype); value->rettype = inc_zebu_type(trie->rettype); }
			free_zebu_type(trie);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_type* subgrammar = data.data[--yacc.n, --data.n];
		if (value->args.n == value->args.cap)
		{
			value->args.cap = value->args.cap << 1 ?: 1;
			value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
		}
		memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
		value->args.data[0] = inc_zebu_type(subgrammar), value->args.n++;
		free_zebu_type(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 27;
		break;
	}
	case 41:
	{
		struct zebu_type* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_primary_type* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_primary_type(value->base), value->base = inc_zebu_primary_type(subgrammar);
		free_zebu_primary_type(subgrammar);
		}
		d = value, g = 27;
		break;
	}
	case 31:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 32:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 34:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 35:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_unary_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_unary_expression(value->sub), value->sub = inc_zebu_unary_expression(subgrammar);
		free_zebu_unary_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 23;
		break;
	}
	case 21:
	{
		struct zebu_unary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_postfix_expression(value->base), value->base = inc_zebu_postfix_expression(subgrammar);
		free_zebu_postfix_expression(subgrammar);
		}
		d = value, g = 23;
		break;
	}
	case 195:
	{
		struct zebu_using_directive* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->path), value->path = inc_zebu_token(token);
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		d = value, g = 24;
		break;
	}
	case 192:
	{
		struct zebu_value_declare* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->refcount = 1;
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
		free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
		free_zebu_expression(subgrammar);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(token);
		}
		{
		struct zebu_token* token = data.data[--yacc.n, --data.n];
		free_zebu_token(value->name), value->name = inc_zebu_token(token);
		free_zebu_token(token);
		}
		d = value, g = 25;
		break;
	}
}
			
			if (g == 77)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			assert(!"266");
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















