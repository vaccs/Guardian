
// $using "set-templates.maia"

// builtin functions:
	// all
	// any
	// map
	// filter
	// min
	// max
	// unique
	// reduce
	// zip
	// call
	// bool
	// int
	// float
	// range

// types:
	// char
	// bool
	// int
	// float
	// list
	// tuple
	// lambda
	// grammar-rule

// expression operators:
	// boolean literals, numeric literals, string literals, {set construction},
		// (tuple construction, ), parenthesis
	
	// '$1($2, ...)`: function-call
	// '$1.field': field-access
	// '$1[index]': list-index
	// '$1.[index]': element-wise list-index
	
	// ' +': positive
	// '.+': element-wise positive
	// ' -': negative
	// '.-': element-wise negative
	// ' !': logical-not
	// '.!': element-wise logical-not
	// ' ~': bitwise-not
	// '.~': element-wise bitwise-not
	
	// '**': exponentiation
	// '.**': element-wise equivalent
	
	// ' *': multiplication, '/': division, '%': remainder
	// '.*', './', '.%': element-wise equivalent
	
	// ' +': addition or concatenation, '-' subtraction
	// '.+': element-wise equivalent
	
	// ' <<': leftbitshift, '>>': rightbitshift
	// '.<<', '.>>': element-wise equivalent
	
	// ' <': less-than, '<=': less-than-equal-to, '>': greater-than, '>=': greater-than-equal-to
	// '.<', '.<=', '.>', '.>=': element-wise equivalent
	
	// ' ==': equal-to, '!=': not-equal-to
	// '.==', '.!=': element-wise equivalent
	
	// ' &': bitwise-and
	// '.&': element-wise equivalent
	
	// ' ^': bitwise-xor
	// '.^': element-wise equivalent
	
	// ' |': bitwise-or
	// '.|': element-wise equivalent
	
	// ' &&': logical-and
	// '.&&': element-wise equivalent
	
	// ' ||': logical-or
	// '.||': element-wise equivalent
	
	// ' ?' & ':': ternary-conditional
	// '.?' & ':': element-wise equivalent
	
	// "implies"-operator
	
	// "iff"-operator

// charset operators:
	// character-literal, parenthesis
	// '!': complement
	// ':': range
	// '&': intersection
	// '^': symmetric-difference
	// '|': union

// regular-expression operators:
	// [charset], string literal, numeric literal, parenthesis
	// '+', '*', '?', '{' expression '}'
	// ' ' juxtaposition
	// '|'-or

// grammar operators:
	// /regex/, [charset], string literal, numeric literal, parenthesis
	// '+', '*', '?', '{' expression '}'
	// ' ' juxtaposition
	// '|'-or

// syntactic-rule:
// name -> grammar rule;

// value-define, gets evaluated immediately
// name = expression;

// evaluated on runtime
// ("(require)" | "(warn)" | "(info)") expression;

%skip: ' ' | '\t' | '\n';

// "boolean" as a type refers to a thing with two strings.
// "boolean" as a variable refers to the list of those types that were parsed.
boolean: "true" #true_ | "false" #false_;

integer: /['-','+']? ['1'-'9'] ['0'-'9']* / #literal;

string: /'\"' [!'\"']* '\"'/ #literal;

list: '[' (value #elements[] (',' value #elements[])*)? ']';

keyvalue: string #key ':' value #value;

dict: '{' (keyvalue #entries[] (',' keyvalue #entries[])*)? '}';

value: boolean | integer | string | list | dict;

%start: value;

blacklist = "\"" .+ {"abc", "def", "ghi"} .+ "\"";

assert: (debug) len(blacklist);

(debug) 1 + 2;

// no key of any dictionary can be equal to "abc":
(require) all($char[] s, b: s != b, keyvalue.key, blacklist);

// every integer read from the file must be prime:
(warn) all($int u: u > 1 implies all($int n: u % n, 1:u), map(int, integer.literal));

// the number of "true"s read has to be equal to the number "false"s read:
(info) len(boolean.true_) == len(boolean.false_);

// keys of the same dictionary can't start with the same letter:
nonrepeating = $char[] list: all($int i, j: i != j implies list[i] != list[j], range(list), range(list));

(warn) all($dict d: nonrepeating(map($char[] s: s[0], d:.keyvalue:.string)), dict);



















