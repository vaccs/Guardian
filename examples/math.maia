
%skip: ' ' | '\t' | '\n';

highest: /int: '-'? ['0'-'9']+/ #literal | '(' root #subexp ')';

multiplicative: highest #base ('*' highest #multmes[] | '/' highest #divmes[])*;

additive: multiplicative #base ('+' multiplicative #addmes[] | '-' multiplicative #submes[])*;

root: additive #exp;

%start: root #root;

// %forward: eval_root = $root: int;

// struct lambda_%u
// {
	// struct type_%u super;
	// captures
	// ...
// };

// struct rettype lambda_%u_evaluate(struct type_%u* this, parameters, ...)
// {
	// 
// }

// void free_lambda_%u(struct type_%u* this)
// {
	// free_captures(this->captures);
// }

// struct type_%u* new_lambda_%u(captures, ...)
// {
	// struct lambda_%u* this = malloc(sizeof(*this));
	// this->super.evaluate = lambda_%u_evaluate;
	// this->super.free = free_lambda_%u;
	// this->captures = inc_capatures(captures);
	// return this;
// }

// struct type_%u (rettype, parameter-types, ...)
// {
	// rettype (*evaluate)(struct type_%u*, parameter-types, ...);
	// void (*free)(struct type_%u*);
// };

// struct rettype* evaluate_lambda(struct type_%u* this, parameters, ...):
	// return (this->evaluate)(this, parameters, ...);

// void free_type_%u(struct type_%u* this):
	// if this && !--this->refcount:
		// (this->free)(this);
		// free(this);

// eval_highest = $highest h: (h has literal) ? h.literal : eval_root(h.subexp);

// eval_multiply = $multiplicative m: eval_highest(m.base)
// 	* product(map(eval_highest, m.multmes))
// 	/ product(map(eval_highest, m.divmes))
// 	;

// eval_add = $additive a: eval_multiply(a.base)
// 	+ sum(map(eval_multiply, a.addmes))
// 	- sum(map(eval_multiply, a.submes))
// 	;

// eval_root = $root r: eval_add(r.exp);

// x = eval_root(root[0]);

// %error: x != 0;

a = $int x: $: $int y: $: x + y;

x = highest[0].literal;
y = highest[1].literal;

// %error: a(3)()(4)() == 7;
%error: a(x)()(y)() == 7;

//%error: !all($root r: eval_root(r) != 0, root)

//isprime = $int x: all(map($int m: x % m != 0, range(2, x - 1)));
//%warning: !isprime(x);


















